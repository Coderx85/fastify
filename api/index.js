
import { createRequire } from 'module';
import { fileURLToPath as __fileURLToPath } from 'url';
import { dirname as __dirname_fn } from 'path';
const require = createRequire(import.meta.url);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except2)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/package.json"(exports, module) {
    module.exports = {
      name: "dotenv",
      version: "17.2.3",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      homepage: "https://github.com/motdotla/dotenv#readme",
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/main.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var os2 = __require("os");
    var crypto3 = __require("crypto");
    var packageJson = require_package();
    var version3 = packageJson.version;
    var TIPS = [
      "\u{1F510} encrypt with Dotenvx: https://dotenvx.com",
      "\u{1F510} prevent committing .env to code: https://dotenvx.com/precommit",
      "\u{1F510} prevent building .env in docker: https://dotenvx.com/prebuild",
      "\u{1F4E1} add observability to secrets: https://dotenvx.com/ops",
      "\u{1F465} sync secrets across teammates & machines: https://dotenvx.com/ops",
      "\u{1F5C2}\uFE0F backup and recover secrets: https://dotenvx.com/ops",
      "\u2705 audit secrets and track compliance: https://dotenvx.com/ops",
      "\u{1F504} add secrets lifecycle management: https://dotenvx.com/ops",
      "\u{1F511} add access controls to secrets: https://dotenvx.com/ops",
      "\u{1F6E0}\uFE0F  run anywhere with `dotenvx run -- yourcommand`",
      "\u2699\uFE0F  specify custom .env file path with { path: '/custom/path/.env' }",
      "\u2699\uFE0F  enable debug logging with { debug: true }",
      "\u2699\uFE0F  override existing env vars with { override: true }",
      "\u2699\uFE0F  suppress all logs with { quiet: true }",
      "\u2699\uFE0F  write to custom object with { processEnv: myObject }",
      "\u2699\uFE0F  load multiple .env files with { path: ['.env.local', '.env'] }"
    ];
    function _getRandomTip() {
      return TIPS[Math.floor(Math.random() * TIPS.length)];
    }
    function parseBoolean(value) {
      if (typeof value === "string") {
        return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
      }
      return Boolean(value);
    }
    function supportsAnsi() {
      return process.stdout.isTTY;
    }
    function dim(text2) {
      return supportsAnsi() ? `\x1B[2m${text2}\x1B[0m` : text2;
    }
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse3(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match2;
      while ((match2 = LINE.exec(lines)) != null) {
        const key = match2[1];
        let value = match2[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      options = options || {};
      const vaultPath = _vaultPath(options);
      options.path = vaultPath;
      const result = DotenvModule.configDotenv(options);
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error48) {
          if (i + 1 >= length) {
            throw error48;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _warn(message) {
      console.error(`[dotenv@${version3}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version3}][DEBUG] ${message}`);
    }
    function _log(message) {
      console.log(`[dotenv@${version3}] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error48) {
        if (error48.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error48;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os2.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);
      const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);
      if (debug || !quiet) {
        _log("Loading env from encrypted .env.vault");
      }
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);
      let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path2 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path2} ${e.message}`);
          }
          lastError = e;
        }
      }
      const populated = DotenvModule.populate(processEnv, parsedAll, options);
      debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
      quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
      if (debug || !quiet) {
        const keysCount = Object.keys(populated).length;
        const shortPaths = [];
        for (const filePath of optionPaths) {
          try {
            const relative = path.relative(process.cwd(), filePath);
            shortPaths.push(relative);
          } catch (e) {
            if (debug) {
              _debug(`Failed to load ${filePath} ${e.message}`);
            }
            lastError = e;
          }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`);
      }
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config3(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error48) {
        const isRange = error48 instanceof RangeError;
        const invalidKeyLength = error48.message === "Invalid key length";
        const decryptionFailed = error48.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error48;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      const populated = {};
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
            populated[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
          populated[key] = parsed[key];
        }
      }
      return populated;
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config3,
      decrypt,
      parse: parse3,
      populate
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
  }
});

// node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/env-options.js
var require_env_options = __commonJS({
  "node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/env-options.js"(exports, module) {
    var options = {};
    if (process.env.DOTENV_CONFIG_ENCODING != null) {
      options.encoding = process.env.DOTENV_CONFIG_ENCODING;
    }
    if (process.env.DOTENV_CONFIG_PATH != null) {
      options.path = process.env.DOTENV_CONFIG_PATH;
    }
    if (process.env.DOTENV_CONFIG_QUIET != null) {
      options.quiet = process.env.DOTENV_CONFIG_QUIET;
    }
    if (process.env.DOTENV_CONFIG_DEBUG != null) {
      options.debug = process.env.DOTENV_CONFIG_DEBUG;
    }
    if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
      options.override = process.env.DOTENV_CONFIG_OVERRIDE;
    }
    if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
      options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
    }
    module.exports = options;
  }
});

// node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/cli-options.js
var require_cli_options = __commonJS({
  "node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/lib/cli-options.js"(exports, module) {
    var re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
    module.exports = function optionMatcher(args) {
      const options = args.reduce(function(acc, cur) {
        const matches = cur.match(re);
        if (matches) {
          acc[matches[1]] = matches[2];
        }
        return acc;
      }, {});
      if (!("quiet" in options)) {
        options.quiet = "true";
      }
      return options;
    };
  }
});

// node_modules/.pnpm/reusify@1.1.0/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/.pnpm/reusify@1.1.0/node_modules/reusify/reusify.js"(exports, module) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module.exports = reusify;
  }
});

// node_modules/.pnpm/fastq@1.20.1/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/.pnpm/fastq@1.20.1/node_modules/fastq/queue.js"(exports, module) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      if (!(_concurrency >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        get concurrency() {
          return _concurrency;
        },
        set concurrency(value) {
          if (!(value >= 1)) {
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          }
          _concurrency = value;
          if (self2.paused) return;
          for (; queueHead && _running < _concurrency; ) {
            _running++;
            release();
          }
        },
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error: error48,
        abort
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused) return;
        self2.paused = false;
        if (queueHead === null) {
          _running++;
          release();
          return;
        }
        for (; queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next && _running <= _concurrency) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function abort() {
        var current = queueHead;
        queueHead = null;
        queueTail = null;
        while (current) {
          var next = current.next;
          var callback = current.callback;
          var errorHandler2 = current.errorHandler;
          var val = current.value;
          var context2 = current.context;
          current.value = null;
          current.callback = noop;
          current.errorHandler = null;
          if (errorHandler2) {
            errorHandler2(new Error("abort"), val);
          }
          callback.call(context2, new Error("abort"));
          current.release(current);
          current = next;
        }
        self2.drain = noop;
      }
      function error48(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, _concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p2 = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p2.catch(noop);
        return p2;
      }
      function unshift(value) {
        var p2 = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p2.catch(noop);
        return p2;
      }
      function drained() {
        var p2 = new Promise(function(resolve) {
          process.nextTick(function() {
            if (queue.idle()) {
              resolve();
            } else {
              var previousDrain = queue.drain;
              queue.drain = function() {
                if (typeof previousDrain === "function") previousDrain();
                resolve();
                queue.drain = previousDrain;
              };
            }
          });
        });
        return p2;
      }
    }
    module.exports = fastqueue;
    module.exports.promise = queueAsPromised;
  }
});

// node_modules/.pnpm/@fastify+error@4.2.0/node_modules/@fastify/error/index.js
var require_error = __commonJS({
  "node_modules/.pnpm/@fastify+error@4.2.0/node_modules/@fastify/error/index.js"(exports, module) {
    "use strict";
    var { format } = __require("node:util");
    function toString() {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
    var FastifyGenericErrorSymbol = /* @__PURE__ */ Symbol.for("fastify-error-generic");
    function createError2(code, message, statusCode = 500, Base = Error, captureStackTrace2 = createError2.captureStackTrace) {
      const shouldCreateFastifyGenericError = code === FastifyGenericErrorSymbol;
      if (shouldCreateFastifyGenericError) {
        code = "FST_ERR";
      }
      if (!code) throw new Error("Fastify error code must not be empty");
      if (!message) throw new Error("Fastify error message must not be empty");
      code = code.toUpperCase();
      !statusCode && (statusCode = void 0);
      const FastifySpecificErrorSymbol = /* @__PURE__ */ Symbol.for(`fastify-error ${code}`);
      function FastifyError(...args) {
        if (!new.target) {
          return new FastifyError(...args);
        }
        this.code = code;
        this.name = "FastifyError";
        this.statusCode = statusCode;
        const lastElement = args.length - 1;
        if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
          this.cause = args.pop().cause;
        }
        this.message = format(message, ...args);
        Error.stackTraceLimit && captureStackTrace2 && Error.captureStackTrace(this, FastifyError);
      }
      FastifyError.prototype = Object.create(Base.prototype, {
        constructor: {
          value: FastifyError,
          enumerable: false,
          writable: true,
          configurable: true
        },
        [FastifyGenericErrorSymbol]: {
          value: true,
          enumerable: false,
          writable: false,
          configurable: false
        },
        [FastifySpecificErrorSymbol]: {
          value: true,
          enumerable: false,
          writable: false,
          configurable: false
        }
      });
      if (shouldCreateFastifyGenericError) {
        Object.defineProperty(FastifyError, Symbol.hasInstance, {
          value(instance) {
            return instance && instance[FastifyGenericErrorSymbol];
          },
          configurable: false,
          writable: false,
          enumerable: false
        });
      } else {
        Object.defineProperty(FastifyError, Symbol.hasInstance, {
          value(instance) {
            return instance && instance[FastifySpecificErrorSymbol];
          },
          configurable: false,
          writable: false,
          enumerable: false
        });
      }
      FastifyError.prototype[Symbol.toStringTag] = "Error";
      FastifyError.prototype.toString = toString;
      return FastifyError;
    }
    createError2.captureStackTrace = true;
    var FastifyErrorConstructor = createError2(FastifyGenericErrorSymbol, "Fastify Error", 500, Error);
    module.exports = createError2;
    module.exports.FastifyError = FastifyErrorConstructor;
    module.exports.default = createError2;
    module.exports.createError = createError2;
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/errors.js"(exports, module) {
    "use strict";
    var { createError: createError2 } = require_error();
    module.exports = {
      AVV_ERR_EXPOSE_ALREADY_DEFINED: createError2(
        "AVV_ERR_EXPOSE_ALREADY_DEFINED",
        "'%s' is already defined, specify an expose option for '%s'"
      ),
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError2(
        "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
        "'%s' is already defined"
      ),
      AVV_ERR_CALLBACK_NOT_FN: createError2(
        "AVV_ERR_CALLBACK_NOT_FN",
        "Callback for '%s' hook is not a function. Received: '%s'"
      ),
      AVV_ERR_PLUGIN_NOT_VALID: createError2(
        "AVV_ERR_PLUGIN_NOT_VALID",
        "Plugin must be a function or a promise. Received: '%s'"
      ),
      AVV_ERR_ROOT_PLG_BOOTED: createError2(
        "AVV_ERR_ROOT_PLG_BOOTED",
        "Root plugin has already booted"
      ),
      AVV_ERR_PARENT_PLG_LOADED: createError2(
        "AVV_ERR_PARENT_PLG_LOADED",
        "Impossible to load '%s' plugin because the parent '%s' was already loaded"
      ),
      AVV_ERR_READY_TIMEOUT: createError2(
        "AVV_ERR_READY_TIMEOUT",
        "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
      ),
      AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError2(
        "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
        "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
      )
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/symbols.js"(exports, module) {
    "use strict";
    var kAvvio = /* @__PURE__ */ Symbol("avvio.Boot");
    var kIsOnCloseHandler = /* @__PURE__ */ Symbol("isOnCloseHandler");
    var kThenifyDoNotWrap = /* @__PURE__ */ Symbol("avvio.ThenifyDoNotWrap");
    var kUntrackNode = /* @__PURE__ */ Symbol("avvio.TimeTree.untrackNode");
    var kTrackNode = /* @__PURE__ */ Symbol("avvio.TimeTree.trackNode");
    var kGetParent = /* @__PURE__ */ Symbol("avvio.TimeTree.getParent");
    var kGetNode = /* @__PURE__ */ Symbol("avvio.TimeTree.getNode");
    var kAddNode = /* @__PURE__ */ Symbol("avvio.TimeTree.addNode");
    var kPluginMeta = /* @__PURE__ */ Symbol.for("plugin-meta");
    module.exports = {
      kAvvio,
      kIsOnCloseHandler,
      kThenifyDoNotWrap,
      kUntrackNode,
      kTrackNode,
      kGetParent,
      kGetNode,
      kAddNode,
      kPluginMeta
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/time-tree.js
var require_time_tree = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/time-tree.js"(exports, module) {
    "use strict";
    var {
      kUntrackNode,
      kTrackNode,
      kGetParent,
      kGetNode,
      kAddNode
    } = require_symbols();
    var TimeTree = class {
      constructor() {
        this.root = null;
        this.tableId = /* @__PURE__ */ new Map();
        this.tableLabel = /* @__PURE__ */ new Map();
      }
      /**
       * @param {TimeTreeNode} node
       */
      [kTrackNode](node) {
        this.tableId.set(node.id, node);
        if (this.tableLabel.has(node.label)) {
          this.tableLabel.get(node.label).push(node);
        } else {
          this.tableLabel.set(node.label, [node]);
        }
      }
      /**
       * @param {TimeTreeNode} node
       */
      [kUntrackNode](node) {
        this.tableId.delete(node.id);
        const labelNode = this.tableLabel.get(node.label);
        labelNode.pop();
        if (labelNode.length === 0) {
          this.tableLabel.delete(node.label);
        }
      }
      /**
       * @param {string} parent
       * @returns {TimeTreeNode}
       */
      [kGetParent](parent) {
        if (parent === null) {
          return null;
        } else if (this.tableLabel.has(parent)) {
          const parentNode = this.tableLabel.get(parent);
          return parentNode[parentNode.length - 1];
        } else {
          return null;
        }
      }
      /**
       *
       * @param {string} nodeId
       * @returns {TimeTreeNode}
       */
      [kGetNode](nodeId) {
        return this.tableId.get(nodeId);
      }
      /**
       * @param {string} parent
       * @param {string} label
       * @param {number} start
       * @returns {TimeTreeNode["id"]}
       */
      [kAddNode](parent, label, start) {
        const parentNode = this[kGetParent](parent);
        const isRoot = parentNode === null;
        if (isRoot) {
          this.root = {
            parent: null,
            id: "root",
            label,
            nodes: [],
            start,
            stop: null,
            diff: -1
          };
          this[kTrackNode](this.root);
          return this.root.id;
        }
        const nodeId = `${label}-${Math.random()}`;
        const childNode = {
          parent,
          id: nodeId,
          label,
          nodes: [],
          start,
          stop: null,
          diff: -1
        };
        parentNode.nodes.push(childNode);
        this[kTrackNode](childNode);
        return nodeId;
      }
      /**
       * @param {string} parent
       * @param {string} label
       * @param {number|undefined} start
       * @returns {TimeTreeNode["id"]}
       */
      start(parent, label, start = Date.now()) {
        return this[kAddNode](parent, label, start);
      }
      /**
       * @param {string} nodeId
       * @param {number|undefined} stop
       */
      stop(nodeId, stop = Date.now()) {
        const node = this[kGetNode](nodeId);
        if (node) {
          node.stop = stop;
          node.diff = node.stop - node.start || 0;
          this[kUntrackNode](node);
        }
      }
      /**
       * @returns {TimeTreeNode}
       */
      toJSON() {
        return Object.assign({}, this.root);
      }
      /**
       * @returns {string}
       */
      prettyPrint() {
        return prettyPrintTimeTree(this.toJSON());
      }
    };
    function prettyPrintTimeTree(obj, prefix = "") {
      let result = prefix;
      const nodesCount = obj.nodes.length;
      const lastIndex = nodesCount - 1;
      result += `${obj.label} ${obj.diff} ms
`;
      for (let i = 0; i < nodesCount; ++i) {
        const node = obj.nodes[i];
        const prefix_ = prefix + (i === lastIndex ? "  " : "\u2502 ");
        result += prefix;
        result += i === lastIndex ? "\u2514\u2500" : "\u251C\u2500";
        result += node.nodes.length === 0 ? "\u2500 " : "\u252C ";
        result += prettyPrintTimeTree(node, prefix_).slice(prefix.length + 2);
      }
      return result;
    }
    module.exports = {
      TimeTree
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/debug.js"(exports, module) {
    "use strict";
    var { debuglog } = __require("node:util");
    var debug = debuglog("avvio");
    module.exports = {
      debug
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/create-promise.js
var require_create_promise = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/create-promise.js"(exports, module) {
    "use strict";
    function createPromise() {
      const obj = {
        resolve: null,
        reject: null,
        promise: null
      };
      obj.promise = new Promise((resolve, reject) => {
        obj.resolve = resolve;
        obj.reject = reject;
      });
      return obj;
    }
    module.exports = {
      createPromise
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/get-plugin-name.js
var require_get_plugin_name = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/get-plugin-name.js"(exports, module) {
    "use strict";
    var { kPluginMeta } = require_symbols();
    function getPluginName(plugin, options) {
      if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
        return plugin[kPluginMeta].name;
      }
      if (options && options.name) {
        return options.name;
      }
      if (plugin.name) {
        return plugin.name;
      } else {
        return plugin.toString().split("\n").slice(0, 2).map((s) => s.trim()).join(" -- ");
      }
    }
    module.exports = {
      getPluginName
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-promise-like.js
var require_is_promise_like = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-promise-like.js"(exports, module) {
    "use strict";
    function isPromiseLike(maybePromiseLike) {
      return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
    }
    module.exports = {
      isPromiseLike
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/plugin.js
var require_plugin = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/plugin.js"(exports, module) {
    "use strict";
    var { EventEmitter } = __require("node:events");
    var { inherits } = __require("node:util");
    var { debug } = require_debug();
    var { createPromise } = require_create_promise();
    var { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = require_errors();
    var { getPluginName } = require_get_plugin_name();
    var { isPromiseLike } = require_is_promise_like();
    function Plugin(queue, func, options, isAfter, timeout) {
      this.queue = queue;
      this.func = func;
      this.options = options;
      this.isAfter = isAfter;
      this.timeout = timeout;
      this.started = false;
      this.name = getPluginName(func, options);
      this.queue.pause();
      this._error = null;
      this.loaded = false;
      this._promise = null;
      this.startTime = null;
    }
    inherits(Plugin, EventEmitter);
    Plugin.prototype.exec = function(server, callback) {
      debug("exec", this.name);
      this.server = server;
      const func = this.func;
      const name = this.name;
      let completed = false;
      this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
      let timer = null;
      const done = (execErr) => {
        if (completed) {
          debug("loading complete", name);
          return;
        }
        this._error = execErr;
        if (execErr) {
          debug("exec errored", name);
        } else {
          debug("exec completed", name);
        }
        completed = true;
        if (timer) {
          clearTimeout(timer);
        }
        callback(execErr);
      };
      if (this.timeout > 0) {
        debug("setting up timeout", name, this.timeout);
        timer = setTimeout(function() {
          debug("timed out", name);
          timer = null;
          const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
          readyTimeoutErr.fn = func;
          done(readyTimeoutErr);
        }, this.timeout);
      }
      this.started = true;
      this.startTime = Date.now();
      this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
      const maybePromiseLike = func(this.server, this.options, done);
      if (isPromiseLike(maybePromiseLike)) {
        debug("exec: resolving promise", name);
        maybePromiseLike.then(
          () => process.nextTick(done),
          (e) => process.nextTick(done, e)
        );
      } else if (func.length < 3) {
        done();
      }
    };
    Plugin.prototype.loadedSoFar = function() {
      debug("loadedSoFar", this.name);
      if (this.loaded) {
        return Promise.resolve();
      }
      const setup = () => {
        this.server.after((afterErr, callback) => {
          this._error = afterErr;
          this.queue.pause();
          if (this._promise) {
            if (afterErr) {
              debug("rejecting promise", this.name, afterErr);
              this._promise.reject(afterErr);
            } else {
              debug("resolving promise", this.name);
              this._promise.resolve();
            }
            this._promise = null;
          }
          process.nextTick(callback, afterErr);
        });
        this.queue.resume();
      };
      let res;
      if (!this._promise) {
        this._promise = createPromise();
        res = this._promise.promise;
        if (!this.server) {
          this.on("start", setup);
        } else {
          setup();
        }
      } else {
        res = Promise.resolve();
      }
      return res;
    };
    Plugin.prototype.enqueue = function(plugin, callback) {
      debug("enqueue", this.name, plugin.name);
      this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
      this.queue.push(plugin, callback);
    };
    Plugin.prototype.finish = function(err, callback) {
      debug("finish", this.name, err);
      const done = () => {
        if (this.loaded) {
          return;
        }
        debug("loaded", this.name);
        this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
        this.loaded = true;
        callback(err);
      };
      if (err) {
        if (this._promise) {
          this._promise.reject(err);
          this._promise = null;
        }
        done();
        return;
      }
      const check3 = () => {
        debug("check", this.name, this.queue.length(), this.queue.running(), this._promise);
        if (this.queue.length() === 0 && this.queue.running() === 0) {
          if (this._promise) {
            const wrap2 = () => {
              debug("wrap");
              queueMicrotask(check3);
            };
            this._promise.resolve();
            this._promise.promise.then(wrap2, wrap2);
            this._promise = null;
          } else {
            done();
          }
        } else {
          debug("delayed", this.name);
          this.queue.drain = () => {
            debug("drain", this.name);
            this.queue.drain = noop;
            queueMicrotask(check3);
          };
        }
      };
      queueMicrotask(check3);
      this.queue.resume();
    };
    function noop() {
    }
    module.exports = {
      Plugin
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/validate-plugin.js
var require_validate_plugin = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/validate-plugin.js"(exports, module) {
    "use strict";
    var { AVV_ERR_PLUGIN_NOT_VALID } = require_errors();
    function validatePlugin(maybePlugin) {
      if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
        if (Array.isArray(maybePlugin)) {
          throw new AVV_ERR_PLUGIN_NOT_VALID("array");
        } else if (maybePlugin === null) {
          throw new AVV_ERR_PLUGIN_NOT_VALID("null");
        } else {
          throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
        }
      }
    }
    module.exports = {
      validatePlugin
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-bundled-or-typescript-plugin.js
var require_is_bundled_or_typescript_plugin = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-bundled-or-typescript-plugin.js"(exports, module) {
    "use strict";
    function isBundledOrTypescriptPlugin(maybeBundledOrTypescriptPlugin) {
      return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
    }
    module.exports = {
      isBundledOrTypescriptPlugin
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/thenify.js
var require_thenify = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/thenify.js"(exports, module) {
    "use strict";
    var { debug } = require_debug();
    var { kThenifyDoNotWrap } = require_symbols();
    function thenify() {
      if (this.booted) {
        debug("thenify returning undefined because we are already booted");
        return;
      }
      if (this[kThenifyDoNotWrap]) {
        this[kThenifyDoNotWrap] = false;
        return;
      }
      debug("thenify");
      return (resolve, reject) => {
        const p2 = this._loadRegistered();
        return p2.then(() => {
          this[kThenifyDoNotWrap] = true;
          return resolve(this._server);
        }, reject);
      };
    }
    module.exports = {
      thenify
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/execute-with-thenable.js
var require_execute_with_thenable = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/execute-with-thenable.js"(exports, module) {
    "use strict";
    var { isPromiseLike } = require_is_promise_like();
    var { kAvvio } = require_symbols();
    function executeWithThenable(func, args, callback) {
      const result = func.apply(func, args);
      if (isPromiseLike(result) && !result[kAvvio]) {
        result.then(() => process.nextTick(callback), (error48) => process.nextTick(callback, error48));
      } else if (callback) {
        process.nextTick(callback);
      }
    }
    module.exports = {
      executeWithThenable
    };
  }
});

// node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/boot.js
var require_boot = __commonJS({
  "node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/boot.js"(exports, module) {
    "use strict";
    var fastq = require_queue();
    var EE = __require("node:events").EventEmitter;
    var inherits = __require("node:util").inherits;
    var {
      AVV_ERR_EXPOSE_ALREADY_DEFINED,
      AVV_ERR_CALLBACK_NOT_FN,
      AVV_ERR_ROOT_PLG_BOOTED,
      AVV_ERR_READY_TIMEOUT,
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
    } = require_errors();
    var {
      kAvvio,
      kIsOnCloseHandler
    } = require_symbols();
    var { TimeTree } = require_time_tree();
    var { Plugin } = require_plugin();
    var { debug } = require_debug();
    var { validatePlugin } = require_validate_plugin();
    var { isBundledOrTypescriptPlugin } = require_is_bundled_or_typescript_plugin();
    var { isPromiseLike } = require_is_promise_like();
    var { thenify } = require_thenify();
    var { executeWithThenable } = require_execute_with_thenable();
    function Boot(server, opts, done) {
      if (typeof server === "function" && arguments.length === 1) {
        done = server;
        opts = {};
        server = null;
      }
      if (typeof opts === "function") {
        done = opts;
        opts = {};
      }
      opts = opts || {};
      opts.autostart = opts.autostart !== false;
      opts.timeout = Number(opts.timeout) || 0;
      opts.expose = opts.expose || {};
      if (!new.target) {
        return new Boot(server, opts, done);
      }
      this._server = server || this;
      this._opts = opts;
      if (server) {
        this._expose();
      }
      this._current = [];
      this._error = null;
      this._lastUsed = null;
      this.setMaxListeners(0);
      if (done) {
        this.once("start", done);
      }
      this.started = false;
      this.booted = false;
      this.pluginTree = new TimeTree();
      this._readyQ = fastq(this, callWithCbOrNextTick, 1);
      this._readyQ.pause();
      this._readyQ.drain = () => {
        this.emit("start");
        this._readyQ.drain = noop;
      };
      this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
      this._closeQ.pause();
      this._closeQ.drain = () => {
        this.emit("close");
        this._closeQ.drain = noop;
      };
      this._doStart = null;
      const instance = this;
      this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root(server2, opts2, done2) {
        instance._doStart = done2;
        opts2.autostart && instance.start();
      }, opts, false, 0);
      this._trackPluginLoading(this._root);
      this._loadPlugin(this._root, (err) => {
        debug("root plugin ready");
        try {
          this.emit("preReady");
          this._root = null;
        } catch (preReadyError) {
          err = err || this._error || preReadyError;
        }
        if (err) {
          this._error = err;
          if (this._readyQ.length() === 0) {
            throw err;
          }
        } else {
          this.booted = true;
        }
        this._readyQ.resume();
      });
    }
    inherits(Boot, EE);
    Boot.prototype.start = function() {
      this.started = true;
      process.nextTick(this._doStart);
      return this;
    };
    Boot.prototype.override = function(server, func, opts) {
      return server;
    };
    Boot.prototype[kAvvio] = true;
    Boot.prototype.use = function(plugin, opts) {
      this._lastUsed = this._addPlugin(plugin, opts, false);
      return this;
    };
    Boot.prototype._loadRegistered = function() {
      const plugin = this._current[0];
      const weNeedToStart = !this.started && !this.booted;
      if (weNeedToStart) {
        process.nextTick(() => this._root.queue.resume());
      }
      if (!plugin) {
        return Promise.resolve();
      }
      return plugin.loadedSoFar();
    };
    Object.defineProperty(Boot.prototype, "then", { get: thenify });
    Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
      if (isBundledOrTypescriptPlugin(pluginFn)) {
        pluginFn = pluginFn.default;
      }
      validatePlugin(pluginFn);
      opts = opts || {};
      if (this.booted) {
        throw new AVV_ERR_ROOT_PLG_BOOTED();
      }
      const current = this._current[0];
      let timeout = this._opts.timeout;
      if (!current.loaded && current.timeout > 0) {
        const delta = Date.now() - current.startTime;
        timeout = current.timeout - (delta + 3);
      }
      const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
      this._trackPluginLoading(plugin);
      if (current.loaded) {
        throw new Error(plugin.name, current.name);
      }
      current.enqueue(plugin, (err) => {
        err && (this._error = err);
      });
      return plugin;
    };
    Boot.prototype._expose = function _expose() {
      const instance = this;
      const server = instance._server;
      const {
        use: useKey = "use",
        after: afterKey = "after",
        ready: readyKey = "ready",
        onClose: onCloseKey = "onClose",
        close: closeKey = "close"
      } = this._opts.expose;
      if (server[useKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
      }
      server[useKey] = function(fn, opts) {
        instance.use(fn, opts);
        return this;
      };
      if (server[afterKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
      }
      server[afterKey] = function(func) {
        if (typeof func !== "function") {
          return instance._loadRegistered();
        }
        instance.after(encapsulateThreeParam(func, this));
        return this;
      };
      if (server[readyKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
      }
      server[readyKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
        }
        return instance.ready(func ? encapsulateThreeParam(func, this) : void 0);
      };
      if (server[onCloseKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
      }
      server[onCloseKey] = function(func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
        }
        instance.onClose(encapsulateTwoParam(func, this));
        return this;
      };
      if (server[closeKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
      }
      server[closeKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
        }
        if (func) {
          instance.close(encapsulateThreeParam(func, this));
          return this;
        }
        return instance.close();
      };
      if (server.then) {
        throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
      }
      Object.defineProperty(server, "then", { get: thenify.bind(instance) });
      server[kAvvio] = true;
    };
    Boot.prototype.after = function(func) {
      if (!func) {
        return this._loadRegistered();
      }
      this._addPlugin(_after.bind(this), {}, true);
      function _after(s, opts, done) {
        callWithCbOrNextTick.call(this, func, done);
      }
      return this;
    };
    Boot.prototype.onClose = function(func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
      }
      func[kIsOnCloseHandler] = true;
      this._closeQ.unshift(func, (err) => {
        err && (this._error = err);
      });
      return this;
    };
    Boot.prototype.close = function(func) {
      let promise2;
      if (func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
        }
      } else {
        promise2 = new Promise(function(resolve, reject) {
          func = function(err) {
            if (err) {
              return reject(err);
            }
            resolve();
          };
        });
      }
      this.ready(() => {
        this._error = null;
        this._closeQ.push(func);
        process.nextTick(this._closeQ.resume.bind(this._closeQ));
      });
      return promise2;
    };
    Boot.prototype.ready = function(func) {
      if (func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
        }
        this._readyQ.push(func);
        queueMicrotask(this.start.bind(this));
        return;
      }
      return new Promise((resolve, reject) => {
        this._readyQ.push(readyPromiseCB);
        this.start();
        const relativeContext = this._current[0].server;
        function readyPromiseCB(err, context, done) {
          if (err) {
            reject(err);
          } else {
            resolve(relativeContext);
          }
          process.nextTick(done);
        }
      });
    };
    Boot.prototype._trackPluginLoading = function(plugin) {
      const parentName = this._current[0]?.name || null;
      plugin.once("start", (serverName, funcName, time5) => {
        const nodeId = this.pluginTree.start(parentName || null, funcName, time5);
        plugin.once("loaded", (serverName2, funcName2, time6) => {
          this.pluginTree.stop(nodeId, time6);
        });
      });
    };
    Boot.prototype.prettyPrint = function() {
      return this.pluginTree.prettyPrint();
    };
    Boot.prototype.toJSON = function() {
      return this.pluginTree.toJSON();
    };
    Boot.prototype._loadPlugin = function(plugin, callback) {
      const instance = this;
      if (isPromiseLike(plugin.func)) {
        plugin.func.then((fn) => {
          if (typeof fn.default === "function") {
            fn = fn.default;
          }
          plugin.func = fn;
          this._loadPlugin(plugin, callback);
        }, callback);
        return;
      }
      const last = instance._current[0];
      instance._current.unshift(plugin);
      if (instance._error && !plugin.isAfter) {
        debug("skipping loading of plugin as instance errored and it is not an after", plugin.name);
        process.nextTick(execCallback);
        return;
      }
      let server = last && last.server || instance._server;
      if (!plugin.isAfter) {
        try {
          server = instance.override(server, plugin.func, plugin.options);
        } catch (overrideErr) {
          debug("override errored", plugin.name);
          return execCallback(overrideErr);
        }
      }
      plugin.exec(server, execCallback);
      function execCallback(err) {
        plugin.finish(err, (err2) => {
          instance._current.shift();
          callback(err2);
        });
      }
    };
    Boot.prototype._loadPluginNextTick = function(plugin, callback) {
      process.nextTick(this._loadPlugin.bind(this), plugin, callback);
    };
    function noop() {
    }
    function callWithCbOrNextTick(func, cb) {
      const context = this._server;
      const err = this._error;
      this._error = null;
      if (func.length === 0) {
        this._error = err;
        executeWithThenable(func, [], cb);
      } else if (func.length === 1) {
        executeWithThenable(func, [err], cb);
      } else {
        if (this._opts.timeout === 0) {
          const wrapCb = (err2) => {
            this._error = err2;
            cb(this._error);
          };
          if (func.length === 2) {
            func(err, wrapCb);
          } else {
            func(err, context, wrapCb);
          }
        } else {
          timeoutCall.call(this, func, err, context, cb);
        }
      }
    }
    function timeoutCall(func, rootErr, context, cb) {
      const name = func.unwrappedName ?? func.name;
      debug("setting up ready timeout", name, this._opts.timeout);
      let timer = setTimeout(() => {
        debug("timed out", name);
        timer = null;
        const toutErr = new AVV_ERR_READY_TIMEOUT(name);
        toutErr.fn = func;
        this._error = toutErr;
        cb(toutErr);
      }, this._opts.timeout);
      if (func.length === 2) {
        func(rootErr, timeoutCb.bind(this));
      } else {
        func(rootErr, context, timeoutCb.bind(this));
      }
      function timeoutCb(err) {
        if (timer) {
          clearTimeout(timer);
          this._error = err;
          cb(this._error);
        } else {
        }
      }
    }
    function closeWithCbOrNextTick(func, cb) {
      const context = this._server;
      const isOnCloseHandler = func[kIsOnCloseHandler];
      if (func.length === 0 || func.length === 1) {
        let promise2;
        if (isOnCloseHandler) {
          promise2 = func(context);
        } else {
          promise2 = func(this._error);
        }
        if (promise2 && typeof promise2.then === "function") {
          debug("resolving close/onClose promise");
          promise2.then(
            () => process.nextTick(cb),
            (e) => process.nextTick(cb, e)
          );
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, cb);
        }
      } else {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, context, cb);
        }
      }
    }
    function encapsulateTwoParam(func, that) {
      return _encapsulateTwoParam.bind(that);
      function _encapsulateTwoParam(context, cb) {
        let res;
        if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 1) {
          res = func(this);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else {
          func(this, cb);
        }
      }
    }
    function encapsulateThreeParam(func, that) {
      const wrapped = _encapsulateThreeParam.bind(that);
      wrapped.unwrappedName = func.name;
      return wrapped;
      function _encapsulateThreeParam(err, cb) {
        let res;
        if (!func) {
          process.nextTick(cb);
        } else if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb, err);
            }, cb);
          } else {
            process.nextTick(cb, err);
          }
        } else if (func.length === 1) {
          res = func(err);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 2) {
          func(err, cb);
        } else {
          func(err, this, cb);
        }
      }
    }
    module.exports = Boot;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/symbols.js"(exports, module) {
    "use strict";
    var keys = {
      kAvvioBoot: /* @__PURE__ */ Symbol("fastify.avvioBoot"),
      kChildren: /* @__PURE__ */ Symbol("fastify.children"),
      kServerBindings: /* @__PURE__ */ Symbol("fastify.serverBindings"),
      kBodyLimit: /* @__PURE__ */ Symbol("fastify.bodyLimit"),
      kSupportedHTTPMethods: /* @__PURE__ */ Symbol("fastify.acceptedHTTPMethods"),
      kRoutePrefix: /* @__PURE__ */ Symbol("fastify.routePrefix"),
      kLogLevel: /* @__PURE__ */ Symbol("fastify.logLevel"),
      kLogSerializers: /* @__PURE__ */ Symbol("fastify.logSerializers"),
      kHooks: /* @__PURE__ */ Symbol("fastify.hooks"),
      kContentTypeParser: /* @__PURE__ */ Symbol("fastify.contentTypeParser"),
      kState: /* @__PURE__ */ Symbol("fastify.state"),
      kOptions: /* @__PURE__ */ Symbol("fastify.options"),
      kDisableRequestLogging: /* @__PURE__ */ Symbol("fastify.disableRequestLogging"),
      kPluginNameChain: /* @__PURE__ */ Symbol("fastify.pluginNameChain"),
      kRouteContext: /* @__PURE__ */ Symbol("fastify.context"),
      kGenReqId: /* @__PURE__ */ Symbol("fastify.genReqId"),
      kHttp2ServerSessions: /* @__PURE__ */ Symbol("fastify.http2ServerSessions"),
      // Schema
      kSchemaController: /* @__PURE__ */ Symbol("fastify.schemaController"),
      kSchemaHeaders: /* @__PURE__ */ Symbol("headers-schema"),
      kSchemaParams: /* @__PURE__ */ Symbol("params-schema"),
      kSchemaQuerystring: /* @__PURE__ */ Symbol("querystring-schema"),
      kSchemaBody: /* @__PURE__ */ Symbol("body-schema"),
      kSchemaResponse: /* @__PURE__ */ Symbol("response-schema"),
      kSchemaErrorFormatter: /* @__PURE__ */ Symbol("fastify.schemaErrorFormatter"),
      kSchemaVisited: /* @__PURE__ */ Symbol("fastify.schemas.visited"),
      // Request
      kRequest: /* @__PURE__ */ Symbol("fastify.Request"),
      kRequestPayloadStream: /* @__PURE__ */ Symbol("fastify.RequestPayloadStream"),
      kRequestAcceptVersion: /* @__PURE__ */ Symbol("fastify.RequestAcceptVersion"),
      kRequestCacheValidateFns: /* @__PURE__ */ Symbol("fastify.request.cache.validateFns"),
      kRequestOriginalUrl: /* @__PURE__ */ Symbol("fastify.request.originalUrl"),
      // 404
      kFourOhFour: /* @__PURE__ */ Symbol("fastify.404"),
      kCanSetNotFoundHandler: /* @__PURE__ */ Symbol("fastify.canSetNotFoundHandler"),
      kFourOhFourLevelInstance: /* @__PURE__ */ Symbol("fastify.404LogLevelInstance"),
      kFourOhFourContext: /* @__PURE__ */ Symbol("fastify.404ContextKey"),
      kDefaultJsonParse: /* @__PURE__ */ Symbol("fastify.defaultJSONParse"),
      // Reply
      kReply: /* @__PURE__ */ Symbol("fastify.Reply"),
      kReplySerializer: /* @__PURE__ */ Symbol("fastify.reply.serializer"),
      kReplyIsError: /* @__PURE__ */ Symbol("fastify.reply.isError"),
      kReplyHeaders: /* @__PURE__ */ Symbol("fastify.reply.headers"),
      kReplyTrailers: /* @__PURE__ */ Symbol("fastify.reply.trailers"),
      kReplyHasStatusCode: /* @__PURE__ */ Symbol("fastify.reply.hasStatusCode"),
      kReplyHijacked: /* @__PURE__ */ Symbol("fastify.reply.hijacked"),
      kReplyStartTime: /* @__PURE__ */ Symbol("fastify.reply.startTime"),
      kReplyNextErrorHandler: /* @__PURE__ */ Symbol("fastify.reply.nextErrorHandler"),
      kReplyEndTime: /* @__PURE__ */ Symbol("fastify.reply.endTime"),
      kReplyErrorHandlerCalled: /* @__PURE__ */ Symbol("fastify.reply.errorHandlerCalled"),
      kReplyIsRunningOnErrorHook: /* @__PURE__ */ Symbol("fastify.reply.isRunningOnErrorHook"),
      kReplySerializerDefault: /* @__PURE__ */ Symbol("fastify.replySerializerDefault"),
      kReplyCacheSerializeFns: /* @__PURE__ */ Symbol("fastify.reply.cache.serializeFns"),
      // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
      kTestInternals: /* @__PURE__ */ Symbol("fastify.testInternals"),
      kErrorHandler: /* @__PURE__ */ Symbol("fastify.errorHandler"),
      kErrorHandlerAlreadySet: /* @__PURE__ */ Symbol("fastify.errorHandlerAlreadySet"),
      kChildLoggerFactory: /* @__PURE__ */ Symbol("fastify.childLoggerFactory"),
      kHasBeenDecorated: /* @__PURE__ */ Symbol("fastify.hasBeenDecorated"),
      kKeepAliveConnections: /* @__PURE__ */ Symbol("fastify.keepAliveConnections"),
      kRouteByFastify: /* @__PURE__ */ Symbol("fastify.routeByFastify")
    };
    module.exports = keys;
  }
});

// node_modules/.pnpm/process-warning@5.0.0/node_modules/process-warning/index.js
var require_process_warning = __commonJS({
  "node_modules/.pnpm/process-warning@5.0.0/node_modules/process-warning/index.js"(exports, module) {
    "use strict";
    var { format } = __require("node:util");
    function createDeprecation(params) {
      return createWarning({ ...params, name: "DeprecationWarning" });
    }
    function createWarning({ name, code, message, unlimited = false } = {}) {
      if (!name) throw new Error("Warning name must not be empty");
      if (!code) throw new Error("Warning code must not be empty");
      if (!message) throw new Error("Warning message must not be empty");
      if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
      code = code.toUpperCase();
      let warningContainer = {
        [name]: function(a2, b2, c) {
          if (warning.emitted === true && warning.unlimited !== true) {
            return;
          }
          warning.emitted = true;
          process.emitWarning(warning.format(a2, b2, c), warning.name, warning.code);
        }
      };
      if (unlimited) {
        warningContainer = {
          [name]: function(a2, b2, c) {
            warning.emitted = true;
            process.emitWarning(warning.format(a2, b2, c), warning.name, warning.code);
          }
        };
      }
      const warning = warningContainer[name];
      warning.emitted = false;
      warning.message = message;
      warning.unlimited = unlimited;
      warning.code = code;
      warning.format = function(a2, b2, c) {
        let formatted;
        if (a2 && b2 && c) {
          formatted = format(message, a2, b2, c);
        } else if (a2 && b2) {
          formatted = format(message, a2, b2);
        } else if (a2) {
          formatted = format(message, a2);
        } else {
          formatted = message;
        }
        return formatted;
      };
      return warning;
    }
    var out = { createWarning, createDeprecation };
    module.exports = out;
    module.exports.default = out;
    module.exports.processWarning = out;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/warnings.js
var require_warnings = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/warnings.js"(exports, module) {
    "use strict";
    var { createWarning } = require_process_warning();
    var FSTWRN001 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN001",
      message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
      unlimited: true
    });
    var FSTWRN003 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN003",
      message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
      unlimited: true
    });
    var FSTWRN004 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN004",
      message: "It seems that you are overriding an errorHandler in the same scope, which can lead to subtle bugs.",
      unlimited: true
    });
    var FSTSEC001 = createWarning({
      name: "FastifySecurity",
      code: "FSTSEC001",
      message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
      unlimited: true
    });
    var FSTDEP022 = createWarning({
      name: "FastifyWarning",
      code: "FSTDEP022",
      message: 'The router options for %s property access is deprecated. Please use "options.routerOptions" instead for accessing router options. The router options will be removed in `fastify@6`.',
      unlimited: true
    });
    module.exports = {
      FSTWRN001,
      FSTWRN003,
      FSTWRN004,
      FSTSEC001,
      FSTDEP022
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/errors.js"(exports, module) {
    "use strict";
    var createError2 = require_error();
    var codes = {
      /**
       * Basic
       */
      FST_ERR_NOT_FOUND: createError2(
        "FST_ERR_NOT_FOUND",
        "Not Found",
        404
      ),
      FST_ERR_OPTIONS_NOT_OBJ: createError2(
        "FST_ERR_OPTIONS_NOT_OBJ",
        "Options must be an object",
        500,
        TypeError
      ),
      FST_ERR_QSP_NOT_FN: createError2(
        "FST_ERR_QSP_NOT_FN",
        "querystringParser option should be a function, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError2(
        "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
        "schemaController.bucket option should be a function, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError2(
        "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
        "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
        500,
        TypeError
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError2(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
        "ajv.customOptions option should be an object, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError2(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
        "ajv.plugins option should be an array, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_VALIDATION: createError2(
        "FST_ERR_VALIDATION",
        "%s",
        400
      ),
      FST_ERR_LISTEN_OPTIONS_INVALID: createError2(
        "FST_ERR_LISTEN_OPTIONS_INVALID",
        "Invalid listen options: '%s'",
        500,
        TypeError
      ),
      FST_ERR_ERROR_HANDLER_NOT_FN: createError2(
        "FST_ERR_ERROR_HANDLER_NOT_FN",
        "Error Handler must be a function",
        500,
        TypeError
      ),
      FST_ERR_ERROR_HANDLER_ALREADY_SET: createError2(
        "FST_ERR_ERROR_HANDLER_ALREADY_SET",
        "Error Handler already set in this scope. Set 'allowErrorHandlerOverride: true' to allow overriding.",
        500,
        TypeError
      ),
      /**
       * ContentTypeParser
      */
      FST_ERR_CTP_ALREADY_PRESENT: createError2(
        "FST_ERR_CTP_ALREADY_PRESENT",
        "Content type parser '%s' already present."
      ),
      FST_ERR_CTP_INVALID_TYPE: createError2(
        "FST_ERR_CTP_INVALID_TYPE",
        "The content type should be a string or a RegExp",
        500,
        TypeError
      ),
      FST_ERR_CTP_EMPTY_TYPE: createError2(
        "FST_ERR_CTP_EMPTY_TYPE",
        "The content type cannot be an empty string",
        500,
        TypeError
      ),
      FST_ERR_CTP_INVALID_HANDLER: createError2(
        "FST_ERR_CTP_INVALID_HANDLER",
        "The content type handler should be a function",
        500,
        TypeError
      ),
      FST_ERR_CTP_INVALID_PARSE_TYPE: createError2(
        "FST_ERR_CTP_INVALID_PARSE_TYPE",
        "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
        500,
        TypeError
      ),
      FST_ERR_CTP_BODY_TOO_LARGE: createError2(
        "FST_ERR_CTP_BODY_TOO_LARGE",
        "Request body is too large",
        413,
        RangeError
      ),
      FST_ERR_CTP_INVALID_MEDIA_TYPE: createError2(
        "FST_ERR_CTP_INVALID_MEDIA_TYPE",
        "Unsupported Media Type: %s",
        415
      ),
      FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError2(
        "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
        "Request body size did not match Content-Length",
        400,
        RangeError
      ),
      FST_ERR_CTP_EMPTY_JSON_BODY: createError2(
        "FST_ERR_CTP_EMPTY_JSON_BODY",
        "Body cannot be empty when content-type is set to 'application/json'",
        400
      ),
      FST_ERR_CTP_INVALID_JSON_BODY: createError2(
        "FST_ERR_CTP_INVALID_JSON_BODY",
        "Body is not valid JSON but content-type is set to 'application/json'",
        400
      ),
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError2(
        "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
        'Cannot call "%s" when fastify instance is already started!',
        400
      ),
      /**
       * decorate
      */
      FST_ERR_DEC_ALREADY_PRESENT: createError2(
        "FST_ERR_DEC_ALREADY_PRESENT",
        "The decorator '%s' has already been added!"
      ),
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError2(
        "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
        "The dependencies of decorator '%s' must be of type Array.",
        500,
        TypeError
      ),
      FST_ERR_DEC_MISSING_DEPENDENCY: createError2(
        "FST_ERR_DEC_MISSING_DEPENDENCY",
        "The decorator is missing dependency '%s'."
      ),
      FST_ERR_DEC_AFTER_START: createError2(
        "FST_ERR_DEC_AFTER_START",
        "The decorator '%s' has been added after start!"
      ),
      FST_ERR_DEC_REFERENCE_TYPE: createError2(
        "FST_ERR_DEC_REFERENCE_TYPE",
        "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
      ),
      FST_ERR_DEC_UNDECLARED: createError2(
        "FST_ERR_DEC_UNDECLARED",
        "No decorator '%s' has been declared on %s."
      ),
      /**
       * hooks
      */
      FST_ERR_HOOK_INVALID_TYPE: createError2(
        "FST_ERR_HOOK_INVALID_TYPE",
        "The hook name must be a string",
        500,
        TypeError
      ),
      FST_ERR_HOOK_INVALID_HANDLER: createError2(
        "FST_ERR_HOOK_INVALID_HANDLER",
        "%s hook should be a function, instead got %s",
        500,
        TypeError
      ),
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError2(
        "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
        "Async function has too many arguments. Async hooks should not use the 'done' argument.",
        500,
        TypeError
      ),
      FST_ERR_HOOK_NOT_SUPPORTED: createError2(
        "FST_ERR_HOOK_NOT_SUPPORTED",
        "%s hook not supported!",
        500,
        TypeError
      ),
      /**
       * Middlewares
       */
      FST_ERR_MISSING_MIDDLEWARE: createError2(
        "FST_ERR_MISSING_MIDDLEWARE",
        "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
        500
      ),
      FST_ERR_HOOK_TIMEOUT: createError2(
        "FST_ERR_HOOK_TIMEOUT",
        "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
      ),
      /**
       * logger
      */
      FST_ERR_LOG_INVALID_DESTINATION: createError2(
        "FST_ERR_LOG_INVALID_DESTINATION",
        "Cannot specify both logger.stream and logger.file options"
      ),
      FST_ERR_LOG_INVALID_LOGGER: createError2(
        "FST_ERR_LOG_INVALID_LOGGER",
        "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
        500,
        TypeError
      ),
      FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError2(
        "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
        "loggerInstance only accepts a logger instance.",
        500,
        TypeError
      ),
      FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError2(
        "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
        "logger options only accepts a configuration object.",
        500,
        TypeError
      ),
      FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError2(
        "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
        "You cannot provide both logger and loggerInstance. Please provide only one.",
        500,
        TypeError
      ),
      /**
       * reply
      */
      FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError2(
        "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
        "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
        500,
        TypeError
      ),
      FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError2(
        "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
        "Response.body is already consumed."
      ),
      FST_ERR_REP_READABLE_STREAM_LOCKED: createError2(
        "FST_ERR_REP_READABLE_STREAM_LOCKED",
        "ReadableStream was locked. You should call releaseLock() method on reader before sending."
      ),
      FST_ERR_REP_ALREADY_SENT: createError2(
        "FST_ERR_REP_ALREADY_SENT",
        'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
      ),
      FST_ERR_REP_SENT_VALUE: createError2(
        "FST_ERR_REP_SENT_VALUE",
        "The only possible value for reply.sent is true.",
        500,
        TypeError
      ),
      FST_ERR_SEND_INSIDE_ONERR: createError2(
        "FST_ERR_SEND_INSIDE_ONERR",
        "You cannot use `send` inside the `onError` hook"
      ),
      FST_ERR_SEND_UNDEFINED_ERR: createError2(
        "FST_ERR_SEND_UNDEFINED_ERR",
        "Undefined error has occurred"
      ),
      FST_ERR_BAD_STATUS_CODE: createError2(
        "FST_ERR_BAD_STATUS_CODE",
        "Called reply with an invalid status code: %s"
      ),
      FST_ERR_BAD_TRAILER_NAME: createError2(
        "FST_ERR_BAD_TRAILER_NAME",
        "Called reply.trailer with an invalid header name: %s"
      ),
      FST_ERR_BAD_TRAILER_VALUE: createError2(
        "FST_ERR_BAD_TRAILER_VALUE",
        "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
      ),
      FST_ERR_FAILED_ERROR_SERIALIZATION: createError2(
        "FST_ERR_FAILED_ERROR_SERIALIZATION",
        "Failed to serialize an error. Error: %s. Original error: %s"
      ),
      FST_ERR_MISSING_SERIALIZATION_FN: createError2(
        "FST_ERR_MISSING_SERIALIZATION_FN",
        'Missing serialization function. Key "%s"'
      ),
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError2(
        "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
        'Missing serialization function. Key "%s:%s"'
      ),
      FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError2(
        "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
        'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
      ),
      /**
       * schemas
      */
      FST_ERR_SCH_MISSING_ID: createError2(
        "FST_ERR_SCH_MISSING_ID",
        "Missing schema $id property"
      ),
      FST_ERR_SCH_ALREADY_PRESENT: createError2(
        "FST_ERR_SCH_ALREADY_PRESENT",
        "Schema with id '%s' already declared!"
      ),
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError2(
        "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
        "Schema is missing for the content type '%s'"
      ),
      FST_ERR_SCH_DUPLICATE: createError2(
        "FST_ERR_SCH_DUPLICATE",
        "Schema with '%s' already present!"
      ),
      FST_ERR_SCH_VALIDATION_BUILD: createError2(
        "FST_ERR_SCH_VALIDATION_BUILD",
        "Failed building the validation schema for %s: %s, due to error %s"
      ),
      FST_ERR_SCH_SERIALIZATION_BUILD: createError2(
        "FST_ERR_SCH_SERIALIZATION_BUILD",
        "Failed building the serialization schema for %s: %s, due to error %s"
      ),
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError2(
        "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
        'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
      ),
      /**
       * initialConfig
       */
      FST_ERR_INIT_OPTS_INVALID: createError2(
        "FST_ERR_INIT_OPTS_INVALID",
        "Invalid initialization options: '%s'"
      ),
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError2(
        "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
        "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
      ),
      /**
       * router
       */
      FST_ERR_DUPLICATED_ROUTE: createError2(
        "FST_ERR_DUPLICATED_ROUTE",
        "Method '%s' already declared for route '%s'"
      ),
      FST_ERR_BAD_URL: createError2(
        "FST_ERR_BAD_URL",
        "'%s' is not a valid url component",
        400,
        URIError
      ),
      FST_ERR_ASYNC_CONSTRAINT: createError2(
        "FST_ERR_ASYNC_CONSTRAINT",
        "Unexpected error from async constraint",
        500
      ),
      FST_ERR_INVALID_URL: createError2(
        "FST_ERR_INVALID_URL",
        "URL must be a string. Received '%s'",
        400,
        TypeError
      ),
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError2(
        "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
        'Options for "%s:%s" route must be an object',
        500,
        TypeError
      ),
      FST_ERR_ROUTE_DUPLICATED_HANDLER: createError2(
        "FST_ERR_ROUTE_DUPLICATED_HANDLER",
        'Duplicate handler for "%s:%s" route is not allowed!',
        500
      ),
      FST_ERR_ROUTE_HANDLER_NOT_FN: createError2(
        "FST_ERR_ROUTE_HANDLER_NOT_FN",
        "Error Handler for %s:%s route, if defined, must be a function",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_MISSING_HANDLER: createError2(
        "FST_ERR_ROUTE_MISSING_HANDLER",
        'Missing handler function for "%s:%s" route.',
        500
      ),
      FST_ERR_ROUTE_METHOD_INVALID: createError2(
        "FST_ERR_ROUTE_METHOD_INVALID",
        "Provided method is invalid!",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError2(
        "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
        "%s method is not supported.",
        500
      ),
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError2(
        "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
        "Body validation schema for %s:%s route is not supported!",
        500
      ),
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError2(
        "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
        "'bodyLimit' option must be an integer > 0. Got '%s'",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_REWRITE_NOT_STR: createError2(
        "FST_ERR_ROUTE_REWRITE_NOT_STR",
        'Rewrite url for "%s" needs to be of type "string" but received "%s"',
        500,
        TypeError
      ),
      /**
       *  again listen when close server
       */
      FST_ERR_REOPENED_CLOSE_SERVER: createError2(
        "FST_ERR_REOPENED_CLOSE_SERVER",
        "Fastify has already been closed and cannot be reopened"
      ),
      FST_ERR_REOPENED_SERVER: createError2(
        "FST_ERR_REOPENED_SERVER",
        "Fastify is already listening"
      ),
      FST_ERR_INSTANCE_ALREADY_LISTENING: createError2(
        "FST_ERR_INSTANCE_ALREADY_LISTENING",
        "Fastify instance is already listening. %s"
      ),
      /**
       * plugin
       */
      FST_ERR_PLUGIN_VERSION_MISMATCH: createError2(
        "FST_ERR_PLUGIN_VERSION_MISMATCH",
        "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
      ),
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError2(
        "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
        "The decorator '%s'%s is not present in %s"
      ),
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError2(
        "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
        "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
        500,
        TypeError
      ),
      /**
       *  Avvio Errors
       */
      FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError2(
        "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
        "fastify-plugin: %s",
        500,
        TypeError
      ),
      FST_ERR_PLUGIN_NOT_VALID: createError2(
        "FST_ERR_PLUGIN_NOT_VALID",
        "fastify-plugin: %s"
      ),
      FST_ERR_ROOT_PLG_BOOTED: createError2(
        "FST_ERR_ROOT_PLG_BOOTED",
        "fastify-plugin: %s"
      ),
      FST_ERR_PARENT_PLUGIN_BOOTED: createError2(
        "FST_ERR_PARENT_PLUGIN_BOOTED",
        "fastify-plugin: %s"
      ),
      FST_ERR_PLUGIN_TIMEOUT: createError2(
        "FST_ERR_PLUGIN_TIMEOUT",
        "fastify-plugin: %s"
      )
    };
    function appendStackTrace(oldErr, newErr) {
      newErr.cause = oldErr;
      return newErr;
    }
    module.exports = codes;
    module.exports.appendStackTrace = appendStackTrace;
    module.exports.AVVIO_ERRORS_MAP = {
      AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
      AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
      AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
      AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
      AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
      AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/hooks.js
var require_hooks = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/hooks.js"(exports, module) {
    "use strict";
    var applicationHooks = [
      "onRoute",
      "onRegister",
      "onReady",
      "onListen",
      "preClose",
      "onClose"
    ];
    var lifecycleHooks = [
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError",
      "onRequestAbort"
    ];
    var supportedHooks = lifecycleHooks.concat(applicationHooks);
    var {
      FST_ERR_HOOK_INVALID_TYPE,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_SEND_UNDEFINED_ERR,
      FST_ERR_HOOK_TIMEOUT,
      FST_ERR_HOOK_NOT_SUPPORTED,
      AVVIO_ERRORS_MAP,
      appendStackTrace
    } = require_errors2();
    var {
      kChildren,
      kHooks,
      kRequestPayloadStream
    } = require_symbols2();
    function Hooks() {
      this.onRequest = [];
      this.preParsing = [];
      this.preValidation = [];
      this.preSerialization = [];
      this.preHandler = [];
      this.onResponse = [];
      this.onSend = [];
      this.onError = [];
      this.onRoute = [];
      this.onRegister = [];
      this.onReady = [];
      this.onListen = [];
      this.onTimeout = [];
      this.onRequestAbort = [];
      this.preClose = [];
    }
    Hooks.prototype = /* @__PURE__ */ Object.create(null);
    Hooks.prototype.validate = function(hook, fn) {
      if (typeof hook !== "string") throw new FST_ERR_HOOK_INVALID_TYPE();
      if (Array.isArray(this[hook]) === false) {
        throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
      }
      if (typeof fn !== "function") throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn));
    };
    Hooks.prototype.add = function(hook, fn) {
      this.validate(hook, fn);
      this[hook].push(fn);
    };
    function buildHooks(h) {
      const hooks = new Hooks();
      hooks.onRequest = h.onRequest.slice();
      hooks.preParsing = h.preParsing.slice();
      hooks.preValidation = h.preValidation.slice();
      hooks.preSerialization = h.preSerialization.slice();
      hooks.preHandler = h.preHandler.slice();
      hooks.onSend = h.onSend.slice();
      hooks.onResponse = h.onResponse.slice();
      hooks.onError = h.onError.slice();
      hooks.onRoute = h.onRoute.slice();
      hooks.onRegister = h.onRegister.slice();
      hooks.onTimeout = h.onTimeout.slice();
      hooks.onRequestAbort = h.onRequestAbort.slice();
      hooks.onReady = [];
      hooks.onListen = [];
      hooks.preClose = [];
      return hooks;
    }
    function hookRunnerApplication(hookName, boot, server, cb) {
      const hooks = server[kHooks][hookName];
      let i = 0;
      let c = 0;
      next();
      function exit(err) {
        const hookFnName = hooks[i - 1]?.name;
        const hookFnFragment = hookFnName ? ` "${hookFnName}"` : "";
        if (err) {
          if (err.code === "AVV_ERR_READY_TIMEOUT") {
            err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
          } else {
            err = AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
          }
          cb(err);
          return;
        }
        cb();
      }
      function next(err) {
        if (err) {
          exit(err);
          return;
        }
        if (i === hooks.length && c === server[kChildren].length) {
          if (i === 0 && c === 0) {
            exit();
          } else {
            boot(function manageTimeout(err2, done) {
              exit(err2);
              done(err2);
            });
          }
          return;
        }
        if (i === hooks.length && c < server[kChildren].length) {
          const child = server[kChildren][c++];
          hookRunnerApplication(hookName, boot, child, next);
          return;
        }
        boot(wrap2(hooks[i++], server));
        next();
      }
      function wrap2(fn, server2) {
        return function(err, done) {
          if (err) {
            done(err);
            return;
          }
          if (fn.length === 1) {
            try {
              fn.call(server2, done);
            } catch (error48) {
              done(error48);
            }
            return;
          }
          try {
            const ret = fn.call(server2);
            if (ret && typeof ret.then === "function") {
              ret.then(done, done);
              return;
            }
          } catch (error48) {
            err = error48;
          }
          done(err);
        };
      }
    }
    function onListenHookRunner(server) {
      const hooks = server[kHooks].onListen;
      const hooksLen = hooks.length;
      let i = 0;
      let c = 0;
      next();
      function next(err) {
        err && server.log.error(err);
        if (i === hooksLen) {
          while (c < server[kChildren].length) {
            const child = server[kChildren][c++];
            onListenHookRunner(child);
          }
          return;
        }
        wrap2(hooks[i++], server, next);
      }
      async function wrap2(fn, server2, done) {
        if (fn.length === 1) {
          try {
            fn.call(server2, done);
          } catch (e) {
            done(e);
          }
          return;
        }
        try {
          const ret = fn.call(server2);
          if (ret && typeof ret.then === "function") {
            ret.then(done, done);
            return;
          }
          done();
        } catch (error48) {
          done(error48);
        }
      }
    }
    function hookRunnerGenerator(iterator) {
      return function hookRunner(functions, request, reply, cb) {
        let i = 0;
        function next(err) {
          if (err || i === functions.length) {
            cb(err, request, reply);
            return;
          }
          let result;
          try {
            result = iterator(functions[i++], request, reply, next);
          } catch (error48) {
            cb(error48, request, reply);
            return;
          }
          if (result && typeof result.then === "function") {
            result.then(handleResolve, handleReject);
          }
        }
        function handleResolve() {
          next();
        }
        function handleReject(err) {
          if (!err) {
            err = new FST_ERR_SEND_UNDEFINED_ERR();
          }
          cb(err, request, reply);
        }
        next();
      };
    }
    function onResponseHookIterator(fn, request, reply, next) {
      return fn(request, reply, next);
    }
    var onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
    var preValidationHookRunner = hookRunnerGenerator(hookIterator);
    var preHandlerHookRunner = hookRunnerGenerator(hookIterator);
    var onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
    var onRequestHookRunner = hookRunnerGenerator(hookIterator);
    function onSendHookRunner(functions, request, reply, payload, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (err) {
          cb(err, request, reply, payload);
          return;
        }
        if (newPayload !== void 0) {
          payload = newPayload;
        }
        if (i === functions.length) {
          cb(null, request, reply, payload);
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, payload, next);
        } catch (error48) {
          cb(error48, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request, reply, payload);
      }
      next();
    }
    var preSerializationHookRunner = onSendHookRunner;
    function preParsingHookRunner(functions, request, reply, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (reply.sent) {
          return;
        }
        if (newPayload !== void 0) {
          request[kRequestPayloadStream] = newPayload;
        }
        if (err || i === functions.length) {
          cb(err, request, reply);
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, request[kRequestPayloadStream], next);
        } catch (error48) {
          cb(error48, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request, reply);
      }
      next();
    }
    function onRequestAbortHookRunner(functions, request, cb) {
      let i = 0;
      function next(err) {
        if (err || i === functions.length) {
          cb(err, request);
          return;
        }
        let result;
        try {
          result = functions[i++](request, next);
        } catch (error48) {
          cb(error48, request);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request);
      }
      next();
    }
    function hookIterator(fn, request, reply, next) {
      if (reply.sent === true) return void 0;
      return fn(request, reply, next);
    }
    module.exports = {
      Hooks,
      buildHooks,
      hookRunnerGenerator,
      preParsingHookRunner,
      onResponseHookRunner,
      onSendHookRunner,
      preSerializationHookRunner,
      onRequestAbortHookRunner,
      hookIterator,
      hookRunnerApplication,
      onListenHookRunner,
      preHandlerHookRunner,
      preValidationHookRunner,
      onRequestHookRunner,
      onTimeoutHookRunner,
      lifecycleHooks,
      supportedHooks
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/promise.js
var require_promise = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/promise.js"(exports, module) {
    "use strict";
    var { kTestInternals } = require_symbols2();
    function withResolvers() {
      let res, rej;
      const promise2 = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise: promise2, resolve: res, reject: rej };
    }
    module.exports = {
      // TODO(20.x): remove when node@20 is not supported
      withResolvers: typeof Promise.withResolvers === "function" ? Promise.withResolvers.bind(Promise) : withResolvers,
      // Tested using the kTestInternals
      [kTestInternals]: {
        withResolvers
      }
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/server.js
var require_server = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/server.js"(exports, module) {
    "use strict";
    var http = __require("node:http");
    var https = __require("node:https");
    var http2 = __require("node:http2");
    var dns = __require("node:dns");
    var os2 = __require("node:os");
    var { kState, kOptions, kServerBindings, kHttp2ServerSessions } = require_symbols2();
    var { FSTWRN003 } = require_warnings();
    var { onListenHookRunner } = require_hooks();
    var {
      FST_ERR_REOPENED_CLOSE_SERVER,
      FST_ERR_REOPENED_SERVER,
      FST_ERR_LISTEN_OPTIONS_INVALID
    } = require_errors2();
    var PonyPromise = require_promise();
    module.exports.createServer = createServer;
    function defaultResolveServerListeningText(address) {
      return `Server listening at ${address}`;
    }
    function createServer(options, httpHandler) {
      const server = getServerInstance(options, httpHandler);
      function listen(listenOptions = { port: 0, host: "localhost" }, cb = void 0) {
        if (typeof cb === "function") {
          if (cb.constructor.name === "AsyncFunction") {
            FSTWRN003("listen method");
          }
          listenOptions.cb = cb;
        }
        if (listenOptions.signal) {
          if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
            throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
          }
          this[kState].aborted = listenOptions.signal.aborted;
          if (this[kState].aborted) {
            return this.close();
          } else {
            const onAborted = () => {
              this[kState].aborted = true;
              this.close();
            };
            listenOptions.signal.addEventListener("abort", onAborted, { once: true });
          }
        }
        let host;
        if (listenOptions.path == null) {
          host = listenOptions.host ?? "localhost";
        } else {
          host = listenOptions.host;
        }
        if (!Object.hasOwn(listenOptions, "host") || listenOptions.host == null) {
          listenOptions.host = host;
        }
        if (host === "localhost") {
          listenOptions.cb = (err, address) => {
            if (err) {
              cb(err, address);
              return;
            }
            multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
              this[kState].listening = true;
              cb(null, address);
              onListenHookRunner(this);
            });
          };
        } else {
          listenOptions.cb = (err, address) => {
            if (err) {
              cb(err, address);
              return;
            }
            this[kState].listening = true;
            cb(null, address);
            onListenHookRunner(this);
          };
        }
        if (cb === void 0) {
          const listening = listenPromise.call(this, server, listenOptions);
          return listening.then((address) => {
            const { promise: promise2, resolve } = PonyPromise.withResolvers();
            if (host === "localhost") {
              multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
                this[kState].listening = true;
                resolve(address);
                onListenHookRunner(this);
              });
            } else {
              resolve(address);
              onListenHookRunner(this);
            }
            return promise2;
          });
        }
        this.ready(listenCallback.call(this, server, listenOptions));
      }
      return { server, listen };
    }
    function multipleBindings(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
      this[kState].listening = false;
      dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
        if (dnsErr || this[kState].aborted) {
          onListen();
          return;
        }
        const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
        let binding = 0;
        let bound = 0;
        if (!isMainServerListening) {
          const primaryAddress = mainServer.address();
          for (const adr of addresses) {
            if (adr.address !== primaryAddress.address) {
              binding++;
              const secondaryOpts = Object.assign({}, listenOptions, {
                host: adr.address,
                port: primaryAddress.port,
                cb: (_ignoreErr) => {
                  bound++;
                  if (!_ignoreErr) {
                    this[kServerBindings].push(secondaryServer);
                  }
                  if (bound === binding) {
                    onListen();
                  }
                }
              });
              const secondaryServer = getServerInstance(serverOpts, httpHandler);
              const closeSecondary = () => {
                secondaryServer.close(() => {
                });
                if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections === true) {
                  secondaryServer.closeAllConnections();
                }
                if (typeof secondaryServer.closeHttp2Sessions === "function") {
                  secondaryServer.closeHttp2Sessions();
                }
              };
              secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
              mainServer.on("unref", closeSecondary);
              mainServer.on("close", closeSecondary);
              mainServer.on("error", closeSecondary);
              this[kState].listening = false;
              listenCallback.call(this, secondaryServer, secondaryOpts)();
            }
          }
        }
        if (binding === 0) {
          onListen();
          return;
        }
        const originUnref = mainServer.unref;
        mainServer.unref = function() {
          originUnref.call(mainServer);
          mainServer.emit("unref");
        };
      });
    }
    function listenCallback(server, listenOptions) {
      const wrap2 = (err) => {
        server.removeListener("error", wrap2);
        server.removeListener("listening", wrap2);
        if (!err) {
          const address = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
          listenOptions.cb(null, address);
        } else {
          this[kState].listening = false;
          listenOptions.cb(err, null);
        }
      };
      return (err) => {
        if (err != null) return listenOptions.cb(err);
        if (this[kState].listening && this[kState].closing) {
          return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null);
        }
        if (this[kState].listening) {
          return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null);
        }
        server.once("error", wrap2);
        if (!this[kState].closing) {
          server.once("listening", wrap2);
          server.listen(listenOptions);
          this[kState].listening = true;
        }
      };
    }
    function listenPromise(server, listenOptions) {
      if (this[kState].listening && this[kState].closing) {
        return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER());
      }
      if (this[kState].listening) {
        return Promise.reject(new FST_ERR_REOPENED_SERVER());
      }
      return this.ready().then(() => {
        if (this[kState].aborted) return;
        const { promise: promise2, resolve, reject } = PonyPromise.withResolvers();
        const errEventHandler = (err) => {
          cleanup();
          this[kState].listening = false;
          reject(err);
        };
        const listeningEventHandler = () => {
          cleanup();
          this[kState].listening = true;
          resolve(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
        };
        function cleanup() {
          server.removeListener("error", errEventHandler);
          server.removeListener("listening", listeningEventHandler);
        }
        server.once("error", errEventHandler);
        server.once("listening", listeningEventHandler);
        server.listen(listenOptions);
        return promise2;
      });
    }
    function getServerInstance(options, httpHandler) {
      if (options.serverFactory) {
        return options.serverFactory(httpHandler, options);
      }
      const httpsOptions = options.https === true ? {} : options.https;
      if (options.http2) {
        const server2 = typeof httpsOptions === "object" ? http2.createSecureServer(httpsOptions, httpHandler) : http2.createServer(options.http, httpHandler);
        server2.on("session", (session) => session.setTimeout(options.http2SessionTimeout, () => {
          session.close();
        }));
        if (options.forceCloseConnections === true) {
          server2.closeHttp2Sessions = createCloseHttp2SessionsByHttp2Server(server2);
        }
        server2.setTimeout(options.connectionTimeout);
        return server2;
      }
      const server = httpsOptions ? https.createServer(httpsOptions, httpHandler) : http.createServer(options.http, httpHandler);
      server.keepAliveTimeout = options.keepAliveTimeout;
      server.requestTimeout = options.requestTimeout;
      server.setTimeout(options.connectionTimeout);
      if (options.maxRequestsPerSocket > 0) {
        server.maxRequestsPerSocket = options.maxRequestsPerSocket;
      }
      return server;
    }
    function getAddresses(address) {
      if (address.address === "0.0.0.0") {
        return Object.values(os2.networkInterfaces()).flatMap((iface) => {
          return iface.filter((iface2) => iface2.family === "IPv4");
        }).sort((iface) => {
          return iface.internal ? -1 : 1;
        }).map((iface) => {
          return iface.address;
        });
      }
      return [address.address];
    }
    function logServerAddress(server, listenTextResolver) {
      let addresses;
      const isUnixSocket = typeof server.address() === "string";
      if (!isUnixSocket) {
        if (server.address().address.indexOf(":") === -1) {
          addresses = getAddresses(server.address()).map((address) => address + ":" + server.address().port);
        } else {
          addresses = ["[" + server.address().address + "]:" + server.address().port];
        }
        addresses = addresses.map((address) => "http" + (this[kOptions].https ? "s" : "") + "://" + address);
      } else {
        addresses = [server.address()];
      }
      for (const address of addresses) {
        this.log.info(listenTextResolver(address));
      }
      return addresses[0];
    }
    function createCloseHttp2SessionsByHttp2Server(http2Server) {
      http2Server[kHttp2ServerSessions] = /* @__PURE__ */ new Set();
      http2Server.on("session", function(session) {
        session.once("connect", function() {
          http2Server[kHttp2ServerSessions].add(session);
        });
        session.once("close", function() {
          http2Server[kHttp2ServerSessions].delete(session);
        });
        session.once("frameError", function(type, code, streamId) {
          if (streamId === 0) {
            http2Server[kHttp2ServerSessions].delete(session);
          }
        });
        session.once("goaway", function() {
          http2Server[kHttp2ServerSessions].delete(session);
        });
      });
      return function closeHttp2Sessions() {
        if (http2Server[kHttp2ServerSessions].size === 0) {
          return;
        }
        for (const session of http2Server[kHttp2ServerSessions]) {
          session.close();
        }
      };
    }
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/validation.js
var require_validation = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/validation.js"(exports, module) {
    "use strict";
    var {
      kSchemaHeaders: headersSchema,
      kSchemaParams: paramsSchema,
      kSchemaQuerystring: querystringSchema,
      kSchemaBody: bodySchema,
      kSchemaResponse: responseSchema
    } = require_symbols2();
    var scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;
    var {
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
    } = require_errors2();
    var { FSTWRN001 } = require_warnings();
    function compileSchemasForSerialization(context, compile) {
      if (!context.schema || !context.schema.response) {
        return;
      }
      const { method, url: url2 } = context.config || {};
      context[responseSchema] = Object.keys(context.schema.response).reduce(function(acc, statusCode) {
        const schema = context.schema.response[statusCode];
        statusCode = statusCode.toLowerCase();
        if (!scChecker.test(statusCode)) {
          throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX();
        }
        if (schema.content) {
          const contentTypesSchemas = {};
          for (const mediaName of Object.keys(schema.content)) {
            const contentSchema = schema.content[mediaName].schema;
            contentTypesSchemas[mediaName] = compile({
              schema: contentSchema,
              url: url2,
              method,
              httpStatus: statusCode,
              contentType: mediaName
            });
          }
          acc[statusCode] = contentTypesSchemas;
        } else {
          acc[statusCode] = compile({
            schema,
            url: url2,
            method,
            httpStatus: statusCode
          });
        }
        return acc;
      }, {});
    }
    function compileSchemasForValidation(context, compile, isCustom) {
      const { schema } = context;
      if (!schema) {
        return;
      }
      const { method, url: url2 } = context.config || {};
      const headers = schema.headers;
      if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
        context[headersSchema] = compile({ schema: headers, method, url: url2, httpPart: "headers" });
      } else if (headers) {
        const headersSchemaLowerCase = {};
        Object.keys(headers).forEach((k) => {
          headersSchemaLowerCase[k] = headers[k];
        });
        if (headersSchemaLowerCase.required instanceof Array) {
          headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
        }
        if (headers.properties) {
          headersSchemaLowerCase.properties = {};
          Object.keys(headers.properties).forEach((k) => {
            headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
          });
        }
        context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url: url2, httpPart: "headers" });
      } else if (Object.hasOwn(schema, "headers")) {
        FSTWRN001("headers", method, url2);
      }
      if (schema.body) {
        const contentProperty = schema.body.content;
        if (contentProperty) {
          const contentTypeSchemas = {};
          for (const contentType of Object.keys(contentProperty)) {
            const contentSchema = contentProperty[contentType].schema;
            contentTypeSchemas[contentType] = compile({ schema: contentSchema, method, url: url2, httpPart: "body", contentType });
          }
          context[bodySchema] = contentTypeSchemas;
        } else {
          context[bodySchema] = compile({ schema: schema.body, method, url: url2, httpPart: "body" });
        }
      } else if (Object.hasOwn(schema, "body")) {
        FSTWRN001("body", method, url2);
      }
      if (schema.querystring) {
        context[querystringSchema] = compile({ schema: schema.querystring, method, url: url2, httpPart: "querystring" });
      } else if (Object.hasOwn(schema, "querystring")) {
        FSTWRN001("querystring", method, url2);
      }
      if (schema.params) {
        context[paramsSchema] = compile({ schema: schema.params, method, url: url2, httpPart: "params" });
      } else if (Object.hasOwn(schema, "params")) {
        FSTWRN001("params", method, url2);
      }
    }
    function validateParam(validatorFunction, request, paramName) {
      const isUndefined = request[paramName] === void 0;
      const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName]);
      if (ret && typeof ret.then === "function") {
        return ret.then((res) => {
          return answer(res);
        }).catch((err) => {
          return err;
        });
      }
      return answer(ret);
      function answer(ret2) {
        if (ret2 === false) return validatorFunction.errors;
        if (ret2 && ret2.error) return ret2.error;
        if (ret2 && ret2.value) request[paramName] = ret2.value;
        return false;
      }
    }
    function validate(context, request, execution) {
      const runExecution = execution === void 0;
      if (runExecution || !execution.skipParams) {
        const params = validateParam(context[paramsSchema], request, "params");
        if (params) {
          if (typeof params.then !== "function") {
            return wrapValidationError(params, "params", context.schemaErrorFormatter);
          } else {
            return validateAsyncParams(params, context, request);
          }
        }
      }
      if (runExecution || !execution.skipBody) {
        let validatorFunction = null;
        if (typeof context[bodySchema] === "function") {
          validatorFunction = context[bodySchema];
        } else if (context[bodySchema]) {
          const contentType = getEssenceMediaType(request.headers["content-type"]);
          const contentSchema = context[bodySchema][contentType];
          if (contentSchema) {
            validatorFunction = contentSchema;
          }
        }
        const body = validateParam(validatorFunction, request, "body");
        if (body) {
          if (typeof body.then !== "function") {
            return wrapValidationError(body, "body", context.schemaErrorFormatter);
          } else {
            return validateAsyncBody(body, context, request);
          }
        }
      }
      if (runExecution || !execution.skipQuery) {
        const query = validateParam(context[querystringSchema], request, "query");
        if (query) {
          if (typeof query.then !== "function") {
            return wrapValidationError(query, "querystring", context.schemaErrorFormatter);
          } else {
            return validateAsyncQuery(query, context, request);
          }
        }
      }
      const headers = validateParam(context[headersSchema], request, "headers");
      if (headers) {
        if (typeof headers.then !== "function") {
          return wrapValidationError(headers, "headers", context.schemaErrorFormatter);
        } else {
          return validateAsyncHeaders(headers, context, request);
        }
      }
      return false;
    }
    function validateAsyncParams(validatePromise, context, request) {
      return validatePromise.then((paramsResult) => {
        if (paramsResult) {
          return wrapValidationError(paramsResult, "params", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true });
      });
    }
    function validateAsyncBody(validatePromise, context, request) {
      return validatePromise.then((bodyResult) => {
        if (bodyResult) {
          return wrapValidationError(bodyResult, "body", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true, skipBody: true });
      });
    }
    function validateAsyncQuery(validatePromise, context, request) {
      return validatePromise.then((queryResult) => {
        if (queryResult) {
          return wrapValidationError(queryResult, "querystring", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true, skipBody: true, skipQuery: true });
      });
    }
    function validateAsyncHeaders(validatePromise, context, request) {
      return validatePromise.then((headersResult) => {
        if (headersResult) {
          return wrapValidationError(headersResult, "headers", context.schemaErrorFormatter);
        }
        return false;
      });
    }
    function wrapValidationError(result, dataVar, schemaErrorFormatter) {
      if (result instanceof Error) {
        result.statusCode = result.statusCode || 400;
        result.code = result.code || "FST_ERR_VALIDATION";
        result.validationContext = result.validationContext || dataVar;
        return result;
      }
      const error48 = schemaErrorFormatter(result, dataVar);
      error48.statusCode = error48.statusCode || 400;
      error48.code = error48.code || "FST_ERR_VALIDATION";
      error48.validation = result;
      error48.validationContext = dataVar;
      return error48;
    }
    function getEssenceMediaType(header) {
      if (!header) return "";
      return header.split(/[ ;]/, 1)[0].trim().toLowerCase();
    }
    module.exports = {
      symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
      compileSchemasForValidation,
      compileSchemasForSerialization,
      validate
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/wrapThenable.js
var require_wrapThenable = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/wrapThenable.js"(exports, module) {
    "use strict";
    var {
      kReplyIsError,
      kReplyHijacked
    } = require_symbols2();
    var diagnostics = __require("node:diagnostics_channel");
    var channels = diagnostics.tracingChannel("fastify.request.handler");
    function wrapThenable(thenable, reply, store) {
      if (store) store.async = true;
      thenable.then(function(payload) {
        if (reply[kReplyHijacked] === true) {
          return;
        }
        if (store) {
          channels.asyncStart.publish(store);
        }
        try {
          if (payload !== void 0 || //
          reply.sent === false && //
          reply.raw.headersSent === false && reply.request.raw.aborted === false && reply.request.socket && !reply.request.socket.destroyed) {
            try {
              reply.send(payload);
            } catch (err) {
              reply[kReplyIsError] = true;
              reply.send(err);
            }
          }
        } finally {
          if (store) {
            channels.asyncEnd.publish(store);
          }
        }
      }, function(err) {
        if (store) {
          store.error = err;
          channels.error.publish(store);
          channels.asyncStart.publish(store);
        }
        try {
          if (reply.sent === true) {
            reply.log.error({ err }, "Promise errored, but reply.sent = true was set");
            return;
          }
          reply[kReplyIsError] = true;
          reply.send(err);
        } catch (err2) {
          reply.send(err2);
        } finally {
          if (store) {
            channels.asyncEnd.publish(store);
          }
        }
      });
    }
    module.exports = wrapThenable;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/handleRequest.js
var require_handleRequest = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/handleRequest.js"(exports, module) {
    "use strict";
    var diagnostics = __require("node:diagnostics_channel");
    var { validate: validateSchema } = require_validation();
    var { preValidationHookRunner, preHandlerHookRunner } = require_hooks();
    var wrapThenable = require_wrapThenable();
    var {
      kReplyIsError,
      kRouteContext,
      kFourOhFourContext,
      kSupportedHTTPMethods
    } = require_symbols2();
    var channels = diagnostics.tracingChannel("fastify.request.handler");
    function handleRequest(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      const method = request.method;
      if (this[kSupportedHTTPMethods].bodyless.has(method)) {
        handler(request, reply);
        return;
      }
      if (this[kSupportedHTTPMethods].bodywith.has(method)) {
        const headers = request.headers;
        const contentType = headers["content-type"];
        if (contentType === void 0) {
          const contentLength = headers["content-length"];
          const transferEncoding = headers["transfer-encoding"];
          const isEmptyBody = transferEncoding === void 0 && (contentLength === void 0 || contentLength === "0");
          if (isEmptyBody) {
            handler(request, reply);
            return;
          }
          request[kRouteContext].contentTypeParser.run("", handler, request, reply);
          return;
        }
        request[kRouteContext].contentTypeParser.run(contentType, handler, request, reply);
        return;
      }
      handler(request, reply);
    }
    function handler(request, reply) {
      try {
        if (request[kRouteContext].preValidation !== null) {
          preValidationHookRunner(
            request[kRouteContext].preValidation,
            request,
            reply,
            preValidationCallback
          );
        } else {
          preValidationCallback(null, request, reply);
        }
      } catch (err) {
        preValidationCallback(err, request, reply);
      }
    }
    function preValidationCallback(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      const validationErr = validateSchema(reply[kRouteContext], request);
      const isAsync = validationErr && typeof validationErr.then === "function" || false;
      if (isAsync) {
        const cb = validationCompleted.bind(null, request, reply);
        validationErr.then(cb, cb);
      } else {
        validationCompleted(request, reply, validationErr);
      }
    }
    function validationCompleted(request, reply, validationErr) {
      if (validationErr) {
        if (reply[kRouteContext].attachValidation === false) {
          reply.send(validationErr);
          return;
        }
        reply.request.validationError = validationErr;
      }
      if (request[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          request[kRouteContext].preHandler,
          request,
          reply,
          preHandlerCallback
        );
      } else {
        preHandlerCallback(null, request, reply);
      }
    }
    function preHandlerCallback(err, request, reply) {
      if (reply.sent) return;
      const context = request[kRouteContext];
      if (!channels.hasSubscribers || context[kFourOhFourContext] === null) {
        preHandlerCallbackInner(err, request, reply);
      } else {
        const store = {
          request,
          reply,
          async: false,
          route: {
            url: context.config.url,
            method: context.config.method
          }
        };
        channels.start.runStores(store, preHandlerCallbackInner, void 0, err, request, reply, store);
      }
    }
    function preHandlerCallbackInner(err, request, reply, store) {
      const context = request[kRouteContext];
      try {
        if (err != null) {
          reply[kReplyIsError] = true;
          reply.send(err);
          if (store) {
            store.error = err;
            channels.error.publish(store);
          }
          return;
        }
        let result;
        try {
          result = context.handler(request, reply);
        } catch (err2) {
          if (store) {
            store.error = err2;
            channels.error.publish(store);
          }
          reply[kReplyIsError] = true;
          reply.send(err2);
          return;
        }
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply, store);
          } else {
            reply.send(result);
          }
        }
      } finally {
        if (store) channels.end.publish(store);
      }
    }
    module.exports = handleRequest;
    module.exports[/* @__PURE__ */ Symbol.for("internals")] = { handler, preHandlerCallback };
  }
});

// node_modules/.pnpm/abstract-logging@2.0.1/node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS({
  "node_modules/.pnpm/abstract-logging@2.0.1/node_modules/abstract-logging/index.js"(exports, module) {
    "use strict";
    function noop() {
    }
    var proto = {
      fatal: noop,
      error: noop,
      warn: noop,
      info: noop,
      debug: noop,
      trace: noop
    };
    Object.defineProperty(module, "exports", {
      get() {
        return Object.create(proto);
      }
    });
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-helpers.js"(exports, module) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-proto.js"(exports, module) {
    "use strict";
    var seen = /* @__PURE__ */ Symbol("circular-ref-tag");
    var rawSymbol = /* @__PURE__ */ Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err.js"(exports, module) {
    "use strict";
    module.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports, module) {
    "use strict";
    module.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/req.js"(exports, module) {
    "use strict";
    module.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = /* @__PURE__ */ Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path = req.path;
        _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/res.js"(exports, module) {
    "use strict";
    module.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = /* @__PURE__ */ Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/index.js"(exports, module) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/caller.js"(exports, module) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// node_modules/.pnpm/@pinojs+redact@0.4.0/node_modules/@pinojs/redact/index.js
var require_redact = __commonJS({
  "node_modules/.pnpm/@pinojs+redact@0.4.0/node_modules/@pinojs/redact/index.js"(exports, module) {
    "use strict";
    function deepClone(obj) {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof Array) {
        const cloned = [];
        for (let i = 0; i < obj.length; i++) {
          cloned[i] = deepClone(obj[i]);
        }
        return cloned;
      }
      if (typeof obj === "object") {
        const cloned = Object.create(Object.getPrototypeOf(obj));
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key]);
          }
        }
        return cloned;
      }
      return obj;
    }
    function parsePath(path) {
      const parts = [];
      let current = "";
      let inBrackets = false;
      let inQuotes = false;
      let quoteChar = "";
      for (let i = 0; i < path.length; i++) {
        const char2 = path[i];
        if (!inBrackets && char2 === ".") {
          if (current) {
            parts.push(current);
            current = "";
          }
        } else if (char2 === "[") {
          if (current) {
            parts.push(current);
            current = "";
          }
          inBrackets = true;
        } else if (char2 === "]" && inBrackets) {
          parts.push(current);
          current = "";
          inBrackets = false;
          inQuotes = false;
        } else if ((char2 === '"' || char2 === "'") && inBrackets) {
          if (!inQuotes) {
            inQuotes = true;
            quoteChar = char2;
          } else if (char2 === quoteChar) {
            inQuotes = false;
            quoteChar = "";
          } else {
            current += char2;
          }
        } else {
          current += char2;
        }
      }
      if (current) {
        parts.push(current);
      }
      return parts;
    }
    function setValue(obj, parts, value) {
      let current = obj;
      for (let i = 0; i < parts.length - 1; i++) {
        const key = parts[i];
        if (typeof current !== "object" || current === null || !(key in current)) {
          return false;
        }
        if (typeof current[key] !== "object" || current[key] === null) {
          return false;
        }
        current = current[key];
      }
      const lastKey = parts[parts.length - 1];
      if (lastKey === "*") {
        if (Array.isArray(current)) {
          for (let i = 0; i < current.length; i++) {
            current[i] = value;
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              current[key] = value;
            }
          }
        }
      } else {
        if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
          current[lastKey] = value;
        }
      }
      return true;
    }
    function removeKey(obj, parts) {
      let current = obj;
      for (let i = 0; i < parts.length - 1; i++) {
        const key = parts[i];
        if (typeof current !== "object" || current === null || !(key in current)) {
          return false;
        }
        if (typeof current[key] !== "object" || current[key] === null) {
          return false;
        }
        current = current[key];
      }
      const lastKey = parts[parts.length - 1];
      if (lastKey === "*") {
        if (Array.isArray(current)) {
          for (let i = 0; i < current.length; i++) {
            current[i] = void 0;
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              delete current[key];
            }
          }
        }
      } else {
        if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
          delete current[lastKey];
        }
      }
      return true;
    }
    var PATH_NOT_FOUND = /* @__PURE__ */ Symbol("PATH_NOT_FOUND");
    function getValueIfExists(obj, parts) {
      let current = obj;
      for (const part of parts) {
        if (current === null || current === void 0) {
          return PATH_NOT_FOUND;
        }
        if (typeof current !== "object" || current === null) {
          return PATH_NOT_FOUND;
        }
        if (!(part in current)) {
          return PATH_NOT_FOUND;
        }
        current = current[part];
      }
      return current;
    }
    function getValue(obj, parts) {
      let current = obj;
      for (const part of parts) {
        if (current === null || current === void 0) {
          return void 0;
        }
        if (typeof current !== "object" || current === null) {
          return void 0;
        }
        current = current[part];
      }
      return current;
    }
    function redactPaths(obj, paths, censor, remove = false) {
      for (const path of paths) {
        const parts = parsePath(path);
        if (parts.includes("*")) {
          redactWildcardPath(obj, parts, censor, path, remove);
        } else {
          if (remove) {
            removeKey(obj, parts);
          } else {
            const value = getValueIfExists(obj, parts);
            if (value === PATH_NOT_FOUND) {
              continue;
            }
            const actualCensor = typeof censor === "function" ? censor(value, parts) : censor;
            setValue(obj, parts, actualCensor);
          }
        }
      }
    }
    function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
      const wildcardIndex = parts.indexOf("*");
      if (wildcardIndex === parts.length - 1) {
        const parentParts = parts.slice(0, -1);
        let current = obj;
        for (const part of parentParts) {
          if (current === null || current === void 0) return;
          if (typeof current !== "object" || current === null) return;
          current = current[part];
        }
        if (Array.isArray(current)) {
          if (remove) {
            for (let i = 0; i < current.length; i++) {
              current[i] = void 0;
            }
          } else {
            for (let i = 0; i < current.length; i++) {
              const indexPath = [...parentParts, i.toString()];
              const actualCensor = typeof censor === "function" ? censor(current[i], indexPath) : censor;
              current[i] = actualCensor;
            }
          }
        } else if (typeof current === "object" && current !== null) {
          if (remove) {
            const keysToDelete = [];
            for (const key in current) {
              if (Object.prototype.hasOwnProperty.call(current, key)) {
                keysToDelete.push(key);
              }
            }
            for (const key of keysToDelete) {
              delete current[key];
            }
          } else {
            for (const key in current) {
              const keyPath = [...parentParts, key];
              const actualCensor = typeof censor === "function" ? censor(current[key], keyPath) : censor;
              current[key] = actualCensor;
            }
          }
        }
      } else {
        redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
      }
    }
    function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
      const beforeWildcard = parts.slice(0, wildcardIndex);
      const afterWildcard = parts.slice(wildcardIndex + 1);
      const pathArray = [];
      function traverse(current, pathLength) {
        if (pathLength === beforeWildcard.length) {
          if (Array.isArray(current)) {
            for (let i = 0; i < current.length; i++) {
              pathArray[pathLength] = i.toString();
              traverse(current[i], pathLength + 1);
            }
          } else if (typeof current === "object" && current !== null) {
            for (const key in current) {
              pathArray[pathLength] = key;
              traverse(current[key], pathLength + 1);
            }
          }
        } else if (pathLength < beforeWildcard.length) {
          const nextKey = beforeWildcard[pathLength];
          if (current && typeof current === "object" && current !== null && nextKey in current) {
            pathArray[pathLength] = nextKey;
            traverse(current[nextKey], pathLength + 1);
          }
        } else {
          if (afterWildcard.includes("*")) {
            const wrappedCensor = typeof censor === "function" ? (value, path) => {
              const fullPath = [...pathArray.slice(0, pathLength), ...path];
              return censor(value, fullPath);
            } : censor;
            redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
          } else {
            if (remove) {
              removeKey(current, afterWildcard);
            } else {
              const actualCensor = typeof censor === "function" ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard]) : censor;
              setValue(current, afterWildcard, actualCensor);
            }
          }
        }
      }
      if (beforeWildcard.length === 0) {
        traverse(obj, 0);
      } else {
        let current = obj;
        for (let i = 0; i < beforeWildcard.length; i++) {
          const part = beforeWildcard[i];
          if (current === null || current === void 0) return;
          if (typeof current !== "object" || current === null) return;
          current = current[part];
          pathArray[i] = part;
        }
        if (current !== null && current !== void 0) {
          traverse(current, beforeWildcard.length);
        }
      }
    }
    function buildPathStructure(pathsToClone) {
      if (pathsToClone.length === 0) {
        return null;
      }
      const pathStructure = /* @__PURE__ */ new Map();
      for (const path of pathsToClone) {
        const parts = parsePath(path);
        let current = pathStructure;
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          if (!current.has(part)) {
            current.set(part, /* @__PURE__ */ new Map());
          }
          current = current.get(part);
        }
      }
      return pathStructure;
    }
    function selectiveClone(obj, pathStructure) {
      if (!pathStructure) {
        return obj;
      }
      function cloneSelectively(source, pathMap, depth = 0) {
        if (!pathMap || pathMap.size === 0) {
          return source;
        }
        if (source === null || typeof source !== "object") {
          return source;
        }
        if (source instanceof Date) {
          return new Date(source.getTime());
        }
        if (Array.isArray(source)) {
          const cloned2 = [];
          for (let i = 0; i < source.length; i++) {
            const indexStr = i.toString();
            if (pathMap.has(indexStr) || pathMap.has("*")) {
              cloned2[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get("*"));
            } else {
              cloned2[i] = source[i];
            }
          }
          return cloned2;
        }
        const cloned = Object.create(Object.getPrototypeOf(source));
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (pathMap.has(key) || pathMap.has("*")) {
              cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get("*"));
            } else {
              cloned[key] = source[key];
            }
          }
        }
        return cloned;
      }
      return cloneSelectively(obj, pathStructure);
    }
    function validatePath(path) {
      if (typeof path !== "string") {
        throw new Error("Paths must be (non-empty) strings");
      }
      if (path === "") {
        throw new Error("Invalid redaction path ()");
      }
      if (path.includes("..")) {
        throw new Error(`Invalid redaction path (${path})`);
      }
      if (path.includes(",")) {
        throw new Error(`Invalid redaction path (${path})`);
      }
      let bracketCount = 0;
      let inQuotes = false;
      let quoteChar = "";
      for (let i = 0; i < path.length; i++) {
        const char2 = path[i];
        if ((char2 === '"' || char2 === "'") && bracketCount > 0) {
          if (!inQuotes) {
            inQuotes = true;
            quoteChar = char2;
          } else if (char2 === quoteChar) {
            inQuotes = false;
            quoteChar = "";
          }
        } else if (char2 === "[" && !inQuotes) {
          bracketCount++;
        } else if (char2 === "]" && !inQuotes) {
          bracketCount--;
          if (bracketCount < 0) {
            throw new Error(`Invalid redaction path (${path})`);
          }
        }
      }
      if (bracketCount !== 0) {
        throw new Error(`Invalid redaction path (${path})`);
      }
    }
    function validatePaths(paths) {
      if (!Array.isArray(paths)) {
        throw new TypeError("paths must be an array");
      }
      for (const path of paths) {
        validatePath(path);
      }
    }
    function slowRedact(options = {}) {
      const {
        paths = [],
        censor = "[REDACTED]",
        serialize = JSON.stringify,
        strict = true,
        remove = false
      } = options;
      validatePaths(paths);
      const pathStructure = buildPathStructure(paths);
      return function redact(obj) {
        if (strict && (obj === null || typeof obj !== "object")) {
          if (obj === null || obj === void 0) {
            return serialize ? serialize(obj) : obj;
          }
          if (typeof obj !== "object") {
            return serialize ? serialize(obj) : obj;
          }
        }
        const cloned = selectiveClone(obj, pathStructure);
        const original = obj;
        let actualCensor = censor;
        if (typeof censor === "function") {
          actualCensor = censor;
        }
        redactPaths(cloned, paths, actualCensor, remove);
        if (serialize === false) {
          cloned.restore = function() {
            return deepClone(original);
          };
          return cloned;
        }
        if (typeof serialize === "function") {
          return serialize(cloned);
        }
        return JSON.stringify(cloned);
      };
    }
    module.exports = slowRedact;
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js"(exports, module) {
    "use strict";
    var setLevelSym = /* @__PURE__ */ Symbol("pino.setLevel");
    var getLevelSym = /* @__PURE__ */ Symbol("pino.getLevel");
    var levelValSym = /* @__PURE__ */ Symbol("pino.levelVal");
    var levelCompSym = /* @__PURE__ */ Symbol("pino.levelComp");
    var useLevelLabelsSym = /* @__PURE__ */ Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = /* @__PURE__ */ Symbol("pino.useOnlyCustomLevels");
    var mixinSym = /* @__PURE__ */ Symbol("pino.mixin");
    var lsCacheSym = /* @__PURE__ */ Symbol("pino.lsCache");
    var chindingsSym = /* @__PURE__ */ Symbol("pino.chindings");
    var asJsonSym = /* @__PURE__ */ Symbol("pino.asJson");
    var writeSym = /* @__PURE__ */ Symbol("pino.write");
    var redactFmtSym = /* @__PURE__ */ Symbol("pino.redactFmt");
    var timeSym = /* @__PURE__ */ Symbol("pino.time");
    var timeSliceIndexSym = /* @__PURE__ */ Symbol("pino.timeSliceIndex");
    var streamSym = /* @__PURE__ */ Symbol("pino.stream");
    var stringifySym = /* @__PURE__ */ Symbol("pino.stringify");
    var stringifySafeSym = /* @__PURE__ */ Symbol("pino.stringifySafe");
    var stringifiersSym = /* @__PURE__ */ Symbol("pino.stringifiers");
    var endSym = /* @__PURE__ */ Symbol("pino.end");
    var formatOptsSym = /* @__PURE__ */ Symbol("pino.formatOpts");
    var messageKeySym = /* @__PURE__ */ Symbol("pino.messageKey");
    var errorKeySym = /* @__PURE__ */ Symbol("pino.errorKey");
    var nestedKeySym = /* @__PURE__ */ Symbol("pino.nestedKey");
    var nestedKeyStrSym = /* @__PURE__ */ Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = /* @__PURE__ */ Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = /* @__PURE__ */ Symbol("pino.msgPrefix");
    var wildcardFirstSym = /* @__PURE__ */ Symbol("pino.wildcardFirst");
    var serializersSym = /* @__PURE__ */ Symbol.for("pino.serializers");
    var formattersSym = /* @__PURE__ */ Symbol.for("pino.formatters");
    var hooksSym = /* @__PURE__ */ Symbol.for("pino.hooks");
    var needsMetadataGsym = /* @__PURE__ */ Symbol.for("pino.metadata");
    module.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/redaction.js"(exports, module) {
    "use strict";
    var Redact = require_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols3();
    var rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor, remove } = handle(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index: index2 } = next;
        const nextPath = `${str.substr(index2, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: Redact({ paths, censor, serialize, strict, remove })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [k, ...path]);
          } : censor;
          o[k] = Redact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict,
            remove
          });
        }
        return o;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      return { paths, censor, remove };
    }
    module.exports = redaction;
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/time.js"(exports, module) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    var NS_PER_MS = 1000000n;
    var NS_PER_SEC = 1000000000n;
    var startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
    var startHrTime = process.hrtime.bigint();
    var isoTimeNano = () => {
      const elapsedNs = process.hrtime.bigint() - startHrTime;
      const currentTimeNs = startWallTimeNs + elapsedNs;
      const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
      const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
      const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1000000n);
      const date9 = new Date(msSinceEpoch);
      const year = date9.getUTCFullYear();
      const month = (date9.getUTCMonth() + 1).toString().padStart(2, "0");
      const day = date9.getUTCDate().toString().padStart(2, "0");
      const hours = date9.getUTCHours().toString().padStart(2, "0");
      const minutes = date9.getUTCMinutes().toString().padStart(2, "0");
      const seconds = date9.getUTCSeconds().toString().padStart(2, "0");
      return `,"time":"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, "0")}Z"`;
    };
    module.exports = { nullTime, epochTime, unixTime, isoTime, isoTimeNano };
  }
});

// node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f, args, opts) {
      var ss2 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss2(f);
        for (var index2 = 1; index2 < len; index2++) {
          objects[index2] = ss2(args[index2]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a2 = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a2 >= argLen)
                break;
              if (args[a2] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a2]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a2 >= argLen)
                break;
              if (args[a2] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a2]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a2 >= argLen)
                break;
              if (args[a2] === void 0) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a2];
              if (type === "string") {
                str += "'" + args[a2] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a2].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss2(args[a2]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a2 >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a2]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a2--;
              break;
          }
          ++a2;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports, module) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms2) {
        const valid = ms2 > 0 && ms2 < Infinity;
        if (valid === false) {
          if (typeof ms2 !== "number" && typeof ms2 !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil2, 0, 0, Number(ms2));
      };
      const nil2 = new Int32Array(new SharedArrayBuffer(4));
      module.exports = sleep;
    } else {
      let sleep = function(ms2) {
        const valid = ms2 > 0 && ms2 < Infinity;
        if (valid === false) {
          if (typeof ms2 !== "number" && typeof ms2 !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms2);
        while (target > Date.now()) {
        }
      };
      module.exports = sleep;
    }
  }
});

// node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var EventEmitter = __require("events");
    var inherits = __require("util").inherits;
    var path = __require("path");
    var sleep = require_atomic_sleep();
    var assert2 = __require("assert");
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
    var kCopyBuffer = major >= 22 && minor >= 7;
    function openFile(file2, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file2;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs.mkdirSync(path.dirname(file2), { recursive: true });
          const fd = fs.openSync(file2, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs.mkdir(path.dirname(file2), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs.open(file2, flags, mode, fileOpened);
        });
      } else {
        fs.open(file2, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this._periodicFlush = periodicFlush || 0;
      this._periodicFlushTimer = void 0;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n2 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
      if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
      }
    }
    function releaseWritingBuf(writingBuf, len, n) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
      }
      len = Math.max(len - n, 0);
      writingBuf = writingBuf.slice(n);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([data]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          try {
            fs.fsync(this.fd, (err) => {
              this._flushPending = false;
              cb(err);
            });
          } catch (err) {
            cb(err);
          }
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error48 = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error48);
          return;
        }
        throw error48;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error48 = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error48);
          return;
        }
        throw error48;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file2) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file2);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file2) {
        this.file = file2;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf = "";
      while (this._bufs.length || buf) {
        if (buf.length <= 0) {
          buf = this._bufs[0];
        }
        try {
          const n = fs.writeSync(this.fd, buf, "utf8");
          const releasedBufObj = releaseWritingBuf(buf, this._len, n);
          buf = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf = kEmptyBuffer;
      while (this._bufs.length || buf.length) {
        if (buf.length <= 0) {
          buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n = fs.writeSync(this.fd, buf);
          buf = buf.subarray(n);
          this._len = Math.max(this._len - n, 0);
          if (buf.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        if (kCopyBuffer) {
          this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      if (sonic._periodicFlushTimer !== void 0) {
        clearInterval(sonic._periodicFlushTimer);
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      assert2(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
      try {
        fs.fsync(sonic.fd, closeWrapped);
      } catch {
      }
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module.exports = SonicBoom;
  }
});

// node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js"(exports, module) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry2;
    function ensureRegistry() {
      if (registry2 === void 0) {
        registry2 = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry2 = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index2 = refs[event].indexOf(ref);
        refs[event].splice(index2, index2 + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry2.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry2 === void 0) {
        return;
      }
      registry2.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/package.json
var require_package2 = __commonJS({
  "node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/package.json"(exports, module) {
    module.exports = {
      name: "thread-stream",
      version: "3.1.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^4.0.1",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        build: "tsc --noEmit",
        test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*",
          "test/syntax-error.mjs"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/wait.js"(exports, module) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state, index2, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index2);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check3 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index2);
            if (current === prior) {
              check3(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check3(1);
    }
    function waitDiff(state, index2, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index2);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check3 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index2);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check3(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check3(1);
    }
    module.exports = { wait, waitDiff };
  }
});

// node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/indexes.js"(exports, module) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/index.js"(exports, module) {
    "use strict";
    var { version: version3 } = require_package2();
    var { EventEmitter } = __require("events");
    var { Worker } = __require("worker_threads");
    var { join } = __require("path");
    var { pathToFileURL } = __require("url");
    var { wait } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = __require("buffer");
    var assert2 = __require("assert");
    var kImpl = /* @__PURE__ */ Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry2 = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version3
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry2.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert2(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry2.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error48(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error48(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error48(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error48(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module.exports = ThreadStream;
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/transport.js"(exports, module) {
    "use strict";
    var { createRequire } = __require("module");
    var getCallers = require_caller();
    var { join, isAbsolute, sep } = __require("node:path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts, sync) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
      const options = {
        ...fullOptions.options
      };
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.targets = targets.filter((dest) => dest.target).map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
        options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
          return dest.pipeline.map((t) => {
            return {
              ...t,
              level: dest.level,
              // duplicate the pipeline `level` property defined in the upper level
              target: fixTarget(t.target)
            };
          });
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.pipelines = [pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        })];
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      options.pinoWillSendConfig = true;
      return buildStream(fixTarget(target), options, worker, sync);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module.exports = transport;
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/tools.js"(exports, module) {
    "use strict";
    var diagChan = __require("node:diagnostics_channel");
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols3();
    var { isMainThread } = __require("worker_threads");
    var transport = require_transport();
    var asJsonChan;
    if (typeof diagChan.tracingChannel === "function") {
      asJsonChan = diagChan.tracingChannel("pino_asJson");
    } else {
      asJsonChan = {
        hasSubscribers: false,
        traceSync(fn, store, thisArg, ...args) {
          return fn.call(thisArg, ...args);
        }
      };
    }
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o, ...n) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o === void 0 ? n.shift() : o;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point2 = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point2 >= 32; i++) {
        point2 = str.charCodeAt(i);
        if (point2 === 34 || point2 === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point2 < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time5) {
      if (asJsonChan.hasSubscribers === false) {
        return _asJson.call(this, obj, msg, num, time5);
      }
      const store = { instance: this, arguments };
      return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time5);
    }
    function _asJson(obj, msg, num, time5) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time5;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = (key.length < 5 || key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels") && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions, opts);
        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/constants.js"(exports, module) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/levels.js"(exports, module) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols3();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
      o[DEFAULT_LEVELS[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = '{"level":' + Number(k);
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/meta.js"(exports, module) {
    "use strict";
    module.exports = { version: "9.14.0" };
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/proto.js"(exports, module) {
    "use strict";
    var { EventEmitter } = __require("node:events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym,
      hooksSym
    } = require_symbols3();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify,
      noop
    } = require_tools();
    var {
      version: version3
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version3,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      get msgPrefix() {
        return this[msgPrefixSym];
      },
      get [Symbol.toStringTag]() {
        return "Pino";
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options == null) {
        if (instance[formattersSym].bindings !== resetChildingsFormatter) {
          instance[formattersSym] = buildFormatters(
            formatters.level,
            resetChildingsFormatter,
            formatters.log
          );
        }
        instance[chindingsSym] = asChindings(instance, bindings2);
        instance[setLevelSym](this.level);
        if (this.onChild !== noop) {
          this.onChild(instance);
        }
        return instance;
      }
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi2 = 0; bi2 < bindingsSymbols.length; bi2++) {
          const bks = bindingsSymbols[bi2];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      const streamWriteHook = this[hooksSym].streamWrite;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(streamWriteHook ? streamWriteHook(s) : s);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});

// node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports, module) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports.stringify = stringify;
    exports.configure = configure;
    module.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array3, comparator) {
      if (array3.length > 200 || comparator) {
        return array3.sort(comparator);
      }
      for (let i = 1; i < array3.length; i++) {
        const currentValue = array3[i];
        let position = i;
        while (position !== 0 && array3[position - 1] > currentValue) {
          array3[position] = array3[position - 1];
          position--;
        }
        array3[position] = currentValue;
      }
      return array3;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array3, separator, maximumBreadth) {
      if (array3.length < maximumBreadth) {
        maximumBreadth = array3.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array3[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array3[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number6) {
      if (number6 === 1) {
        return "1 item";
      }
      return `${number6} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail2 = getStrictOption(options);
      if (fail2) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint6 = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint6) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint6) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint6) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint6) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/multistream.js"(exports, module) {
    "use strict";
    var metadata = /* @__PURE__ */ Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i) => {
          streamLevels[i] = opts.levels[i];
        });
      }
      const res = {
        write,
        add,
        remove,
        emit,
        flushSync,
        end,
        minLevel: 0,
        lastId: 0,
        streams: [],
        clone: clone2,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
          dest = streams[i];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function emit(...args) {
        for (const { stream } of this.streams) {
          if (typeof stream.emit === "function") {
            stream.emit(...args);
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: ++res.lastId
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function remove(id) {
        const { streams } = this;
        const index2 = streams.findIndex((s) => s.id === id);
        if (index2 >= 0) {
          streams.splice(index2, 1);
          streams.sort(compareByLevel);
          this.minLevel = streams.length > 0 ? streams[0].level : -1;
        }
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone2(level) {
        const streams = new Array(this.streams.length);
        for (let i = 0; i < streams.length; i++) {
          streams[i] = {
            level,
            stream: this.streams[i].stream
          };
        }
        return {
          write,
          add,
          remove,
          minLevel: level,
          streams,
          clone: clone2,
          emit,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a2, b2) {
      return a2.level - b2.level;
    }
    function initLoopVar(length, dedupe) {
      return dedupe ? length - 1 : 0;
    }
    function adjustLoopVar(i, dedupe) {
      return dedupe ? i - 1 : i + 1;
    }
    function checkLoopVar(i, length, dedupe) {
      return dedupe ? i >= 0 : i < length;
    }
    module.exports = multistream;
  }
});

// node_modules/.pnpm/pino@9.14.0/node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/.pnpm/pino@9.14.0/node_modules/pino/pino.js"(exports, module) {
    "use strict";
    var os2 = __require("node:os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time5 = require_time();
    var proto = require_proto();
    var symbols = require_symbols3();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version: version3 } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols;
    var { epochTime, nullTime } = time5;
    var { pid } = process;
    var hostname3 = os2.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname: hostname3 },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number6) {
          return { level: number6 };
        }
      }),
      hooks: {
        logMethod: void 0,
        streamWrite: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize = createArgsNormalizer(defaultOptions);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args) {
      const instance = {};
      const { opts, stream } = normalize(instance, caller(), ...args);
      if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp: timestamp2,
        messageKey,
        errorKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time6 = timestamp2 instanceof Function ? timestamp2 : timestamp2 ? epochTime : nullTime;
      const timeSliceIndex = time6().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      if (typeof stream.emit === "function") {
        stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
      }
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time6,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module.exports = pino;
    module.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module.exports.transport = require_transport();
    module.exports.multistream = require_multistream();
    module.exports.levels = mappings();
    module.exports.stdSerializers = serializers;
    module.exports.stdTimeFunctions = Object.assign({}, time5);
    module.exports.symbols = symbols;
    module.exports.version = version3;
    module.exports.default = pino;
    module.exports.pino = pino;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/logger-pino.js
var require_logger_pino = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/logger-pino.js"(exports, module) {
    "use strict";
    var pino = require_pino();
    var { serializersSym } = pino.symbols;
    var {
      FST_ERR_LOG_INVALID_DESTINATION
    } = require_errors2();
    function createPinoLogger(opts) {
      if (opts.stream && opts.file) {
        throw new FST_ERR_LOG_INVALID_DESTINATION();
      } else if (opts.file) {
        opts.stream = pino.destination(opts.file);
        delete opts.file;
      }
      const prevLogger = opts.logger;
      const prevGenReqId = opts.genReqId;
      let logger = null;
      if (prevLogger) {
        opts.logger = void 0;
        opts.genReqId = void 0;
        if (prevLogger[serializersSym]) {
          opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
        }
        logger = prevLogger.child({}, opts);
        opts.logger = prevLogger;
        opts.genReqId = prevGenReqId;
      } else {
        logger = pino(opts, opts.stream);
      }
      return logger;
    }
    var serializers = {
      req: function asReqValue(req) {
        return {
          method: req.method,
          url: req.url,
          version: req.headers && req.headers["accept-version"],
          host: req.host,
          remoteAddress: req.ip,
          remotePort: req.socket ? req.socket.remotePort : void 0
        };
      },
      err: pino.stdSerializers.err,
      res: function asResValue(reply) {
        return {
          statusCode: reply.statusCode
        };
      }
    };
    module.exports = {
      serializers,
      createPinoLogger
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/logger-factory.js
var require_logger_factory = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/logger-factory.js"(exports, module) {
    "use strict";
    var {
      FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
      FST_ERR_LOG_INVALID_LOGGER_CONFIG,
      FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
      FST_ERR_LOG_INVALID_LOGGER
    } = require_errors2();
    function createChildLogger(context, logger, req, reqId, loggerOpts) {
      const loggerBindings = {
        [context.requestIdLogLabel]: reqId
      };
      const child = context.childLoggerFactory.call(context.server, logger, loggerBindings, loggerOpts || {}, req);
      if (context.childLoggerFactory !== defaultChildLoggerFactory) {
        validateLogger(child, true);
      }
      return child;
    }
    function defaultChildLoggerFactory(logger, bindings, opts) {
      return logger.child(bindings, opts);
    }
    function validateLogger(logger, strict) {
      const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
      const missingMethods = logger ? methods.filter((method) => !logger[method] || typeof logger[method] !== "function") : methods;
      if (!missingMethods.length) {
        return true;
      } else if (missingMethods.length === methods.length && !strict) {
        return false;
      } else {
        throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
      }
    }
    function createLogger(options) {
      if (options.logger && options.loggerInstance) {
        throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED();
      }
      if (!options.loggerInstance && !options.logger) {
        const nullLogger = require_abstract_logging();
        const logger2 = nullLogger;
        logger2.child = () => logger2;
        return { logger: logger2, hasLogger: false };
      }
      const { createPinoLogger, serializers } = require_logger_pino();
      if (validateLogger(options.loggerInstance)) {
        const logger2 = createPinoLogger({
          logger: options.loggerInstance,
          serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
        });
        return { logger: logger2, hasLogger: true };
      }
      if (validateLogger(options.logger)) {
        throw FST_ERR_LOG_INVALID_LOGGER_CONFIG();
      }
      if (options.loggerInstance) {
        throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE();
      }
      const localLoggerOptions = {};
      if (Object.prototype.toString.call(options.logger) === "[object Object]") {
        Reflect.ownKeys(options.logger).forEach((prop) => {
          Object.defineProperty(localLoggerOptions, prop, {
            value: options.logger[prop],
            writable: true,
            enumerable: true,
            configurable: true
          });
        });
      }
      localLoggerOptions.level = localLoggerOptions.level || "info";
      localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
      options.logger = localLoggerOptions;
      const logger = createPinoLogger(options.logger);
      return { logger, hasLogger: true };
    }
    function now() {
      const ts2 = process.hrtime();
      return ts2[0] * 1e3 + ts2[1] / 1e6;
    }
    module.exports = {
      createChildLogger,
      defaultChildLoggerFactory,
      createLogger,
      validateLogger,
      now
    };
  }
});

// node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(exports, module) {
    "use strict";
    module.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone2;
      function cloneArray(a2, fn) {
        const keys = Object.keys(a2);
        const a22 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a2[k];
          if (typeof cur !== "object" || cur === null) {
            a22[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a22[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a22[k] = copyBuffer(cur);
          } else {
            a22[k] = fn(cur);
          }
        }
        return a22;
      }
      function clone2(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone2);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone2);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone2);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone2(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone2;
      function cloneArray(a2, fn) {
        const keys = Object.keys(a2);
        const a22 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a2[k];
          if (typeof cur !== "object" || cur === null) {
            a22[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a22[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a22[k] = copyBuffer(cur);
          } else {
            const index2 = refs.indexOf(cur);
            if (index2 !== -1) {
              a22[k] = refsNew[index2];
            } else {
              a22[k] = fn(cur);
            }
          }
        }
        return a22;
      }
      function clone2(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone2);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone2);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone2);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone2(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/schemas.js"(exports, module) {
    "use strict";
    var fastClone = require_rfdc()({ circles: false, proto: true });
    var { kSchemaVisited, kSchemaResponse } = require_symbols2();
    var kFluentSchema = /* @__PURE__ */ Symbol.for("fluent-schema-object");
    var {
      FST_ERR_SCH_MISSING_ID,
      FST_ERR_SCH_ALREADY_PRESENT,
      FST_ERR_SCH_DUPLICATE,
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA
    } = require_errors2();
    var SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
    function Schemas(initStore) {
      this.store = initStore || {};
    }
    Schemas.prototype.add = function(inputSchema) {
      const schema = fastClone(
        inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema
      );
      const id = schema.$id;
      if (!id) {
        throw new FST_ERR_SCH_MISSING_ID();
      }
      if (this.store[id]) {
        throw new FST_ERR_SCH_ALREADY_PRESENT(id);
      }
      this.store[id] = schema;
    };
    Schemas.prototype.getSchemas = function() {
      return Object.assign({}, this.store);
    };
    Schemas.prototype.getSchema = function(schemaId) {
      return this.store[schemaId];
    };
    function isCustomSchemaPrototype(schema) {
      return typeof schema === "object" && Object.getPrototypeOf(schema) !== Object.prototype;
    }
    function normalizeSchema(routeSchemas, serverOptions) {
      if (routeSchemas[kSchemaVisited]) {
        return routeSchemas;
      }
      if (routeSchemas.query) {
        if (routeSchemas.querystring) {
          throw new FST_ERR_SCH_DUPLICATE("querystring");
        }
        routeSchemas.querystring = routeSchemas.query;
      }
      generateFluentSchema(routeSchemas);
      for (const key of SCHEMAS_SOURCE) {
        const schema = routeSchemas[key];
        if (schema && !isCustomSchemaPrototype(schema)) {
          if (key === "body" && schema.content) {
            const contentProperty = schema.content;
            const keys = Object.keys(contentProperty);
            for (let i = 0; i < keys.length; i++) {
              const contentType = keys[i];
              const contentSchema = contentProperty[contentType].schema;
              if (!contentSchema) {
                throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType);
              }
            }
            continue;
          }
        }
      }
      if (routeSchemas.response) {
        const httpCodes = Object.keys(routeSchemas.response);
        for (const code of httpCodes) {
          if (isCustomSchemaPrototype(routeSchemas.response[code])) {
            continue;
          }
          const contentProperty = routeSchemas.response[code].content;
          if (contentProperty) {
            const keys = Object.keys(contentProperty);
            for (let i = 0; i < keys.length; i++) {
              const mediaName = keys[i];
              if (!contentProperty[mediaName].schema) {
                throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
              }
            }
          }
        }
      }
      routeSchemas[kSchemaVisited] = true;
      return routeSchemas;
    }
    function generateFluentSchema(schema) {
      for (const key of SCHEMAS_SOURCE) {
        if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
          schema[key] = schema[key].valueOf();
        }
      }
      if (schema.response) {
        const httpCodes = Object.keys(schema.response);
        for (const code of httpCodes) {
          if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
            schema.response[code] = schema.response[code].valueOf();
          }
        }
      }
    }
    function getSchemaSerializer(context, statusCode, contentType) {
      const responseSchemaDef = context[kSchemaResponse];
      if (!responseSchemaDef) {
        return false;
      }
      if (responseSchemaDef[statusCode]) {
        if (responseSchemaDef[statusCode].constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef[statusCode][mediaName]) {
            return responseSchemaDef[statusCode][mediaName];
          }
          if (responseSchemaDef[statusCode]["*/*"]) {
            return responseSchemaDef[statusCode]["*/*"];
          }
          return false;
        }
        return responseSchemaDef[statusCode];
      }
      const fallbackStatusCode = (statusCode + "")[0] + "xx";
      if (responseSchemaDef[fallbackStatusCode]) {
        if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef[fallbackStatusCode][mediaName]) {
            return responseSchemaDef[fallbackStatusCode][mediaName];
          }
          if (responseSchemaDef[fallbackStatusCode]["*/*"]) {
            return responseSchemaDef[fallbackStatusCode]["*/*"];
          }
          return false;
        }
        return responseSchemaDef[fallbackStatusCode];
      }
      if (responseSchemaDef.default) {
        if (responseSchemaDef.default.constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef.default[mediaName]) {
            return responseSchemaDef.default[mediaName];
          }
          if (responseSchemaDef.default["*/*"]) {
            return responseSchemaDef.default["*/*"];
          }
          return false;
        }
        return responseSchemaDef.default;
      }
      return false;
    }
    module.exports = {
      buildSchemas(initStore) {
        return new Schemas(initStore);
      },
      getSchemaSerializer,
      normalizeSchema
    };
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/serializer.js
var require_serializer = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/serializer.js"(exports, module) {
    "use strict";
    var STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    module.exports = class Serializer {
      constructor(options) {
        switch (options && options.rounding) {
          case "floor":
            this.parseInteger = Math.floor;
            break;
          case "ceil":
            this.parseInteger = Math.ceil;
            break;
          case "round":
            this.parseInteger = Math.round;
            break;
          case "trunc":
          default:
            this.parseInteger = Math.trunc;
            break;
        }
        this._options = options;
      }
      asInteger(i) {
        if (Number.isInteger(i)) {
          return "" + i;
        } else if (typeof i === "bigint") {
          return i.toString();
        }
        const integer3 = this.parseInteger(i);
        if (integer3 === Infinity || integer3 === -Infinity || integer3 !== integer3) {
          throw new Error(`The value "${i}" cannot be converted to an integer.`);
        }
        return "" + integer3;
      }
      asNumber(i) {
        const num = Number(i);
        if (num !== num) {
          throw new Error(`The value "${i}" cannot be converted to a number.`);
        } else if (num === Infinity || num === -Infinity) {
          return "null";
        } else {
          return "" + num;
        }
      }
      asBoolean(bool) {
        return bool && "true" || "false";
      }
      asDateTime(date9) {
        if (date9 === null) return '""';
        if (date9 instanceof Date) {
          return '"' + date9.toISOString() + '"';
        }
        if (typeof date9 === "string") {
          return '"' + date9 + '"';
        }
        throw new Error(`The value "${date9}" cannot be converted to a date-time.`);
      }
      asDate(date9) {
        if (date9 === null) return '""';
        if (date9 instanceof Date) {
          return '"' + new Date(date9.getTime() - date9.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
        }
        if (typeof date9 === "string") {
          return '"' + date9 + '"';
        }
        throw new Error(`The value "${date9}" cannot be converted to a date.`);
      }
      asTime(date9) {
        if (date9 === null) return '""';
        if (date9 instanceof Date) {
          return '"' + new Date(date9.getTime() - date9.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
        }
        if (typeof date9 === "string") {
          return '"' + date9 + '"';
        }
        throw new Error(`The value "${date9}" cannot be converted to a time.`);
      }
      asString(str) {
        const len = str.length;
        if (len === 0) {
          return '""';
        } else if (len < 42) {
          let result = "";
          let last = -1;
          let point2 = 255;
          for (let i = 0; i < len; i++) {
            point2 = str.charCodeAt(i);
            if (point2 === 34 || // '"'
            point2 === 92) {
              last === -1 && (last = 0);
              result += str.slice(last, i) + "\\";
              last = i;
            } else if (point2 < 32 || point2 >= 55296 && point2 <= 57343) {
              return JSON.stringify(str);
            }
          }
          return last === -1 && '"' + str + '"' || '"' + result + str.slice(last) + '"';
        } else if (len < 5e3 && STR_ESCAPE.test(str) === false) {
          return '"' + str + '"';
        } else {
          return JSON.stringify(str);
        }
      }
      asUnsafeString(str) {
        return '"' + str + '"';
      }
      getState() {
        return this._options;
      }
      static restoreFromState(state) {
        return new Serializer(state);
      }
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/error-serializer.js
var require_error_serializer = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/error-serializer.js"(exports, module) {
    "use strict";
    var Serializer = require_serializer();
    var serializerState = { "mode": "standalone" };
    var serializer = Serializer.restoreFromState(serializerState);
    var validator = null;
    module.exports = (function anonymous(validator2, serializer2) {
      const JSON_STR_BEGIN_OBJECT = "{";
      const JSON_STR_END_OBJECT = "}";
      const JSON_STR_BEGIN_ARRAY = "[";
      const JSON_STR_END_ARRAY = "]";
      const JSON_STR_COMMA = ",";
      const JSON_STR_COLONS = ":";
      const JSON_STR_QUOTE = '"';
      const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
      const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY;
      const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
      const JSON_STR_NULL = "null";
      function anonymous0(input) {
        const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
        if (obj === null) return JSON_STR_EMPTY_OBJECT;
        let value;
        let json4 = JSON_STR_BEGIN_OBJECT;
        let addComma = false;
        value = obj["statusCode"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json4 += JSON_STR_COMMA);
          json4 += '"statusCode":';
          json4 += serializer2.asNumber(value);
        }
        value = obj["code"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json4 += JSON_STR_COMMA);
          json4 += '"code":';
          if (typeof value !== "string") {
            if (value === null) {
              json4 += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json4 += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json4 += serializer2.asString(value.source);
            } else {
              json4 += serializer2.asString(value.toString());
            }
          } else {
            json4 += serializer2.asString(value);
          }
        }
        value = obj["error"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json4 += JSON_STR_COMMA);
          json4 += '"error":';
          if (typeof value !== "string") {
            if (value === null) {
              json4 += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json4 += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json4 += serializer2.asString(value.source);
            } else {
              json4 += serializer2.asString(value.toString());
            }
          } else {
            json4 += serializer2.asString(value);
          }
        }
        value = obj["message"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json4 += JSON_STR_COMMA);
          json4 += '"message":';
          if (typeof value !== "string") {
            if (value === null) {
              json4 += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json4 += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json4 += serializer2.asString(value.source);
            } else {
              json4 += serializer2.asString(value.toString());
            }
          } else {
            json4 += serializer2.asString(value);
          }
        }
        return json4 + JSON_STR_END_OBJECT;
      }
      const main = anonymous0;
      return main;
    })(validator, serializer);
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/error-handler.js
var require_error_handler = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/error-handler.js"(exports, module) {
    "use strict";
    var statusCodes = __require("node:http").STATUS_CODES;
    var wrapThenable = require_wrapThenable();
    var {
      kReplyHeaders,
      kReplyNextErrorHandler,
      kReplyIsRunningOnErrorHook,
      kReplyHasStatusCode,
      kRouteContext,
      kDisableRequestLogging
    } = require_symbols2();
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_FAILED_ERROR_SERIALIZATION
    } = require_errors2();
    var { getSchemaSerializer } = require_schemas();
    var serializeError = require_error_serializer();
    var rootErrorHandler = {
      func: defaultErrorHandler,
      toJSON() {
        return this.func.name.toString() + "()";
      }
    };
    function handleError(reply, error48, cb) {
      reply[kReplyIsRunningOnErrorHook] = false;
      const context = reply[kRouteContext];
      if (reply[kReplyNextErrorHandler] === false) {
        fallbackErrorHandler(error48, reply, function(reply2, payload) {
          try {
            reply2.raw.writeHead(reply2.raw.statusCode, reply2[kReplyHeaders]);
          } catch (error49) {
            if (!reply2.log[kDisableRequestLogging]) {
              reply2.log.warn(
                { req: reply2.request, res: reply2, err: error49 },
                error49?.message
              );
            }
            reply2.raw.writeHead(reply2.raw.statusCode);
          }
          reply2.raw.end(payload);
        });
        return;
      }
      const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;
      reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);
      delete reply[kReplyHeaders]["content-type"];
      delete reply[kReplyHeaders]["content-length"];
      const func = errorHandler.func;
      if (!func) {
        reply[kReplyNextErrorHandler] = false;
        fallbackErrorHandler(error48, reply, cb);
        return;
      }
      try {
        const result = func(error48, reply.request, reply);
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply);
          } else {
            reply.send(result);
          }
        }
      } catch (err) {
        reply.send(err);
      }
    }
    function defaultErrorHandler(error48, request, reply) {
      setErrorHeaders(error48, reply);
      if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
        const statusCode = error48.statusCode || error48.status;
        reply.code(statusCode >= 400 ? statusCode : 500);
      }
      if (reply.statusCode < 500) {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.info(
            { res: reply, err: error48 },
            error48?.message
          );
        }
      } else {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.error(
            { req: request, res: reply, err: error48 },
            error48?.message
          );
        }
      }
      reply.send(error48);
    }
    function fallbackErrorHandler(error48, reply, cb) {
      const res = reply.raw;
      const statusCode = reply.statusCode;
      reply[kReplyHeaders]["content-type"] = reply[kReplyHeaders]["content-type"] ?? "application/json; charset=utf-8";
      let payload;
      try {
        const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]["content-type"]);
        if (serializerFn === false) {
          payload = serializeError({
            error: statusCodes[statusCode + ""],
            code: error48.code,
            message: error48.message,
            statusCode
          });
        } else {
          payload = serializerFn(Object.create(error48, {
            error: { value: statusCodes[statusCode + ""] },
            message: { value: error48.message },
            statusCode: { value: statusCode }
          }));
        }
      } catch (err) {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.error({ err, statusCode: res.statusCode }, "The serializer for the given status code failed");
        }
        reply.code(500);
        payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error48.message));
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
      }
      reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      cb(reply, payload);
    }
    function buildErrorHandler(parent = rootErrorHandler, func) {
      if (!func) {
        return parent;
      }
      const errorHandler = Object.create(parent);
      errorHandler.func = func;
      return errorHandler;
    }
    function setErrorHeaders(error48, reply) {
      const res = reply.raw;
      let statusCode = res.statusCode;
      statusCode = statusCode >= 400 ? statusCode : 500;
      if (error48 != null) {
        if (error48.headers !== void 0) {
          reply.headers(error48.headers);
        }
        if (error48.status >= 400) {
          statusCode = error48.status;
        } else if (error48.statusCode >= 400) {
          statusCode = error48.statusCode;
        }
      }
      res.statusCode = statusCode;
    }
    module.exports = {
      buildErrorHandler,
      handleError
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/decorate.js
var require_decorate = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/decorate.js"(exports, module) {
    "use strict";
    var {
      kReply,
      kRequest,
      kState,
      kHasBeenDecorated
    } = require_symbols2();
    var {
      FST_ERR_DEC_ALREADY_PRESENT,
      FST_ERR_DEC_MISSING_DEPENDENCY,
      FST_ERR_DEC_AFTER_START,
      FST_ERR_DEC_REFERENCE_TYPE,
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE,
      FST_ERR_DEC_UNDECLARED
    } = require_errors2();
    function decorate(instance, name, fn, dependencies) {
      if (Object.hasOwn(instance, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      checkDependencies(instance, name, dependencies);
      if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn.getter,
          set: fn.setter
        });
      } else {
        instance[name] = fn;
      }
    }
    function getInstanceDecorator(name) {
      if (!checkExistence(this, name)) {
        throw new FST_ERR_DEC_UNDECLARED(name, "instance");
      }
      if (typeof this[name] === "function") {
        return this[name].bind(this);
      }
      return this[name];
    }
    function decorateConstructor(konstructor, name, fn, dependencies) {
      const instance = konstructor.prototype;
      if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      konstructor[kHasBeenDecorated] = true;
      checkDependencies(konstructor, name, dependencies);
      if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn.getter,
          set: fn.setter
        });
      } else if (typeof fn === "function") {
        instance[name] = fn;
      } else {
        konstructor.props.push({ key: name, value: fn });
      }
    }
    function checkReferenceType(name, fn) {
      if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
        throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn);
      }
    }
    function decorateFastify(name, fn, dependencies) {
      assertNotStarted(this, name);
      decorate(this, name, fn, dependencies);
      return this;
    }
    function checkExistence(instance, name) {
      if (name) {
        return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
      }
      return instance in this;
    }
    function hasKey(fn, name) {
      if (fn.props) {
        return fn.props.find(({ key }) => key === name);
      }
      return false;
    }
    function checkRequestExistence(name) {
      if (name && hasKey(this[kRequest], name)) return true;
      return checkExistence(this[kRequest].prototype, name);
    }
    function checkReplyExistence(name) {
      if (name && hasKey(this[kReply], name)) return true;
      return checkExistence(this[kReply].prototype, name);
    }
    function checkDependencies(instance, name, deps) {
      if (deps === void 0 || deps === null) {
        return;
      }
      if (!Array.isArray(deps)) {
        throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
      }
      for (let i = 0; i !== deps.length; ++i) {
        if (!checkExistence(instance, deps[i])) {
          throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
        }
      }
    }
    function decorateReply(name, fn, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn);
      decorateConstructor(this[kReply], name, fn, dependencies);
      return this;
    }
    function decorateRequest(name, fn, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn);
      decorateConstructor(this[kRequest], name, fn, dependencies);
      return this;
    }
    function assertNotStarted(instance, name) {
      if (instance[kState].started) {
        throw new FST_ERR_DEC_AFTER_START(name);
      }
    }
    module.exports = {
      add: decorateFastify,
      exist: checkExistence,
      existRequest: checkRequestExistence,
      existReply: checkReplyExistence,
      dependencies: checkDependencies,
      decorateReply,
      decorateRequest,
      getInstanceDecorator,
      hasKey
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/reply.js
var require_reply = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/reply.js"(exports, module) {
    "use strict";
    var eos = __require("node:stream").finished;
    var Readable = __require("node:stream").Readable;
    var {
      kFourOhFourContext,
      kReplyErrorHandlerCalled,
      kReplyHijacked,
      kReplyStartTime,
      kReplyEndTime,
      kReplySerializer,
      kReplySerializerDefault,
      kReplyIsError,
      kReplyHeaders,
      kReplyTrailers,
      kReplyHasStatusCode,
      kReplyIsRunningOnErrorHook,
      kReplyNextErrorHandler,
      kDisableRequestLogging,
      kSchemaResponse,
      kReplyCacheSerializeFns,
      kSchemaController,
      kOptions,
      kRouteContext
    } = require_symbols2();
    var {
      onSendHookRunner,
      onResponseHookRunner,
      preHandlerHookRunner,
      preSerializationHookRunner
    } = require_hooks();
    var internals = require_handleRequest()[/* @__PURE__ */ Symbol.for("internals")];
    var loggerUtils = require_logger_factory();
    var now = loggerUtils.now;
    var { handleError } = require_error_handler();
    var { getSchemaSerializer } = require_schemas();
    var CONTENT_TYPE = {
      JSON: "application/json; charset=utf-8",
      PLAIN: "text/plain; charset=utf-8",
      OCTET: "application/octet-stream"
    };
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_REP_RESPONSE_BODY_CONSUMED,
      FST_ERR_REP_READABLE_STREAM_LOCKED,
      FST_ERR_REP_ALREADY_SENT,
      FST_ERR_SEND_INSIDE_ONERR,
      FST_ERR_BAD_STATUS_CODE,
      FST_ERR_BAD_TRAILER_NAME,
      FST_ERR_BAD_TRAILER_VALUE,
      FST_ERR_MISSING_SERIALIZATION_FN,
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN,
      FST_ERR_DEC_UNDECLARED
    } = require_errors2();
    var decorators = require_decorate();
    var toString = Object.prototype.toString;
    function Reply(res, request, log) {
      this.raw = res;
      this[kReplySerializer] = null;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyIsError] = false;
      this[kReplyIsRunningOnErrorHook] = false;
      this.request = request;
      this[kReplyHeaders] = {};
      this[kReplyTrailers] = null;
      this[kReplyHasStatusCode] = false;
      this[kReplyStartTime] = void 0;
      this.log = log;
    }
    Reply.props = [];
    Object.defineProperties(Reply.prototype, {
      [kRouteContext]: {
        get() {
          return this.request[kRouteContext];
        }
      },
      elapsedTime: {
        get() {
          if (this[kReplyStartTime] === void 0) {
            return 0;
          }
          return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
        }
      },
      server: {
        get() {
          return this.request[kRouteContext].server;
        }
      },
      sent: {
        enumerable: true,
        get() {
          return (this[kReplyHijacked] || this.raw.writableEnded) === true;
        }
      },
      statusCode: {
        get() {
          return this.raw.statusCode;
        },
        set(value) {
          this.code(value);
        }
      },
      routeOptions: {
        get() {
          return this.request.routeOptions;
        }
      }
    });
    Reply.prototype.writeEarlyHints = function(hints, callback) {
      this.raw.writeEarlyHints(hints, callback);
      return this;
    };
    Reply.prototype.hijack = function() {
      this[kReplyHijacked] = true;
      return this;
    };
    Reply.prototype.send = function(payload) {
      if (this[kReplyIsRunningOnErrorHook]) {
        throw new FST_ERR_SEND_INSIDE_ONERR();
      }
      if (this.sent === true) {
        this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
        return this;
      }
      if (this[kReplyIsError] || payload instanceof Error) {
        this[kReplyIsError] = false;
        onErrorHook(this, payload, onSendHook);
        return this;
      }
      if (payload === void 0) {
        onSendHook(this, payload);
        return this;
      }
      const contentType = this.getHeader("content-type");
      const hasContentType = contentType !== void 0;
      if (payload !== null) {
        if (
          // node:stream
          typeof payload.pipe === "function" || // node:stream/web
          typeof payload.getReader === "function" || // Response
          toString.call(payload) === "[object Response]"
        ) {
          onSendHook(this, payload);
          return this;
        }
        if (payload.buffer instanceof ArrayBuffer) {
          if (!hasContentType) {
            this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
          }
          const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
          onSendHook(this, payloadToSend);
          return this;
        }
        if (!hasContentType && typeof payload === "string") {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
          onSendHook(this, payload);
          return this;
        }
      }
      if (this[kReplySerializer] !== null) {
        if (typeof payload !== "string") {
          preSerializationHook(this, payload);
          return this;
        }
        payload = this[kReplySerializer](payload);
      } else if (!hasContentType || contentType.indexOf("json") !== -1) {
        if (!hasContentType) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
        } else if (contentType.indexOf("charset") === -1) {
          const customContentType = contentType.trim();
          if (customContentType.endsWith(";")) {
            this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
          } else {
            this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
          }
        }
        if (typeof payload !== "string") {
          preSerializationHook(this, payload);
          return this;
        }
      }
      onSendHook(this, payload);
      return this;
    };
    Reply.prototype.getHeader = function(key) {
      key = key.toLowerCase();
      const value = this[kReplyHeaders][key];
      return value !== void 0 ? value : this.raw.getHeader(key);
    };
    Reply.prototype.getHeaders = function() {
      return {
        ...this.raw.getHeaders(),
        ...this[kReplyHeaders]
      };
    };
    Reply.prototype.hasHeader = function(key) {
      key = key.toLowerCase();
      return this[kReplyHeaders][key] !== void 0 || this.raw.hasHeader(key);
    };
    Reply.prototype.removeHeader = function(key) {
      delete this[kReplyHeaders][key.toLowerCase()];
      return this;
    };
    Reply.prototype.header = function(key, value = "") {
      key = key.toLowerCase();
      if (this[kReplyHeaders][key] && key === "set-cookie") {
        if (typeof this[kReplyHeaders][key] === "string") {
          this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
        }
        if (Array.isArray(value)) {
          Array.prototype.push.apply(this[kReplyHeaders][key], value);
        } else {
          this[kReplyHeaders][key].push(value);
        }
      } else {
        this[kReplyHeaders][key] = value;
      }
      return this;
    };
    Reply.prototype.headers = function(headers) {
      const keys = Object.keys(headers);
      for (let i = 0; i !== keys.length; ++i) {
        const key = keys[i];
        this.header(key, headers[key]);
      }
      return this;
    };
    var INVALID_TRAILERS = /* @__PURE__ */ new Set([
      "transfer-encoding",
      "content-length",
      "host",
      "cache-control",
      "max-forwards",
      "te",
      "authorization",
      "set-cookie",
      "content-encoding",
      "content-type",
      "content-range",
      "trailer"
    ]);
    Reply.prototype.trailer = function(key, fn) {
      key = key.toLowerCase();
      if (INVALID_TRAILERS.has(key)) {
        throw new FST_ERR_BAD_TRAILER_NAME(key);
      }
      if (typeof fn !== "function") {
        throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
      }
      if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
      this[kReplyTrailers][key] = fn;
      return this;
    };
    Reply.prototype.hasTrailer = function(key) {
      return this[kReplyTrailers]?.[key.toLowerCase()] !== void 0;
    };
    Reply.prototype.removeTrailer = function(key) {
      if (this[kReplyTrailers] === null) return this;
      this[kReplyTrailers][key.toLowerCase()] = void 0;
      return this;
    };
    Reply.prototype.code = function(code) {
      const statusCode = +code;
      if (!(statusCode >= 100 && statusCode <= 599)) {
        throw new FST_ERR_BAD_STATUS_CODE(code || String(code));
      }
      this.raw.statusCode = statusCode;
      this[kReplyHasStatusCode] = true;
      return this;
    };
    Reply.prototype.status = Reply.prototype.code;
    Reply.prototype.getSerializationFunction = function(schemaOrStatus, contentType) {
      let serialize2;
      if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
        if (typeof contentType === "string") {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
        } else {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
        }
      } else if (typeof schemaOrStatus === "object") {
        serialize2 = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
      }
      return serialize2;
    };
    Reply.prototype.compileSerializationSchema = function(schema, httpStatus = null, contentType = null) {
      const { request } = this;
      const { method, url: url2 } = request;
      if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
        return this[kRouteContext][kReplyCacheSerializeFns].get(schema);
      }
      const serializerCompiler2 = this[kRouteContext].serializerCompiler || this.server[kSchemaController].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
      // nor set
      (this.server[kSchemaController].setupSerializer(this.server[kOptions]) || this.server[kSchemaController].serializerCompiler);
      const serializeFn = serializerCompiler2({
        schema,
        method,
        url: url2,
        httpStatus,
        contentType
      });
      if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
        this[kRouteContext][kReplyCacheSerializeFns] = /* @__PURE__ */ new WeakMap();
      }
      this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);
      return serializeFn;
    };
    Reply.prototype.serializeInput = function(input, schema, httpStatus, contentType) {
      const possibleContentType = httpStatus;
      let serialize2;
      httpStatus = typeof schema === "string" || typeof schema === "number" ? schema : httpStatus;
      contentType = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType;
      if (httpStatus != null) {
        if (contentType != null) {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
        } else {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus];
        }
        if (serialize2 == null) {
          if (contentType) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType);
          throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
        }
      } else {
        if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
          serialize2 = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
        } else {
          serialize2 = this.compileSerializationSchema(schema, httpStatus, contentType);
        }
      }
      return serialize2(input);
    };
    Reply.prototype.serialize = function(payload) {
      if (this[kReplySerializer] !== null) {
        return this[kReplySerializer](payload);
      } else {
        if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
          return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode);
        } else {
          return serialize(this[kRouteContext], payload, this.raw.statusCode);
        }
      }
    };
    Reply.prototype.serializer = function(fn) {
      this[kReplySerializer] = fn;
      return this;
    };
    Reply.prototype.type = function(type) {
      this[kReplyHeaders]["content-type"] = type;
      return this;
    };
    Reply.prototype.redirect = function(url2, code) {
      if (!code) {
        code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
      }
      return this.header("location", url2).code(code).send();
    };
    Reply.prototype.callNotFound = function() {
      notFound(this);
      return this;
    };
    Reply.prototype.then = function(fulfilled, rejected) {
      if (this.sent) {
        fulfilled();
        return;
      }
      eos(this.raw, (err) => {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          if (rejected) {
            rejected(err);
          } else {
            this.log && this.log.warn("unhandled rejection on reply.then");
          }
        } else {
          fulfilled();
        }
      });
    };
    Reply.prototype.getDecorator = function(name) {
      if (!decorators.hasKey(this, name) && !decorators.exist(this, name)) {
        throw new FST_ERR_DEC_UNDECLARED(name, "reply");
      }
      const decorator = this[name];
      if (typeof decorator === "function") {
        return decorator.bind(this);
      }
      return decorator;
    };
    function preSerializationHook(reply, payload) {
      if (reply[kRouteContext].preSerialization !== null) {
        preSerializationHookRunner(
          reply[kRouteContext].preSerialization,
          reply.request,
          reply,
          payload,
          preSerializationHookEnd
        );
      } else {
        preSerializationHookEnd(null, void 0, reply, payload);
      }
    }
    function preSerializationHookEnd(err, _request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
        return;
      }
      try {
        if (reply[kReplySerializer] !== null) {
          payload = reply[kReplySerializer](payload);
        } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
          payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
        } else {
          payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]["content-type"]);
        }
      } catch (e) {
        wrapSerializationError(e, reply);
        onErrorHook(reply, e);
        return;
      }
      onSendHook(reply, payload);
    }
    function wrapSerializationError(error48, reply) {
      error48.serialization = reply[kRouteContext].config;
    }
    function onSendHook(reply, payload) {
      if (reply[kRouteContext].onSend !== null) {
        onSendHookRunner(
          reply[kRouteContext].onSend,
          reply.request,
          reply,
          payload,
          wrapOnSendEnd
        );
      } else {
        onSendEnd(reply, payload);
      }
    }
    function wrapOnSendEnd(err, request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
      } else {
        onSendEnd(reply, payload);
      }
    }
    function safeWriteHead(reply, statusCode) {
      const res = reply.raw;
      try {
        res.writeHead(statusCode, reply[kReplyHeaders]);
      } catch (err) {
        if (err.code === "ERR_HTTP_HEADERS_SENT") {
          reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
        }
        throw err;
      }
    }
    function onSendEnd(reply, payload) {
      const res = reply.raw;
      const req = reply.request;
      if (reply[kReplyTrailers] !== null) {
        const trailerHeaders = Object.keys(reply[kReplyTrailers]);
        let header = "";
        for (const trailerName of trailerHeaders) {
          if (typeof reply[kReplyTrailers][trailerName] !== "function") continue;
          header += " ";
          header += trailerName;
        }
        reply.header("Transfer-Encoding", "chunked");
        reply.header("Trailer", header.trim());
      }
      if (toString.call(payload) === "[object Response]") {
        if (typeof payload.status === "number") {
          reply.code(payload.status);
        }
        if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
          for (const [headerName, headerValue] of payload.headers) {
            reply.header(headerName, headerValue);
          }
        }
        if (payload.body !== null) {
          if (payload.bodyUsed) {
            throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED();
          }
        }
        payload = payload.body;
      }
      const statusCode = res.statusCode;
      if (payload === void 0 || payload === null) {
        if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== "HEAD" && reply[kReplyTrailers] === null) {
          reply[kReplyHeaders]["content-length"] = "0";
        }
        safeWriteHead(reply, statusCode);
        sendTrailer(payload, res, reply);
        return;
      }
      if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
        reply.removeHeader("content-type");
        reply.removeHeader("content-length");
        safeWriteHead(reply, statusCode);
        sendTrailer(void 0, res, reply);
        if (typeof payload.resume === "function") {
          payload.on("error", noop);
          payload.resume();
        }
        return;
      }
      if (typeof payload.pipe === "function") {
        sendStream(payload, res, reply);
        return;
      }
      if (typeof payload.getReader === "function") {
        sendWebStream(payload, res, reply);
        return;
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
      }
      if (reply[kReplyTrailers] === null) {
        const contentLength = reply[kReplyHeaders]["content-length"];
        if (!contentLength || req.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
          reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
        }
      }
      safeWriteHead(reply, statusCode);
      res.write(payload);
      sendTrailer(payload, res, reply);
    }
    function logStreamError(logger, err, res) {
      if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
        if (!logger[kDisableRequestLogging]) {
          logger.info({ res }, "stream closed prematurely");
        }
      } else {
        logger.warn({ err }, "response terminated with an error with headers already sent");
      }
    }
    function sendWebStream(payload, res, reply) {
      if (payload.locked) {
        throw FST_ERR_REP_READABLE_STREAM_LOCKED();
      }
      const nodeStream = Readable.fromWeb(payload);
      sendStream(nodeStream, res, reply);
    }
    function sendStream(payload, res, reply) {
      let sourceOpen = true;
      let errorLogged = false;
      sendStreamTrailer(payload, res, reply);
      eos(payload, { readable: true, writable: false }, function(err) {
        sourceOpen = false;
        if (err != null) {
          if (res.headersSent || reply.request.raw.aborted === true) {
            if (!errorLogged) {
              errorLogged = true;
              logStreamError(reply.log, err, reply);
            }
            res.destroy();
          } else {
            onErrorHook(reply, err);
          }
        }
      });
      eos(res, function(err) {
        if (sourceOpen) {
          if (err != null && res.headersSent && !errorLogged) {
            errorLogged = true;
            logStreamError(reply.log, err, res);
          }
          if (typeof payload.destroy === "function") {
            payload.destroy();
          } else if (typeof payload.close === "function") {
            payload.close(noop);
          } else if (typeof payload.abort === "function") {
            payload.abort();
          } else {
            reply.log.warn("stream payload does not end properly");
          }
        }
      });
      if (!res.headersSent) {
        for (const key in reply[kReplyHeaders]) {
          res.setHeader(key, reply[kReplyHeaders][key]);
        }
      } else {
        reply.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
      }
      payload.pipe(res);
    }
    function sendTrailer(payload, res, reply) {
      if (reply[kReplyTrailers] === null) {
        res.end(null, null, null);
        return;
      }
      const trailerHeaders = Object.keys(reply[kReplyTrailers]);
      const trailers = {};
      let handled = 0;
      let skipped = true;
      function send() {
        if (handled === 0) {
          res.addTrailers(trailers);
          res.end(null, null, null);
        }
      }
      for (const trailerName of trailerHeaders) {
        let cb = function(err, value) {
          handled++;
          if (err) reply.log.debug(err);
          else trailers[trailerName] = value;
          process.nextTick(send);
        };
        if (typeof reply[kReplyTrailers][trailerName] !== "function") continue;
        skipped = false;
        handled--;
        const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
        if (typeof result === "object" && typeof result.then === "function") {
          result.then((v2) => cb(null, v2), cb);
        }
      }
      if (skipped) res.end(null, null, null);
    }
    function sendStreamTrailer(payload, res, reply) {
      if (reply[kReplyTrailers] === null) return;
      payload.on("end", () => sendTrailer(null, res, reply));
    }
    function onErrorHook(reply, error48, cb) {
      if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
        reply[kReplyIsRunningOnErrorHook] = true;
        onSendHookRunner(
          reply[kRouteContext].onError,
          reply.request,
          reply,
          error48,
          () => handleError(reply, error48, cb)
        );
      } else {
        handleError(reply, error48, cb);
      }
    }
    function setupResponseListeners(reply) {
      reply[kReplyStartTime] = now();
      const onResFinished = (err) => {
        reply[kReplyEndTime] = now();
        reply.raw.removeListener("finish", onResFinished);
        reply.raw.removeListener("error", onResFinished);
        const ctx = reply[kRouteContext];
        if (ctx && ctx.onResponse !== null) {
          onResponseHookRunner(
            ctx.onResponse,
            reply.request,
            reply,
            onResponseCallback
          );
        } else {
          onResponseCallback(err, reply.request, reply);
        }
      };
      reply.raw.on("finish", onResFinished);
      reply.raw.on("error", onResFinished);
    }
    function onResponseCallback(err, request, reply) {
      if (reply.log[kDisableRequestLogging]) {
        return;
      }
      const responseTime = reply.elapsedTime;
      if (err != null) {
        reply.log.error({
          res: reply,
          err,
          responseTime
        }, "request errored");
        return;
      }
      reply.log.info({
        res: reply,
        responseTime
      }, "request completed");
    }
    function buildReply(R) {
      const props = R.props.slice();
      function _Reply(res, request, log) {
        this.raw = res;
        this[kReplyIsError] = false;
        this[kReplyErrorHandlerCalled] = false;
        this[kReplyHijacked] = false;
        this[kReplySerializer] = null;
        this.request = request;
        this[kReplyHeaders] = {};
        this[kReplyTrailers] = null;
        this[kReplyStartTime] = void 0;
        this[kReplyEndTime] = void 0;
        this.log = log;
        let prop;
        for (let i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      Object.setPrototypeOf(_Reply.prototype, R.prototype);
      Object.setPrototypeOf(_Reply, R);
      _Reply.parent = R;
      _Reply.props = props;
      return _Reply;
    }
    function notFound(reply) {
      if (reply[kRouteContext][kFourOhFourContext] === null) {
        reply.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
        reply.code(404).send("404 Not Found");
        return;
      }
      reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];
      if (reply[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          reply[kRouteContext].preHandler,
          reply.request,
          reply,
          internals.preHandlerCallback
        );
      } else {
        internals.preHandlerCallback(null, reply.request, reply);
      }
    }
    function serialize(context, data, statusCode, contentType) {
      const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
      if (fnSerialize) {
        return fnSerialize(data);
      }
      return JSON.stringify(data);
    }
    function noop() {
    }
    module.exports = Reply;
    module.exports.buildReply = buildReply;
    module.exports.setupResponseListeners = setupResponseListeners;
  }
});

// node_modules/.pnpm/@fastify+forwarded@3.0.1/node_modules/@fastify/forwarded/index.js
var require_forwarded = __commonJS({
  "node_modules/.pnpm/@fastify+forwarded@3.0.1/node_modules/@fastify/forwarded/index.js"(exports, module) {
    "use strict";
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      const header = req.headers["x-forwarded-for"];
      const socketAddr = req.socket.remoteAddress;
      if (!header || typeof header !== "string") {
        return [socketAddr];
      } else if (header.indexOf(",") === -1) {
        const remote = header.trim();
        return remote.length ? [socketAddr, remote] : [socketAddr];
      } else {
        return parse3(header, socketAddr);
      }
    }
    function parse3(header, socketAddr) {
      const result = [socketAddr];
      let end = header.length;
      let start = end;
      let char2;
      let i;
      for (i = end - 1; i >= 0; --i) {
        char2 = header[i];
        if (char2 === " ") {
          start === end && (start = end = i);
        } else if (char2 === ",") {
          start !== end && result.push(header.slice(start, end));
          start = end = i;
        } else {
          start = i;
        }
      }
      start !== end && result.push(header.substring(start, end));
      return result;
    }
    module.exports = forwarded;
    module.exports.default = forwarded;
    module.exports.forwarded = forwarded;
  }
});

// node_modules/.pnpm/ipaddr.js@2.3.0/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/.pnpm/ipaddr.js@2.3.0/node_modules/ipaddr.js/lib/ipaddr.js"(exports, module) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string6, parts) {
        if (string6.indexOf("::") !== string6.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string6.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string6 = string6.replace(/%.+$/, "");
        }
        while ((lastColon = string6.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string6.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string6.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string6 = string6.replace("::", replacement);
        if (string6[0] === ":") {
          string6 = string6.slice(1);
        }
        if (string6[string6.length - 1] === ":") {
          string6 = string6.slice(0, -1);
        }
        parts = (function() {
          const ref = string6.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        })();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string6) {
        if (hexRegex.test(string6)) {
          return parseInt(string6, 16);
        }
        if (string6[0] === "0" && !isNaN(parseInt(string6[1], 10))) {
          if (octalRegex.test(string6)) {
            return parseInt(string6, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string6} as octal`);
        }
        return parseInt(string6, 10);
      }
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = (function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ],
          // RFC7534, RFC7535
          as112: [
            [new IPv4([192, 175, 48, 0]), 24],
            [new IPv4([192, 31, 196, 0]), 24]
          ],
          // RFC7450
          amt: [
            [new IPv4([192, 52, 193, 0]), 24]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr2 = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr2 += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr2;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      })();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string6) {
        try {
          const cidr2 = this.parseCIDR(string6);
          const ipInterfaceOctets = cidr2[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr2[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string6) {
        return this.parser(string6) !== null;
      };
      ipaddr.IPv4.isValid = function(string6) {
        try {
          new this(this.parser(string6));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidCIDR = function(string6) {
        try {
          this.parseCIDR(string6);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string6) {
        if (ipaddr.IPv4.isValid(string6) && string6.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.isValidCIDRFourPartDecimal = function(string6) {
        const match2 = string6.match(/^(.+)\/(\d+)$/);
        if (!ipaddr.IPv4.isValidCIDR(string6) || !match2) {
          return false;
        }
        return ipaddr.IPv4.isValidFourPartDecimal(match2[1]);
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string6) {
        let cidr2, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr2 = this.parseCIDR(string6);
          ipInterfaceOctets = cidr2[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr2[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string6) {
        const parts = this.parser(string6);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string6) {
        let match2;
        if (match2 = string6.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match2[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match2[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string6) {
        let match2, part, value;
        if (match2 = string6.match(ipv4Regexes.fourOctet)) {
          return (function() {
            const ref = match2.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          })();
        } else if (match2 = string6.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match2[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return (function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          })().reverse();
        } else if (match2 = string6.match(ipv4Regexes.twoOctet)) {
          return (function() {
            const ref = match2.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          })();
        } else if (match2 = string6.match(ipv4Regexes.threeOctet)) {
          return (function() {
            const ref = match2.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          })();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = (function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6666
          discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC5180
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          // RFC7450
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [
            [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
            [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
          ],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
          droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
          reserved: [
            // RFC3849
            [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
            // RFC2928
            [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
          ]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr2 = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr2 += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr2;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = (function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }).call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = (function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }).call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string6 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match2;
          while (match2 = regex.exec(string6)) {
            if (match2[0].length > bestMatchLength) {
              bestMatchIndex = match2.index;
              bestMatchLength = match2[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string6;
          }
          return `${string6.substring(0, bestMatchIndex)}::${string6.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      })();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string6) {
        try {
          const cidr2 = this.parseCIDR(string6);
          const ipInterfaceOctets = cidr2[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr2[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string6) {
        return this.parser(string6) !== null;
      };
      ipaddr.IPv6.isValid = function(string6) {
        if (typeof string6 === "string" && string6.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string6);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.isValidCIDR = function(string6) {
        if (typeof string6 === "string" && string6.indexOf(":") === -1) {
          return false;
        }
        try {
          this.parseCIDR(string6);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string6) {
        let cidr2, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr2 = this.parseCIDR(string6);
          ipInterfaceOctets = cidr2[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr2[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string6) {
        const addr = this.parser(string6);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string6) {
        let maskLength, match2, parsed;
        if (match2 = string6.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match2[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match2[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string6) {
        let addr, i, match2, octet, octets, zoneId;
        if (match2 = string6.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match2[1]}`);
        }
        if (ipv6Regexes.native.test(string6)) {
          return expandIPv6(string6, 8);
        }
        if (match2 = string6.match(ipv6Regexes.transitional)) {
          zoneId = match2[6] || "";
          addr = match2[1];
          if (!match2[1].endsWith("::")) {
            addr = addr.slice(0, -1);
          }
          addr = expandIPv6(addr + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match2[2]),
              parseInt(match2[3]),
              parseInt(match2[4]),
              parseInt(match2[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string6) {
        return ipaddr.IPv6.isValid(string6) || ipaddr.IPv4.isValid(string6);
      };
      ipaddr.isValidCIDR = function(string6) {
        return ipaddr.IPv6.isValidCIDR(string6) || ipaddr.IPv4.isValidCIDR(string6);
      };
      ipaddr.parse = function(string6) {
        if (ipaddr.IPv6.isValid(string6)) {
          return ipaddr.IPv6.parse(string6);
        } else if (ipaddr.IPv4.isValid(string6)) {
          return ipaddr.IPv4.parse(string6);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string6) {
        try {
          return ipaddr.IPv6.parseCIDR(string6);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string6);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string6) {
        const addr = this.parse(string6);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports);
  }
});

// node_modules/.pnpm/@fastify+proxy-addr@5.1.0/node_modules/@fastify/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "node_modules/.pnpm/@fastify+proxy-addr@5.1.0/node_modules/@fastify/proxy-addr/index.js"(exports, module) {
    "use strict";
    module.exports = proxyaddr;
    module.exports.default = proxyaddr;
    module.exports.proxyaddr = proxyaddr;
    module.exports.all = alladdrs;
    module.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^\d+$/u;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      const addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (let i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i)) continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      let trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (let i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.hasOwn(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      const rangeSubnets = new Array(arr.length);
      for (let i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      const len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      const pos = note.lastIndexOf("/");
      const str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      let ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      const max = ip.kind() === "ipv6" ? 128 : 32;
      let range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range === null) {
        range = max;
      } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
      } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
      } else {
        range = null;
      }
      if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range];
    }
    function parseNetmask(netmask) {
      const ip = parseip(netmask);
      const kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      const addrs = alladdrs(req, trust);
      return addrs[addrs.length - 1];
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr)) return false;
        const ip = parseip(addr);
        let ipconv;
        const kind = ip.kind();
        for (let i = 0; i < subnets.length; i++) {
          const subnet = subnets[i];
          const subnetip = subnet[0];
          const subnetkind = subnetip.kind();
          const subnetrange = subnet[1];
          let trusted = ip;
          if (kind !== subnetkind) {
            const subnetisipv4 = subnetkind === "ipv4";
            if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      const subnetip = subnet[0];
      const subnetkind = subnetip.kind();
      const subnetisipv4 = subnetkind === "ipv4";
      const subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr)) return false;
        let ip = parseip(addr);
        const kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/request.js
var require_request = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/request.js"(exports, module) {
    "use strict";
    var proxyAddr = require_proxy_addr();
    var {
      kHasBeenDecorated,
      kSchemaBody,
      kSchemaHeaders,
      kSchemaParams,
      kSchemaQuerystring,
      kSchemaController,
      kOptions,
      kRequestCacheValidateFns,
      kRouteContext,
      kRequestOriginalUrl
    } = require_symbols2();
    var { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION, FST_ERR_DEC_UNDECLARED } = require_errors2();
    var decorators = require_decorate();
    var HTTP_PART_SYMBOL_MAP = {
      body: kSchemaBody,
      headers: kSchemaHeaders,
      params: kSchemaParams,
      querystring: kSchemaQuerystring,
      query: kSchemaQuerystring
    };
    function Request2(id, params, req, query, log, context) {
      this.id = id;
      this[kRouteContext] = context;
      this.params = params;
      this.raw = req;
      this.query = query;
      this.log = log;
      this.body = void 0;
    }
    Request2.props = [];
    function getTrustProxyFn(tp) {
      if (typeof tp === "function") {
        return tp;
      }
      if (tp === true) {
        return null;
      }
      if (typeof tp === "number") {
        return function(a2, i) {
          return i < tp;
        };
      }
      if (typeof tp === "string") {
        const values = tp.split(",").map((it2) => it2.trim());
        return proxyAddr.compile(values);
      }
      return proxyAddr.compile(tp);
    }
    function buildRequest(R, trustProxy) {
      if (trustProxy) {
        return buildRequestWithTrustProxy(R, trustProxy);
      }
      return buildRegularRequest(R);
    }
    function buildRegularRequest(R) {
      const props = R.props.slice();
      function _Request(id, params, req, query, log, context) {
        this.id = id;
        this[kRouteContext] = context;
        this.params = params;
        this.raw = req;
        this.query = query;
        this.log = log;
        this.body = void 0;
        let prop;
        for (let i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      Object.setPrototypeOf(_Request.prototype, R.prototype);
      Object.setPrototypeOf(_Request, R);
      _Request.props = props;
      _Request.parent = R;
      return _Request;
    }
    function getLastEntryInMultiHeaderValue(headerValue) {
      const lastIndex = headerValue.lastIndexOf(",");
      return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
    }
    function buildRequestWithTrustProxy(R, trustProxy) {
      const _Request = buildRegularRequest(R);
      const proxyFn = getTrustProxyFn(trustProxy);
      _Request[kHasBeenDecorated] = true;
      Object.defineProperties(_Request.prototype, {
        ip: {
          get() {
            const addrs = proxyAddr.all(this.raw, proxyFn);
            return addrs[addrs.length - 1];
          }
        },
        ips: {
          get() {
            return proxyAddr.all(this.raw, proxyFn);
          }
        },
        host: {
          get() {
            if (this.ip !== void 0 && this.headers["x-forwarded-host"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
            }
            return this.headers.host ?? this.headers[":authority"] ?? "";
          }
        },
        protocol: {
          get() {
            if (this.headers["x-forwarded-proto"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
            }
            if (this.socket) {
              return this.socket.encrypted ? "https" : "http";
            }
          }
        }
      });
      return _Request;
    }
    function assertsRequestDecoration(request, name) {
      if (!decorators.hasKey(request, name) && !decorators.exist(request, name)) {
        throw new FST_ERR_DEC_UNDECLARED(name, "request");
      }
    }
    Object.defineProperties(Request2.prototype, {
      server: {
        get() {
          return this[kRouteContext].server;
        }
      },
      url: {
        get() {
          return this.raw.url;
        }
      },
      originalUrl: {
        get() {
          if (!this[kRequestOriginalUrl]) {
            this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
          }
          return this[kRequestOriginalUrl];
        }
      },
      method: {
        get() {
          return this.raw.method;
        }
      },
      routeOptions: {
        get() {
          const context = this[kRouteContext];
          const routeLimit = context._parserOptions.limit;
          const serverLimit = context.server.initialConfig.bodyLimit;
          const version3 = context.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0;
          const options = {
            method: context.config?.method,
            url: context.config?.url,
            bodyLimit: routeLimit || serverLimit,
            attachValidation: context.attachValidation,
            logLevel: context.logLevel,
            exposeHeadRoute: context.exposeHeadRoute,
            prefixTrailingSlash: context.prefixTrailingSlash,
            handler: context.handler,
            config: context.config,
            schema: context.schema,
            version: version3
          };
          return options;
        }
      },
      is404: {
        get() {
          return this[kRouteContext].config?.url === void 0;
        }
      },
      socket: {
        get() {
          return this.raw.socket;
        }
      },
      ip: {
        get() {
          if (this.socket) {
            return this.socket.remoteAddress;
          }
        }
      },
      host: {
        get() {
          return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
        }
      },
      hostname: {
        get() {
          return this.host.split(":", 1)[0];
        }
      },
      port: {
        get() {
          const portFromHost = parseInt(this.host.split(":").slice(-1)[0]);
          if (!isNaN(portFromHost)) {
            return portFromHost;
          }
          const host = this.headers.host ?? this.headers[":authority"] ?? "";
          const portFromHeader = parseInt(host.split(":").slice(-1)[0]);
          if (!isNaN(portFromHeader)) {
            return portFromHeader;
          }
          return null;
        }
      },
      protocol: {
        get() {
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      },
      headers: {
        get() {
          if (this.additionalHeaders) {
            return Object.assign({}, this.raw.headers, this.additionalHeaders);
          }
          return this.raw.headers;
        },
        set(headers) {
          this.additionalHeaders = headers;
        }
      },
      getValidationFunction: {
        value: function(httpPartOrSchema) {
          if (typeof httpPartOrSchema === "string") {
            const symbol2 = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
            return this[kRouteContext][symbol2];
          } else if (typeof httpPartOrSchema === "object") {
            return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema);
          }
        }
      },
      compileValidationSchema: {
        value: function(schema, httpPart = null) {
          const { method, url: url2 } = this;
          if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
            return this[kRouteContext][kRequestCacheValidateFns].get(schema);
          }
          const validatorCompiler2 = this[kRouteContext].validatorCompiler || this.server[kSchemaController].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
          // nor set
          (this.server[kSchemaController].setupValidator(this.server[kOptions]) || this.server[kSchemaController].validatorCompiler);
          const validateFn = validatorCompiler2({
            schema,
            method,
            url: url2,
            httpPart
          });
          if (this[kRouteContext][kRequestCacheValidateFns] == null) {
            this[kRouteContext][kRequestCacheValidateFns] = /* @__PURE__ */ new WeakMap();
          }
          this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);
          return validateFn;
        }
      },
      validateInput: {
        value: function(input, schema, httpPart) {
          httpPart = typeof schema === "string" ? schema : httpPart;
          const symbol2 = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
          let validate;
          if (symbol2) {
            validate = this[kRouteContext][symbol2];
          }
          if (validate == null && (schema == null || typeof schema !== "object" || Array.isArray(schema))) {
            throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
          }
          if (validate == null) {
            if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
              validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
            } else {
              validate = this.compileValidationSchema(schema, httpPart);
            }
          }
          return validate(input);
        }
      },
      getDecorator: {
        value: function(name) {
          assertsRequestDecoration(this, name);
          const decorator = this[name];
          if (typeof decorator === "function") {
            return decorator.bind(this);
          }
          return decorator;
        }
      },
      setDecorator: {
        value: function(name, value) {
          assertsRequestDecoration(this, name);
          this[name] = value;
        }
      }
    });
    module.exports = Request2;
    module.exports.buildRequest = buildRequest;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/context.js
var require_context = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/context.js"(exports, module) {
    "use strict";
    var {
      kFourOhFourContext,
      kReplySerializerDefault,
      kSchemaErrorFormatter,
      kErrorHandler,
      kChildLoggerFactory,
      kOptions,
      kReply,
      kRequest,
      kBodyLimit,
      kLogLevel,
      kContentTypeParser,
      kRouteByFastify,
      kRequestCacheValidateFns,
      kReplyCacheSerializeFns
    } = require_symbols2();
    function Context({
      schema,
      handler,
      config: config3,
      requestIdLogLabel,
      childLoggerFactory,
      errorHandler,
      bodyLimit,
      logLevel,
      logSerializers,
      attachValidation,
      validatorCompiler: validatorCompiler2,
      serializerCompiler: serializerCompiler2,
      replySerializer,
      schemaErrorFormatter,
      exposeHeadRoute,
      prefixTrailingSlash,
      server,
      isFastify
    }) {
      this.schema = schema;
      this.handler = handler;
      this.Reply = server[kReply];
      this.Request = server[kRequest];
      this.contentTypeParser = server[kContentTypeParser];
      this.onRequest = null;
      this.onSend = null;
      this.onError = null;
      this.onTimeout = null;
      this.preHandler = null;
      this.onResponse = null;
      this.preSerialization = null;
      this.onRequestAbort = null;
      this.config = config3;
      this.errorHandler = errorHandler || server[kErrorHandler];
      this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
      this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
      this._middie = null;
      this._parserOptions = {
        limit: bodyLimit || server[kBodyLimit]
      };
      this.exposeHeadRoute = exposeHeadRoute;
      this.prefixTrailingSlash = prefixTrailingSlash;
      this.logLevel = logLevel || server[kLogLevel];
      this.logSerializers = logSerializers;
      this[kFourOhFourContext] = null;
      this.attachValidation = attachValidation;
      this[kReplySerializerDefault] = replySerializer;
      this.schemaErrorFormatter = schemaErrorFormatter || server[kSchemaErrorFormatter] || defaultSchemaErrorFormatter;
      this[kRouteByFastify] = isFastify;
      this[kRequestCacheValidateFns] = null;
      this[kReplyCacheSerializeFns] = null;
      this.validatorCompiler = validatorCompiler2 || null;
      this.serializerCompiler = serializerCompiler2 || null;
      this.server = server;
    }
    function defaultSchemaErrorFormatter(errors, dataVar) {
      let text2 = "";
      const separator = ", ";
      for (let i = 0; i !== errors.length; ++i) {
        const e = errors[i];
        text2 += dataVar + (e.instancePath || "") + " " + e.message + separator;
      }
      return new Error(text2.slice(0, -separator.length));
    }
    module.exports = Context;
  }
});

// node_modules/.pnpm/toad-cache@3.7.0/node_modules/toad-cache/dist/toad-cache.cjs
var require_toad_cache = __commonJS({
  "node_modules/.pnpm/toad-cache@3.7.0/node_modules/toad-cache/dist/toad-cache.cjs"(exports) {
    "use strict";
    var FifoMap = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      get size() {
        return this.items.size;
      }
      clear() {
        this.items = /* @__PURE__ */ new Map();
        this.first = null;
        this.last = null;
      }
      delete(key) {
        if (this.items.has(key)) {
          const deletedItem = this.items.get(key);
          this.items.delete(key);
          if (deletedItem.prev !== null) {
            deletedItem.prev.next = deletedItem.next;
          }
          if (deletedItem.next !== null) {
            deletedItem.next.prev = deletedItem.prev;
          }
          if (this.first === deletedItem) {
            this.first = deletedItem.next;
          }
          if (this.last === deletedItem) {
            this.last = deletedItem.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          this.items.delete(item.key);
          if (this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (this.items.has(key)) {
          return this.items.get(key).expiry;
        }
      }
      get(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return this.items.keys();
      }
      set(key, value) {
        if (this.items.has(key)) {
          const item2 = this.items.get(key);
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items.set(key, item);
        if (this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var LruMap = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      get size() {
        return this.items.size;
      }
      bumpLru(item) {
        if (this.last === item) {
          return;
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
          this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
        this.last = item;
      }
      clear() {
        this.items = /* @__PURE__ */ new Map();
        this.first = null;
        this.last = null;
      }
      delete(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          this.items.delete(key);
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          this.items.delete(item.key);
          if (this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (this.items.has(key)) {
          return this.items.get(key).expiry;
        }
      }
      get(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          this.bumpLru(item);
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return this.items.keys();
      }
      set(key, value) {
        if (this.items.has(key)) {
          const item2 = this.items.get(key);
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          if (this.last !== item2) {
            this.bumpLru(item2);
          }
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items.set(key, item);
        if (this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var LruObject = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      bumpLru(item) {
        if (this.last === item) {
          return;
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
          this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
        this.last = item;
      }
      clear() {
        this.items = /* @__PURE__ */ Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
      }
      delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          delete this.items[key];
          this.size--;
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          return this.items[key].expiry;
        }
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          this.bumpLru(item);
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item2 = this.items[key];
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          if (this.last !== item2) {
            this.bumpLru(item2);
          }
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items[key] = item;
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var HitStatisticsRecord = class {
      constructor() {
        this.records = {};
      }
      initForCache(cacheId, currentTimeStamp) {
        this.records[cacheId] = {
          [currentTimeStamp]: {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0
          }
        };
      }
      resetForCache(cacheId) {
        for (let key of Object.keys(this.records[cacheId])) {
          this.records[cacheId][key] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0
          };
        }
      }
      getStatistics() {
        return this.records;
      }
    };
    function getTimestamp(date9) {
      return `${date9.getFullYear()}-${(date9.getMonth() + 1).toString().padStart(2, "0")}-${date9.getDate().toString().padStart(2, "0")}`;
    }
    var HitStatistics = class {
      constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
        this.cacheId = cacheId;
        this.statisticTtlInHours = statisticTtlInHours;
        this.collectionStart = /* @__PURE__ */ new Date();
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records = globalStatisticsRecord || new HitStatisticsRecord();
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
      get currentRecord() {
        if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
          this.records.records[this.cacheId][this.currentTimeStamp] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            sets: 0,
            invalidateOne: 0,
            invalidateAll: 0
          };
        }
        return this.records.records[this.cacheId][this.currentTimeStamp];
      }
      hoursPassed() {
        return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
      }
      addHit() {
        this.archiveIfNeeded();
        this.currentRecord.hits++;
      }
      addFalsyHit() {
        this.archiveIfNeeded();
        this.currentRecord.falsyHits++;
      }
      addEmptyHit() {
        this.archiveIfNeeded();
        this.currentRecord.emptyHits++;
      }
      addMiss() {
        this.archiveIfNeeded();
        this.currentRecord.misses++;
      }
      addEviction() {
        this.archiveIfNeeded();
        this.currentRecord.evictions++;
      }
      setCacheSize(currentSize) {
        this.archiveIfNeeded();
        this.currentRecord.cacheSize = currentSize;
      }
      addExpiration() {
        this.archiveIfNeeded();
        this.currentRecord.expirations++;
      }
      addSet() {
        this.archiveIfNeeded();
        this.currentRecord.sets++;
      }
      addInvalidateOne() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateOne++;
      }
      addInvalidateAll() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateAll++;
      }
      getStatistics() {
        return this.records.getStatistics();
      }
      archiveIfNeeded() {
        if (this.hoursPassed() >= this.statisticTtlInHours) {
          this.collectionStart = /* @__PURE__ */ new Date();
          this.currentTimeStamp = getTimestamp(this.collectionStart);
          this.records.initForCache(this.cacheId, this.currentTimeStamp);
        }
      }
    };
    var LruObjectHitStatistics = class extends LruObject {
      constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
        super(max || 1e3, ttlInMsecs || 0);
        if (!cacheId) {
          throw new Error("Cache id is mandatory");
        }
        this.hitStatistics = new HitStatistics(
          cacheId,
          statisticTtlInHours !== void 0 ? statisticTtlInHours : 24,
          globalStatisticsRecord
        );
      }
      getStatistics() {
        return this.hitStatistics.getStatistics();
      }
      set(key, value) {
        super.set(key, value);
        this.hitStatistics.addSet();
        this.hitStatistics.setCacheSize(this.size);
      }
      evict() {
        super.evict();
        this.hitStatistics.addEviction();
        this.hitStatistics.setCacheSize(this.size);
      }
      delete(key, isExpiration = false) {
        super.delete(key);
        if (!isExpiration) {
          this.hitStatistics.addInvalidateOne();
        }
        this.hitStatistics.setCacheSize(this.size);
      }
      clear() {
        super.clear();
        this.hitStatistics.addInvalidateAll();
        this.hitStatistics.setCacheSize(this.size);
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key, true);
            this.hitStatistics.addExpiration();
            return;
          }
          this.bumpLru(item);
          if (!item.value) {
            this.hitStatistics.addFalsyHit();
          }
          if (item.value === void 0 || item.value === null || item.value === "") {
            this.hitStatistics.addEmptyHit();
          }
          this.hitStatistics.addHit();
          return item.value;
        }
        this.hitStatistics.addMiss();
      }
    };
    var FifoObject = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      clear() {
        this.items = /* @__PURE__ */ Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
      }
      delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const deletedItem = this.items[key];
          delete this.items[key];
          this.size--;
          if (deletedItem.prev !== null) {
            deletedItem.prev.next = deletedItem.next;
          }
          if (deletedItem.next !== null) {
            deletedItem.next.prev = deletedItem.prev;
          }
          if (this.first === deletedItem) {
            this.first = deletedItem.next;
          }
          if (this.last === deletedItem) {
            this.last = deletedItem.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          return this.items[key].expiry;
        }
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item2 = this.items[key];
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items[key] = item;
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    exports.Fifo = FifoObject;
    exports.FifoMap = FifoMap;
    exports.FifoObject = FifoObject;
    exports.HitStatisticsRecord = HitStatisticsRecord;
    exports.Lru = LruObject;
    exports.LruHitStatistics = LruObjectHitStatistics;
    exports.LruMap = LruMap;
    exports.LruObject = LruObject;
    exports.LruObjectHitStatistics = LruObjectHitStatistics;
  }
});

// node_modules/.pnpm/secure-json-parse@4.1.0/node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/.pnpm/secure-json-parse@4.1.0/node_modules/secure-json-parse/index.js"(exports, module) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse2(text2, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text2)) {
        text2 = text2.toString();
      }
      if (text2 && text2.charCodeAt(0) === 65279) {
        text2 = text2.slice(1);
      }
      const obj = JSON.parse(text2, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text2) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text2) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && node.constructor !== null && typeof node.constructor === "object" && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse3(text2, reviver, options) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse2(text2, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse4(text2, reviver) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse2(text2, reviver, { safe: true });
      } catch {
        return void 0;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse3;
    module.exports.default = parse3;
    module.exports.parse = parse3;
    module.exports.safeParse = safeParse4;
    module.exports.scan = filter;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/contentTypeParser.js
var require_contentTypeParser = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/contentTypeParser.js"(exports, module) {
    "use strict";
    var { AsyncResource } = __require("node:async_hooks");
    var { FifoMap: Fifo } = require_toad_cache();
    var { parse: secureJsonParse } = require_secure_json_parse();
    var {
      kDefaultJsonParse,
      kContentTypeParser,
      kBodyLimit,
      kRequestPayloadStream,
      kState,
      kTestInternals,
      kReplyIsError,
      kRouteContext
    } = require_symbols2();
    var {
      FST_ERR_CTP_INVALID_TYPE,
      FST_ERR_CTP_EMPTY_TYPE,
      FST_ERR_CTP_ALREADY_PRESENT,
      FST_ERR_CTP_INVALID_HANDLER,
      FST_ERR_CTP_INVALID_PARSE_TYPE,
      FST_ERR_CTP_BODY_TOO_LARGE,
      FST_ERR_CTP_INVALID_MEDIA_TYPE,
      FST_ERR_CTP_INVALID_CONTENT_LENGTH,
      FST_ERR_CTP_EMPTY_JSON_BODY,
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED,
      FST_ERR_CTP_INVALID_JSON_BODY
    } = require_errors2();
    var { FSTSEC001 } = require_warnings();
    function ContentTypeParser(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
      this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
      this.customParsers = /* @__PURE__ */ new Map();
      this.customParsers.set("application/json", new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
      this.customParsers.set("text/plain", new Parser(true, false, bodyLimit, defaultPlainTextParser));
      this.parserList = ["application/json", "text/plain"];
      this.parserRegExpList = [];
      this.cache = new Fifo(100);
    }
    ContentTypeParser.prototype.add = function(contentType, opts, parserFn) {
      const contentTypeIsString = typeof contentType === "string";
      if (contentTypeIsString) {
        contentType = contentType.trim().toLowerCase();
        if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE();
      } else if (!(contentType instanceof RegExp)) {
        throw new FST_ERR_CTP_INVALID_TYPE();
      }
      if (typeof parserFn !== "function") {
        throw new FST_ERR_CTP_INVALID_HANDLER();
      }
      if (this.existingParser(contentType)) {
        throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
      }
      if (opts.parseAs !== void 0) {
        if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
          throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
        }
      }
      const parser = new Parser(
        opts.parseAs === "string",
        opts.parseAs === "buffer",
        opts.bodyLimit,
        parserFn
      );
      if (contentType === "*") {
        this.customParsers.set("", parser);
      } else {
        if (contentTypeIsString) {
          this.parserList.unshift(contentType);
          this.customParsers.set(contentType, parser);
        } else {
          validateRegExp(contentType);
          this.parserRegExpList.unshift(contentType);
          this.customParsers.set(contentType.toString(), parser);
        }
      }
    };
    ContentTypeParser.prototype.hasParser = function(contentType) {
      if (typeof contentType === "string") {
        contentType = contentType.trim().toLowerCase();
      } else {
        if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType = contentType.toString();
      }
      return this.customParsers.has(contentType);
    };
    ContentTypeParser.prototype.existingParser = function(contentType) {
      if (contentType === "application/json" && this.customParsers.has(contentType)) {
        return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse];
      }
      if (contentType === "text/plain" && this.customParsers.has(contentType)) {
        return this.customParsers.get(contentType).fn !== defaultPlainTextParser;
      }
      return this.hasParser(contentType);
    };
    ContentTypeParser.prototype.getParser = function(contentType) {
      let parser = this.customParsers.get(contentType);
      if (parser !== void 0) return parser;
      parser = this.cache.get(contentType);
      if (parser !== void 0) return parser;
      const caseInsensitiveContentType = contentType.toLowerCase();
      for (let i = 0; i !== this.parserList.length; ++i) {
        const parserListItem = this.parserList[i];
        if (caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem && (caseInsensitiveContentType.length === parserListItem.length || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32)) {
          parser = this.customParsers.get(parserListItem);
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      for (let j = 0; j !== this.parserRegExpList.length; ++j) {
        const parserRegExp = this.parserRegExpList[j];
        if (parserRegExp.test(contentType)) {
          parser = this.customParsers.get(parserRegExp.toString());
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      return this.customParsers.get("");
    };
    ContentTypeParser.prototype.removeAll = function() {
      this.customParsers = /* @__PURE__ */ new Map();
      this.parserRegExpList = [];
      this.parserList = [];
      this.cache = new Fifo(100);
    };
    ContentTypeParser.prototype.remove = function(contentType) {
      let parsers;
      if (typeof contentType === "string") {
        contentType = contentType.trim().toLowerCase();
        parsers = this.parserList;
      } else {
        if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType = contentType.toString();
        parsers = this.parserRegExpList;
      }
      const removed = this.customParsers.delete(contentType);
      const idx = parsers.findIndex((ct2) => ct2.toString() === contentType);
      if (idx > -1) {
        parsers.splice(idx, 1);
      }
      return removed || idx > -1;
    };
    ContentTypeParser.prototype.run = function(contentType, handler, request, reply) {
      const parser = this.getParser(contentType);
      if (parser === void 0) {
        if (request.is404 === true) {
          handler(request, reply);
          return;
        }
        reply[kReplyIsError] = true;
        reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || void 0));
        return;
      }
      const resource = new AsyncResource("content-type-parser:run", request);
      const done = resource.bind(onDone);
      if (parser.asString === true || parser.asBuffer === true) {
        rawBody(
          request,
          reply,
          reply[kRouteContext]._parserOptions,
          parser,
          done
        );
        return;
      }
      const result = parser.fn(request, request[kRequestPayloadStream], done);
      if (result && typeof result.then === "function") {
        result.then((body) => {
          done(null, body);
        }, done);
      }
      function onDone(error48, body) {
        resource.emitDestroy();
        if (error48 != null) {
          reply.header("connection", "close");
          reply[kReplyIsError] = true;
          reply.send(error48);
          return;
        }
        request.body = body;
        handler(request, reply);
      }
    };
    function rawBody(request, reply, options, parser, done) {
      const asString = parser.asString === true;
      const limit = options.limit === null ? parser.bodyLimit : options.limit;
      const contentLength = Number(request.headers["content-length"]);
      if (contentLength > limit) {
        done(new FST_ERR_CTP_BODY_TOO_LARGE(), void 0);
        return;
      }
      let receivedLength = 0;
      let body = asString ? "" : [];
      const payload = request[kRequestPayloadStream] || request.raw;
      if (asString) {
        payload.setEncoding("utf8");
      }
      payload.on("data", onData);
      payload.on("end", onEnd);
      payload.on("error", onEnd);
      payload.resume();
      function onData(chunk) {
        receivedLength += asString ? Buffer.byteLength(chunk) : chunk.length;
        const { receivedEncodedLength = 0 } = payload;
        if (receivedLength > limit || receivedEncodedLength > limit) {
          payload.removeListener("data", onData);
          payload.removeListener("end", onEnd);
          payload.removeListener("error", onEnd);
          done(new FST_ERR_CTP_BODY_TOO_LARGE(), void 0);
          return;
        }
        if (asString) {
          body += chunk;
        } else {
          body.push(chunk);
        }
      }
      function onEnd(err) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        if (err != null) {
          if (!(typeof err.statusCode === "number" && err.statusCode >= 400)) {
            err.statusCode = 400;
          }
          done(err, void 0);
          return;
        }
        if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
          done(new FST_ERR_CTP_INVALID_CONTENT_LENGTH(), void 0);
          return;
        }
        if (!asString) {
          body = Buffer.concat(body);
        }
        const result = parser.fn(request, body, done);
        if (result && typeof result.then === "function") {
          result.then((body2) => {
            done(null, body2);
          }, done);
        }
      }
    }
    function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
      const parseOptions = { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning };
      return defaultJsonParser;
      function defaultJsonParser(req, body, done) {
        if (body.length === 0) {
          done(new FST_ERR_CTP_EMPTY_JSON_BODY(), void 0);
          return;
        }
        try {
          done(null, secureJsonParse(body, parseOptions));
        } catch {
          done(new FST_ERR_CTP_INVALID_JSON_BODY(), void 0);
        }
      }
    }
    function defaultPlainTextParser(req, body, done) {
      done(null, body);
    }
    function Parser(asString, asBuffer, bodyLimit, fn) {
      this.asString = asString;
      this.asBuffer = asBuffer;
      this.bodyLimit = bodyLimit;
      this.fn = fn;
    }
    function buildContentTypeParser(c) {
      const contentTypeParser = new ContentTypeParser();
      contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
      contentTypeParser.customParsers = new Map(c.customParsers.entries());
      contentTypeParser.parserList = c.parserList.slice();
      contentTypeParser.parserRegExpList = c.parserRegExpList.slice();
      return contentTypeParser;
    }
    function addContentTypeParser(contentType, opts, parser) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
      }
      if (typeof opts === "function") {
        parser = opts;
        opts = {};
      }
      if (!opts) opts = {};
      if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];
      if (Array.isArray(contentType)) {
        contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
      } else {
        this[kContentTypeParser].add(contentType, opts, parser);
      }
      return this;
    }
    function hasContentTypeParser(contentType) {
      return this[kContentTypeParser].hasParser(contentType);
    }
    function removeContentTypeParser(contentType) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
      }
      if (Array.isArray(contentType)) {
        for (const type of contentType) {
          this[kContentTypeParser].remove(type);
        }
      } else {
        this[kContentTypeParser].remove(contentType);
      }
    }
    function removeAllContentTypeParsers() {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
      }
      this[kContentTypeParser].removeAll();
    }
    function validateRegExp(regexp) {
      if (regexp.source[0] !== "^" && regexp.source.includes(";?") === false) {
        FSTSEC001(regexp.source);
      }
    }
    module.exports = ContentTypeParser;
    module.exports.helpers = {
      buildContentTypeParser,
      addContentTypeParser,
      hasContentTypeParser,
      removeContentTypeParser,
      removeAllContentTypeParsers
    };
    module.exports.defaultParsers = {
      getDefaultJsonParser,
      defaultTextParser: defaultPlainTextParser
    };
    module.exports[kTestInternals] = { rawBody };
  }
});

// node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.js"(exports) {
    var has = Object.prototype.hasOwnProperty;
    function find(iter, tar, key) {
      for (key of iter.keys()) {
        if (dequal(key, tar)) return key;
      }
    }
    function dequal(foo, bar) {
      var ctor, len, tmp;
      if (foo === bar) return true;
      if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date) return foo.getTime() === bar.getTime();
        if (ctor === RegExp) return foo.toString() === bar.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar.length) {
            while (len-- && dequal(foo[len], bar[len])) ;
          }
          return len === -1;
        }
        if (ctor === Set) {
          if (foo.size !== bar.size) {
            return false;
          }
          for (len of foo) {
            tmp = len;
            if (tmp && typeof tmp === "object") {
              tmp = find(bar, tmp);
              if (!tmp) return false;
            }
            if (!bar.has(tmp)) return false;
          }
          return true;
        }
        if (ctor === Map) {
          if (foo.size !== bar.size) {
            return false;
          }
          for (len of foo) {
            tmp = len[0];
            if (tmp && typeof tmp === "object") {
              tmp = find(bar, tmp);
              if (!tmp) return false;
            }
            if (!dequal(len[1], bar.get(tmp))) {
              return false;
            }
          }
          return true;
        }
        if (ctor === ArrayBuffer) {
          foo = new Uint8Array(foo);
          bar = new Uint8Array(bar);
        } else if (ctor === DataView) {
          if ((len = foo.byteLength) === bar.byteLength) {
            while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
          }
          return len === -1;
        }
        if (ArrayBuffer.isView(foo)) {
          if ((len = foo.byteLength) === bar.byteLength) {
            while (len-- && foo[len] === bar[len]) ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
            if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
          }
          return Object.keys(bar).length === len;
        }
      }
      return foo !== foo && bar !== bar;
    }
    exports.dequal = dequal;
  }
});

// node_modules/.pnpm/json-schema-ref-resolver@3.0.0/node_modules/json-schema-ref-resolver/index.js
var require_json_schema_ref_resolver = __commonJS({
  "node_modules/.pnpm/json-schema-ref-resolver@3.0.0/node_modules/json-schema-ref-resolver/index.js"(exports, module) {
    "use strict";
    var { dequal: deepEqual } = require_dist();
    var jsonSchemaRefSymbol = /* @__PURE__ */ Symbol.for("json-schema-ref");
    var RefResolver = class {
      #schemas;
      #derefSchemas;
      #insertRefSymbol;
      #allowEqualDuplicates;
      #cloneSchemaWithoutRefs;
      constructor(opts = {}) {
        this.#schemas = {};
        this.#derefSchemas = {};
        this.#insertRefSymbol = opts.insertRefSymbol ?? false;
        this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
        this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
      }
      addSchema(schema, rootSchemaId, isRootSchema = true) {
        if (isRootSchema) {
          if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
            rootSchemaId = schema.$id;
          } else {
            this.#insertSchemaBySchemaId(schema, rootSchemaId);
          }
        }
        const schemaId = schema.$id;
        if (schemaId !== void 0 && typeof schemaId === "string") {
          if (schemaId.charAt(0) === "#") {
            this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
          } else {
            this.#insertSchemaBySchemaId(schema, schemaId);
            rootSchemaId = schemaId;
          }
        }
        const ref = schema.$ref;
        if (ref !== void 0 && typeof ref === "string") {
          const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
          this.#schemas[rootSchemaId].refs.push({
            schemaId: refSchemaId,
            jsonPointer: refJsonPointer
          });
        }
        for (const key in schema) {
          if (typeof schema[key] === "object" && schema[key] !== null) {
            this.addSchema(schema[key], rootSchemaId, false);
          }
        }
      }
      getSchema(schemaId, jsonPointer = "#") {
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(
            `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
          );
        }
        if (schema.anchors[jsonPointer] !== void 0) {
          return schema.anchors[jsonPointer];
        }
        return getDataByJSONPointer(schema.schema, jsonPointer);
      }
      hasSchema(schemaId) {
        return this.#schemas[schemaId] !== void 0;
      }
      getSchemaRefs(schemaId) {
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(`Schema with id "${schemaId}" is not found.`);
        }
        return schema.refs;
      }
      getSchemaDependencies(schemaId, dependencies = {}) {
        const schema = this.#schemas[schemaId];
        for (const ref of schema.refs) {
          const dependencySchemaId = ref.schemaId;
          if (dependencySchemaId === schemaId || dependencies[dependencySchemaId] !== void 0) continue;
          dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
          this.getSchemaDependencies(dependencySchemaId, dependencies);
        }
        return dependencies;
      }
      derefSchema(schemaId) {
        if (this.#derefSchemas[schemaId] !== void 0) return;
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(`Schema with id "${schemaId}" is not found.`);
        }
        if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
          this.#derefSchemas[schemaId] = {
            schema: schema.schema,
            anchors: schema.anchors
          };
        }
        const refs = [];
        this.#addDerefSchema(schema.schema, schemaId, true, refs);
        const dependencies = this.getSchemaDependencies(schemaId);
        for (const schemaId2 in dependencies) {
          const schema2 = dependencies[schemaId2];
          this.#addDerefSchema(schema2, schemaId2, true, refs);
        }
        for (const ref of refs) {
          const {
            refSchemaId,
            refJsonPointer
          } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);
          const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
          if (targetSchema === null) {
            throw new Error(
              `Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
            );
          }
          ref.targetSchema = targetSchema;
          ref.targetSchemaId = refSchemaId;
        }
        for (const ref of refs) {
          this.#resolveRef(ref, refs);
        }
      }
      getDerefSchema(schemaId, jsonPointer = "#") {
        let derefSchema = this.#derefSchemas[schemaId];
        if (derefSchema === void 0) {
          this.derefSchema(schemaId);
          derefSchema = this.#derefSchemas[schemaId];
        }
        if (derefSchema.anchors[jsonPointer] !== void 0) {
          return derefSchema.anchors[jsonPointer];
        }
        return getDataByJSONPointer(derefSchema.schema, jsonPointer);
      }
      #parseSchemaRef(ref, schemaId) {
        const sharpIndex = ref.indexOf("#");
        if (sharpIndex === -1) {
          return { refSchemaId: ref, refJsonPointer: "#" };
        }
        if (sharpIndex === 0) {
          return { refSchemaId: schemaId, refJsonPointer: ref };
        }
        return {
          refSchemaId: ref.slice(0, sharpIndex),
          refJsonPointer: ref.slice(sharpIndex)
        };
      }
      #addDerefSchema(schema, rootSchemaId, isRootSchema, refs = []) {
        const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };
        if (isRootSchema) {
          if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
            rootSchemaId = schema.$id;
          } else {
            this.#insertDerefSchemaBySchemaId(derefSchema, rootSchemaId);
          }
        }
        const schemaId = derefSchema.$id;
        if (schemaId !== void 0 && typeof schemaId === "string") {
          if (schemaId.charAt(0) === "#") {
            this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
          } else {
            this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
            rootSchemaId = schemaId;
          }
        }
        if (derefSchema.$ref !== void 0) {
          refs.push({
            ref: derefSchema.$ref,
            sourceSchemaId: rootSchemaId,
            sourceSchema: derefSchema
          });
        }
        for (const key in derefSchema) {
          const value = derefSchema[key];
          if (typeof value === "object" && value !== null) {
            derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, false, refs);
          }
        }
        return derefSchema;
      }
      #resolveRef(ref, refs) {
        const { sourceSchema, targetSchema } = ref;
        if (!sourceSchema.$ref) return;
        if (this.#insertRefSymbol) {
          sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
        }
        delete sourceSchema.$ref;
        if (targetSchema.$ref) {
          const targetSchemaRef = refs.find((ref2) => ref2.sourceSchema === targetSchema);
          this.#resolveRef(targetSchemaRef, refs);
        }
        for (const key in targetSchema) {
          if (key === "$id") continue;
          if (sourceSchema[key] !== void 0) {
            if (deepEqual(sourceSchema[key], targetSchema[key])) continue;
            throw new Error(
              `Cannot resolve ref "${ref.ref}". Property "${key}" already exists in schema "${ref.sourceSchemaId}".`
            );
          }
          sourceSchema[key] = targetSchema[key];
        }
        ref.isResolved = true;
      }
      #insertSchemaBySchemaId(schema, schemaId) {
        const foundSchema = this.#schemas[schemaId];
        if (foundSchema !== void 0) {
          if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return;
          throw new Error(`There is already another schema with id "${schemaId}".`);
        }
        this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
      }
      #insertSchemaByAnchor(schema, schemaId, anchor) {
        const { anchors } = this.#schemas[schemaId];
        if (anchors[anchor] !== void 0) {
          throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`);
        }
        anchors[anchor] = schema;
      }
      #insertDerefSchemaBySchemaId(schema, schemaId) {
        const foundSchema = this.#derefSchemas[schemaId];
        if (foundSchema !== void 0) return;
        this.#derefSchemas[schemaId] = { schema, anchors: {} };
      }
      #insertDerefSchemaByAnchor(schema, schemaId, anchor) {
        const { anchors } = this.#derefSchemas[schemaId];
        anchors[anchor] = schema;
      }
    };
    function getDataByJSONPointer(data, jsonPointer) {
      const parts = jsonPointer.split("/");
      let current = data;
      for (const part of parts) {
        if (part === "" || part === "#") continue;
        if (typeof current !== "object" || current === null) {
          return null;
        }
        current = current[part];
      }
      return current ?? null;
    }
    module.exports = { RefResolver };
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name2 = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name2;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a3;
        return (_a3 = this._str) !== null && _a3 !== void 0 ? _a3 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a3;
        return (_a3 = this._names) !== null && _a3 !== void 0 ? _a3 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name2)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name2)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a2, b2) {
      if (b2 === '""')
        return a2;
      if (a2 === '""')
        return b2;
      if (typeof a2 == "string") {
        if (b2 instanceof Name2 || a2[a2.length - 1] !== '"')
          return;
        if (typeof b2 != "string")
          return `${a2.slice(0, -1)}${b2}"`;
        if (b2[0] === '"')
          return a2.slice(0, -1) + b2.slice(1);
        return;
      }
      if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name2))
        return `"${a2}${b2.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x2) {
      return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
    }
    function stringify(x2) {
      return new _Code(safeStringify(x2));
    }
    exports.stringify = stringify;
    function safeStringify(x2) {
      return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope2 = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a3, _b;
        if (((_b = (_a3 = this._parent) === null || _a3 === void 0 ? void 0 : _a3._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope2;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line2 = (0, code_1._)`\n`;
    var ValueScope = class extends Scope2 {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line2 : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a3;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a3 = value.key) !== null && _a3 !== void 0 ? _a3 : value.ref;
        let vs2 = this._values[prefix];
        if (vs2) {
          const _name = vs2.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs2 = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs2.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs2 = this._values[prefix];
        if (!vs2)
          return;
        return vs2.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs2 = values[prefix];
          if (!vs2)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs2.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error48) {
        super();
        this.error = error48;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not2(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a3;
        this.else = (_a3 = this.else) === null || _a3 === void 0 ? void 0 : _a3.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func2 = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func2.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a3, _b;
        super.optimizeNodes();
        (_a3 = this.catch) === null || _a3 === void 0 ? void 0 : _a3.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a3, _b;
        super.optimizeNames(names, constants);
        (_a3 = this.catch) === null || _a3 === void 0 ? void 0 : _a3.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error48) {
        super();
        this.error = error48;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs2 = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs2.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error48 = this.name("e");
          this._currNode = node.catch = new Catch(error48);
          catchCode(error48);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error48) {
        return this._leafNode(new Throw(error48));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func2(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func2);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not2(x2) {
      return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_1._)`!${par(x2)}`;
    }
    exports.not = not2;
    var andCode = mappend(exports.operators.AND);
    function and2(...args) {
      return args.reduce(andCode);
    }
    exports.and = and2;
    var orCode = mappend(exports.operators.OR);
    function or2(...args) {
      return args.reduce(orCode);
    }
    exports.or = or2;
    function mappend(op) {
      return (x2, y) => x2 === code_1.nil ? y : y === code_1.nil ? x2 : (0, code_1._)`${par(x2)} ${op} ${par(y)}`;
    }
    function par(x2) {
      return x2 instanceof code_1.Name ? x2 : (0, code_1._)`(${x2})`;
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash2 = {};
      for (const item of arr)
        hash2[item] = true;
      return hash2;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it2, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it2, schema);
      return !schemaHasRules(schema, it2.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it2, schema = it2.schema) {
      const { opts, self: self2 } = it2;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it2, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x2 of xs)
          f(x2);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues2(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it2.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js
var require_errors3 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error48 = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error48, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error48 = exports.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error48, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E2 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error48, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error48, errorPaths);
    }
    function errorObject(cxt, error48, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error48, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E2.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it: it2 } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it2;
      keyValues.push([E2.keyword, keyword], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E2.propertyName, propertyName]);
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema, validateName } = it2;
      if (schema === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema } = it2;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x2) {
      return typeof x2 == "string" && jsonTypes.has(x2);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a3;
      return schema[rule.keyword] !== void 0 || ((_a3 = rule.definition.implements) === null || _a3 === void 0 ? void 0 : _a3.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts2) {
      const types = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it2, types) {
      const { gen, data, opts } = it2;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it2, types, coerceTo);
          else
            reportTypeError(it2);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it2, types, coerceTo) {
      const { gen, data, opts } = it2;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it2);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it2, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it2) {
      const cxt = getTypeErrorContext(it2);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it2) {
      const { gen, data, schema } = it2;
      const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it2
      };
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it2, ty) {
      const { properties, items } = it2.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it2, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it2, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it2, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p2]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it2.parentData],
        [names_1.default.parentDataProperty, it2.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors3();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
      const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a3;
      const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def);
      const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a4;
        gen.if((0, codegen_1.not)((_a4 = def.valid) !== null && _a4 !== void 0 ? _a4 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it2.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it2.dataLevel + 1;
        subschema.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it2.data;
        subschema.dataNames = [...it2.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a2[i], b2[i])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p2 = resolver.parse(id);
      return _getFullPath(resolver, p2);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors3();
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema, gen, opts } = it2;
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
      schemaKeywords(it2, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema, errSchemaPath, opts, self: self2 } = it2;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema, opts } = it2;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it2, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it2;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema, opts: { useDefaults } } = it2;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types) {
      if (!types.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it2.dataTypes, t)) {
          strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types);
    }
    function checkMultipleTypes(it2, ts2) {
      if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts2) {
      const rules = it2.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts2, t))) {
            strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts2, t) {
      return ts2.includes(t) || t === "integer" && ts2.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts2 = [];
      for (const t of it2.dataTypes) {
        if (includesType(withTypes, t))
          ts2.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts2.push("integer");
      }
      it2.dataTypes = ts2;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it2, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword;
        this.data = it2.data;
        this.schema = it2.schema[keyword];
        this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it: it2 } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it2, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env2) {
        var _a3;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env2.schema == "object")
          schema = env2.schema;
        this.schema = env2.schema;
        this.schemaId = env2.schemaId;
        this.root = env2.root || this;
        this.baseId = (_a3 = env2.baseId) !== null && _a3 !== void 0 ? _a3 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
        this.schemaPath = env2.schemaPath;
        this.localRefs = env2.localRefs;
        this.meta = env2.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef2(root, baseId, ref) {
      var _a3;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a3 = root.localRefs) === null || _a3 === void 0 ? void 0 : _a3[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef2;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema2.call(this, root, ref);
    }
    function resolveSchema2(root, ref) {
      const p2 = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema2.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    exports.resolveSchema = resolveSchema2;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a3;
      if (((_a3 = parsedRef.fragment) === null || _a3 === void 0 ? void 0 : _a3[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env2;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env2 = resolveSchema2.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env2 = env2 || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env2.schema !== env2.root.schema)
        return env2;
      return void 0;
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex3 = stringArrayToHexStripped(buffer);
        if (hex3 !== "") {
          address.push(hex3);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv63 = getIPV6(host);
      if (!ipv63.error) {
        let newHost = ipv63.address;
        let escapedHost = ipv63.address;
        if (ipv63.zone) {
          newHost += "%" + ipv63.zone;
          escapedHost += "%25" + ipv63.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path) {
      let input = path;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      const func = esc2 !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse3(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse3(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse3(serialize(base, options), options);
        relative = parse3(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o2, _p, _q, _r, _s2, _t3, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a3 = o.code) === null || _a3 === void 0 ? void 0 : _a3.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o2 = o.strictRequired) !== null && _o2 !== void 0 ? _o2 : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s2 = o.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t3 = o.messages) !== null && _t3 !== void 0 ? _t3 : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta3, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta3 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta3, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v2;
        if (typeof schemaKeyRef == "string") {
          v2 = this.getSchema(schemaKeyRef);
          if (!v2)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v2 = this.compile(schemaKeyRef);
        }
        const valid = v2(data);
        if (!("$async" in v2))
          this.errors = v2.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta3) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta3);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta3);
        }
        async function _loadSchema(ref) {
          const p2 = this._loading[ref];
          if (p2)
            return p2;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text2, msg) => text2 + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a3;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a3 = definition.implements) === null || _a3 === void 0 ? void 0 : _a3.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it2;
        const { root } = env2;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env2 === root)
            return callRef(cxt, validateName, env2, env2.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v2 = getValidate(cxt, sch);
          callRef(cxt, v2, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v2, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env2, opts } = it2;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env2.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v2, passCxt)}`);
          addEvaluatedFrom(v2);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a3;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a3 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a3 === void 0 ? void 0 : _a3.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error48 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error: error48,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error48 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error: error48,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error48 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error: error48,
      code(cxt) {
        const { keyword, data, schemaCode, it: it2 } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error48 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error: error48,
      code(cxt) {
        const { data, $data, schema, schemaCode, it: it2 } = cxt;
        const u = it2.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error48 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error: error48,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error48 = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error: error48,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error48 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error: error48,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error48 = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error: error48,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error48 = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error: error48,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error48 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error: error48,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error48 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error48,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it: it2 } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error48 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error48,
      code(cxt) {
        const { schema, parentSchema, it: it2 } = cxt;
        const { prefixItems } = parentSchema;
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error48 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error: error48,
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error48 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error48,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error48 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error: error48,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it2.definedProperties.add(prop);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
        }
        const properties = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schema[p2]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it2, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error48 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error: error48,
      code(cxt) {
        const { gen, schema, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error48 = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error: error48,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it2, keyword) {
      const schema = it2.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
    }
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error48 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error: error48,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error48 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error48,
      code(cxt) {
        const { gen, data, schema, parentSchema, it: it2 } = cxt;
        const { oneOf } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a3;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
            }
            const propSch = (_a3 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a3 === void 0 ? void 0 : _a3[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v2) => this.addVocabulary(v2));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv;
    module.exports = exports = Ajv;
    module.exports.Ajv = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date9, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date9(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time5(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time5 = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date9(dateTime[0]) && time5(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error48 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error: error48,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it: it2 } = cxt;
        const { opts, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a3;
      var _b;
      (_a3 = (_b = ajv.opts.code).formats) !== null && _a3 !== void 0 ? _a3 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/validator.js"(exports, module) {
    "use strict";
    var Ajv = require_ajv();
    var fastUri = require_fast_uri();
    var ajvFormats = require_dist2();
    var clone2 = require_rfdc()({ proto: true });
    var Validator = class _Validator {
      constructor(ajvOptions) {
        this.ajv = new Ajv({
          ...ajvOptions,
          strictSchema: false,
          validateSchema: false,
          allowUnionTypes: true,
          uriResolver: fastUri
        });
        ajvFormats(this.ajv);
        this.ajv.addKeyword({
          keyword: "fjs_type",
          type: "object",
          errors: false,
          validate: (_type, data) => {
            return data && typeof data.toJSON === "function";
          }
        });
        this._ajvSchemas = {};
        this._ajvOptions = ajvOptions || {};
      }
      addSchema(schema, schemaName) {
        let schemaKey = schema.$id || schemaName;
        if (schema.$id !== void 0 && schema.$id[0] === "#") {
          schemaKey = schemaName + schema.$id;
        }
        if (this.ajv.refs[schemaKey] === void 0 && this.ajv.schemas[schemaKey] === void 0) {
          const ajvSchema = clone2(schema);
          this.convertSchemaToAjvFormat(ajvSchema);
          this.ajv.addSchema(ajvSchema, schemaKey);
          this._ajvSchemas[schemaKey] = schema;
        }
      }
      validate(schemaRef, data) {
        return this.ajv.validate(schemaRef, data);
      }
      // Ajv does not natively support JavaScript objects like Date or other types
      // that rely on a custom .toJSON() representation. To properly validate schemas
      // that may contain such objects (e.g. Date, ObjectId, etc.), we replace all
      // occurrences of the string type with a custom keyword fjs_type
      // (see https://github.com/fastify/fast-json-stringify/pull/441)
      convertSchemaToAjvFormat(schema) {
        if (schema === null) return;
        if (schema.type === "string") {
          schema.fjs_type = "string";
          schema.type = ["string", "object"];
        } else if (Array.isArray(schema.type) && schema.type.includes("string") && !schema.type.includes("object")) {
          schema.fjs_type = "string";
          schema.type.push("object");
        }
        for (const property in schema) {
          if (typeof schema[property] === "object") {
            this.convertSchemaToAjvFormat(schema[property]);
          }
        }
      }
      getState() {
        return {
          ajvOptions: this._ajvOptions,
          ajvSchemas: this._ajvSchemas
        };
      }
      static restoreFromState(state) {
        const validator = new _Validator(state.ajvOptions);
        for (const [id, ajvSchema] of Object.entries(state.ajvSchemas)) {
          validator.ajv.addSchema(ajvSchema, id);
        }
        return validator;
      }
    };
    module.exports = Validator;
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/location.js
var require_location = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/location.js"(exports, module) {
    "use strict";
    var Location = class _Location {
      constructor(schema, schemaId, jsonPointer = "#") {
        this.schema = schema;
        this.schemaId = schemaId;
        this.jsonPointer = jsonPointer;
      }
      getPropertyLocation(propertyName) {
        const propertyLocation = new _Location(
          this.schema[propertyName],
          this.schemaId,
          this.jsonPointer + "/" + propertyName
        );
        return propertyLocation;
      }
      getSchemaRef() {
        return this.schemaId + this.jsonPointer;
      }
    };
    module.exports = Location;
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/schema-validator.js
var require_schema_validator = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/schema-validator.js"(exports, module) {
    "use strict";
    module.exports = validate10;
    module.exports.default = validate10;
    var schema11 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "http://json-schema.org/draft-07/schema#", "title": "Core schema meta-schema", "definitions": { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } }, "type": ["object", "boolean"], "properties": { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } }, "default": true };
    var schema20 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
    var formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var formats2 = require_formats().fullFormats.uri;
    var formats6 = require_formats().fullFormats.regex;
    function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      const _errs1 = errors;
      if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
        validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
        return false;
      }
      if (errors === _errs1) {
        if (typeof data == "number" && isFinite(data)) {
          if (data < 0 || isNaN(data)) {
            validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
            return false;
          }
        }
      }
      validate11.errors = vErrors;
      return errors === 0;
    }
    var root1 = { validate: validate10 };
    function validate13(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (errors === 0) {
        if (Array.isArray(data)) {
          if (data.length < 1) {
            validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
            return false;
          } else {
            var valid0 = true;
            const len0 = data.length;
            for (let i0 = 0; i0 < len0; i0++) {
              const _errs1 = errors;
              if (!root1.validate(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
                errors = vErrors.length;
              }
              var valid0 = _errs1 === errors;
              if (!valid0) {
                break;
              }
            }
          }
        } else {
          validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
          return false;
        }
      }
      validate13.errors = vErrors;
      return errors === 0;
    }
    var func0 = require_equal().default;
    function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      ;
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11.type }, message: "must be object,boolean" }];
        return false;
      }
      if (errors === 0) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.$id !== void 0) {
            let data0 = data.$id;
            const _errs1 = errors;
            if (errors === _errs1) {
              if (errors === _errs1) {
                if (typeof data0 === "string") {
                  if (!formats0.test(data0)) {
                    validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                    return false;
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.$schema !== void 0) {
              let data1 = data.$schema;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (errors === _errs3) {
                  if (typeof data1 === "string") {
                    if (!formats2(data1)) {
                      validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }];
                      return false;
                    }
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.$ref !== void 0) {
                let data2 = data.$ref;
                const _errs5 = errors;
                if (errors === _errs5) {
                  if (errors === _errs5) {
                    if (typeof data2 === "string") {
                      if (!formats0.test(data2)) {
                        validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                        return false;
                      }
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                  }
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.$comment !== void 0) {
                  const _errs7 = errors;
                  if (typeof data.$comment !== "string") {
                    validate10.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs7 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.title !== void 0) {
                    const _errs9 = errors;
                    if (typeof data.title !== "string") {
                      validate10.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs9 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.description !== void 0) {
                      const _errs11 = errors;
                      if (typeof data.description !== "string") {
                        validate10.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      var valid0 = _errs11 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.readOnly !== void 0) {
                        const _errs13 = errors;
                        if (typeof data.readOnly !== "boolean") {
                          validate10.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                          return false;
                        }
                        var valid0 = _errs13 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.examples !== void 0) {
                          const _errs15 = errors;
                          if (errors === _errs15) {
                            if (!Array.isArray(data.examples)) {
                              validate10.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                              return false;
                            }
                          }
                          var valid0 = _errs15 === errors;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.multipleOf !== void 0) {
                            let data8 = data.multipleOf;
                            const _errs17 = errors;
                            if (errors === _errs17) {
                              if (typeof data8 == "number" && isFinite(data8)) {
                                if (data8 <= 0 || isNaN(data8)) {
                                  validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                                  return false;
                                }
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                            }
                            var valid0 = _errs17 === errors;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.maximum !== void 0) {
                              let data9 = data.maximum;
                              const _errs19 = errors;
                              if (!(typeof data9 == "number" && isFinite(data9))) {
                                validate10.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs19 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.exclusiveMaximum !== void 0) {
                                let data10 = data.exclusiveMaximum;
                                const _errs21 = errors;
                                if (!(typeof data10 == "number" && isFinite(data10))) {
                                  validate10.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs21 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data.minimum !== void 0) {
                                  let data11 = data.minimum;
                                  const _errs23 = errors;
                                  if (!(typeof data11 == "number" && isFinite(data11))) {
                                    validate10.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                    return false;
                                  }
                                  var valid0 = _errs23 === errors;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data.exclusiveMinimum !== void 0) {
                                    let data12 = data.exclusiveMinimum;
                                    const _errs25 = errors;
                                    if (!(typeof data12 == "number" && isFinite(data12))) {
                                      validate10.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                      return false;
                                    }
                                    var valid0 = _errs25 === errors;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data.maxLength !== void 0) {
                                      let data13 = data.maxLength;
                                      const _errs27 = errors;
                                      const _errs28 = errors;
                                      if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                        validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                        return false;
                                      }
                                      if (errors === _errs28) {
                                        if (typeof data13 == "number" && isFinite(data13)) {
                                          if (data13 < 0 || isNaN(data13)) {
                                            validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                            return false;
                                          }
                                        }
                                      }
                                      var valid0 = _errs27 === errors;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data.minLength !== void 0) {
                                        const _errs30 = errors;
                                        if (!validate11(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
                                          vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                          errors = vErrors.length;
                                        }
                                        var valid0 = _errs30 === errors;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data.pattern !== void 0) {
                                          let data15 = data.pattern;
                                          const _errs31 = errors;
                                          if (errors === _errs31) {
                                            if (errors === _errs31) {
                                              if (typeof data15 === "string") {
                                                if (!formats6(data15)) {
                                                  validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }];
                                                  return false;
                                                }
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                          }
                                          var valid0 = _errs31 === errors;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data.additionalItems !== void 0) {
                                            const _errs33 = errors;
                                            if (!validate10(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                              errors = vErrors.length;
                                            }
                                            var valid0 = _errs33 === errors;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data.items !== void 0) {
                                              let data17 = data.items;
                                              const _errs34 = errors;
                                              const _errs35 = errors;
                                              let valid2 = false;
                                              const _errs36 = errors;
                                              if (!validate10(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                errors = vErrors.length;
                                              }
                                              var _valid0 = _errs36 === errors;
                                              valid2 = valid2 || _valid0;
                                              if (!valid2) {
                                                const _errs37 = errors;
                                                if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                                  vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                  errors = vErrors.length;
                                                }
                                                var _valid0 = _errs37 === errors;
                                                valid2 = valid2 || _valid0;
                                              }
                                              if (!valid2) {
                                                const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err0];
                                                } else {
                                                  vErrors.push(err0);
                                                }
                                                errors++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors = _errs35;
                                                if (vErrors !== null) {
                                                  if (_errs35) {
                                                    vErrors.length = _errs35;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs34 === errors;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data.maxItems !== void 0) {
                                                let data18 = data.maxItems;
                                                const _errs38 = errors;
                                                const _errs39 = errors;
                                                if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                                  validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                                if (errors === _errs39) {
                                                  if (typeof data18 == "number" && isFinite(data18)) {
                                                    if (data18 < 0 || isNaN(data18)) {
                                                      validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                      return false;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs38 === errors;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data.minItems !== void 0) {
                                                  const _errs41 = errors;
                                                  if (!validate11(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
                                                    vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                    errors = vErrors.length;
                                                  }
                                                  var valid0 = _errs41 === errors;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data.uniqueItems !== void 0) {
                                                    const _errs42 = errors;
                                                    if (typeof data.uniqueItems !== "boolean") {
                                                      validate10.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                      return false;
                                                    }
                                                    var valid0 = _errs42 === errors;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data.contains !== void 0) {
                                                      const _errs44 = errors;
                                                      if (!validate10(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                        errors = vErrors.length;
                                                      }
                                                      var valid0 = _errs44 === errors;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.maxProperties !== void 0) {
                                                        let data22 = data.maxProperties;
                                                        const _errs45 = errors;
                                                        const _errs46 = errors;
                                                        if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                          validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                          return false;
                                                        }
                                                        if (errors === _errs46) {
                                                          if (typeof data22 == "number" && isFinite(data22)) {
                                                            if (data22 < 0 || isNaN(data22)) {
                                                              validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                              return false;
                                                            }
                                                          }
                                                        }
                                                        var valid0 = _errs45 === errors;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.minProperties !== void 0) {
                                                          const _errs48 = errors;
                                                          if (!validate11(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
                                                            vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                            errors = vErrors.length;
                                                          }
                                                          var valid0 = _errs48 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.required !== void 0) {
                                                            let data24 = data.required;
                                                            const _errs49 = errors;
                                                            const _errs50 = errors;
                                                            if (errors === _errs50) {
                                                              if (Array.isArray(data24)) {
                                                                var valid6 = true;
                                                                const len0 = data24.length;
                                                                for (let i0 = 0; i0 < len0; i0++) {
                                                                  const _errs52 = errors;
                                                                  if (typeof data24[i0] !== "string") {
                                                                    validate10.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                    return false;
                                                                  }
                                                                  var valid6 = _errs52 === errors;
                                                                  if (!valid6) {
                                                                    break;
                                                                  }
                                                                }
                                                                if (valid6) {
                                                                  let i1 = data24.length;
                                                                  let j0;
                                                                  if (i1 > 1) {
                                                                    const indices0 = {};
                                                                    for (; i1--; ) {
                                                                      let item0 = data24[i1];
                                                                      if (typeof item0 !== "string") {
                                                                        continue;
                                                                      }
                                                                      if (typeof indices0[item0] == "number") {
                                                                        j0 = indices0[item0];
                                                                        validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                        return false;
                                                                        break;
                                                                      }
                                                                      indices0[item0] = i1;
                                                                    }
                                                                  }
                                                                }
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs49 === errors;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data.additionalProperties !== void 0) {
                                                              const _errs54 = errors;
                                                              if (!validate10(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
                                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                errors = vErrors.length;
                                                              }
                                                              var valid0 = _errs54 === errors;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data.definitions !== void 0) {
                                                                let data27 = data.definitions;
                                                                const _errs55 = errors;
                                                                if (errors === _errs55) {
                                                                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                    for (const key0 in data27) {
                                                                      const _errs58 = errors;
                                                                      if (!validate10(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors = vErrors.length;
                                                                      }
                                                                      var valid8 = _errs58 === errors;
                                                                      if (!valid8) {
                                                                        break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs55 === errors;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data.properties !== void 0) {
                                                                  let data29 = data.properties;
                                                                  const _errs59 = errors;
                                                                  if (errors === _errs59) {
                                                                    if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                      for (const key1 in data29) {
                                                                        const _errs62 = errors;
                                                                        if (!validate10(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid9 = _errs62 === errors;
                                                                        if (!valid9) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs59 === errors;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data.patternProperties !== void 0) {
                                                                    let data31 = data.patternProperties;
                                                                    const _errs63 = errors;
                                                                    if (errors === _errs63) {
                                                                      if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                        for (const key2 in data31) {
                                                                          const _errs65 = errors;
                                                                          if (errors === _errs65) {
                                                                            if (typeof key2 === "string") {
                                                                              if (!formats6(key2)) {
                                                                                const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: key2 };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err1];
                                                                                } else {
                                                                                  vErrors.push(err1);
                                                                                }
                                                                                errors++;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid10 = _errs65 === errors;
                                                                          if (!valid10) {
                                                                            const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err2];
                                                                            } else {
                                                                              vErrors.push(err2);
                                                                            }
                                                                            errors++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                            break;
                                                                          }
                                                                        }
                                                                        if (valid10) {
                                                                          for (const key3 in data31) {
                                                                            const _errs67 = errors;
                                                                            if (!validate10(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                              errors = vErrors.length;
                                                                            }
                                                                            var valid11 = _errs67 === errors;
                                                                            if (!valid11) {
                                                                              break;
                                                                            }
                                                                          }
                                                                        }
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    var valid0 = _errs63 === errors;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data.dependencies !== void 0) {
                                                                      let data33 = data.dependencies;
                                                                      const _errs68 = errors;
                                                                      if (errors === _errs68) {
                                                                        if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                          for (const key4 in data33) {
                                                                            let data34 = data33[key4];
                                                                            const _errs71 = errors;
                                                                            const _errs72 = errors;
                                                                            let valid13 = false;
                                                                            const _errs73 = errors;
                                                                            if (!validate10(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                              errors = vErrors.length;
                                                                            }
                                                                            var _valid1 = _errs73 === errors;
                                                                            valid13 = valid13 || _valid1;
                                                                            if (!valid13) {
                                                                              const _errs74 = errors;
                                                                              const _errs75 = errors;
                                                                              if (errors === _errs75) {
                                                                                if (Array.isArray(data34)) {
                                                                                  var valid15 = true;
                                                                                  const len1 = data34.length;
                                                                                  for (let i2 = 0; i2 < len1; i2++) {
                                                                                    const _errs77 = errors;
                                                                                    if (typeof data34[i2] !== "string") {
                                                                                      const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err3];
                                                                                      } else {
                                                                                        vErrors.push(err3);
                                                                                      }
                                                                                      errors++;
                                                                                    }
                                                                                    var valid15 = _errs77 === errors;
                                                                                    if (!valid15) {
                                                                                      break;
                                                                                    }
                                                                                  }
                                                                                  if (valid15) {
                                                                                    let i3 = data34.length;
                                                                                    let j1;
                                                                                    if (i3 > 1) {
                                                                                      const indices1 = {};
                                                                                      for (; i3--; ) {
                                                                                        let item1 = data34[i3];
                                                                                        if (typeof item1 !== "string") {
                                                                                          continue;
                                                                                        }
                                                                                        if (typeof indices1[item1] == "number") {
                                                                                          j1 = indices1[item1];
                                                                                          const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                          if (vErrors === null) {
                                                                                            vErrors = [err4];
                                                                                          } else {
                                                                                            vErrors.push(err4);
                                                                                          }
                                                                                          errors++;
                                                                                          break;
                                                                                        }
                                                                                        indices1[item1] = i3;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err5];
                                                                                  } else {
                                                                                    vErrors.push(err5);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                              }
                                                                              var _valid1 = _errs74 === errors;
                                                                              valid13 = valid13 || _valid1;
                                                                            }
                                                                            if (!valid13) {
                                                                              const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err6];
                                                                              } else {
                                                                                vErrors.push(err6);
                                                                              }
                                                                              errors++;
                                                                              validate10.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = _errs72;
                                                                              if (vErrors !== null) {
                                                                                if (_errs72) {
                                                                                  vErrors.length = _errs72;
                                                                                } else {
                                                                                  vErrors = null;
                                                                                }
                                                                              }
                                                                            }
                                                                            var valid12 = _errs71 === errors;
                                                                            if (!valid12) {
                                                                              break;
                                                                            }
                                                                          }
                                                                        } else {
                                                                          validate10.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      var valid0 = _errs68 === errors;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data.propertyNames !== void 0) {
                                                                        const _errs79 = errors;
                                                                        if (!validate10(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid0 = _errs79 === errors;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data.enum !== void 0) {
                                                                          let data37 = data.enum;
                                                                          const _errs80 = errors;
                                                                          if (errors === _errs80) {
                                                                            if (Array.isArray(data37)) {
                                                                              if (data37.length < 1) {
                                                                                validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                                return false;
                                                                              } else {
                                                                                let i4 = data37.length;
                                                                                let j2;
                                                                                if (i4 > 1) {
                                                                                  outer0:
                                                                                    for (; i4--; ) {
                                                                                      for (j2 = i4; j2--; ) {
                                                                                        if (func0(data37[i4], data37[j2])) {
                                                                                          validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                          return false;
                                                                                          break outer0;
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          var valid0 = _errs80 === errors;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data.type !== void 0) {
                                                                            let data38 = data.type;
                                                                            const _errs82 = errors;
                                                                            const _errs83 = errors;
                                                                            let valid18 = false;
                                                                            const _errs84 = errors;
                                                                            if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                              const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err7];
                                                                              } else {
                                                                                vErrors.push(err7);
                                                                              }
                                                                              errors++;
                                                                            }
                                                                            var _valid2 = _errs84 === errors;
                                                                            valid18 = valid18 || _valid2;
                                                                            if (!valid18) {
                                                                              const _errs86 = errors;
                                                                              if (errors === _errs86) {
                                                                                if (Array.isArray(data38)) {
                                                                                  if (data38.length < 1) {
                                                                                    const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err8];
                                                                                    } else {
                                                                                      vErrors.push(err8);
                                                                                    }
                                                                                    errors++;
                                                                                  } else {
                                                                                    var valid20 = true;
                                                                                    const len2 = data38.length;
                                                                                    for (let i5 = 0; i5 < len2; i5++) {
                                                                                      let data39 = data38[i5];
                                                                                      const _errs88 = errors;
                                                                                      if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                        const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                        if (vErrors === null) {
                                                                                          vErrors = [err9];
                                                                                        } else {
                                                                                          vErrors.push(err9);
                                                                                        }
                                                                                        errors++;
                                                                                      }
                                                                                      var valid20 = _errs88 === errors;
                                                                                      if (!valid20) {
                                                                                        break;
                                                                                      }
                                                                                    }
                                                                                    if (valid20) {
                                                                                      let i6 = data38.length;
                                                                                      let j3;
                                                                                      if (i6 > 1) {
                                                                                        outer1:
                                                                                          for (; i6--; ) {
                                                                                            for (j3 = i6; j3--; ) {
                                                                                              if (func0(data38[i6], data38[j3])) {
                                                                                                const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                                if (vErrors === null) {
                                                                                                  vErrors = [err10];
                                                                                                } else {
                                                                                                  vErrors.push(err10);
                                                                                                }
                                                                                                errors++;
                                                                                                break outer1;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err11];
                                                                                  } else {
                                                                                    vErrors.push(err11);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                              }
                                                                              var _valid2 = _errs86 === errors;
                                                                              valid18 = valid18 || _valid2;
                                                                            }
                                                                            if (!valid18) {
                                                                              const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err12];
                                                                              } else {
                                                                                vErrors.push(err12);
                                                                              }
                                                                              errors++;
                                                                              validate10.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = _errs83;
                                                                              if (vErrors !== null) {
                                                                                if (_errs83) {
                                                                                  vErrors.length = _errs83;
                                                                                } else {
                                                                                  vErrors = null;
                                                                                }
                                                                              }
                                                                            }
                                                                            var valid0 = _errs82 === errors;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data.format !== void 0) {
                                                                              const _errs90 = errors;
                                                                              if (typeof data.format !== "string") {
                                                                                validate10.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs90 === errors;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data.contentMediaType !== void 0) {
                                                                                const _errs92 = errors;
                                                                                if (typeof data.contentMediaType !== "string") {
                                                                                  validate10.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                  return false;
                                                                                }
                                                                                var valid0 = _errs92 === errors;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data.contentEncoding !== void 0) {
                                                                                  const _errs94 = errors;
                                                                                  if (typeof data.contentEncoding !== "string") {
                                                                                    validate10.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                    return false;
                                                                                  }
                                                                                  var valid0 = _errs94 === errors;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data.if !== void 0) {
                                                                                    const _errs96 = errors;
                                                                                    if (!validate10(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                      errors = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs96 === errors;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data.then !== void 0) {
                                                                                      const _errs97 = errors;
                                                                                      if (!validate10(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
                                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                        errors = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs97 === errors;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data.else !== void 0) {
                                                                                        const _errs98 = errors;
                                                                                        if (!validate10(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
                                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                          errors = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs98 === errors;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data.allOf !== void 0) {
                                                                                          const _errs99 = errors;
                                                                                          if (!validate13(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs99 === errors;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data.anyOf !== void 0) {
                                                                                            const _errs100 = errors;
                                                                                            if (!validate13(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
                                                                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                              errors = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs100 === errors;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                          if (valid0) {
                                                                                            if (data.oneOf !== void 0) {
                                                                                              const _errs101 = errors;
                                                                                              if (!validate13(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
                                                                                                vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                                errors = vErrors.length;
                                                                                              }
                                                                                              var valid0 = _errs101 === errors;
                                                                                            } else {
                                                                                              var valid0 = true;
                                                                                            }
                                                                                            if (valid0) {
                                                                                              if (data.not !== void 0) {
                                                                                                const _errs102 = errors;
                                                                                                if (!validate10(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
                                                                                                  vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                                  errors = vErrors.length;
                                                                                                }
                                                                                                var valid0 = _errs102 === errors;
                                                                                              } else {
                                                                                                var valid0 = true;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/.pnpm/@fastify+merge-json-schemas@0.2.1/node_modules/@fastify/merge-json-schemas/lib/errors.js
var require_errors4 = __commonJS({
  "node_modules/.pnpm/@fastify+merge-json-schemas@0.2.1/node_modules/@fastify/merge-json-schemas/lib/errors.js"(exports, module) {
    "use strict";
    var MergeError = class extends Error {
      constructor(keyword, schemas) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Failed to merge "${keyword}" keyword schemas.`;
        this.schemas = schemas;
      }
    };
    var ResolverNotFoundError = class extends Error {
      constructor(keyword, schemas) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Resolver for "${keyword}" keyword not found.`;
        this.schemas = schemas;
      }
    };
    var InvalidOnConflictOptionError = class extends Error {
      constructor(onConflict) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Invalid "onConflict" option: "${onConflict}".`;
      }
    };
    module.exports = {
      MergeError,
      ResolverNotFoundError,
      InvalidOnConflictOptionError
    };
  }
});

// node_modules/.pnpm/@fastify+merge-json-schemas@0.2.1/node_modules/@fastify/merge-json-schemas/lib/resolvers.js
var require_resolvers = __commonJS({
  "node_modules/.pnpm/@fastify+merge-json-schemas@0.2.1/node_modules/@fastify/merge-json-schemas/lib/resolvers.js"(exports, module) {
    "use strict";
    var { dequal: deepEqual } = require_dist();
    var { MergeError } = require_errors4();
    function _arraysIntersection(arrays) {
      let intersection3 = arrays[0];
      for (let i = 1; i < arrays.length; i++) {
        intersection3 = intersection3.filter(
          (value) => arrays[i].includes(value)
        );
      }
      return intersection3;
    }
    function arraysIntersection(keyword, values, mergedSchema) {
      const intersection3 = _arraysIntersection(values);
      if (intersection3.length === 0) {
        throw new MergeError(keyword, values);
      }
      mergedSchema[keyword] = intersection3;
    }
    function hybridArraysIntersection(keyword, values, mergedSchema) {
      for (let i = 0; i < values.length; i++) {
        if (!Array.isArray(values[i])) {
          values[i] = [values[i]];
        }
      }
      const intersection3 = _arraysIntersection(values);
      if (intersection3.length === 0) {
        throw new MergeError(keyword, values);
      }
      if (intersection3.length === 1) {
        mergedSchema[keyword] = intersection3[0];
      } else {
        mergedSchema[keyword] = intersection3;
      }
    }
    function arraysUnion(keyword, values, mergedSchema) {
      const union4 = [];
      for (const array3 of values) {
        for (const value of array3) {
          if (!union4.includes(value)) {
            union4.push(value);
          }
        }
      }
      mergedSchema[keyword] = union4;
    }
    function minNumber(keyword, values, mergedSchema) {
      mergedSchema[keyword] = Math.min(...values);
    }
    function maxNumber(keyword, values, mergedSchema) {
      mergedSchema[keyword] = Math.max(...values);
    }
    function commonMultiple(keyword, values, mergedSchema) {
      const gcd = (a2, b2) => !b2 ? a2 : gcd(b2, a2 % b2);
      const lcm = (a2, b2) => a2 * b2 / gcd(a2, b2);
      let scale = 1;
      for (const value of values) {
        while (value * scale % 1 !== 0) {
          scale *= 10;
        }
      }
      let multiple = values[0] * scale;
      for (const value of values) {
        multiple = lcm(multiple, value * scale);
      }
      mergedSchema[keyword] = multiple / scale;
    }
    function allEqual(keyword, values, mergedSchema) {
      const firstValue = values[0];
      for (let i = 1; i < values.length; i++) {
        if (!deepEqual(values[i], firstValue)) {
          throw new MergeError(keyword, values);
        }
      }
      mergedSchema[keyword] = firstValue;
    }
    function skip() {
    }
    function booleanAnd(keyword, values, mergedSchema) {
      for (const value of values) {
        if (value === false) {
          mergedSchema[keyword] = false;
          return;
        }
      }
      mergedSchema[keyword] = true;
    }
    function booleanOr(keyword, values, mergedSchema) {
      for (const value of values) {
        if (value === true) {
          mergedSchema[keyword] = true;
          return;
        }
      }
      mergedSchema[keyword] = false;
    }
    module.exports = {
      arraysIntersection,
      hybridArraysIntersection,
      arraysUnion,
      minNumber,
      maxNumber,
      commonMultiple,
      allEqual,
      booleanAnd,
      booleanOr,
      skip
    };
  }
});

// node_modules/.pnpm/@fastify+merge-json-schemas@0.2.1/node_modules/@fastify/merge-json-schemas/index.js
var require_merge_json_schemas = __commonJS({
  "node_modules/.pnpm/@fastify+merge-json-schemas@0.2.1/node_modules/@fastify/merge-json-schemas/index.js"(exports, module) {
    "use strict";
    var { dequal: deepEqual } = require_dist();
    var resolvers = require_resolvers();
    var errors = require_errors4();
    var keywordsResolvers = {
      $id: resolvers.skip,
      type: resolvers.hybridArraysIntersection,
      enum: resolvers.arraysIntersection,
      minLength: resolvers.maxNumber,
      maxLength: resolvers.minNumber,
      minimum: resolvers.maxNumber,
      maximum: resolvers.minNumber,
      multipleOf: resolvers.commonMultiple,
      exclusiveMinimum: resolvers.maxNumber,
      exclusiveMaximum: resolvers.minNumber,
      minItems: resolvers.maxNumber,
      maxItems: resolvers.minNumber,
      maxProperties: resolvers.minNumber,
      minProperties: resolvers.maxNumber,
      const: resolvers.allEqual,
      default: resolvers.allEqual,
      format: resolvers.allEqual,
      required: resolvers.arraysUnion,
      properties: mergeProperties,
      patternProperties: mergeObjects,
      additionalProperties: mergeSchemasResolver,
      items: mergeItems,
      additionalItems: mergeAdditionalItems,
      definitions: mergeObjects,
      $defs: mergeObjects,
      nullable: resolvers.booleanAnd,
      oneOf: mergeOneOf,
      anyOf: mergeOneOf,
      allOf: resolvers.arraysUnion,
      not: mergeSchemasResolver,
      if: mergeIfThenElseSchemas,
      then: resolvers.skip,
      else: resolvers.skip,
      dependencies: mergeDependencies,
      dependentRequired: mergeDependencies,
      dependentSchemas: mergeObjects,
      propertyNames: mergeSchemasResolver,
      uniqueItems: resolvers.booleanOr,
      contains: mergeSchemasResolver
    };
    function mergeSchemasResolver(keyword, values, mergedSchema, _schemas, options) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
    }
    function cartesianProduct(arrays) {
      let result = [[]];
      for (const array3 of arrays) {
        const temp = [];
        for (const x2 of result) {
          for (const y of array3) {
            temp.push([...x2, y]);
          }
        }
        result = temp;
      }
      return result;
    }
    function mergeOneOf(keyword, values, mergedSchema, _schemas, options) {
      if (values.length === 1) {
        mergedSchema[keyword] = values[0];
        return;
      }
      const product2 = cartesianProduct(values);
      const mergedOneOf = [];
      for (const combination of product2) {
        try {
          const mergedSchema2 = _mergeSchemas(combination, options);
          if (mergedSchema2 !== void 0) {
            mergedOneOf.push(mergedSchema2);
          }
        } catch (error48) {
          if (error48 instanceof errors.MergeError) continue;
          throw error48;
        }
      }
      mergedSchema[keyword] = mergedOneOf;
    }
    function getSchemaForItem(schema, index2) {
      const { items, additionalItems } = schema;
      if (Array.isArray(items)) {
        if (index2 < items.length) {
          return items[index2];
        }
        return additionalItems;
      }
      if (items !== void 0) {
        return items;
      }
      return additionalItems;
    }
    function mergeItems(keyword, values, mergedSchema, schemas, options) {
      let maxArrayItemsLength = 0;
      for (const itemsSchema of values) {
        if (Array.isArray(itemsSchema)) {
          maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
        }
      }
      if (maxArrayItemsLength === 0) {
        mergedSchema[keyword] = _mergeSchemas(values, options);
        return;
      }
      const mergedItemsSchemas = [];
      for (let i = 0; i < maxArrayItemsLength; i++) {
        const indexItemSchemas = [];
        for (const schema of schemas) {
          const itemSchema = getSchemaForItem(schema, i);
          if (itemSchema !== void 0) {
            indexItemSchemas.push(itemSchema);
          }
        }
        mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
      }
      mergedSchema[keyword] = mergedItemsSchemas;
    }
    function mergeAdditionalItems(keyword, values, mergedSchema, schemas, options) {
      let hasArrayItems = false;
      for (const schema of schemas) {
        if (Array.isArray(schema.items)) {
          hasArrayItems = true;
          break;
        }
      }
      if (!hasArrayItems) {
        mergedSchema[keyword] = _mergeSchemas(values, options);
        return;
      }
      const mergedAdditionalItemsSchemas = [];
      for (const schema of schemas) {
        let additionalItemsSchema = schema.additionalItems;
        if (additionalItemsSchema === void 0 && !Array.isArray(schema.items)) {
          additionalItemsSchema = schema.items;
        }
        if (additionalItemsSchema !== void 0) {
          mergedAdditionalItemsSchemas.push(additionalItemsSchema);
        }
      }
      mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
    }
    function getSchemaForProperty(schema, propertyName) {
      const { properties, patternProperties, additionalProperties } = schema;
      if (properties?.[propertyName] !== void 0) {
        return properties[propertyName];
      }
      for (const pattern of Object.keys(patternProperties ?? {})) {
        const regexp = new RegExp(pattern);
        if (regexp.test(propertyName)) {
          return patternProperties[pattern];
        }
      }
      return additionalProperties;
    }
    function mergeProperties(keyword, _values, mergedSchema, schemas, options) {
      const foundProperties = {};
      for (const currentSchema of schemas) {
        const properties = currentSchema.properties ?? {};
        for (const propertyName of Object.keys(properties)) {
          if (foundProperties[propertyName] !== void 0) continue;
          const propertySchema = properties[propertyName];
          foundProperties[propertyName] = [propertySchema];
          for (const anotherSchema of schemas) {
            if (currentSchema === anotherSchema) continue;
            const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
            if (propertySchema2 !== void 0) {
              foundProperties[propertyName].push(propertySchema2);
            }
          }
        }
      }
      const mergedProperties = {};
      for (const property of Object.keys(foundProperties)) {
        const propertySchemas = foundProperties[property];
        mergedProperties[property] = _mergeSchemas(propertySchemas, options);
      }
      mergedSchema[keyword] = mergedProperties;
    }
    function mergeObjects(keyword, values, mergedSchema, _schemas, options) {
      const objectsProperties = {};
      for (const properties of values) {
        for (const propertyName of Object.keys(properties)) {
          if (objectsProperties[propertyName] === void 0) {
            objectsProperties[propertyName] = [];
          }
          objectsProperties[propertyName].push(properties[propertyName]);
        }
      }
      const mergedProperties = {};
      for (const propertyName of Object.keys(objectsProperties)) {
        const propertySchemas = objectsProperties[propertyName];
        const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
        mergedProperties[propertyName] = mergedPropertySchema;
      }
      mergedSchema[keyword] = mergedProperties;
    }
    function mergeIfThenElseSchemas(_keyword, _values, mergedSchema, schemas, options) {
      for (let i = 0; i < schemas.length; i++) {
        const subSchema = {
          if: schemas[i].if,
          then: schemas[i].then,
          else: schemas[i].else
        };
        if (subSchema.if === void 0) continue;
        if (mergedSchema.if === void 0) {
          mergedSchema.if = subSchema.if;
          if (subSchema.then !== void 0) {
            mergedSchema.then = subSchema.then;
          }
          if (subSchema.else !== void 0) {
            mergedSchema.else = subSchema.else;
          }
          continue;
        }
        if (mergedSchema.then !== void 0) {
          mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
        }
        if (mergedSchema.else !== void 0) {
          mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
        }
      }
    }
    function mergeDependencies(keyword, values, mergedSchema) {
      const mergedDependencies = {};
      for (const dependencies of values) {
        for (const propertyName of Object.keys(dependencies)) {
          if (mergedDependencies[propertyName] === void 0) {
            mergedDependencies[propertyName] = [];
          }
          const mergedPropertyDependencies = mergedDependencies[propertyName];
          for (const propertyDependency of dependencies[propertyName]) {
            if (!mergedPropertyDependencies.includes(propertyDependency)) {
              mergedPropertyDependencies.push(propertyDependency);
            }
          }
        }
      }
      mergedSchema[keyword] = mergedDependencies;
    }
    function _mergeSchemas(schemas, options) {
      if (schemas.length === 0) return {};
      if (schemas.length === 1) return schemas[0];
      const mergedSchema = {};
      const keywords = {};
      let allSchemasAreTrue = true;
      for (const schema of schemas) {
        if (schema === false) return false;
        if (schema === true) continue;
        allSchemasAreTrue = false;
        for (const keyword of Object.keys(schema)) {
          if (keywords[keyword] === void 0) {
            keywords[keyword] = [];
          }
          keywords[keyword].push(schema[keyword]);
        }
      }
      if (allSchemasAreTrue) return true;
      for (const keyword of Object.keys(keywords)) {
        const keywordValues = keywords[keyword];
        const resolver = options.resolvers[keyword] ?? options.defaultResolver;
        resolver(keyword, keywordValues, mergedSchema, schemas, options);
      }
      return mergedSchema;
    }
    function defaultResolver(keyword, values, mergedSchema, _schemas, options) {
      const onConflict = options.onConflict ?? "throw";
      if (values.length === 1 || onConflict === "first") {
        mergedSchema[keyword] = values[0];
        return;
      }
      let allValuesEqual = true;
      for (let i = 1; i < values.length; i++) {
        if (!deepEqual(values[i], values[0])) {
          allValuesEqual = false;
          break;
        }
      }
      if (allValuesEqual) {
        mergedSchema[keyword] = values[0];
        return;
      }
      if (onConflict === "throw") {
        throw new errors.ResolverNotFoundError(keyword, values);
      }
      if (onConflict === "skip") {
        return;
      }
      throw new errors.InvalidOnConflictOptionError(onConflict);
    }
    function mergeSchemas(schemas, options = {}) {
      if (options.defaultResolver === void 0) {
        options.defaultResolver = defaultResolver;
      }
      options.resolvers = { ...keywordsResolvers, ...options.resolvers };
      const mergedSchema = _mergeSchemas(schemas, options);
      return mergedSchema;
    }
    module.exports = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors };
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/merge-schemas.js
var require_merge_schemas = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/merge-schemas.js"(exports, module) {
    "use strict";
    var { mergeSchemas: _mergeSchemas } = require_merge_json_schemas();
    function mergeSchemas(schemas) {
      return _mergeSchemas(schemas, { onConflict: "skip" });
    }
    module.exports = mergeSchemas;
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/standalone.js
var require_standalone = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/lib/standalone.js"(exports, module) {
    "use strict";
    function buildStandaloneCode(contextFunc, context, serializer, validator) {
      let ajvDependencyCode = "";
      if (context.validatorSchemasIds.size > 0) {
        ajvDependencyCode += "const Validator = require('fast-json-stringify/lib/validator')\n";
        ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}
`;
        ajvDependencyCode += "const validator = Validator.restoreFromState(validatorState)\n";
      } else {
        ajvDependencyCode += "const validator = null\n";
      }
      const { schema, ...serializerState } = serializer.getState();
      return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
    }
    module.exports = buildStandaloneCode;
    module.exports.dependencies = {
      Serializer: require_serializer(),
      Validator: require_validator()
    };
  }
});

// node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/index.js
var require_fast_json_stringify = __commonJS({
  "node_modules/.pnpm/fast-json-stringify@6.2.0/node_modules/fast-json-stringify/index.js"(exports, module) {
    "use strict";
    var { RefResolver } = require_json_schema_ref_resolver();
    var Serializer = require_serializer();
    var Validator = require_validator();
    var Location = require_location();
    var validate = require_schema_validator();
    var mergeSchemas = require_merge_schemas();
    var SINGLE_TICK = /'/g;
    var largeArraySize = 2e4;
    var largeArrayMechanism = "default";
    var serializerFns = `
const {
  asString,
  asNumber,
  asBoolean,
  asDateTime,
  asDate,
  asTime,
  asUnsafeString
} = serializer

const asInteger = serializer.asInteger.bind(serializer)

`;
    var validRoundingMethods = /* @__PURE__ */ new Set([
      "floor",
      "ceil",
      "round",
      "trunc"
    ]);
    var validLargeArrayMechanisms = /* @__PURE__ */ new Set([
      "default",
      "json-stringify"
    ]);
    var schemaIdCounter = 0;
    function isValidSchema(schema, name) {
      if (!validate(schema)) {
        if (name) {
          name = `"${name}" `;
        } else {
          name = "";
        }
        const first = validate.errors[0];
        const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
        err.errors = isValidSchema.errors;
        throw err;
      }
    }
    function resolveRef2(context, location) {
      const ref = location.schema.$ref;
      let hashIndex = ref.indexOf("#");
      if (hashIndex === -1) {
        hashIndex = ref.length;
      }
      const schemaId = ref.slice(0, hashIndex) || location.schemaId;
      const jsonPointer = ref.slice(hashIndex) || "#";
      const schema = context.refResolver.getSchema(schemaId, jsonPointer);
      if (schema === null) {
        throw new Error(`Cannot find reference "${ref}"`);
      }
      const newLocation = new Location(schema, schemaId, jsonPointer);
      if (schema.$ref !== void 0) {
        return resolveRef2(context, newLocation);
      }
      return newLocation;
    }
    function getMergedLocation(context, mergedSchemaId) {
      const mergedSchema = context.refResolver.getSchema(mergedSchemaId, "#");
      return new Location(mergedSchema, mergedSchemaId, "#");
    }
    function getSchemaId2(schema, rootSchemaId) {
      if (schema.$id && schema.$id.charAt(0) !== "#") {
        return schema.$id;
      }
      return rootSchemaId;
    }
    function getSafeSchemaRef(context, location) {
      let schemaRef = location.getSchemaRef() || "";
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "") || "#";
      }
      return schemaRef;
    }
    function build(schema, options) {
      isValidSchema(schema);
      options = options || {};
      const context = {
        functions: [],
        functionsCounter: 0,
        functionsNamesBySchema: /* @__PURE__ */ new Map(),
        options,
        refResolver: new RefResolver(),
        rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
        validatorSchemasIds: /* @__PURE__ */ new Set(),
        mergedSchemasIds: /* @__PURE__ */ new Map(),
        recursiveSchemas: /* @__PURE__ */ new Set(),
        recursivePaths: /* @__PURE__ */ new Set(),
        buildingSet: /* @__PURE__ */ new Set(),
        uid: 0
      };
      const schemaId = getSchemaId2(schema, context.rootSchemaId);
      if (!context.refResolver.hasSchema(schemaId)) {
        context.refResolver.addSchema(schema, context.rootSchemaId);
      }
      if (options.schema) {
        for (const key in options.schema) {
          const schema2 = options.schema[key];
          const schemaId2 = getSchemaId2(schema2, key);
          if (!context.refResolver.hasSchema(schemaId2)) {
            isValidSchema(schema2, key);
            context.refResolver.addSchema(schema2, key);
          }
        }
      }
      if (options.rounding) {
        if (!validRoundingMethods.has(options.rounding)) {
          throw new Error(`Unsupported integer rounding method ${options.rounding}`);
        }
      }
      if (options.largeArrayMechanism) {
        if (validLargeArrayMechanisms.has(options.largeArrayMechanism)) {
          largeArrayMechanism = options.largeArrayMechanism;
        } else {
          throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
        }
      }
      if (options.largeArraySize) {
        const largeArraySizeType = typeof options.largeArraySize;
        let parsedNumber;
        if (largeArraySizeType === "string" && Number.isFinite(parsedNumber = Number.parseInt(options.largeArraySize, 10))) {
          largeArraySize = parsedNumber;
        } else if (largeArraySizeType === "number" && Number.isInteger(options.largeArraySize)) {
          largeArraySize = options.largeArraySize;
        } else if (largeArraySizeType === "bigint") {
          largeArraySize = Number(options.largeArraySize);
        } else {
          throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
        }
      }
      const location = new Location(schema, context.rootSchemaId);
      detectRecursiveSchemas(context, location);
      const code = buildValue(context, location, "input");
      let contextFunctionCode = `
    ${serializerFns}
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
      if (code === "json += anonymous0(input)") {
        contextFunctionCode += `
    ${context.functions.join("\n")}
    const main = anonymous0
    return main
    `;
      } else {
        contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join("\n")}
    return main
    `;
      }
      const serializer = new Serializer(options);
      const validator = new Validator(options.ajv);
      for (const schemaId2 of context.validatorSchemasIds) {
        const schema2 = context.refResolver.getSchema(schemaId2);
        validator.addSchema(schema2, schemaId2);
        const dependencies = context.refResolver.getSchemaDependencies(schemaId2);
        for (const [schemaId3, schema3] of Object.entries(dependencies)) {
          validator.addSchema(schema3, schemaId3);
        }
      }
      if (options.debugMode) {
        options.mode = "debug";
      }
      if (options.mode === "debug") {
        return {
          validator,
          serializer,
          code: `validator
serializer
${contextFunctionCode}`,
          ajv: validator.ajv
        };
      }
      const contextFunc = new Function("validator", "serializer", contextFunctionCode);
      if (options.mode === "standalone") {
        const buildStandaloneCode = require_standalone();
        return buildStandaloneCode(contextFunc, context, serializer, validator);
      }
      return contextFunc(validator, serializer);
    }
    var objectKeywords = [
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "maxProperties",
      "minProperties",
      "dependencies"
    ];
    var arrayKeywords = [
      "items",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "contains"
    ];
    var stringKeywords = [
      "maxLength",
      "minLength",
      "pattern"
    ];
    var numberKeywords = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum"
    ];
    function inferTypeByKeyword(schema) {
      for (const keyword of objectKeywords) {
        if (keyword in schema) return "object";
      }
      for (const keyword of arrayKeywords) {
        if (keyword in schema) return "array";
      }
      for (const keyword of stringKeywords) {
        if (keyword in schema) return "string";
      }
      for (const keyword of numberKeywords) {
        if (keyword in schema) return "number";
      }
      return schema.type;
    }
    function buildExtraObjectPropertiesSerializer(context, location, addComma, objVar) {
      const schema = location.schema;
      const propertiesKeys = Object.keys(schema.properties || {});
      let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(${objVar})) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
      const patternPropertiesLocation = location.getPropertyLocation("patternProperties");
      const patternPropertiesSchema = patternPropertiesLocation.schema;
      if (patternPropertiesSchema !== void 0) {
        for (const propertyKey in patternPropertiesSchema) {
          const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
          code += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma}
          json += asString(key) + JSON_STR_COLONS
          ${buildValue(context, propertyLocation, "value")}
          continue
        }
      `;
        }
      }
      const additionalPropertiesLocation = location.getPropertyLocation("additionalProperties");
      const additionalPropertiesSchema = additionalPropertiesLocation.schema;
      if (additionalPropertiesSchema !== void 0) {
        if (additionalPropertiesSchema === true) {
          code += `
        ${addComma}
        json += asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
        } else {
          const propertyLocation = location.getPropertyLocation("additionalProperties");
          code += `
        ${addComma}
        json += asString(key) + JSON_STR_COLONS
        ${buildValue(context, propertyLocation, "value")}
      `;
        }
      }
      code += `
    }
  `;
      return code;
    }
    function buildInnerObject(context, location, objVar) {
      const schema = location.schema;
      const propertiesLocation = location.getPropertyLocation("properties");
      const requiredProperties = schema.required || [];
      const propertiesKeys = Object.keys(schema.properties || {}).sort(
        (key1, key2) => {
          const required1 = requiredProperties.includes(key1);
          const required2 = requiredProperties.includes(key2);
          return required1 === required2 ? 0 : required1 ? -1 : 1;
        }
      );
      let code = "";
      for (const key of requiredProperties) {
        if (!propertiesKeys.includes(key)) {
          const sanitizedKey = JSON.stringify(key);
          code += `if (${objVar}[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
`;
        }
      }
      code += "json += JSON_STR_BEGIN_OBJECT\n";
      const localUid = context.uid++;
      let addComma = "";
      const needsRuntimeComma = propertiesKeys.length > 1 || schema.patternProperties || schema.additionalProperties !== void 0 && schema.additionalProperties !== false;
      if (needsRuntimeComma) {
        code += `let addComma_${localUid} = false
`;
        addComma = `!addComma_${localUid} && (addComma_${localUid} = true) || (json += JSON_STR_COMMA)`;
      }
      for (const key of propertiesKeys) {
        let propertyLocation = propertiesLocation.getPropertyLocation(key);
        if (propertyLocation.schema.$ref) {
          propertyLocation = resolveRef2(context, propertyLocation);
        }
        const sanitizedKey = JSON.stringify(key);
        const value = `value_${key.replace(/[^a-zA-Z0-9]/g, "_")}_${context.uid++}`;
        const defaultValue = propertyLocation.schema.default;
        const isRequired = requiredProperties.includes(key);
        code += `
      const ${value} = ${objVar}[${sanitizedKey}]
      if (${value} !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context, propertyLocation, `${value}`)}
      }`;
        if (defaultValue !== void 0) {
          code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
        } else if (isRequired) {
          code += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
      }
      `;
        } else {
          code += "\n";
        }
      }
      if (schema.patternProperties || schema.additionalProperties) {
        code += buildExtraObjectPropertiesSerializer(context, location, addComma, objVar);
      }
      code += `
    json += JSON_STR_END_OBJECT
  `;
      return code;
    }
    function mergeLocations(context, mergedSchemaId, mergedLocations) {
      for (let i = 0, mergedLocationsLength = mergedLocations.length; i < mergedLocationsLength; i++) {
        const location = mergedLocations[i];
        const schema = location.schema;
        if (schema.$ref) {
          mergedLocations[i] = resolveRef2(context, location);
        }
      }
      const mergedSchemas = [];
      for (const location of mergedLocations) {
        const schema = cloneOriginSchema(context, location.schema, location.schemaId);
        delete schema.$id;
        mergedSchemas.push(schema);
      }
      const mergedSchema = mergeSchemas(mergedSchemas);
      const mergedLocation = new Location(mergedSchema, mergedSchemaId);
      context.refResolver.addSchema(mergedSchema, mergedSchemaId);
      return mergedLocation;
    }
    function cloneOriginSchema(context, schema, schemaId) {
      const clonedSchema = Array.isArray(schema) ? [] : {};
      if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
        schemaId = schema.$id;
      }
      const mergedSchemaRef = context.mergedSchemasIds.get(schema);
      if (mergedSchemaRef) {
        context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
      }
      for (const key in schema) {
        let value = schema[key];
        if (key === "$ref" && typeof value === "string" && value.charAt(0) === "#") {
          value = schemaId + value;
        }
        if (typeof value === "object" && value !== null) {
          value = cloneOriginSchema(context, value, schemaId);
        }
        clonedSchema[key] = value;
      }
      return clonedSchema;
    }
    function toJSON(variableName) {
      return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
    }
    function buildObject(context, location, input) {
      const schema = location.schema;
      if (context.functionsNamesBySchema.has(schema)) {
        const funcName = context.functionsNamesBySchema.get(schema);
        return `json += ${funcName}(${input})`;
      }
      const nullable3 = schema.nullable === true;
      const schemaId = location.schemaId || "";
      const jsonPointer = location.jsonPointer || "";
      const fullPath = `${schemaId}#${jsonPointer}`;
      if (context.recursivePaths.has(fullPath) || context.buildingSet.has(schema)) {
        const functionName = generateFuncName(context);
        context.functionsNamesBySchema.set(schema, functionName);
        const schemaRef = getSafeSchemaRef(context, location);
        const functionCode = `
      // ${schemaRef}
      function ${functionName} (input) {
        const obj = ${toJSON("input")}
        if (obj === null) return ${nullable3 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_OBJECT"}
        let json = ''

        ${buildInnerObject(context, location, "obj")}
        return json
      }
    `;
        context.functions.push(functionCode);
        return `json += ${functionName}(${input})`;
      }
      context.buildingSet.add(schema);
      const objVar = `obj_${context.uid++}`;
      const code = `
    const ${objVar} = ${toJSON(input)}
    if (${objVar} === null) {
      json += ${nullable3 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_OBJECT"}
    } else {
      ${buildInnerObject(context, location, objVar)}
    }
  `;
      context.buildingSet.delete(schema);
      return code;
    }
    function buildArray(context, location, input) {
      const schema = location.schema;
      let itemsLocation = location.getPropertyLocation("items");
      itemsLocation.schema = itemsLocation.schema || {};
      if (itemsLocation.schema.$ref) {
        itemsLocation = resolveRef2(context, itemsLocation);
      }
      const itemsSchema = itemsLocation.schema;
      if (context.functionsNamesBySchema.has(schema)) {
        const funcName = context.functionsNamesBySchema.get(schema);
        return `json += ${funcName}(${input})`;
      }
      const nullable3 = schema.nullable === true;
      const schemaId = location.schemaId || "";
      const jsonPointer = location.jsonPointer || "";
      const fullPath = `${schemaId}#${jsonPointer}`;
      if (context.recursivePaths.has(fullPath) || context.buildingSet.has(schema)) {
        const functionName = generateFuncName(context);
        context.functionsNamesBySchema.set(schema, functionName);
        const schemaRef = getSafeSchemaRef(context, location);
        let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
      let json = ''
  `;
        functionCode += `
    if (obj === null) return ${nullable3 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
        if (!schema.additionalItems && Array.isArray(itemsSchema)) {
          functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
        }
        if (largeArrayMechanism === "json-stringify") {
          functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)
`;
        }
        functionCode += `
    json += JSON_STR_BEGIN_ARRAY
  `;
        if (Array.isArray(itemsSchema)) {
          for (let i = 0, itemsSchemaLength = itemsSchema.length; i < itemsSchemaLength; i++) {
            const item = itemsSchema[i];
            const value = `value_${i}`;
            functionCode += `const ${value} = obj[${i}]`;
            const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), value);
            functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type, value)}) {
            if (${i}) {
              json += JSON_STR_COMMA
            }
            ${tmpRes}
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
          }
          if (schema.additionalItems) {
            functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          if (i) {
            json += JSON_STR_COMMA
          }
          json += JSON.stringify(obj[i])
        }`;
          }
        } else {
          const code = buildValue(context, itemsLocation, "value");
          functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        if (i) {
          json += JSON_STR_COMMA
        }
        const value = obj[i]
        ${code}
      }`;
        }
        functionCode += `
      return json + JSON_STR_END_ARRAY
    }`;
        context.functions.push(functionCode);
        return `json += ${functionName}(${input})`;
      }
      context.buildingSet.add(schema);
      const safeSchemaRef = getSafeSchemaRef(context, location);
      const objVar = `obj_${context.uid++}`;
      let inlinedCode = `
    const ${objVar} = ${input}
    if (${objVar} === null) {
      json += ${nullable3 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_ARRAY"}
    } else if (!Array.isArray(${objVar})) {
      throw new TypeError(\`The value of '${safeSchemaRef}' does not match schema definition.\`)
    } else {
      const arrayLength_${objVar} = ${objVar}.length
  `;
      if (!schema.additionalItems && Array.isArray(itemsSchema)) {
        inlinedCode += `
      if (arrayLength_${objVar} > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
      }
      if (largeArrayMechanism === "json-stringify") {
        inlinedCode += `if (arrayLength_${objVar} >= ${largeArraySize}) json += JSON.stringify(${objVar})
 else {`;
      }
      inlinedCode += `
    json += JSON_STR_BEGIN_ARRAY
  `;
      if (Array.isArray(itemsSchema)) {
        const localUid = context.uid++;
        inlinedCode += `let addComma_${localUid} = false
`;
        for (let i = 0, itemsSchemaLength = itemsSchema.length; i < itemsSchemaLength; i++) {
          const item = itemsSchema[i];
          const value = `value_${i}_${context.uid++}`;
          inlinedCode += `const ${value} = ${objVar}[${i}]`;
          const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), value);
          inlinedCode += `
        if (${i} < arrayLength_${objVar}) {
          if (${buildArrayTypeCondition(item.type, value)}) {
            !addComma_${localUid} && (addComma_${localUid} = true) || (json += JSON_STR_COMMA)
            ${tmpRes}
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
        }
        if (schema.additionalItems) {
          inlinedCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength_${objVar}; i++) {
          !addComma_${localUid} && (addComma_${localUid} = true) || (json += JSON_STR_COMMA)
          json += JSON.stringify(${objVar}[i])
        }`;
        }
      } else {
        const code = buildValue(context, itemsLocation, "value");
        inlinedCode += `
      for (let i = 0; i < arrayLength_${objVar}; i++) {
        if (i) {
          json += JSON_STR_COMMA
        }
        const value = ${objVar}[i]
        ${code}
      }`;
      }
      inlinedCode += `
    json += JSON_STR_END_ARRAY
  `;
      if (largeArrayMechanism === "json-stringify") {
        inlinedCode += "}";
      }
      inlinedCode += "}";
      context.buildingSet.delete(schema);
      return inlinedCode;
    }
    function buildArrayTypeCondition(type, accessor) {
      let condition;
      switch (type) {
        case "null":
          condition = `${accessor} === null`;
          break;
        case "string":
          condition = `typeof ${accessor} === 'string' ||
      ${accessor} === null ||
      ${accessor} instanceof Date ||
      ${accessor} instanceof RegExp ||
      (
        typeof ${accessor} === "object" &&
        typeof ${accessor}.toString === "function" &&
        ${accessor}.toString !== Object.prototype.toString
      )`;
          break;
        case "integer":
          condition = `Number.isInteger(${accessor})`;
          break;
        case "number":
          condition = `Number.isFinite(${accessor})`;
          break;
        case "boolean":
          condition = `typeof ${accessor} === 'boolean'`;
          break;
        case "object":
          condition = `${accessor} && typeof ${accessor} === 'object' && ${accessor}.constructor === Object`;
          break;
        case "array":
          condition = `Array.isArray(${accessor})`;
          break;
        default:
          if (Array.isArray(type)) {
            const conditions = type.map((subType) => {
              return buildArrayTypeCondition(subType, accessor);
            });
            condition = `(${conditions.join(" || ")})`;
          }
      }
      return condition;
    }
    function generateFuncName(context) {
      return "anonymous" + context.functionsCounter++;
    }
    function buildMultiTypeSerializer(context, location, input) {
      const schema = location.schema;
      const types = schema.type.sort((t1) => t1 === "null" ? -1 : 1);
      let code = "";
      types.forEach((type, index2) => {
        location.schema = { ...location.schema, type };
        const nestedResult = buildSingleTypeSerializer(context, location, input);
        const statement = index2 === 0 ? "if" : "else if";
        switch (type) {
          case "null":
            code += `
          ${statement} (${input} === null) {
            ${nestedResult}
          }
          `;
            break;
          case "string": {
            code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          ) {
            ${nestedResult}
          }
        `;
            break;
          }
          case "array": {
            code += `
          ${statement}(Array.isArray(${input})) {
            ${nestedResult}
          }
        `;
            break;
          }
          case "integer": {
            code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null) {
            ${nestedResult}
          }
        `;
            break;
          }
          default: {
            code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null) {
            ${nestedResult}
          }
        `;
            break;
          }
        }
      });
      code += `
    else throw new TypeError(\`The value of '${getSafeSchemaRef(context, location)}' does not match schema definition.\`)
  `;
      return code;
    }
    function buildSingleTypeSerializer(context, location, input) {
      const schema = location.schema;
      switch (schema.type) {
        case "null":
          return "json += JSON_STR_NULL";
        case "string": {
          if (schema.format === "date-time") {
            return `json += asDateTime(${input})`;
          } else if (schema.format === "date") {
            return `json += asDate(${input})`;
          } else if (schema.format === "time") {
            return `json += asTime(${input})`;
          } else if (schema.format === "unsafe") {
            return `json += asUnsafeString(${input})`;
          } else {
            return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += asString(${input}.source)
          } else {
            json += asString(${input}.toString())
          }
        } else {
          json += asString(${input})
        }
        `;
          }
        }
        case "integer":
          return `json += asInteger(${input})`;
        case "number":
          return `json += asNumber(${input})`;
        case "boolean":
          return `json += asBoolean(${input})`;
        case "object": {
          return buildObject(context, location, input);
        }
        case "array": {
          return buildArray(context, location, input);
        }
        case void 0:
          return `json += JSON.stringify(${input})`;
        default:
          throw new Error(`${schema.type} unsupported`);
      }
    }
    function detectRecursiveSchemas(context, location) {
      const pathStack = /* @__PURE__ */ new Set();
      function traverse(location2) {
        const schema = location2.schema;
        if (typeof schema !== "object" || schema === null) return;
        const schemaId = location2.schemaId || "";
        const jsonPointer = location2.jsonPointer || "";
        const fullPath = `${schemaId}#${jsonPointer}`;
        if (pathStack.has(fullPath)) {
          let inCycle = false;
          for (const p2 of pathStack) {
            if (p2 === fullPath) inCycle = true;
            if (inCycle) context.recursivePaths.add(p2);
          }
          context.recursivePaths.add(fullPath);
          return;
        }
        pathStack.add(fullPath);
        if (schema.$ref) {
          try {
            const res = resolveRef2(context, location2);
            traverse(res);
          } catch (err) {
          }
        }
        if (schema.properties) {
          const propertiesLocation = location2.getPropertyLocation("properties");
          for (const key in schema.properties) {
            traverse(propertiesLocation.getPropertyLocation(key));
          }
        }
        if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
          traverse(location2.getPropertyLocation("additionalProperties"));
        }
        if (schema.patternProperties) {
          const patternPropertiesLocation = location2.getPropertyLocation("patternProperties");
          for (const key in schema.patternProperties) {
            traverse(patternPropertiesLocation.getPropertyLocation(key));
          }
        }
        if (schema.items) {
          const itemsLocation = location2.getPropertyLocation("items");
          if (Array.isArray(schema.items)) {
            for (let i = 0; i < schema.items.length; i++) {
              traverse(itemsLocation.getPropertyLocation(i));
            }
          } else {
            traverse(itemsLocation);
          }
        }
        if (schema.additionalItems && typeof schema.additionalItems === "object") {
          traverse(location2.getPropertyLocation("additionalItems"));
        }
        if (schema.oneOf) {
          const oneOfLocation = location2.getPropertyLocation("oneOf");
          for (let i = 0; i < schema.oneOf.length; i++) {
            traverse(oneOfLocation.getPropertyLocation(i));
          }
        }
        if (schema.anyOf) {
          const anyOfLocation = location2.getPropertyLocation("anyOf");
          for (let i = 0; i < schema.anyOf.length; i++) {
            traverse(anyOfLocation.getPropertyLocation(i));
          }
        }
        if (schema.allOf) {
          const allOfLocation = location2.getPropertyLocation("allOf");
          for (let i = 0; i < schema.allOf.length; i++) {
            traverse(allOfLocation.getPropertyLocation(i));
          }
        }
        if (schema.then) traverse(location2.getPropertyLocation("then"));
        if (schema.else) traverse(location2.getPropertyLocation("else"));
        pathStack.delete(fullPath);
      }
      traverse(location);
    }
    function buildConstSerializer(location, input) {
      const schema = location.schema;
      const type = schema.type;
      const hasNullType = Array.isArray(type) && type.includes("null");
      let code = "";
      if (hasNullType) {
        code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
      }
      code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;
      if (hasNullType) {
        code += `
      }
    `;
      }
      return code;
    }
    function buildAllOf(context, location, input) {
      const schema = location.schema;
      let mergedSchemaId = context.mergedSchemasIds.get(schema);
      if (mergedSchemaId) {
        const mergedLocation2 = getMergedLocation(context, mergedSchemaId);
        return buildValue(context, mergedLocation2, input);
      }
      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(schema, mergedSchemaId);
      const { allOf, ...schemaWithoutAllOf } = location.schema;
      const locations = [
        new Location(
          schemaWithoutAllOf,
          location.schemaId,
          location.jsonPointer
        )
      ];
      const allOfsLocation = location.getPropertyLocation("allOf");
      for (let i = 0, allOfLength = allOf.length; i < allOfLength; i++) {
        locations.push(allOfsLocation.getPropertyLocation(i));
      }
      const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
      return buildValue(context, mergedLocation, input);
    }
    function buildOneOf(context, location, input) {
      context.validatorSchemasIds.add(location.schemaId);
      const schema = location.schema;
      const type = schema.anyOf ? "anyOf" : "oneOf";
      const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema;
      const locationWithoutOneOf = new Location(
        schemaWithoutAnyOf,
        location.schemaId,
        location.jsonPointer
      );
      const oneOfsLocation = location.getPropertyLocation(type);
      let code = "";
      for (let index2 = 0, oneOfsLength = oneOfs.length; index2 < oneOfsLength; index2++) {
        const optionLocation = oneOfsLocation.getPropertyLocation(index2);
        const optionSchema = optionLocation.schema;
        let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
        let mergedLocation = null;
        if (mergedSchemaId) {
          mergedLocation = getMergedLocation(context, mergedSchemaId);
        } else {
          mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
          context.mergedSchemasIds.set(optionSchema, mergedSchemaId);
          mergedLocation = mergeLocations(context, mergedSchemaId, [
            locationWithoutOneOf,
            optionLocation
          ]);
        }
        const nestedResult = buildValue(context, mergedLocation, input);
        const schemaRef = optionLocation.getSchemaRef();
        code += `
      ${index2 === 0 ? "if" : "else if"}(validator.validate("${schemaRef}", ${input})) {
        ${nestedResult}
      }
    `;
      }
      code += `
    else throw new TypeError(\`The value of '${getSafeSchemaRef(context, location)}' does not match schema definition.\`)
  `;
      return code;
    }
    function buildIfThenElse(context, location, input) {
      context.validatorSchemasIds.add(location.schemaId);
      const {
        if: ifSchema,
        then: thenSchema,
        else: elseSchema,
        ...schemaWithoutIfThenElse
      } = location.schema;
      const rootLocation = new Location(
        schemaWithoutIfThenElse,
        location.schemaId,
        location.jsonPointer
      );
      const ifLocation = location.getPropertyLocation("if");
      const ifSchemaRef = ifLocation.getSchemaRef();
      const thenLocation = location.getPropertyLocation("then");
      let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
      let thenMergedLocation = null;
      if (thenMergedSchemaId) {
        thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
      } else {
        thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
        thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
          rootLocation,
          thenLocation
        ]);
      }
      if (!elseSchema) {
        return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `;
      }
      const elseLocation = location.getPropertyLocation("else");
      let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
      let elseMergedLocation = null;
      if (elseMergedSchemaId) {
        elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
      } else {
        elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
        elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
          rootLocation,
          elseLocation
        ]);
      }
      return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `;
    }
    function buildValue(context, location, input) {
      let schema = location.schema;
      if (typeof schema === "boolean") {
        return `json += JSON.stringify(${input})`;
      }
      if (schema.$ref) {
        location = resolveRef2(context, location);
        schema = location.schema;
      }
      if (schema.allOf) {
        return buildAllOf(context, location, input);
      }
      if (schema.anyOf || schema.oneOf) {
        return buildOneOf(context, location, input);
      }
      if (schema.if && schema.then) {
        return buildIfThenElse(context, location, input);
      }
      if (schema.type === void 0) {
        const inferredType = inferTypeByKeyword(schema);
        if (inferredType) {
          schema.type = inferredType;
        }
      }
      let code = "";
      const type = schema.type;
      const nullable3 = schema.nullable === true;
      if (nullable3) {
        code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
      }
      if (schema.const !== void 0) {
        code += buildConstSerializer(location, input);
      } else if (Array.isArray(type)) {
        code += buildMultiTypeSerializer(context, location, input);
      } else {
        code += buildSingleTypeSerializer(context, location, input);
      }
      if (nullable3) {
        code += `
      }
    `;
      }
      return code;
    }
    module.exports = build;
    module.exports.default = build;
    module.exports.build = build;
    module.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
    module.exports.restore = function({ code, validator, serializer }) {
      return Function.apply(null, ["validator", "serializer", code]).apply(null, [validator, serializer]);
    };
  }
});

// node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.3/node_modules/@fastify/fast-json-stringify-compiler/standalone.js
var require_standalone2 = __commonJS({
  "node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.3/node_modules/@fastify/fast-json-stringify-compiler/standalone.js"(exports, module) {
    "use strict";
    var fastJsonStringify = require_fast_json_stringify();
    function SerializerSelector() {
      return function buildSerializerFactory(externalSchemas, serializerOpts) {
        const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
        return responseSchemaCompiler.bind(null, fjsOpts);
      };
    }
    function responseSchemaCompiler(fjsOpts, {
      schema
      /* method, url, httpStatus */
    }) {
      if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
        fjsOpts.schema = { ...fjsOpts.schema };
        delete fjsOpts.schema[schema.$id];
      }
      return fastJsonStringify(schema, fjsOpts);
    }
    function StandaloneSerializer(options = { readMode: true }) {
      if (options.readMode === true && typeof options.restoreFunction !== "function") {
        throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
      }
      if (options.readMode !== true && typeof options.storeFunction !== "function") {
        throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
      }
      if (options.readMode === true) {
        return function wrapper() {
          return function(opts) {
            return options.restoreFunction(opts);
          };
        };
      }
      const factory = SerializerSelector();
      return function wrapper(externalSchemas, serializerOpts = {}) {
        serializerOpts.mode = "standalone";
        const compiler = factory(externalSchemas, serializerOpts);
        return function(opts) {
          const serializeFuncCode = compiler(opts);
          options.storeFunction(opts, serializeFuncCode);
          return new Function(serializeFuncCode);
        };
      };
    }
    module.exports.SerializerSelector = SerializerSelector;
    module.exports.StandaloneSerializer = StandaloneSerializer;
    module.exports.default = StandaloneSerializer;
  }
});

// node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.3/node_modules/@fastify/fast-json-stringify-compiler/index.js
var require_fast_json_stringify_compiler = __commonJS({
  "node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.3/node_modules/@fastify/fast-json-stringify-compiler/index.js"(exports, module) {
    "use strict";
    var { SerializerSelector, StandaloneSerializer } = require_standalone2();
    module.exports = SerializerSelector;
    module.exports.default = SerializerSelector;
    module.exports.SerializerSelector = SerializerSelector;
    module.exports.StandaloneSerializer = StandaloneSerializer;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/metadata.js
var require_metadata2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkMetadata = void 0;
    var util_1 = require_util();
    var def = {
      keyword: "metadata",
      schemaType: "object",
      code(cxt) {
        checkMetadata(cxt);
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
        cxt.ok(valid);
      }
    };
    function checkMetadata({ it: it2, keyword }, metadata) {
      if (it2.jtdMetadata !== metadata) {
        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
      }
    }
    exports.checkMetadata = checkMetadata;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/ref.js
var require_ref2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasRef = void 0;
    var compile_1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var ref_1 = require_ref();
    var metadata_1 = require_metadata2();
    var def = {
      keyword: "ref",
      schemaType: "string",
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema: ref, parentSchema, it: it2 } = cxt;
        const { schemaEnv: { root } } = it2;
        const valid = gen.name("valid");
        if (parentSchema.nullable) {
          gen.var(valid, (0, codegen_1._)`${data} === null`);
          gen.if((0, codegen_1.not)(valid), validateJtdRef);
        } else {
          gen.var(valid, false);
          validateJtdRef();
        }
        cxt.ok(valid);
        function validateJtdRef() {
          var _a3;
          const refSchema = (_a3 = root.schema.definitions) === null || _a3 === void 0 ? void 0 : _a3[ref];
          if (!refSchema) {
            throw new ref_error_1.default(it2.opts.uriResolver, "", ref, `No definition ${ref}`);
          }
          if (hasRef(refSchema) || !it2.opts.inlineRefs)
            callValidate(refSchema);
          else
            inlineRefSchema(refSchema);
        }
        function callValidate(schema) {
          const sch = compile_1.compileSchema.call(it2.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
          const v2 = (0, ref_1.getValidate)(cxt, sch);
          const errsCount = gen.const("_errs", names_1.default.errors);
          (0, ref_1.callRef)(cxt, v2, sch, sch.$async);
          gen.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        }
        function inlineRefSchema(schema) {
          const schName = gen.scopeValue("schema", it2.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
          cxt.subschema({
            schema,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: `/definitions/${ref}`
          }, valid);
        }
      }
    };
    function hasRef(schema) {
      for (const key in schema) {
        let sch;
        if (key === "ref" || typeof (sch = schema[key]) == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    exports.hasRef = hasRef;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DT_SEPARATOR = /t|\s/i;
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function validTimestamp(str, allowDate) {
      const dt = str.split(DT_SEPARATOR);
      return dt.length === 2 && validDate(dt[0]) && validTime(dt[1]) || allowDate && dt.length === 1 && validDate(dt[0]);
    }
    exports.default = validTimestamp;
    function validDate(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const y = +matches[1];
      const m2 = +matches[2];
      const d2 = +matches[3];
      return m2 >= 1 && m2 <= 12 && d2 >= 1 && (d2 <= DAYS[m2] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
      m2 === 2 && d2 === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0));
    }
    function validTime(str) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tzH = +(matches[4] || 0);
      const tzM = +(matches[5] || 0);
      return hr <= 23 && min <= 59 && sec <= 59 || // leap second
      hr - tzH === 23 && min - tzM === 59 && sec === 60;
    }
    validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/error.js
var require_error2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeErrorParams = exports.typeErrorMessage = exports.typeError = void 0;
    var codegen_1 = require_codegen();
    function typeError(t) {
      return {
        message: (cxt) => typeErrorMessage(cxt, t),
        params: (cxt) => typeErrorParams(cxt, t)
      };
    }
    exports.typeError = typeError;
    function typeErrorMessage({ parentSchema }, t) {
      return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
    }
    exports.typeErrorMessage = typeErrorMessage;
    function typeErrorParams({ parentSchema }, t) {
      return (0, codegen_1._)`{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
    }
    exports.typeErrorParams = typeErrorParams;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intRange = void 0;
    var codegen_1 = require_codegen();
    var timestamp_1 = require_timestamp();
    var util_1 = require_util();
    var metadata_1 = require_metadata2();
    var error_1 = require_error2();
    exports.intRange = {
      int8: [-128, 127, 3],
      uint8: [0, 255, 3],
      int16: [-32768, 32767, 5],
      uint16: [0, 65535, 5],
      int32: [-2147483648, 2147483647, 10],
      uint32: [0, 4294967295, 10]
    };
    var error48 = {
      message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
      params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema)
    };
    function timestampCode(cxt) {
      const { gen, data, it: it2 } = cxt;
      const { timestamp: timestamp2, allowDate } = it2.opts;
      if (timestamp2 === "date")
        return (0, codegen_1._)`${data} instanceof Date `;
      const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
      const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;
      const validString = (0, codegen_1._)`typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
      return timestamp2 === "string" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data} instanceof Date`, validString);
    }
    var def = {
      keyword: "type",
      schemaType: "string",
      error: error48,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { data, schema, parentSchema, it: it2 } = cxt;
        let cond;
        switch (schema) {
          case "boolean":
          case "string":
            cond = (0, codegen_1._)`typeof ${data} == ${schema}`;
            break;
          case "timestamp": {
            cond = timestampCode(cxt);
            break;
          }
          case "float32":
          case "float64":
            cond = (0, codegen_1._)`typeof ${data} == "number"`;
            break;
          default: {
            const sch = schema;
            cond = (0, codegen_1._)`typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
            if (!it2.opts.int32range && (sch === "int32" || sch === "uint32")) {
              if (sch === "uint32")
                cond = (0, codegen_1._)`${cond} && ${data} >= 0`;
            } else {
              const [min, max] = exports.intRange[sch];
              cond = (0, codegen_1._)`${cond} && ${data} >= ${min} && ${data} <= ${max}`;
            }
          }
        }
        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data} === null`, cond) : cond);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/nullable.js
var require_nullable = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/nullable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkNullableObject = exports.checkNullable = void 0;
    var codegen_1 = require_codegen();
    function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
      const valid = gen.name("valid");
      if (parentSchema.nullable) {
        gen.let(valid, (0, codegen_1._)`${data} === null`);
        cond = (0, codegen_1.not)(valid);
      } else {
        gen.let(valid, false);
      }
      return [valid, cond];
    }
    exports.checkNullable = checkNullable;
    function checkNullableObject(cxt, cond) {
      const [valid, cond_] = checkNullable(cxt, cond);
      return [valid, (0, codegen_1._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
    }
    exports.checkNullableObject = checkNullableObject;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/enum.js
var require_enum2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error48 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      error: error48,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, schemaValue, parentSchema, it: it2 } = cxt;
        if (schema.length === 0)
          throw new Error("enum must have non-empty array");
        if (schema.length !== new Set(schema).size)
          throw new Error("enum items must be unique");
        let valid;
        const isString = (0, codegen_1._)`typeof ${data} == "string"`;
        if (schema.length >= it2.opts.loopEnum) {
          let cond;
          [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
          gen.if(cond, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._)`${data} === ${value}`)));
          if (parentSchema.nullable)
            valid = (0, codegen_1.or)((0, codegen_1._)`${data} === null`, valid);
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.forOf("v", schemaValue, (v2) => gen.if((0, codegen_1._)`${valid} = ${data} === ${v2}`, () => gen.break()));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/elements.js
var require_elements = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/elements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var def = {
      keyword: "elements",
      schemaType: "object",
      error: (0, error_1.typeError)("array"),
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const [valid] = (0, nullable_1.checkNullable)(cxt);
        gen.if((0, codegen_1.not)(valid), () => gen.if((0, codegen_1._)`Array.isArray(${data})`, () => gen.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/properties.js
var require_properties2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateProperties = exports.error = void 0;
    var code_1 = require_code2();
    var util_1 = require_util();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var PropError;
    (function(PropError2) {
      PropError2["Additional"] = "additional";
      PropError2["Missing"] = "missing";
    })(PropError || (PropError = {}));
    exports.error = {
      message: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    var def = {
      keyword: "properties",
      schemaType: "object",
      error: exports.error,
      code: validateProperties
    };
    function validateProperties(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, parentSchema, it: it2 } = cxt;
      const { additionalProperties, nullable: nullable3 } = parentSchema;
      if (it2.jtdDiscriminator && nullable3)
        throw new Error("JTD: nullable inside discriminator mapping");
      if (commonProperties()) {
        throw new Error("JTD: properties and optionalProperties have common members");
      }
      const [allProps, properties] = schemaProperties("properties");
      const [allOptProps, optProperties] = schemaProperties("optionalProperties");
      if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
        return;
      }
      const [valid, cond] = it2.jtdDiscriminator === void 0 ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen.let("valid", false), true];
      gen.if(cond, () => gen.assign(valid, true).block(() => {
        validateProps(properties, "properties", true);
        validateProps(optProperties, "optionalProperties");
        if (!additionalProperties)
          validateAdditional();
      }));
      cxt.pass(valid);
      function commonProperties() {
        const props = parentSchema.properties;
        const optProps = parentSchema.optionalProperties;
        if (!(props && optProps))
          return false;
        for (const p2 in props) {
          if (Object.prototype.hasOwnProperty.call(optProps, p2))
            return true;
        }
        return false;
      }
      function schemaProperties(keyword) {
        const schema = parentSchema[keyword];
        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
        if (it2.jtdDiscriminator && allPs.some((p2) => p2 === it2.jtdDiscriminator)) {
          throw new Error(`JTD: discriminator tag used in ${keyword}`);
        }
        const ps = allPs.filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schema[p2]));
        return [allPs, ps];
      }
      function validateProps(props, keyword, required2) {
        const _valid = gen.var("valid");
        for (const prop of props) {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
          cxt.ok(_valid);
        }
        function missingProperty(prop) {
          if (required2) {
            gen.assign(_valid, false);
            cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
          } else {
            gen.assign(_valid, true);
          }
        }
      }
      function applyPropertySchema(prop, keyword, _valid) {
        cxt.subschema({
          keyword,
          schemaProp: prop,
          dataProp: prop
        }, _valid);
      }
      function validateAdditional() {
        gen.forIn("key", data, (key) => {
          const addProp = isAdditional(key, allProps, "properties", it2.jtdDiscriminator);
          const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
          const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
          gen.if(extra, () => {
            if (it2.opts.removeAdditional) {
              gen.code((0, codegen_1._)`delete ${data}[${key}]`);
            } else {
              cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
              if (!it2.opts.allErrors)
                gen.break();
            }
          });
        });
      }
      function isAdditional(key, props, keyword, jtdDiscriminator) {
        let additional;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema[keyword], keyword);
          additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
          if (jtdDiscriminator !== void 0) {
            additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);
          }
        } else if (props.length || jtdDiscriminator !== void 0) {
          const ps = jtdDiscriminator === void 0 ? props : [jtdDiscriminator].concat(props);
          additional = (0, codegen_1.and)(...ps.map((p2) => (0, codegen_1._)`${key} !== ${p2}`));
        } else {
          additional = true;
        }
        return additional;
      }
    }
    exports.validateProperties = validateProperties;
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
var require_optionalProperties = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var properties_1 = require_properties2();
    var def = {
      keyword: "optionalProperties",
      schemaType: "object",
      error: properties_1.error,
      code(cxt) {
        if (cxt.parentSchema.properties)
          return;
        (0, properties_1.validateProperties)(cxt);
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
var require_discriminator2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/discriminator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var types_1 = require_types();
    var error48 = {
      message: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag "${schema}" must be string` : `value of tag "${schema}" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    var def = {
      keyword: "discriminator",
      schemaType: "string",
      implements: ["mapping"],
      error: error48,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, parentSchema } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
        gen.if(cond);
        validateDiscriminator();
        gen.elseIf((0, codegen_1.not)(valid));
        cxt.error();
        gen.endIf();
        cxt.ok(valid);
        function validateDiscriminator() {
          const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(schema)}`);
          gen.if((0, codegen_1._)`${tag} === undefined`);
          cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
          gen.elseIf((0, codegen_1._)`typeof ${tag} == "string"`);
          validateMapping(tag);
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
          gen.endIf();
        }
        function validateMapping(tag) {
          gen.if(false);
          for (const tagValue in parentSchema.mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(tagValue));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          cxt.subschema({
            keyword: "mapping",
            schemaProp,
            jtdDiscriminator: schema
          }, _valid);
          return _valid;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/values.js
var require_values = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/values.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var def = {
      keyword: "values",
      schemaType: "object",
      error: (0, error_1.typeError)("object"),
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, it: it2 } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
        } else {
          gen.if(cond);
          gen.assign(valid, validateMap());
          gen.elseIf((0, codegen_1.not)(valid));
          cxt.error();
          gen.endIf();
        }
        cxt.ok(valid);
        function validateMap() {
          const _valid = gen.name("valid");
          if (it2.allErrors) {
            const validMap = gen.let("valid", true);
            validateValues(() => gen.assign(validMap, false));
            return validMap;
          }
          gen.var(_valid, true);
          validateValues(() => gen.break());
          return _valid;
          function validateValues(notValid) {
            gen.forIn("key", data, (key) => {
              cxt.subschema({
                keyword: "values",
                dataProp: key,
                dataPropType: util_1.Type.Str
              }, _valid);
              gen.if((0, codegen_1.not)(_valid), notValid);
            });
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/union.js
var require_union = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/union.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "union",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in union" }
    };
    exports.default = def;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/index.js
var require_jtd = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ref_1 = require_ref2();
    var type_1 = require_type();
    var enum_1 = require_enum2();
    var elements_1 = require_elements();
    var properties_1 = require_properties2();
    var optionalProperties_1 = require_optionalProperties();
    var discriminator_1 = require_discriminator2();
    var values_1 = require_values();
    var union_1 = require_union();
    var metadata_1 = require_metadata2();
    var jtdVocabulary = [
      "definitions",
      ref_1.default,
      type_1.default,
      enum_1.default,
      elements_1.default,
      properties_1.default,
      optionalProperties_1.default,
      discriminator_1.default,
      values_1.default,
      union_1.default,
      metadata_1.default,
      { keyword: "additionalProperties", schemaType: "boolean" },
      { keyword: "nullable", schemaType: "boolean" }
    ];
    exports.default = jtdVocabulary;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/jtd-schema.js
var require_jtd_schema = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/jtd-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared = (root) => {
      const sch = {
        nullable: { type: "boolean" },
        metadata: {
          optionalProperties: {
            union: { elements: { ref: "schema" } }
          },
          additionalProperties: true
        }
      };
      if (root)
        sch.definitions = { values: { ref: "schema" } };
      return sch;
    };
    var emptyForm = (root) => ({
      optionalProperties: shared(root)
    });
    var refForm = (root) => ({
      properties: {
        ref: { type: "string" }
      },
      optionalProperties: shared(root)
    });
    var typeForm = (root) => ({
      properties: {
        type: {
          enum: [
            "boolean",
            "timestamp",
            "string",
            "float32",
            "float64",
            "int8",
            "uint8",
            "int16",
            "uint16",
            "int32",
            "uint32"
          ]
        }
      },
      optionalProperties: shared(root)
    });
    var enumForm = (root) => ({
      properties: {
        enum: { elements: { type: "string" } }
      },
      optionalProperties: shared(root)
    });
    var elementsForm = (root) => ({
      properties: {
        elements: { ref: "schema" }
      },
      optionalProperties: shared(root)
    });
    var propertiesForm = (root) => ({
      properties: {
        properties: { values: { ref: "schema" } }
      },
      optionalProperties: {
        optionalProperties: { values: { ref: "schema" } },
        additionalProperties: { type: "boolean" },
        ...shared(root)
      }
    });
    var optionalPropertiesForm = (root) => ({
      properties: {
        optionalProperties: { values: { ref: "schema" } }
      },
      optionalProperties: {
        additionalProperties: { type: "boolean" },
        ...shared(root)
      }
    });
    var discriminatorForm = (root) => ({
      properties: {
        discriminator: { type: "string" },
        mapping: {
          values: {
            metadata: {
              union: [propertiesForm(false), optionalPropertiesForm(false)]
            }
          }
        }
      },
      optionalProperties: shared(root)
    });
    var valuesForm = (root) => ({
      properties: {
        values: { ref: "schema" }
      },
      optionalProperties: shared(root)
    });
    var schema = (root) => ({
      metadata: {
        union: [
          emptyForm,
          refForm,
          typeForm,
          enumForm,
          elementsForm,
          propertiesForm,
          optionalPropertiesForm,
          discriminatorForm,
          valuesForm
        ].map((s) => s(root))
      }
    });
    var jtdMetaSchema = {
      definitions: {
        schema: schema(false)
      },
      ...schema(true)
    };
    exports.default = jtdMetaSchema;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/types.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jtdForms = void 0;
    exports.jtdForms = [
      "elements",
      "values",
      "discriminator",
      "properties",
      "optionalProperties",
      "enum",
      "type",
      "ref"
    ];
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/quote.js
var require_quote = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/quote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rxEscapable = (
      // eslint-disable-next-line no-control-regex, no-misleading-character-class
      /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
    );
    var escaped = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    function quote(s) {
      rxEscapable.lastIndex = 0;
      return '"' + (rxEscapable.test(s) ? s.replace(rxEscapable, (a2) => {
        const c = escaped[a2];
        return typeof c === "string" ? c : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
      }) : s) + '"';
    }
    exports.default = quote;
    quote.code = 'require("ajv/dist/runtime/quote").default';
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/serialize.js
var require_serialize = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/serialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types2();
    var __1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var code_1 = require_code2();
    var ref_1 = require_ref2();
    var util_1 = require_util();
    var quote_1 = require_quote();
    var genSerialize = {
      elements: serializeElements,
      values: serializeValues,
      discriminator: serializeDiscriminator,
      properties: serializeProperties,
      optionalProperties: serializeProperties,
      enum: serializeString,
      type: serializeType,
      ref: serializeRef
    };
    function compileSerializer(sch, definitions) {
      const _sch = __1.getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      const serializeName = gen.scopeName("serialize");
      const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        sch.serializeName = serializeName;
        gen.func(serializeName, names_1.default.data, false, () => {
          gen.let(names_1.default.json, (0, codegen_1.str)``);
          serializeCode(cxt);
          gen.return(names_1.default.json);
        });
        gen.optimize(this.opts.code.optimize);
        const serializeFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
        const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
        const serialize = makeSerialize(this.scope.get());
        this.scope.value(serializeName, { ref: serialize });
        sch.serialize = serialize;
      } catch (e) {
        if (sourceCode)
          this.logger.error("Error compiling serializer, function code:", sourceCode);
        delete sch.serialize;
        delete sch.serializeName;
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
      return sch;
    }
    exports.default = compileSerializer;
    function serializeCode(cxt) {
      let form;
      for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
          form = key;
          break;
        }
      }
      serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
    }
    function serializeNullable(cxt, serializeForm) {
      const { gen, schema, data } = cxt;
      if (!schema.nullable)
        return serializeForm(cxt);
      gen.if((0, codegen_1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._)`"null"`), () => serializeForm(cxt));
    }
    function serializeElements(cxt) {
      const { gen, schema, data } = cxt;
      gen.add(names_1.default.json, (0, codegen_1.str)`[`);
      const first = gen.let("first", true);
      gen.forOf("el", data, (el) => {
        addComma(cxt, first);
        serializeCode({ ...cxt, schema: schema.elements, data: el });
      });
      gen.add(names_1.default.json, (0, codegen_1.str)`]`);
    }
    function serializeValues(cxt) {
      const { gen, schema, data } = cxt;
      gen.add(names_1.default.json, (0, codegen_1.str)`{`);
      const first = gen.let("first", true);
      gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
      gen.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeKeyValue(cxt, key, schema, first) {
      const { gen, data } = cxt;
      addComma(cxt, first);
      serializeString({ ...cxt, data: key });
      gen.add(names_1.default.json, (0, codegen_1.str)`:`);
      const value = gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
      serializeCode({ ...cxt, schema, data: value });
    }
    function serializeDiscriminator(cxt) {
      const { gen, schema, data } = cxt;
      const { discriminator } = schema;
      gen.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(discriminator)}`);
      serializeString({ ...cxt, data: tag });
      gen.if(false);
      for (const tagValue in schema.mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        const sch = schema.mapping[tagValue];
        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
      }
      gen.endIf();
      gen.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeProperties(cxt) {
      const { gen } = cxt;
      gen.add(names_1.default.json, (0, codegen_1.str)`{`);
      serializeSchemaProperties(cxt);
      gen.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeSchemaProperties(cxt, discriminator) {
      const { gen, schema, data } = cxt;
      const { properties, optionalProperties } = schema;
      const props = keys(properties);
      const optProps = keys(optionalProperties);
      const allProps = allProperties(props.concat(optProps));
      let first = !discriminator;
      let firstProp;
      for (const key of props) {
        if (first)
          first = false;
        else
          gen.add(names_1.default.json, (0, codegen_1.str)`,`);
        serializeProperty(key, properties[key], keyValue(key));
      }
      if (first)
        firstProp = gen.let("first", true);
      for (const key of optProps) {
        const value = keyValue(key);
        gen.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
          addComma(cxt, firstProp);
          serializeProperty(key, optionalProperties[key], value);
        });
      }
      if (schema.additionalProperties) {
        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
      }
      function keys(ps) {
        return ps ? Object.keys(ps) : [];
      }
      function allProperties(ps) {
        if (discriminator)
          ps.push(discriminator);
        if (new Set(ps).size !== ps.length) {
          throw new Error("JTD: properties/optionalProperties/disciminator overlap");
        }
        return ps;
      }
      function keyValue(key) {
        return gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
      }
      function serializeProperty(key, propSchema, value) {
        gen.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);
        serializeCode({ ...cxt, schema: propSchema, data: value });
      }
      function isAdditional(key, ps) {
        return ps.length ? (0, codegen_1.and)(...ps.map((p2) => (0, codegen_1._)`${key} !== ${p2}`)) : true;
      }
    }
    function serializeType(cxt) {
      const { gen, schema, data } = cxt;
      switch (schema.type) {
        case "boolean":
          gen.add(names_1.default.json, (0, codegen_1._)`${data} ? "true" : "false"`);
          break;
        case "string":
          serializeString(cxt);
          break;
        case "timestamp":
          gen.if((0, codegen_1._)`${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._)`'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
          break;
        default:
          serializeNumber(cxt);
      }
    }
    function serializeString({ gen, data }) {
      gen.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
    }
    function serializeNumber({ gen, data }) {
      gen.add(names_1.default.json, (0, codegen_1._)`"" + ${data}`);
    }
    function serializeRef(cxt) {
      const { gen, self: self2, data, definitions, schema, schemaEnv } = cxt;
      const { ref } = schema;
      const refSchema = definitions[ref];
      if (!refSchema)
        throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
      if (!(0, ref_1.hasRef)(refSchema))
        return serializeCode({ ...cxt, schema: refSchema });
      const { root } = schemaEnv;
      const sch = compileSerializer.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
      gen.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen, sch)}(${data})`);
    }
    function getSerialize(gen, sch) {
      return sch.serialize ? gen.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
    }
    function serializeEmpty({ gen, data }) {
      gen.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data})`);
    }
    function addComma({ gen }, first) {
      if (first) {
        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str)`,`));
      } else {
        gen.add(names_1.default.json, (0, codegen_1.str)`,`);
      }
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/parseJson.js
var require_parseJson = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/parseJson.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonString = exports.parseJsonNumber = exports.parseJson = void 0;
    var rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
    function parseJson(s, pos) {
      let endPos;
      parseJson.message = void 0;
      let matches;
      if (pos)
        s = s.slice(pos);
      try {
        parseJson.position = pos + s.length;
        return JSON.parse(s);
      } catch (e) {
        matches = rxParseJson.exec(e.message);
        if (!matches) {
          parseJson.message = "unexpected end";
          return void 0;
        }
        endPos = +matches[1];
        const c = s[endPos];
        s = s.slice(0, endPos);
        parseJson.position = pos + endPos;
        try {
          return JSON.parse(s);
        } catch (e1) {
          parseJson.message = `unexpected token ${c}`;
          return void 0;
        }
      }
    }
    exports.parseJson = parseJson;
    parseJson.message = void 0;
    parseJson.position = 0;
    parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
    function parseJsonNumber(s, pos, maxDigits) {
      let numStr = "";
      let c;
      parseJsonNumber.message = void 0;
      if (s[pos] === "-") {
        numStr += "-";
        pos++;
      }
      if (s[pos] === "0") {
        numStr += "0";
        pos++;
      } else {
        if (!parseDigits(maxDigits)) {
          errorMessage();
          return void 0;
        }
      }
      if (maxDigits) {
        parseJsonNumber.position = pos;
        return +numStr;
      }
      if (s[pos] === ".") {
        numStr += ".";
        pos++;
        if (!parseDigits()) {
          errorMessage();
          return void 0;
        }
      }
      if (c = s[pos], c === "e" || c === "E") {
        numStr += "e";
        pos++;
        if (c = s[pos], c === "+" || c === "-") {
          numStr += c;
          pos++;
        }
        if (!parseDigits()) {
          errorMessage();
          return void 0;
        }
      }
      parseJsonNumber.position = pos;
      return +numStr;
      function parseDigits(maxLen) {
        let digit = false;
        while (c = s[pos], c >= "0" && c <= "9" && (maxLen === void 0 || maxLen-- > 0)) {
          digit = true;
          numStr += c;
          pos++;
        }
        return digit;
      }
      function errorMessage() {
        parseJsonNumber.position = pos;
        parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
      }
    }
    exports.parseJsonNumber = parseJsonNumber;
    parseJsonNumber.message = void 0;
    parseJsonNumber.position = 0;
    parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
    var escapedChars = {
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      '"': '"',
      "/": "/",
      "\\": "\\"
    };
    var CODE_A = "a".charCodeAt(0);
    var CODE_0 = "0".charCodeAt(0);
    function parseJsonString(s, pos) {
      let str = "";
      let c;
      parseJsonString.message = void 0;
      while (true) {
        c = s[pos++];
        if (c === '"')
          break;
        if (c === "\\") {
          c = s[pos];
          if (c in escapedChars) {
            str += escapedChars[c];
            pos++;
          } else if (c === "u") {
            pos++;
            let count = 4;
            let code = 0;
            while (count--) {
              code <<= 4;
              c = s[pos];
              if (c === void 0) {
                errorMessage("unexpected end");
                return void 0;
              }
              c = c.toLowerCase();
              if (c >= "a" && c <= "f") {
                code += c.charCodeAt(0) - CODE_A + 10;
              } else if (c >= "0" && c <= "9") {
                code += c.charCodeAt(0) - CODE_0;
              } else {
                errorMessage(`unexpected token ${c}`);
                return void 0;
              }
              pos++;
            }
            str += String.fromCharCode(code);
          } else {
            errorMessage(`unexpected token ${c}`);
            return void 0;
          }
        } else if (c === void 0) {
          errorMessage("unexpected end");
          return void 0;
        } else {
          if (c.charCodeAt(0) >= 32) {
            str += c;
          } else {
            errorMessage(`unexpected token ${c}`);
            return void 0;
          }
        }
      }
      parseJsonString.position = pos;
      return str;
      function errorMessage(msg) {
        parseJsonString.position = pos;
        parseJsonString.message = msg;
      }
    }
    exports.parseJsonString = parseJsonString;
    parseJsonString.message = void 0;
    parseJsonString.position = 0;
    parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types2();
    var __1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var code_1 = require_code2();
    var ref_1 = require_ref2();
    var type_1 = require_type();
    var parseJson_1 = require_parseJson();
    var util_1 = require_util();
    var timestamp_1 = require_timestamp();
    var genParse = {
      elements: parseElements,
      values: parseValues,
      discriminator: parseDiscriminator,
      properties: parseProperties,
      optionalProperties: parseProperties,
      enum: parseEnum,
      type: parseType,
      ref: parseRef
    };
    function compileParser(sch, definitions) {
      const _sch = __1.getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      const parseName = gen.scopeName("parse");
      const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
        parseName,
        char: gen.name("c")
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        sch.parseName = parseName;
        parserFunction(cxt);
        gen.optimize(this.opts.code.optimize);
        const parseFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
        const parse3 = makeParse(this.scope.get());
        this.scope.value(parseName, { ref: parse3 });
        sch.parse = parse3;
      } catch (e) {
        if (sourceCode)
          this.logger.error("Error compiling parser, function code:", sourceCode);
        delete sch.parse;
        delete sch.parseName;
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
      return sch;
    }
    exports.default = compileParser;
    var undef = (0, codegen_1._)`undefined`;
    function parserFunction(cxt) {
      const { gen, parseName, char: char2 } = cxt;
      gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
        gen.let(names_1.default.data);
        gen.let(char2);
        gen.assign((0, codegen_1._)`${parseName}.message`, undef);
        gen.assign((0, codegen_1._)`${parseName}.position`, undef);
        gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
        gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
        parseCode(cxt);
        skipWhitespace(cxt);
        gen.if(names_1.default.jsonPart, () => {
          gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
          gen.return(names_1.default.data);
        });
        gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
        jsonSyntaxError(cxt);
      });
    }
    function parseCode(cxt) {
      let form;
      for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
          form = key;
          break;
        }
      }
      if (form)
        parseNullable(cxt, genParse[form]);
      else
        parseEmpty(cxt);
    }
    var parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
    function parseNullable(cxt, parseForm) {
      const { gen, schema, data } = cxt;
      if (!schema.nullable)
        return parseForm(cxt);
      tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
    }
    function parseElements(cxt) {
      const { gen, schema, data } = cxt;
      parseToken(cxt, "[");
      const ix = gen.let("i", 0);
      gen.assign(data, (0, codegen_1._)`[]`);
      parseItems(cxt, "]", () => {
        const el = gen.let("el");
        parseCode({ ...cxt, schema: schema.elements, data: el });
        gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);
      });
    }
    function parseValues(cxt) {
      const { gen, schema, data } = cxt;
      parseToken(cxt, "{");
      gen.assign(data, (0, codegen_1._)`{}`);
      parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
    }
    function parseItems(cxt, endToken, block) {
      tryParseItems(cxt, endToken, block);
      parseToken(cxt, endToken);
    }
    function tryParseItems(cxt, endToken, block) {
      const { gen } = cxt;
      gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
        block();
        tryParseToken(cxt, ",", () => gen.break(), hasItem);
      });
      function hasItem() {
        tryParseToken(cxt, endToken, () => {
        }, jsonSyntaxError);
      }
    }
    function parseKeyValue(cxt, schema) {
      const { gen } = cxt;
      const key = gen.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      parsePropertyValue(cxt, key, schema);
    }
    function parseDiscriminator(cxt) {
      const { gen, data, schema } = cxt;
      const { discriminator, mapping } = schema;
      parseToken(cxt, "{");
      gen.assign(data, (0, codegen_1._)`{}`);
      const startPos = gen.const("pos", names_1.default.jsonPos);
      const value = gen.let("value");
      const tag = gen.let("tag");
      tryParseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if(
          (0, codegen_1._)`${key} === ${discriminator}`,
          () => {
            parseString({ ...cxt, data: tag });
            gen.assign((0, codegen_1._)`${data}[${key}]`, tag);
            gen.break();
          },
          () => parseEmpty({ ...cxt, data: value })
          // can be discarded/skipped
        );
      });
      gen.assign(names_1.default.jsonPos, startPos);
      gen.if((0, codegen_1._)`${tag} === undefined`);
      parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
      }
      gen.else();
      parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
      gen.endIf();
    }
    function parseProperties(cxt) {
      const { gen, data } = cxt;
      parseToken(cxt, "{");
      gen.assign(data, (0, codegen_1._)`{}`);
      parseSchemaProperties(cxt);
    }
    function parseSchemaProperties(cxt, discriminator) {
      const { gen, schema, data } = cxt;
      const { properties, optionalProperties, additionalProperties } = schema;
      parseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
          gen.elseIf((0, codegen_1._)`${key} === ${discriminator}`);
          const tag = gen.let("tag");
          parseString({ ...cxt, data: tag });
        }
        gen.else();
        if (additionalProperties) {
          parseEmpty({ ...cxt, data: (0, codegen_1._)`${data}[${key}]` });
        } else {
          parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
        }
        gen.endIf();
      });
      if (properties) {
        const hasProp = (0, code_1.hasPropFunc)(gen);
        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p2) => (0, codegen_1._)`${hasProp}.call(${data}, ${p2})`));
        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
      }
    }
    function parseDefinedProperty(cxt, key, schemas = {}) {
      const { gen } = cxt;
      for (const prop in schemas) {
        gen.elseIf((0, codegen_1._)`${key} === ${prop}`);
        parsePropertyValue(cxt, key, schemas[prop]);
      }
    }
    function parsePropertyValue(cxt, key, schema) {
      parseCode({ ...cxt, schema, data: (0, codegen_1._)`${cxt.data}[${key}]` });
    }
    function parseType(cxt) {
      const { gen, schema, data, self: self2 } = cxt;
      switch (schema.type) {
        case "boolean":
          parseBoolean(cxt);
          break;
        case "string":
          parseString(cxt);
          break;
        case "timestamp": {
          parseString(cxt);
          const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
          const { allowDate, parseDate } = self2.opts;
          const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;
          const fail2 = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;
          gen.if(fail2, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
          break;
        }
        case "float32":
        case "float64":
          parseNumber(cxt);
          break;
        default: {
          const t = schema.type;
          if (!self2.opts.int32range && (t === "int32" || t === "uint32")) {
            parseNumber(cxt, 16);
            if (t === "uint32") {
              gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
            }
          } else {
            const [min, max, maxDigits] = type_1.intRange[t];
            parseNumber(cxt, maxDigits);
            gen.if((0, codegen_1._)`${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
          }
        }
      }
    }
    function parseString(cxt) {
      parseToken(cxt, '"');
      parseWith(cxt, parseJson_1.parseJsonString);
    }
    function parseEnum(cxt) {
      const { gen, data, schema } = cxt;
      const enumSch = schema.enum;
      parseToken(cxt, '"');
      gen.if(false);
      for (const value of enumSch) {
        const valueStr = JSON.stringify(value).slice(1);
        gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
        gen.assign(data, (0, codegen_1.str)`${value}`);
        gen.add(names_1.default.jsonPos, valueStr.length);
      }
      gen.else();
      jsonSyntaxError(cxt);
      gen.endIf();
    }
    function parseNumber(cxt, maxDigits) {
      const { gen } = cxt;
      skipWhitespace(cxt);
      gen.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
    }
    function parseBooleanToken(bool, fail2) {
      return (cxt) => {
        const { gen, data } = cxt;
        tryParseToken(cxt, `${bool}`, () => fail2(cxt), () => gen.assign(data, bool));
      };
    }
    function parseRef(cxt) {
      const { gen, self: self2, definitions, schema, schemaEnv } = cxt;
      const { ref } = schema;
      const refSchema = definitions[ref];
      if (!refSchema)
        throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
      if (!(0, ref_1.hasRef)(refSchema))
        return parseCode({ ...cxt, schema: refSchema });
      const { root } = schemaEnv;
      const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
      partialParse(cxt, getParser(gen, sch), true);
    }
    function getParser(gen, sch) {
      return sch.parse ? gen.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.parse`;
    }
    function parseEmpty(cxt) {
      parseWith(cxt, parseJson_1.parseJson);
    }
    function parseWith(cxt, parseFunc, args) {
      partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
    }
    function partialParse(cxt, parseFunc, args) {
      const { gen, data } = cxt;
      gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
      gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
      gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
    }
    function parseToken(cxt, tok) {
      tryParseToken(cxt, tok, jsonSyntaxError);
    }
    function tryParseToken(cxt, tok, fail2, success2) {
      const { gen } = cxt;
      const n = tok.length;
      skipWhitespace(cxt);
      gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {
        gen.add(names_1.default.jsonPos, n);
        success2 === null || success2 === void 0 ? void 0 : success2(cxt);
      }, () => fail2(cxt));
    }
    function skipWhitespace({ gen, char: c }) {
      gen.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
    }
    function jsonSlice(len) {
      return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
    }
    function jsonSyntaxError(cxt) {
      parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
    }
    function parsingError({ gen, parseName }, msg) {
      gen.assign((0, codegen_1._)`${parseName}.message`, msg);
      gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
      gen.return(undef);
    }
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/jtd.js
var require_jtd2 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/jtd.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var jtd_1 = require_jtd();
    var jtd_schema_1 = require_jtd_schema();
    var serialize_1 = require_serialize();
    var parse_1 = require_parse();
    var META_SCHEMA_ID = "JTD-meta-schema";
    var Ajv = class extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          jtd: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        this.addVocabulary(jtd_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
      compileSerializer(schema) {
        const sch = this._addSchema(schema);
        return sch.serialize || this._compileSerializer(sch);
      }
      compileParser(schema) {
        const sch = this._addSchema(schema);
        return sch.parse || this._compileParser(sch);
      }
      _compileSerializer(sch) {
        serialize_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.serialize)
          throw new Error("ajv implementation error");
        return sch.serialize;
      }
      _compileParser(sch) {
        parse_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.parse)
          throw new Error("ajv implementation error");
        return sch.parse;
      }
    };
    exports.Ajv = Ajv;
    module.exports = exports = Ajv;
    module.exports.Ajv = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js
var require_default_ajv_options = __commonJS({
  "node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js"(exports, module) {
    "use strict";
    var fastUri = require_fast_uri();
    module.exports = Object.freeze({
      coerceTypes: "array",
      useDefaults: true,
      removeAdditional: true,
      uriResolver: fastUri,
      addUsedSchema: false,
      // Explicitly set allErrors to `false`.
      // When set to `true`, a DoS attack is possible.
      allErrors: false
    });
  }
});

// node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/lib/validator-compiler.js
var require_validator_compiler = __commonJS({
  "node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/lib/validator-compiler.js"(exports, module) {
    "use strict";
    var Ajv = require_ajv().default;
    var AjvJTD = require_jtd2();
    var defaultAjvOptions = require_default_ajv_options();
    var ValidatorCompiler = class {
      constructor(externalSchemas, options) {
        if (options.mode === "JTD") {
          this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
        } else {
          this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
        }
        let addFormatPlugin = true;
        if (options.plugins && options.plugins.length > 0) {
          for (const plugin of options.plugins) {
            if (Array.isArray(plugin)) {
              addFormatPlugin = addFormatPlugin && plugin[0].name !== "formatsPlugin";
              plugin[0](this.ajv, plugin[1]);
            } else {
              addFormatPlugin = addFormatPlugin && plugin.name !== "formatsPlugin";
              plugin(this.ajv);
            }
          }
        }
        if (addFormatPlugin) {
          require_dist2()(this.ajv);
        }
        options.onCreate?.(this.ajv);
        const sourceSchemas = Object.values(externalSchemas);
        for (const extSchema of sourceSchemas) {
          this.ajv.addSchema(extSchema);
        }
      }
      buildValidatorFunction({
        schema
        /*, method, url, httpPart */
      }) {
        if (schema.$id) {
          const stored = this.ajv.getSchema(schema.$id);
          if (stored) {
            return stored;
          }
        }
        return this.ajv.compile(schema);
      }
    };
    module.exports = ValidatorCompiler;
  }
});

// node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js
var require_serializer_compiler = __commonJS({
  "node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js"(exports, module) {
    "use strict";
    var AjvJTD = require_jtd2();
    var defaultAjvOptions = require_default_ajv_options();
    var SerializerCompiler = class {
      constructor(_externalSchemas, options) {
        this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));
      }
      buildSerializerFunction({
        schema
        /*, method, url, httpStatus */
      }) {
        return this.ajv.compileSerializer(schema);
      }
    };
    module.exports = SerializerCompiler;
  }
});

// node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/standalone/index.js
var require_standalone3 = __commonJS({
  "node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/standalone/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var scope_1 = require_scope();
    var code_1 = require_code();
    function standaloneCode(ajv, refsOrFunc) {
      if (!ajv.opts.code.source) {
        throw new Error("moduleCode: ajv instance must have code.source option");
      }
      const { _n } = ajv.scope.opts;
      return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== void 0 ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, (sch) => sch.meta ? void 0 : ajv.compile(sch.schema));
      function getValidate(id) {
        const v2 = ajv.getSchema(id);
        if (!v2)
          throw new Error(`moduleCode: no schema with id ${id}`);
        return v2;
      }
      function funcExportCode(source) {
        const usedValues = {};
        const n = source === null || source === void 0 ? void 0 : source.validateName;
        const vCode = validateCode(usedValues, source);
        if (ajv.opts.code.esm) {
          return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
        }
        return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
      }
      function multiExportsCode(schemas, getValidateFunc) {
        var _a3;
        const usedValues = {};
        let code = (0, code_1._)`"use strict";`;
        for (const name in schemas) {
          const v2 = getValidateFunc(schemas[name]);
          if (v2) {
            const vCode = validateCode(usedValues, v2.source);
            const exportSyntax = ajv.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;
            code = (0, code_1._)`${code}${_n}${exportSyntax} = ${(_a3 = v2.source) === null || _a3 === void 0 ? void 0 : _a3.validateName};${_n}${vCode}`;
          }
        }
        return `${code}`;
      }
      function validateCode(usedValues, s) {
        if (!s)
          throw new Error('moduleCode: function does not have "source" property');
        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
          return code_1.nil;
        setUsedState(s.validateName, scope_1.UsedValueState.Started);
        const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
        const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
        return s.evaluated ? (0, code_1._)`${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;
        function refValidateCode(n) {
          var _a3;
          const vRef = (_a3 = n.value) === null || _a3 === void 0 ? void 0 : _a3.ref;
          if (n.prefix === "validate" && typeof vRef == "function") {
            const v2 = vRef;
            return validateCode(usedValues, v2.source);
          } else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
            const { validate, validateName } = vRef;
            if (!validateName)
              throw new Error("ajv internal error");
            const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
            const wrapper = (0, code_1._)`${def} ${n} = {validate: ${validateName}};`;
            if (usedState(validateName) === scope_1.UsedValueState.Started)
              return wrapper;
            const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
            return (0, code_1._)`${wrapper}${_n}${vCode}`;
          }
          return void 0;
        }
        function usedState(name) {
          var _a3;
          return (_a3 = usedValues[name.prefix]) === null || _a3 === void 0 ? void 0 : _a3.get(name);
        }
        function setUsedState(name, state) {
          const { prefix } = name;
          const names = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          names.set(name, state);
        }
      }
    }
    module.exports = exports = standaloneCode;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = standaloneCode;
  }
});

// node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/standalone.js
var require_standalone4 = __commonJS({
  "node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/standalone.js"(exports, module) {
    "use strict";
    var ValidatorSelector = require_ajv_compiler();
    var standaloneCode = require_standalone3().default;
    function StandaloneValidator(options = { readMode: true }) {
      if (options.readMode === true && !options.restoreFunction) {
        throw new Error("You must provide a restoreFunction options when readMode ON");
      }
      if (options.readMode !== true && !options.storeFunction) {
        throw new Error("You must provide a storeFunction options when readMode OFF");
      }
      if (options.readMode === true) {
        return function wrapper() {
          return function(opts) {
            return options.restoreFunction(opts);
          };
        };
      }
      const factory = ValidatorSelector();
      return function wrapper(externalSchemas, ajvOptions = {}) {
        if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
          ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
        }
        const compiler = factory(externalSchemas, ajvOptions);
        return function(opts) {
          const validationFunc = compiler(opts);
          const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
          options.storeFunction(opts, schemaValidationCode);
          return validationFunc;
        };
      };
    }
    module.exports = StandaloneValidator;
  }
});

// node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/index.js
var require_ajv_compiler = __commonJS({
  "node_modules/.pnpm/@fastify+ajv-compiler@4.0.5/node_modules/@fastify/ajv-compiler/index.js"(exports, module) {
    "use strict";
    var AjvReference = /* @__PURE__ */ Symbol.for("fastify.ajv-compiler.reference");
    var ValidatorCompiler = require_validator_compiler();
    var SerializerCompiler = require_serializer_compiler();
    function AjvCompiler(opts) {
      const validatorPool = /* @__PURE__ */ new Map();
      const serializerPool = /* @__PURE__ */ new Map();
      if (opts && opts.jtdSerializer === true) {
        return function buildSerializerFromPool(externalSchemas, serializerOpts) {
          const uniqueAjvKey = getPoolKey({}, serializerOpts);
          if (serializerPool.has(uniqueAjvKey)) {
            return serializerPool.get(uniqueAjvKey);
          }
          const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
          const ret = compiler.buildSerializerFunction.bind(compiler);
          serializerPool.set(uniqueAjvKey, ret);
          return ret;
        };
      }
      return function buildCompilerFromPool(externalSchemas, options) {
        const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
        if (validatorPool.has(uniqueAjvKey)) {
          return validatorPool.get(uniqueAjvKey);
        }
        const compiler = new ValidatorCompiler(externalSchemas, options);
        const ret = compiler.buildValidatorFunction.bind(compiler);
        validatorPool.set(uniqueAjvKey, ret);
        if (options.customOptions.code !== void 0) {
          ret[AjvReference] = compiler;
        }
        return ret;
      };
    }
    function getPoolKey(externalSchemas, options) {
      const externals = JSON.stringify(externalSchemas);
      const ajvConfig = JSON.stringify(options);
      return `${externals}${ajvConfig}`;
    }
    module.exports = AjvCompiler;
    module.exports.default = AjvCompiler;
    module.exports.AjvCompiler = AjvCompiler;
    module.exports.AjvReference = AjvReference;
    module.exports.StandaloneValidator = require_standalone4();
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/schema-controller.js
var require_schema_controller = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/schema-controller.js"(exports, module) {
    "use strict";
    var { buildSchemas } = require_schemas();
    var SerializerSelector = require_fast_json_stringify_compiler();
    var ValidatorSelector = require_ajv_compiler();
    function buildSchemaController(parentSchemaCtrl, opts) {
      if (parentSchemaCtrl) {
        return new SchemaController(parentSchemaCtrl, opts);
      }
      const compilersFactory = Object.assign({
        buildValidator: null,
        buildSerializer: null
      }, opts?.compilersFactory);
      if (!compilersFactory.buildValidator) {
        compilersFactory.buildValidator = ValidatorSelector();
      }
      if (!compilersFactory.buildSerializer) {
        compilersFactory.buildSerializer = SerializerSelector();
      }
      const option = {
        bucket: opts && opts.bucket || buildSchemas,
        compilersFactory,
        isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === "function",
        isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === "function"
      };
      return new SchemaController(void 0, option);
    }
    var SchemaController = class {
      constructor(parent, options) {
        this.opts = options || parent?.opts;
        this.addedSchemas = false;
        this.compilersFactory = this.opts.compilersFactory;
        if (parent) {
          this.schemaBucket = this.opts.bucket(parent.getSchemas());
          this.validatorCompiler = parent.getValidatorCompiler();
          this.serializerCompiler = parent.getSerializerCompiler();
          this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
          this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
          this.parent = parent;
        } else {
          this.schemaBucket = this.opts.bucket();
          this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
          this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
        }
      }
      // Bucket interface
      add(schema) {
        this.addedSchemas = true;
        return this.schemaBucket.add(schema);
      }
      getSchema(schemaId) {
        return this.schemaBucket.getSchema(schemaId);
      }
      getSchemas() {
        return this.schemaBucket.getSchemas();
      }
      setValidatorCompiler(validatorCompiler2) {
        this.compilersFactory = Object.assign(
          {},
          this.compilersFactory,
          { buildValidator: () => validatorCompiler2 }
        );
        this.validatorCompiler = validatorCompiler2;
        this.isCustomValidatorCompiler = true;
      }
      setSerializerCompiler(serializerCompiler2) {
        this.compilersFactory = Object.assign(
          {},
          this.compilersFactory,
          { buildSerializer: () => serializerCompiler2 }
        );
        this.serializerCompiler = serializerCompiler2;
        this.isCustomSerializerCompiler = true;
      }
      getValidatorCompiler() {
        return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
      }
      getSerializerCompiler() {
        return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
      }
      getSerializerBuilder() {
        return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
      }
      getValidatorBuilder() {
        return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
      }
      /**
       * This method will be called when a validator must be setup.
       * Do not setup the compiler more than once
       * @param {object} serverOptions the fastify server options
       */
      setupValidator(serverOptions) {
        const isReady = this.validatorCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
      }
      /**
       * This method will be called when a serializer must be setup.
       * Do not setup the compiler more than once
       * @param {object} serverOptions the fastify server options
       */
      setupSerializer(serverOptions) {
        const isReady = this.serializerCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
      }
    };
    SchemaController.buildSchemaController = buildSchemaController;
    module.exports = SchemaController;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug2();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R++;
      debug(name, index2, value);
      t[name] = index2;
      src[index2] = value;
      safeSrc[index2] = safe;
      re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    var numeric2 = /^[0-9]+$/;
    var compareIdentifiers = (a2, b2) => {
      if (typeof a2 === "number" && typeof b2 === "number") {
        return a2 === b2 ? 0 : a2 < b2 ? -1 : 1;
      }
      const anum = numeric2.test(a2);
      const bnum = numeric2.test(b2);
      if (anum && bnum) {
        a2 = +a2;
        b2 = +b2;
      }
      return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
    };
    var rcompareIdentifiers = (a2, b2) => compareIdentifiers(b2, a2);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a2 = this.prerelease[i];
          const b2 = other.prerelease[i];
          debug("prerelease compare", i, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a2 = this.build[i];
          const b2 = other.build[i];
          debug("build compare", i, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match2 = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match2 || match2[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse3;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    var parse3 = require_parse2();
    var valid = (version3, options) => {
      const v2 = parse3(version3, options);
      return v2 ? v2.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    var parse3 = require_parse2();
    var clean = (version3, options) => {
      const s = parse3(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version3, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    var parse3 = require_parse2();
    var diff = (version1, version22) => {
      const v1 = parse3(version1, null, true);
      const v2 = parse3(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var major = (a2, loose) => new SemVer(a2, loose).major;
    module.exports = major;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a2, loose) => new SemVer(a2, loose).minor;
    module.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a2, loose) => new SemVer(a2, loose).patch;
    module.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    var parse3 = require_parse2();
    var prerelease = (version3, options) => {
      const parsed = parse3(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose));
    module.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a2, b2, loose) => compare(b2, a2, loose);
    module.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a2, b2) => compare(a2, b2, true);
    module.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a2, b2, loose) => {
      const versionA = new SemVer(a2, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a2, b2) => compareBuild(a2, b2, loose));
    module.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a2, b2) => compareBuild(b2, a2, loose));
    module.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gt5 = (a2, b2, loose) => compare(a2, b2, loose) > 0;
    module.exports = gt5;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lt2 = (a2, b2, loose) => compare(a2, b2, loose) < 0;
    module.exports = lt2;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var eq2 = (a2, b2, loose) => compare(a2, b2, loose) === 0;
    module.exports = eq2;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var neq = (a2, b2, loose) => compare(a2, b2, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gte2 = (a2, b2, loose) => compare(a2, b2, loose) >= 0;
    module.exports = gte2;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lte2 = (a2, b2, loose) => compare(a2, b2, loose) <= 0;
    module.exports = lte2;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq2 = require_eq();
    var neq = require_neq();
    var gt5 = require_gt();
    var gte2 = require_gte();
    var lt2 = require_lt();
    var lte2 = require_lte();
    var cmp = (a2, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 === b2;
        case "!==":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 !== b2;
        case "":
        case "=":
        case "==":
          return eq2(a2, b2, loose);
        case "!=":
          return neq(a2, b2, loose);
        case ">":
          return gt5(a2, b2, loose);
        case ">=":
          return gte2(a2, b2, loose);
        case "<":
          return lt2(a2, b2, loose);
        case "<=":
          return lte2(a2, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = require_parse2();
    var { safeRe: re, t } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version3)) && (!match2 || match2.index + match2[0].length !== version3.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      const major = match2[2];
      const minor = match2[3] || "0";
      const patch = match2[4] || "0";
      const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
      const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached2 = cache.get(memoKey);
        if (cached2) {
          return cached2;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m2, p2, pr) => {
        debug("tilde", comp, _, M, m2, p2, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.${p2} <${M}.${+m2 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m2, p2, pr) => {
        debug("caret", comp, _, M, m2, p2, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M === "0") {
            ret = `>=${M}.${m2}.0${z2} <${M}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M}.${m2}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p2}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p2}${z2} <${M}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p2}${z2} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p2} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m2, p2, pr) => {
        debug("xRange", comp, ret, gtlt, M, m2, p2, pr);
        const xM = isX(M);
        const xm = xM || isX(m2);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p2 = 0;
            } else {
              m2 = +m2 + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m2}.${p2}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version3, options) => {
      for (let i = 0; i < set2.length; i++) {
        if (!set2[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set2.length; i++) {
          debug(set2[i].semver);
          if (set2[i].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i].semver.prerelease.length > 0) {
            const allowed = set2[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = /* @__PURE__ */ Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m2 = comp.match(r);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    };
    module.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!max || maxSV.compare(v2) === -1) {
            max = v2;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!min || minSV.compare(v2) === 1) {
            min = v2;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt5 = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt5(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt5(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt5 = require_gt();
    var lt2 = require_lt();
    var lte2 = require_lte();
    var gte2 = require_gte();
    var outside = (version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt5;
          ltefn = lte2;
          ltfn = lt2;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt2;
          ltefn = gte2;
          ltfn = gt5;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var gtr = (version3, range, options) => outside(version3, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var ltr = (version3, range, options) => outside(version3, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v2 = versions.sort((a2, b2) => compare(a2, b2, options));
      for (const version3 of v2) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v2[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v2[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt5, lt2;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt5 = higherGT(gt5, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt2 = lowerLT(lt2, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt5 && lt2) {
        gtltComp = compare(gt5.semver, lt2.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt5.operator !== ">=" || lt2.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt5 && !satisfies(eq2, String(gt5), options)) {
          return null;
        }
        if (lt2 && !satisfies(eq2, String(lt2), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq2, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
      let needDomGTPre = gt5 && !options.includePrerelease && gt5.semver.prerelease.length ? gt5.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt5) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt5, c, options);
            if (higher === c && higher !== gt5) {
              return false;
            }
          } else if (gt5.operator === ">=" && !satisfies(gt5.semver, String(c), options)) {
            return false;
          }
        }
        if (lt2) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt2, c, options);
            if (lower === c && lower !== lt2) {
              return false;
            }
          } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt2 || gt5) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt5 && hasDomLT && !lt2 && gtltComp !== 0) {
        return false;
      }
      if (lt2 && hasDomGT && !gt5 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a2, b2, options) => {
      if (!a2) {
        return b2;
      }
      const comp = compare(a2.semver, b2.semver, options);
      return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
    };
    var lowerLT = (a2, b2, options) => {
      if (!a2) {
        return b2;
      }
      const comp = compare(a2.semver, b2.semver, options);
      return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
    };
    module.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js"(exports, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse2();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt5 = require_gt();
    var lt2 = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte2 = require_gte();
    var lte2 = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt5,
      lt: lt2,
      eq: eq2,
      neq,
      gte: gte2,
      lte: lte2,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/pluginUtils.js
var require_pluginUtils = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/pluginUtils.js"(exports, module) {
    "use strict";
    var semver = require_semver2();
    var assert2 = __require("node:assert");
    var kRegisteredPlugins = /* @__PURE__ */ Symbol.for("registered-plugin");
    var {
      kTestInternals
    } = require_symbols2();
    var { exist, existReply, existRequest } = require_decorate();
    var {
      FST_ERR_PLUGIN_VERSION_MISMATCH,
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
    } = require_errors2();
    var rcRegex = /-(?:rc|pre|alpha).+$/u;
    function getMeta(fn) {
      return fn[/* @__PURE__ */ Symbol.for("plugin-meta")];
    }
    function getPluginName(func) {
      const display = getDisplayName(func);
      if (display) {
        return display;
      }
      const cache = __require.cache;
      if (cache) {
        const keys = Object.keys(cache);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (cache[key].exports === func) {
            return key;
          }
        }
      }
      if (func.name) {
        return func.name;
      }
      return null;
    }
    function getFuncPreview(func) {
      return func.toString().split("\n", 2).map((s) => s.trim()).join(" -- ");
    }
    function getDisplayName(fn) {
      return fn[/* @__PURE__ */ Symbol.for("fastify.display-name")];
    }
    function shouldSkipOverride(fn) {
      return !!fn[/* @__PURE__ */ Symbol.for("skip-override")];
    }
    function checkDependencies(fn) {
      const meta3 = getMeta(fn);
      if (!meta3) return;
      const dependencies = meta3.dependencies;
      if (!dependencies) return;
      assert2(Array.isArray(dependencies), "The dependencies should be an array of strings");
      dependencies.forEach((dependency) => {
        assert2(
          this[kRegisteredPlugins].indexOf(dependency) > -1,
          `The dependency '${dependency}' of plugin '${meta3.name}' is not registered`
        );
      });
    }
    function checkDecorators(fn) {
      const meta3 = getMeta(fn);
      if (!meta3) return;
      const { decorators, name } = meta3;
      if (!decorators) return;
      if (decorators.fastify) _checkDecorators(this, "Fastify", decorators.fastify, name);
      if (decorators.reply) _checkDecorators(this, "Reply", decorators.reply, name);
      if (decorators.request) _checkDecorators(this, "Request", decorators.request, name);
    }
    var checks = {
      Fastify: exist,
      Request: existRequest,
      Reply: existReply
    };
    function _checkDecorators(that, instance, decorators, name) {
      assert2(Array.isArray(decorators), "The decorators should be an array of strings");
      decorators.forEach((decorator) => {
        const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
        if (!checks[instance].call(that, decorator)) {
          throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance);
        }
      });
    }
    function checkVersion(fn) {
      const meta3 = getMeta(fn);
      if (meta3?.fastify == null) return;
      const requiredVersion = meta3.fastify;
      const fastifyRc = rcRegex.test(this.version);
      if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
        return;
      }
      if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
        throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta3.name, requiredVersion, this.version);
      }
    }
    function registerPluginName(fn) {
      const meta3 = getMeta(fn);
      if (!meta3) return;
      const name = meta3.name;
      if (!name) return;
      this[kRegisteredPlugins].push(name);
      return name;
    }
    function checkPluginHealthiness(fn, pluginName) {
      if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
        throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName);
      }
    }
    function registerPlugin(fn) {
      const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
      checkPluginHealthiness.call(this, fn, pluginName);
      checkVersion.call(this, fn);
      checkDecorators.call(this, fn);
      checkDependencies.call(this, fn);
      return shouldSkipOverride(fn);
    }
    module.exports = {
      getPluginName,
      getFuncPreview,
      kRegisteredPlugins,
      getDisplayName,
      registerPlugin
    };
    module.exports[kTestInternals] = {
      shouldSkipOverride,
      getMeta,
      checkDecorators,
      checkDependencies
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/reqIdGenFactory.js
var require_reqIdGenFactory = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/reqIdGenFactory.js"(exports, module) {
    "use strict";
    function reqIdGenFactory(requestIdHeader, optGenReqId) {
      const genReqId = optGenReqId || buildDefaultGenReqId();
      if (requestIdHeader) {
        return buildOptionalHeaderReqId(requestIdHeader, genReqId);
      }
      return genReqId;
    }
    function getGenReqId(contextServer, req) {
      return contextServer.genReqId(req);
    }
    function buildDefaultGenReqId() {
      const maxInt = 2147483647;
      let nextReqId = 0;
      return function defaultGenReqId() {
        nextReqId = nextReqId + 1 & maxInt;
        return `req-${nextReqId.toString(36)}`;
      };
    }
    function buildOptionalHeaderReqId(requestIdHeader, genReqId) {
      return function(req) {
        return req.headers[requestIdHeader] || genReqId(req);
      };
    }
    module.exports = {
      getGenReqId,
      reqIdGenFactory
    };
  }
});

// node_modules/.pnpm/fast-decode-uri-component@1.0.1/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS({
  "node_modules/.pnpm/fast-decode-uri-component@1.0.1/node_modules/fast-decode-uri-component/index.js"(exports, module) {
    "use strict";
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      var percentPosition = uri.indexOf("%");
      if (percentPosition === -1) return uri;
      var length = uri.length;
      var decoded = "";
      var last = 0;
      var codepoint = 0;
      var startOfOctets = percentPosition;
      var state = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        var high = hexCodeToInt(uri[percentPosition + 1], 4);
        var low = hexCodeToInt(uri[percentPosition + 2], 0);
        var byte = high | low;
        var type = UTF8_DATA[byte];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
            55232 + (codepoint >> 10),
            56320 + (codepoint & 1023)
          );
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    function hexCodeToInt(c, shift) {
      var i = HEX[c];
      return i === void 0 ? 255 : i << shift;
    }
    module.exports = decodeURIComponent2;
  }
});

// node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/parse.js"(exports, module) {
    "use strict";
    var fastDecode = require_fast_decode_uri_component();
    var plusRegex = /\+/g;
    var Empty = function() {
    };
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function parse3(input) {
      const result = new Empty();
      if (typeof input !== "string") {
        return result;
      }
      let inputLength = input.length;
      let key = "";
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let shouldDecodeKey = false;
      let shouldDecodeValue = false;
      let keyHasPlus = false;
      let valueHasPlus = false;
      let hasBothKeyValuePair = false;
      let c = 0;
      for (let i = 0; i < inputLength + 1; i++) {
        c = i !== inputLength ? input.charCodeAt(i) : 38;
        if (c === 38) {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair) {
            equalityIndex = i;
          }
          key = input.slice(startingIndex + 1, equalityIndex);
          if (hasBothKeyValuePair || key.length > 0) {
            if (keyHasPlus) {
              key = key.replace(plusRegex, " ");
            }
            if (shouldDecodeKey) {
              key = fastDecode(key) || key;
            }
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (valueHasPlus) {
                value = value.replace(plusRegex, " ");
              }
              if (shouldDecodeValue) {
                value = fastDecode(value) || value;
              }
            }
            const currentValue = result[key];
            if (currentValue === void 0) {
              result[key] = value;
            } else {
              if (currentValue.pop) {
                currentValue.push(value);
              } else {
                result[key] = [currentValue, value];
              }
            }
          }
          value = "";
          startingIndex = i;
          equalityIndex = i;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
        } else if (c === 61) {
          if (equalityIndex <= startingIndex) {
            equalityIndex = i;
          } else {
            shouldDecodeValue = true;
          }
        } else if (c === 43) {
          if (equalityIndex > startingIndex) {
            valueHasPlus = true;
          } else {
            keyHasPlus = true;
          }
        } else if (c === 37) {
          if (equalityIndex > startingIndex) {
            shouldDecodeValue = true;
          } else {
            shouldDecodeKey = true;
          }
        }
      }
      return result;
    }
    module.exports = parse3;
  }
});

// node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS({
  "node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/internals/querystring.js"(exports, module) {
    var hexTable = Array.from(
      { length: 256 },
      (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
    );
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // 80 - 95
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
      // 112 - 127
    ]);
    function encodeString(str) {
      const len = str.length;
      if (len === 0) return "";
      let out = "";
      let lastPos = 0;
      let i = 0;
      outer: for (; i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i) out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len) break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      if (lastPos === 0) return str;
      if (lastPos < len) return out + str.slice(lastPos);
      return out;
    }
    module.exports = { encodeString };
  }
});

// node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/stringify.js"(exports, module) {
    "use strict";
    var { encodeString } = require_querystring();
    function getAsPrimitive(value) {
      const type = typeof value;
      if (type === "string") {
        return encodeString(value);
      } else if (type === "bigint") {
        return value.toString();
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "number" && Number.isFinite(value)) {
        return value < 1e21 ? "" + value : encodeString("" + value);
      }
      return "";
    }
    function stringify(input) {
      let result = "";
      if (input === null || typeof input !== "object") {
        return result;
      }
      const separator = "&";
      const keys = Object.keys(input);
      const keyLength = keys.length;
      let valueLength = 0;
      for (let i = 0; i < keyLength; i++) {
        const key = keys[i];
        const value = input[key];
        const encodedKey = encodeString(key) + "=";
        if (i) {
          result += separator;
        }
        if (Array.isArray(value)) {
          valueLength = value.length;
          for (let j = 0; j < valueLength; j++) {
            if (j) {
              result += separator;
            }
            result += encodedKey;
            result += getAsPrimitive(value[j]);
          }
        } else {
          result += encodedKey;
          result += getAsPrimitive(value);
        }
      }
      return result;
    }
    module.exports = stringify;
  }
});

// node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/index.js"(exports, module) {
    "use strict";
    var parse3 = require_parse3();
    var stringify = require_stringify();
    var fastQuerystring = {
      parse: parse3,
      stringify
    };
    module.exports = fastQuerystring;
    module.exports.default = fastQuerystring;
    module.exports.parse = parse3;
    module.exports.stringify = stringify;
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/tokens.js
var require_tokens = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/tokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/types.js
var require_types3 = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = void 0;
    var types;
    (function(types2) {
      types2[types2["ROOT"] = 0] = "ROOT";
      types2[types2["GROUP"] = 1] = "GROUP";
      types2[types2["POSITION"] = 2] = "POSITION";
      types2[types2["SET"] = 3] = "SET";
      types2[types2["RANGE"] = 4] = "RANGE";
      types2[types2["REPETITION"] = 5] = "REPETITION";
      types2[types2["REFERENCE"] = 6] = "REFERENCE";
      types2[types2["CHAR"] = 7] = "CHAR";
    })(types = exports.types || (exports.types = {}));
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/set-lookup.js
var require_set_lookup = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/set-lookup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/index.js
var require_types4 = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_tokens(), exports);
    __exportStar(require_types3(), exports);
    __exportStar(require_set_lookup(), exports);
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets.js
var require_sets = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.anyChar = exports.notWhitespace = exports.whitespace = exports.notInts = exports.ints = exports.notWords = exports.words = void 0;
    var types_1 = require_types4();
    var INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
    var WORDS = () => [
      { type: types_1.types.CHAR, value: 95 },
      { type: types_1.types.RANGE, from: 97, to: 122 },
      { type: types_1.types.RANGE, from: 65, to: 90 },
      { type: types_1.types.RANGE, from: 48, to: 57 }
    ];
    var WHITESPACE = () => [
      { type: types_1.types.CHAR, value: 9 },
      { type: types_1.types.CHAR, value: 10 },
      { type: types_1.types.CHAR, value: 11 },
      { type: types_1.types.CHAR, value: 12 },
      { type: types_1.types.CHAR, value: 13 },
      { type: types_1.types.CHAR, value: 32 },
      { type: types_1.types.CHAR, value: 160 },
      { type: types_1.types.CHAR, value: 5760 },
      { type: types_1.types.RANGE, from: 8192, to: 8202 },
      { type: types_1.types.CHAR, value: 8232 },
      { type: types_1.types.CHAR, value: 8233 },
      { type: types_1.types.CHAR, value: 8239 },
      { type: types_1.types.CHAR, value: 8287 },
      { type: types_1.types.CHAR, value: 12288 },
      { type: types_1.types.CHAR, value: 65279 }
    ];
    var NOTANYCHAR = () => [
      { type: types_1.types.CHAR, value: 10 },
      { type: types_1.types.CHAR, value: 13 },
      { type: types_1.types.CHAR, value: 8232 },
      { type: types_1.types.CHAR, value: 8233 }
    ];
    exports.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
    exports.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
    exports.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
    exports.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
    exports.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
    exports.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
    exports.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/util.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    }) : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenizeClass = exports.strToChars = void 0;
    var types_1 = require_types4();
    var sets = __importStar(require_sets());
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    exports.strToChars = (str) => {
      const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      return str.replace(charsRegex, (s, b2, lbs, a16, b16, dctrl, eslsh) => {
        if (lbs) {
          return s;
        }
        let code = b2 ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : dctrl ? CTRL.indexOf(dctrl) : {
          0: 0,
          t: 9,
          n: 10,
          v: 11,
          f: 12,
          r: 13
        }[eslsh];
        let c = String.fromCharCode(code);
        return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
      });
    };
    exports.tokenizeClass = (str, regexpStr) => {
      var _a3, _b, _c, _d, _e, _f, _g;
      let tokens = [], rs, c;
      const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
      while ((rs = regexp.exec(str)) !== null) {
        const p2 = (_g = (_f = (_e = (_d = (_c = (_b = (_a3 = rs[1] && sets.words()) !== null && _a3 !== void 0 ? _a3 : rs[2] && sets.ints()) !== null && _b !== void 0 ? _b : rs[3] && sets.whitespace()) !== null && _c !== void 0 ? _c : rs[4] && sets.notWords()) !== null && _d !== void 0 ? _d : rs[5] && sets.notInts()) !== null && _e !== void 0 ? _e : rs[6] && sets.notWhitespace()) !== null && _f !== void 0 ? _f : rs[7] && {
          type: types_1.types.RANGE,
          from: (rs[8] || rs[9]).charCodeAt(0),
          to: (c = rs[10]).charCodeAt(c.length - 1)
        }) !== null && _g !== void 0 ? _g : (c = rs[16]) && { type: types_1.types.CHAR, value: c.charCodeAt(0) };
        if (p2) {
          tokens.push(p2);
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
    };
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/tokenizer.js
var require_tokenizer = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/tokenizer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    }) : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenizer = void 0;
    var util = __importStar(require_util2());
    var types_1 = require_types4();
    var sets = __importStar(require_sets());
    var captureGroupFirstChar = /^[a-zA-Z_$]$/i;
    var captureGroupChars = /^[a-zA-Z0-9_$]$/i;
    var digit = /\d/;
    exports.tokenizer = (regexpStr) => {
      let i = 0, c;
      let start = { type: types_1.types.ROOT, stack: [] };
      let lastGroup = start;
      let last = start.stack;
      let groupStack = [];
      let referenceQueue = [];
      let groupCount = 0;
      const repeatErr = (col) => {
        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
      };
      let str = util.strToChars(regexpStr);
      while (i < str.length) {
        switch (c = str[i++]) {
          // Handle escaped characters, inclues a few sets.
          case "\\":
            if (i === str.length) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
            }
            switch (c = str[i++]) {
              case "b":
                last.push({ type: types_1.types.POSITION, value: "b" });
                break;
              case "B":
                last.push({ type: types_1.types.POSITION, value: "B" });
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (digit.test(c)) {
                  let digits = c;
                  while (i < str.length && digit.test(str[i])) {
                    digits += str[i++];
                  }
                  let value = parseInt(digits, 10);
                  const reference = { type: types_1.types.REFERENCE, value };
                  last.push(reference);
                  referenceQueue.push({ reference, stack: last, index: last.length - 1 });
                } else {
                  last.push({ type: types_1.types.CHAR, value: c.charCodeAt(0) });
                }
            }
            break;
          // Positionals.
          case "^":
            last.push({ type: types_1.types.POSITION, value: "^" });
            break;
          case "$":
            last.push({ type: types_1.types.POSITION, value: "$" });
            break;
          // Handle custom sets.
          case "[": {
            let not2;
            if (str[i] === "^") {
              not2 = true;
              i++;
            } else {
              not2 = false;
            }
            let classTokens = util.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types_1.types.SET,
              set: classTokens[0],
              not: not2
            });
            break;
          }
          // Class of any character except \n.
          case ".":
            last.push(sets.anyChar());
            break;
          // Push group onto stack.
          case "(": {
            let group = {
              type: types_1.types.GROUP,
              stack: [],
              remember: true
            };
            if (str[i] === "?") {
              c = str[i + 1];
              i += 2;
              if (c === "=") {
                group.followedBy = true;
                group.remember = false;
              } else if (c === "!") {
                group.notFollowedBy = true;
                group.remember = false;
              } else if (c === "<") {
                let name = "";
                if (captureGroupFirstChar.test(str[i])) {
                  name += str[i];
                  i++;
                } else {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
                }
                while (i < str.length && captureGroupChars.test(str[i])) {
                  name += str[i];
                  i++;
                }
                if (!name) {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
                }
                if (str[i] !== ">") {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found '${str[i]}' at column ${i + 1}`);
                }
                group.name = name;
                i++;
              } else if (c === ":") {
                group.remember = false;
              } else {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c}' after '?' at column ${i - 1}`);
              }
            } else {
              groupCount += 1;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          }
          // Pop group out of stack.
          case ")":
            if (groupStack.length === 0) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          // Use pipe character to give more choices.
          case "|": {
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            let stack = [];
            lastGroup.options.push(stack);
            last = stack;
            break;
          }
          // Repetition.
          // For every repetition, remove last element from last stack
          // then insert back a RANGE object.
          // This design is chosen because there could be more than
          // one repetition symbols in a regex i.e. `a?+{2,3}`.
          case "{": {
            let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types_1.types.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types_1.types.CHAR,
                value: 123
              });
            }
            break;
          }
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          // Default is a character that is not `\[](){}?+*^$`.
          default:
            last.push({
              type: types_1.types.CHAR,
              value: c.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
      }
      updateReferences(referenceQueue, groupCount);
      return start;
    };
    function updateReferences(referenceQueue, groupCount) {
      for (const elem of referenceQueue.reverse()) {
        if (groupCount < elem.reference.value) {
          elem.reference.type = types_1.types.CHAR;
          const valueString = elem.reference.value.toString();
          elem.reference.value = parseInt(valueString, 8);
          if (!/^[0-7]+$/.test(valueString)) {
            let i = 0;
            while (valueString[i] !== "8" && valueString[i] !== "9") {
              i += 1;
            }
            if (i === 0) {
              elem.reference.value = valueString.charCodeAt(0);
              i += 1;
            } else {
              elem.reference.value = parseInt(valueString.slice(0, i), 8);
            }
            if (valueString.length > i) {
              const tail = elem.stack.splice(elem.index + 1);
              for (const char2 of valueString.slice(i)) {
                elem.stack.push({
                  type: types_1.types.CHAR,
                  value: char2.charCodeAt(0)
                });
              }
              elem.stack.push(...tail);
            }
          }
        }
      }
    }
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets-lookup.js
var require_sets_lookup = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets-lookup.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    }) : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NOTANYCHAR = exports.WHITESPACE = exports.WORDS = exports.INTS = void 0;
    var Sets = __importStar(require_sets());
    var types_1 = require_types4();
    function setToLookup(tokens) {
      let lookup = {};
      let len = 0;
      for (const token of tokens) {
        if (token.type === types_1.types.CHAR) {
          lookup[token.value] = true;
        }
        if (token.type === types_1.types.RANGE) {
          lookup[`${token.from}-${token.to}`] = true;
        }
        len += 1;
      }
      return {
        lookup: () => Object.assign({}, lookup),
        len
      };
    }
    exports.INTS = setToLookup(Sets.ints().set);
    exports.WORDS = setToLookup(Sets.words().set);
    exports.WHITESPACE = setToLookup(Sets.whitespace().set);
    exports.NOTANYCHAR = setToLookup(Sets.anyChar().set);
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/write-set-tokens.js
var require_write_set_tokens = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/write-set-tokens.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    }) : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeSetTokens = exports.setChar = void 0;
    var types_1 = require_types4();
    var sets = __importStar(require_sets_lookup());
    function setChar(charCode) {
      return charCode === 94 ? "\\^" : charCode === 92 ? "\\\\" : charCode === 93 ? "\\]" : charCode === 45 ? "\\-" : String.fromCharCode(charCode);
    }
    exports.setChar = setChar;
    function isSameSet(set2, { lookup, len }) {
      if (len !== set2.length) {
        return false;
      }
      const map2 = lookup();
      for (const elem of set2) {
        if (elem.type === types_1.types.SET) {
          return false;
        }
        const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
        if (map2[key]) {
          map2[key] = false;
        } else {
          return false;
        }
      }
      return true;
    }
    function writeSetTokens(set2, isNested = false) {
      if (isSameSet(set2.set, sets.INTS)) {
        return set2.not ? "\\D" : "\\d";
      }
      if (isSameSet(set2.set, sets.WORDS)) {
        return set2.not ? "\\W" : "\\w";
      }
      if (set2.not && isSameSet(set2.set, sets.NOTANYCHAR)) {
        return ".";
      }
      if (isSameSet(set2.set, sets.WHITESPACE)) {
        return set2.not ? "\\S" : "\\s";
      }
      let tokenString = "";
      for (let i = 0; i < set2.set.length; i++) {
        const subset = set2.set[i];
        tokenString += writeSetToken(subset);
      }
      const contents = `${set2.not ? "^" : ""}${tokenString}`;
      return isNested ? contents : `[${contents}]`;
    }
    exports.writeSetTokens = writeSetTokens;
    function writeSetToken(set2) {
      if (set2.type === types_1.types.CHAR) {
        return setChar(set2.value);
      } else if (set2.type === types_1.types.RANGE) {
        return `${setChar(set2.from)}-${setChar(set2.to)}`;
      }
      return writeSetTokens(set2, true);
    }
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/reconstruct.js
var require_reconstruct = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/reconstruct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reconstruct = void 0;
    var types_1 = require_types4();
    var write_set_tokens_1 = require_write_set_tokens();
    var reduceStack = (stack) => stack.map(exports.reconstruct).join("");
    var createAlternate = (token) => {
      if ("options" in token) {
        return token.options.map(reduceStack).join("|");
      } else if ("stack" in token) {
        return reduceStack(token.stack);
      } else {
        throw new Error(`options or stack must be Root or Group token`);
      }
    };
    exports.reconstruct = (token) => {
      switch (token.type) {
        case types_1.types.ROOT:
          return createAlternate(token);
        case types_1.types.CHAR: {
          const c = String.fromCharCode(token.value);
          return (/[[\\{}$^.|?*+()]/.test(c) ? "\\" : "") + c;
        }
        case types_1.types.POSITION:
          if (token.value === "^" || token.value === "$") {
            return token.value;
          } else {
            return `\\${token.value}`;
          }
        case types_1.types.REFERENCE:
          return `\\${token.value}`;
        case types_1.types.SET:
          return write_set_tokens_1.writeSetTokens(token);
        case types_1.types.GROUP: {
          const prefix = token.name ? `?<${token.name}>` : token.remember ? "" : token.followedBy ? "?=" : token.notFollowedBy ? "?!" : "?:";
          return `(${prefix}${createAlternate(token)})`;
        }
        case types_1.types.REPETITION: {
          const { min, max } = token;
          let endWith;
          if (min === 0 && max === 1) {
            endWith = "?";
          } else if (min === 1 && max === Infinity) {
            endWith = "+";
          } else if (min === 0 && max === Infinity) {
            endWith = "*";
          } else if (max === Infinity) {
            endWith = `{${min},}`;
          } else if (min === max) {
            endWith = `{${min}}`;
          } else {
            endWith = `{${min},${max}}`;
          }
          return `${exports.reconstruct(token.value)}${endWith}`;
        }
        case types_1.types.RANGE:
          return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
        default:
          throw new Error(`Invalid token type ${token}`);
      }
    };
  }
});

// node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/index.js"(exports, module) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = void 0;
    var types_1 = require_types4();
    Object.defineProperty(exports, "types", { enumerable: true, get: function() {
      return types_1.types;
    } });
    __exportStar(require_tokenizer(), exports);
    __exportStar(require_reconstruct(), exports);
    var tokenizer_1 = require_tokenizer();
    var reconstruct_1 = require_reconstruct();
    __exportStar(require_types4(), exports);
    exports.default = tokenizer_1.tokenizer;
    module.exports = tokenizer_1.tokenizer;
    module.exports.types = types_1.types;
    module.exports.reconstruct = reconstruct_1.reconstruct;
  }
});

// node_modules/.pnpm/safe-regex2@5.0.0/node_modules/safe-regex2/index.js
var require_safe_regex2 = __commonJS({
  "node_modules/.pnpm/safe-regex2@5.0.0/node_modules/safe-regex2/index.js"(exports, module) {
    "use strict";
    var parse3 = require_dist3();
    var types = parse3.types;
    function safeRegex(re, opts) {
      if (!opts) opts = {};
      const replimit = opts.limit === void 0 ? 25 : opts.limit;
      if (isRegExp(re)) re = re.source;
      else if (typeof re !== "string") re = String(re);
      try {
        re = parse3(re);
      } catch {
        return false;
      }
      let reps = 0;
      return (function walk(node, starHeight) {
        let i;
        let ok;
        let len;
        if (node.type === types.REPETITION) {
          starHeight++;
          reps++;
          if (starHeight > 1) return false;
          if (reps > replimit) return false;
        }
        if (node.options) {
          for (i = 0, len = node.options.length; i < len; i++) {
            ok = walk({ stack: node.options[i] }, starHeight);
            if (!ok) return false;
          }
        }
        const stack = node.stack || node.value?.stack;
        if (!stack) return true;
        for (i = 0; i < stack.length; i++) {
          ok = walk(stack[i], starHeight);
          if (!ok) return false;
        }
        return true;
      })(re, 0);
    }
    function isRegExp(x2) {
      return {}.toString.call(x2) === "[object RegExp]";
    }
    module.exports = safeRegex;
    module.exports.default = safeRegex;
    module.exports.safeRegex = safeRegex;
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/strategies/http-method.js
var require_http_method = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/strategies/http-method.js"(exports, module) {
    "use strict";
    module.exports = {
      name: "__fmw_internal_strategy_merged_tree_http_method__",
      storage: function() {
        const handlers = /* @__PURE__ */ new Map();
        return {
          get: (type) => {
            return handlers.get(type) || null;
          },
          set: (type, store) => {
            handlers.set(type, store);
          }
        };
      },
      /* c8 ignore next 1 */
      deriveConstraint: (req) => req.method,
      mustMatchWhenDerived: true
    };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/pretty-print.js"(exports, module) {
    "use strict";
    var deepEqual = require_fast_deep_equal();
    var httpMethodStrategy = require_http_method();
    var treeDataSymbol = /* @__PURE__ */ Symbol("treeData");
    function printObjectTree(obj, parentPrefix = "") {
      let tree = "";
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        const isLast = i === keys.length - 1;
        const nodePrefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
        const childPrefix = isLast ? "    " : "\u2502   ";
        const nodeData = value[treeDataSymbol] || "";
        const prefixedNodeData = nodeData.replaceAll("\n", "\n" + parentPrefix + childPrefix);
        tree += parentPrefix + nodePrefix + key + prefixedNodeData + "\n";
        tree += printObjectTree(value, parentPrefix + childPrefix);
      }
      return tree;
    }
    function parseFunctionName(fn) {
      let fName = fn.name || "";
      fName = fName.replace("bound", "").trim();
      fName = (fName || "anonymous") + "()";
      return fName;
    }
    function parseMeta(meta3) {
      if (Array.isArray(meta3)) return meta3.map((m2) => parseMeta(m2));
      if (typeof meta3 === "symbol") return meta3.toString();
      if (typeof meta3 === "function") return parseFunctionName(meta3);
      return meta3;
    }
    function getRouteMetaData(route, options) {
      if (!options.includeMeta) return {};
      const metaDataObject = options.buildPrettyMeta(route);
      const filteredMetaData = {};
      let includeMetaKeys = options.includeMeta;
      if (!Array.isArray(includeMetaKeys)) {
        includeMetaKeys = Reflect.ownKeys(metaDataObject);
      }
      for (const metaKey of includeMetaKeys) {
        if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue;
        const serializedKey = metaKey.toString();
        const metaValue = metaDataObject[metaKey];
        if (metaValue !== void 0 && metaValue !== null) {
          const serializedValue = JSON.stringify(parseMeta(metaValue));
          filteredMetaData[serializedKey] = serializedValue;
        }
      }
      return filteredMetaData;
    }
    function serializeMetaData(metaData) {
      let serializedMetaData = "";
      for (const [key, value] of Object.entries(metaData)) {
        serializedMetaData += `
\u2022 (${key}) ${value}`;
      }
      return serializedMetaData;
    }
    function normalizeRoute(route) {
      const constraints = { ...route.opts.constraints };
      const method = constraints[httpMethodStrategy.name];
      delete constraints[httpMethodStrategy.name];
      return { ...route, method, opts: { constraints } };
    }
    function serializeRoute(route) {
      let serializedRoute = ` (${route.method})`;
      const constraints = route.opts.constraints || {};
      if (Object.keys(constraints).length !== 0) {
        serializedRoute += " " + JSON.stringify(constraints);
      }
      serializedRoute += serializeMetaData(route.metaData);
      return serializedRoute;
    }
    function mergeSimilarRoutes(routes) {
      return routes.reduce((mergedRoutes, route) => {
        for (const nodeRoute of mergedRoutes) {
          if (deepEqual(route.opts.constraints, nodeRoute.opts.constraints) && deepEqual(route.metaData, nodeRoute.metaData)) {
            nodeRoute.method += ", " + route.method;
            return mergedRoutes;
          }
        }
        mergedRoutes.push(route);
        return mergedRoutes;
      }, []);
    }
    function serializeNode(node, prefix, options) {
      let routes = node.routes;
      if (options.method === void 0) {
        routes = routes.map(normalizeRoute);
      }
      routes = routes.map((route) => {
        route.metaData = getRouteMetaData(route, options);
        return route;
      });
      if (options.method === void 0) {
        routes = mergeSimilarRoutes(routes);
      }
      return routes.map(serializeRoute).join(`
${prefix}`);
    }
    function buildObjectTree(node, tree, prefix, options) {
      if (node.isLeafNode || options.commonPrefix !== false) {
        prefix = prefix || "(empty root node)";
        tree = tree[prefix] = {};
        if (node.isLeafNode) {
          tree[treeDataSymbol] = serializeNode(node, prefix, options);
        }
        prefix = "";
      }
      if (node.staticChildren) {
        for (const child of Object.values(node.staticChildren)) {
          buildObjectTree(child, tree, prefix + child.prefix, options);
        }
      }
      if (node.parametricChildren) {
        for (const child of Object.values(node.parametricChildren)) {
          const childPrefix = Array.from(child.nodePaths).join("|");
          buildObjectTree(child, tree, prefix + childPrefix, options);
        }
      }
      if (node.wildcardChild) {
        buildObjectTree(node.wildcardChild, tree, "*", options);
      }
    }
    function prettyPrintTree(root, options) {
      const objectTree = {};
      buildObjectTree(root, objectTree, root.prefix, options);
      return printObjectTree(objectTree);
    }
    module.exports = { prettyPrintTree };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/null-object.js
var require_null_object = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/null-object.js"(exports, module) {
    "use strict";
    var NullObject = function() {
    };
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    module.exports = {
      NullObject
    };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/handler-storage.js
var require_handler_storage = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/handler-storage.js"(exports, module) {
    "use strict";
    var { NullObject } = require_null_object();
    var httpMethodStrategy = require_http_method();
    var HandlerStorage = class {
      constructor() {
        this.unconstrainedHandler = null;
        this.constraints = [];
        this.handlers = [];
        this.constrainedHandlerStores = null;
      }
      // This is the hot path for node handler finding -- change with care!
      getMatchingHandler(derivedConstraints) {
        if (derivedConstraints === void 0) {
          return this.unconstrainedHandler;
        }
        return this._getHandlerMatchingConstraints(derivedConstraints);
      }
      addHandler(constrainer, route) {
        const params = route.params;
        const constraints = route.opts.constraints || {};
        const handlerObject = {
          params,
          constraints,
          handler: route.handler,
          store: route.store || null,
          _createParamsObject: this._compileCreateParamsObject(params)
        };
        const constraintsNames = Object.keys(constraints);
        if (constraintsNames.length === 0) {
          this.unconstrainedHandler = handlerObject;
        }
        for (const constraint of constraintsNames) {
          if (!this.constraints.includes(constraint)) {
            if (constraint === "version") {
              this.constraints.unshift(constraint);
            } else {
              this.constraints.push(constraint);
            }
          }
        }
        const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
        if (!isMergedTree && this.handlers.length >= 31) {
          throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
        }
        this.handlers.push(handlerObject);
        this.handlers.sort((a2, b2) => Object.keys(a2.constraints).length - Object.keys(b2.constraints).length);
        if (!isMergedTree) {
          this._compileGetHandlerMatchingConstraints(constrainer, constraints);
        }
      }
      _compileCreateParamsObject(params) {
        const fnBody = [];
        fnBody.push("const fn = function _createParamsObject (paramsArray) {");
        fnBody.push("const params = new NullObject()");
        for (let i = 0; i < params.length; i++) {
          fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
        }
        fnBody.push("return params");
        fnBody.push("}");
        fnBody.push("return fn");
        return new Function("NullObject", fnBody.join("\n"))(NullObject);
      }
      _getHandlerMatchingConstraints() {
        return null;
      }
      // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
      // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
      // The store's implementation comes from the strategies provided to the Router.
      _buildConstraintStore(store, constraint) {
        for (let i = 0; i < this.handlers.length; i++) {
          const handler = this.handlers[i];
          const constraintValue = handler.constraints[constraint];
          if (constraintValue !== void 0) {
            let indexes = store.get(constraintValue) || 0;
            indexes |= 1 << i;
            store.set(constraintValue, indexes);
          }
        }
      }
      // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
      _constrainedIndexBitmask(constraint) {
        let mask = 0;
        for (let i = 0; i < this.handlers.length; i++) {
          const handler = this.handlers[i];
          const constraintValue = handler.constraints[constraint];
          if (constraintValue !== void 0) {
            mask |= 1 << i;
          }
        }
        return ~mask;
      }
      // Compile a fast function to match the handlers for this node
      // The function implements a general case multi-constraint matching algorithm.
      // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
      // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
      // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
      // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
      _compileGetHandlerMatchingConstraints(constrainer) {
        this.constrainedHandlerStores = {};
        for (const constraint of this.constraints) {
          const store = constrainer.newStoreForConstraint(constraint);
          this.constrainedHandlerStores[constraint] = store;
          this._buildConstraintStore(store, constraint);
        }
        const lines = [];
        lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
        for (const constraint of this.constraints) {
          lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
          const strategy = constrainer.strategies[constraint];
          const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
          lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
        }
        for (const constraint in constrainer.strategies) {
          const strategy = constrainer.strategies[constraint];
          if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
            lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
          }
        }
        lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
        this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
      }
    };
    module.exports = HandlerStorage;
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/node.js"(exports, module) {
    "use strict";
    var HandlerStorage = require_handler_storage();
    var NODE_TYPES = {
      STATIC: 0,
      PARAMETRIC: 1,
      WILDCARD: 2
    };
    var Node = class {
      constructor() {
        this.isLeafNode = false;
        this.routes = null;
        this.handlerStorage = null;
      }
      addRoute(route, constrainer) {
        if (this.routes === null) {
          this.routes = [];
        }
        if (this.handlerStorage === null) {
          this.handlerStorage = new HandlerStorage();
        }
        this.isLeafNode = true;
        this.routes.push(route);
        this.handlerStorage.addHandler(constrainer, route);
      }
    };
    var ParentNode = class extends Node {
      constructor() {
        super();
        this.staticChildren = {};
      }
      findStaticMatchingChild(path, pathIndex) {
        const staticChild = this.staticChildren[path.charAt(pathIndex)];
        if (staticChild === void 0 || !staticChild.matchPrefix(path, pathIndex)) {
          return null;
        }
        return staticChild;
      }
      getStaticChild(path, pathIndex = 0) {
        if (path.length === pathIndex) {
          return this;
        }
        const staticChild = this.findStaticMatchingChild(path, pathIndex);
        if (staticChild) {
          return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);
        }
        return null;
      }
      createStaticChild(path) {
        if (path.length === 0) {
          return this;
        }
        let staticChild = this.staticChildren[path.charAt(0)];
        if (staticChild) {
          let i = 1;
          for (; i < staticChild.prefix.length; i++) {
            if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
              staticChild = staticChild.split(this, i);
              break;
            }
          }
          return staticChild.createStaticChild(path.slice(i));
        }
        const label = path.charAt(0);
        this.staticChildren[label] = new StaticNode(path);
        return this.staticChildren[label];
      }
    };
    var StaticNode = class _StaticNode extends ParentNode {
      constructor(prefix) {
        super();
        this.prefix = prefix;
        this.wildcardChild = null;
        this.parametricChildren = [];
        this.kind = NODE_TYPES.STATIC;
        this._compilePrefixMatch();
      }
      getParametricChild(regex) {
        const regexpSource = regex && regex.source;
        const parametricChild = this.parametricChildren.find((child) => {
          const childRegexSource = child.regex && child.regex.source;
          return childRegexSource === regexpSource;
        });
        if (parametricChild) {
          return parametricChild;
        }
        return null;
      }
      createParametricChild(regex, staticSuffix, nodePath) {
        let parametricChild = this.getParametricChild(regex);
        if (parametricChild) {
          parametricChild.nodePaths.add(nodePath);
          return parametricChild;
        }
        parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
        this.parametricChildren.push(parametricChild);
        this.parametricChildren.sort((child1, child2) => {
          if (!child1.isRegex) return 1;
          if (!child2.isRegex) return -1;
          if (child1.staticSuffix === null) return 1;
          if (child2.staticSuffix === null) return -1;
          if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;
          if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;
          return 0;
        });
        return parametricChild;
      }
      getWildcardChild() {
        return this.wildcardChild;
      }
      createWildcardChild() {
        this.wildcardChild = this.getWildcardChild() || new WildcardNode();
        return this.wildcardChild;
      }
      split(parentNode, length) {
        const parentPrefix = this.prefix.slice(0, length);
        const childPrefix = this.prefix.slice(length);
        this.prefix = childPrefix;
        this._compilePrefixMatch();
        const staticNode = new _StaticNode(parentPrefix);
        staticNode.staticChildren[childPrefix.charAt(0)] = this;
        parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
        return staticNode;
      }
      getNextNode(path, pathIndex, nodeStack, paramsCount) {
        let node = this.findStaticMatchingChild(path, pathIndex);
        let parametricBrotherNodeIndex = 0;
        if (node === null) {
          if (this.parametricChildren.length === 0) {
            return this.wildcardChild;
          }
          node = this.parametricChildren[0];
          parametricBrotherNodeIndex = 1;
        }
        if (this.wildcardChild !== null) {
          nodeStack.push({
            paramsCount,
            brotherPathIndex: pathIndex,
            brotherNode: this.wildcardChild
          });
        }
        for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
          nodeStack.push({
            paramsCount,
            brotherPathIndex: pathIndex,
            brotherNode: this.parametricChildren[i]
          });
        }
        return node;
      }
      _compilePrefixMatch() {
        if (this.prefix.length === 1) {
          this.matchPrefix = () => true;
          return;
        }
        const lines = [];
        for (let i = 1; i < this.prefix.length; i++) {
          const charCode = this.prefix.charCodeAt(i);
          lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
        }
        this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
      }
    };
    var ParametricNode = class extends ParentNode {
      constructor(regex, staticSuffix, nodePath) {
        super();
        this.isRegex = !!regex;
        this.regex = regex || null;
        this.staticSuffix = staticSuffix || null;
        this.kind = NODE_TYPES.PARAMETRIC;
        this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
      }
      getNextNode(path, pathIndex) {
        return this.findStaticMatchingChild(path, pathIndex);
      }
    };
    var WildcardNode = class extends Node {
      constructor() {
        super();
        this.kind = NODE_TYPES.WILDCARD;
      }
      getNextNode() {
        return null;
      }
    };
    module.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/strategies/accept-version.js
var require_accept_version = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/strategies/accept-version.js"(exports, module) {
    "use strict";
    var assert2 = __require("node:assert");
    function SemVerStore() {
      if (!(this instanceof SemVerStore)) {
        return new SemVerStore();
      }
      this.store = /* @__PURE__ */ new Map();
      this.maxMajor = 0;
      this.maxMinors = {};
      this.maxPatches = {};
    }
    SemVerStore.prototype.set = function(version3, store) {
      if (typeof version3 !== "string") {
        throw new TypeError("Version should be a string");
      }
      let [major, minor, patch] = version3.split(".", 3);
      if (isNaN(major)) {
        throw new TypeError("Major version must be a numeric value");
      }
      major = Number(major);
      minor = Number(minor) || 0;
      patch = Number(patch) || 0;
      if (major >= this.maxMajor) {
        this.maxMajor = major;
        this.store.set("x", store);
        this.store.set("*", store);
        this.store.set("x.x", store);
        this.store.set("x.x.x", store);
      }
      if (minor >= (this.maxMinors[major] || 0)) {
        this.maxMinors[major] = minor;
        this.store.set(`${major}.x`, store);
        this.store.set(`${major}.x.x`, store);
      }
      if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
        this.maxPatches[`${major}.${minor}`] = patch;
        this.store.set(`${major}.${minor}.x`, store);
      }
      this.store.set(`${major}.${minor}.${patch}`, store);
      return this;
    };
    SemVerStore.prototype.get = function(version3) {
      return this.store.get(version3);
    };
    module.exports = {
      name: "version",
      mustMatchWhenDerived: true,
      storage: SemVerStore,
      validate(value) {
        assert2(typeof value === "string", "Version should be a string");
      }
    };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/strategies/accept-host.js
var require_accept_host = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/strategies/accept-host.js"(exports, module) {
    "use strict";
    var assert2 = __require("node:assert");
    function HostStorage() {
      const hosts = /* @__PURE__ */ new Map();
      const regexHosts = [];
      return {
        get: (host) => {
          const exact = hosts.get(host);
          if (exact) {
            return exact;
          }
          for (const regex of regexHosts) {
            if (regex.host.test(host)) {
              return regex.value;
            }
          }
        },
        set: (host, value) => {
          if (host instanceof RegExp) {
            regexHosts.push({ host, value });
          } else {
            hosts.set(host, value);
          }
        }
      };
    }
    module.exports = {
      name: "host",
      mustMatchWhenDerived: false,
      storage: HostStorage,
      validate(value) {
        assert2(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
      }
    };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/constrainer.js
var require_constrainer = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/constrainer.js"(exports, module) {
    "use strict";
    var acceptVersionStrategy = require_accept_version();
    var acceptHostStrategy = require_accept_host();
    var assert2 = __require("node:assert");
    var Constrainer = class {
      constructor(customStrategies) {
        this.strategies = {
          version: acceptVersionStrategy,
          host: acceptHostStrategy
        };
        this.strategiesInUse = /* @__PURE__ */ new Set();
        this.asyncStrategiesInUse = /* @__PURE__ */ new Set();
        if (customStrategies) {
          for (const strategy of Object.values(customStrategies)) {
            this.addConstraintStrategy(strategy);
          }
        }
      }
      isStrategyUsed(strategyName) {
        return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
      }
      hasConstraintStrategy(strategyName) {
        const customConstraintStrategy = this.strategies[strategyName];
        if (customConstraintStrategy !== void 0) {
          return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
        }
        return false;
      }
      addConstraintStrategy(strategy) {
        assert2(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
        assert2(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
        assert2(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
        if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
          throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
        }
        if (this.isStrategyUsed(strategy.name)) {
          throw new Error(`There already exists a route with ${strategy.name} constraint.`);
        }
        strategy.isCustom = true;
        strategy.isAsync = strategy.deriveConstraint.length === 3;
        this.strategies[strategy.name] = strategy;
        if (strategy.mustMatchWhenDerived) {
          this.noteUsage({ [strategy.name]: strategy });
        }
      }
      deriveConstraints(req, ctx, done) {
        const constraints = this.deriveSyncConstraints(req, ctx);
        if (done === void 0) {
          return constraints;
        }
        this.deriveAsyncConstraints(constraints, req, ctx, done);
      }
      deriveSyncConstraints(req, ctx) {
        return void 0;
      }
      // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
      noteUsage(constraints) {
        if (constraints) {
          const beforeSize = this.strategiesInUse.size;
          for (const key in constraints) {
            const strategy = this.strategies[key];
            if (strategy.isAsync) {
              this.asyncStrategiesInUse.add(key);
            } else {
              this.strategiesInUse.add(key);
            }
          }
          if (beforeSize !== this.strategiesInUse.size) {
            this._buildDeriveConstraints();
          }
        }
      }
      newStoreForConstraint(constraint) {
        if (!this.strategies[constraint]) {
          throw new Error(`No strategy registered for constraint key ${constraint}`);
        }
        return this.strategies[constraint].storage();
      }
      validateConstraints(constraints) {
        for (const key in constraints) {
          const value = constraints[key];
          if (typeof value === "undefined") {
            throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
          }
          const strategy = this.strategies[key];
          if (!strategy) {
            throw new Error(`No strategy registered for constraint key ${key}`);
          }
          if (strategy.validate) {
            strategy.validate(value);
          }
        }
      }
      deriveAsyncConstraints(constraints, req, ctx, done) {
        let asyncConstraintsCount = this.asyncStrategiesInUse.size;
        if (asyncConstraintsCount === 0) {
          done(null, constraints);
          return;
        }
        constraints = constraints || {};
        for (const key of this.asyncStrategiesInUse) {
          const strategy = this.strategies[key];
          strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
            if (err !== null) {
              done(err);
              return;
            }
            constraints[key] = constraintValue;
            if (--asyncConstraintsCount === 0) {
              done(null, constraints);
            }
          });
        }
      }
      // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
      // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
      // This allows us to not allocate an object to hold constraint values if no constraints are defined.
      _buildDeriveConstraints() {
        if (this.strategiesInUse.size === 0) return;
        const lines = ["return {"];
        for (const key of this.strategiesInUse) {
          const strategy = this.strategies[key];
          if (!strategy.isCustom) {
            if (key === "version") {
              lines.push("   version: req.headers['accept-version'],");
            } else {
              lines.push("   host: req.headers.host || req.headers[':authority'],");
            }
          } else {
            lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
          }
        }
        lines.push("}");
        this.deriveSyncConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
      }
    };
    module.exports = Constrainer;
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/http-methods.js
var require_http_methods = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/http-methods.js"(exports, module) {
    "use strict";
    var httpMethods = [
      "ACL",
      "BIND",
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LINK",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCALENDAR",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "QUERY",
      "REBIND",
      "REPORT",
      "SEARCH",
      "SOURCE",
      "SUBSCRIBE",
      "TRACE",
      "UNBIND",
      "UNLINK",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    module.exports = httpMethods;
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/url-sanitizer.js
var require_url_sanitizer = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/lib/url-sanitizer.js"(exports, module) {
    "use strict";
    function decodeComponentChar(highCharCode, lowCharCode) {
      if (highCharCode === 50) {
        if (lowCharCode === 53) return "%";
        if (lowCharCode === 51) return "#";
        if (lowCharCode === 52) return "$";
        if (lowCharCode === 54) return "&";
        if (lowCharCode === 66) return "+";
        if (lowCharCode === 98) return "+";
        if (lowCharCode === 67) return ",";
        if (lowCharCode === 99) return ",";
        if (lowCharCode === 70) return "/";
        if (lowCharCode === 102) return "/";
        return null;
      }
      if (highCharCode === 51) {
        if (lowCharCode === 65) return ":";
        if (lowCharCode === 97) return ":";
        if (lowCharCode === 66) return ";";
        if (lowCharCode === 98) return ";";
        if (lowCharCode === 68) return "=";
        if (lowCharCode === 100) return "=";
        if (lowCharCode === 70) return "?";
        if (lowCharCode === 102) return "?";
        return null;
      }
      if (highCharCode === 52 && lowCharCode === 48) {
        return "@";
      }
      return null;
    }
    function safeDecodeURI(path, useSemicolonDelimiter) {
      let shouldDecode = false;
      let shouldDecodeParam = false;
      let querystring = "";
      for (let i = 1; i < path.length; i++) {
        const charCode = path.charCodeAt(i);
        if (charCode === 37) {
          const highCharCode = path.charCodeAt(i + 1);
          const lowCharCode = path.charCodeAt(i + 2);
          if (decodeComponentChar(highCharCode, lowCharCode) === null) {
            shouldDecode = true;
          } else {
            shouldDecodeParam = true;
            if (highCharCode === 50 && lowCharCode === 53) {
              shouldDecode = true;
              path = path.slice(0, i + 1) + "25" + path.slice(i + 1);
              i += 2;
            }
            i += 2;
          }
        } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
          querystring = path.slice(i + 1);
          path = path.slice(0, i);
          break;
        }
      }
      const decodedPath = shouldDecode ? decodeURI(path) : path;
      return { path: decodedPath, querystring, shouldDecodeParam };
    }
    function safeDecodeURIComponent(uriComponent) {
      const startIndex = uriComponent.indexOf("%");
      if (startIndex === -1) return uriComponent;
      let decoded = "";
      let lastIndex = startIndex;
      for (let i = startIndex; i < uriComponent.length; i++) {
        if (uriComponent.charCodeAt(i) === 37) {
          const highCharCode = uriComponent.charCodeAt(i + 1);
          const lowCharCode = uriComponent.charCodeAt(i + 2);
          const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
          decoded += uriComponent.slice(lastIndex, i) + decodedChar;
          lastIndex = i + 3;
        }
      }
      return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
    }
    module.exports = { safeDecodeURI, safeDecodeURIComponent };
  }
});

// node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/index.js
var require_find_my_way = __commonJS({
  "node_modules/.pnpm/find-my-way@9.4.0/node_modules/find-my-way/index.js"(exports, module) {
    "use strict";
    var assert2 = __require("node:assert");
    var querystring = require_lib();
    var isRegexSafe = require_safe_regex2();
    var deepEqual = require_fast_deep_equal();
    var { prettyPrintTree } = require_pretty_print();
    var { StaticNode, NODE_TYPES } = require_node();
    var Constrainer = require_constrainer();
    var httpMethods = require_http_methods();
    var httpMethodStrategy = require_http_method();
    var { safeDecodeURI, safeDecodeURIComponent } = require_url_sanitizer();
    var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
    var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
    var ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
    var REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;
    if (!isRegexSafe(FULL_PATH_REGEXP)) {
      throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
      throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(ESCAPE_REGEXP)) {
      throw new Error("the ESCAPE_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
      throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
    }
    function Router(opts) {
      if (!(this instanceof Router)) {
        return new Router(opts);
      }
      opts = opts || {};
      this._opts = opts;
      if (opts.defaultRoute) {
        assert2(typeof opts.defaultRoute === "function", "The default route must be a function");
        this.defaultRoute = opts.defaultRoute;
      } else {
        this.defaultRoute = null;
      }
      if (opts.onBadUrl) {
        assert2(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
        this.onBadUrl = opts.onBadUrl;
      } else {
        this.onBadUrl = null;
      }
      if (opts.buildPrettyMeta) {
        assert2(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
        this.buildPrettyMeta = opts.buildPrettyMeta;
      } else {
        this.buildPrettyMeta = defaultBuildPrettyMeta;
      }
      if (opts.querystringParser) {
        assert2(typeof opts.querystringParser === "function", "querystringParser must be a function");
        this.querystringParser = opts.querystringParser;
      } else {
        this.querystringParser = (query) => query.length === 0 ? {} : querystring.parse(query);
      }
      this.caseSensitive = opts.caseSensitive === void 0 ? true : opts.caseSensitive;
      this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
      this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
      this.maxParamLength = opts.maxParamLength || 100;
      this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
      this.constrainer = new Constrainer(opts.constraints);
      this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
      this.routes = [];
      this.trees = {};
    }
    Router.prototype.on = function on(method, path, opts, handler, store) {
      if (typeof opts === "function") {
        if (handler !== void 0) {
          store = handler;
        }
        handler = opts;
        opts = {};
      }
      assert2(typeof path === "string", "Path should be a string");
      assert2(path.length > 0, "The path could not be empty");
      assert2(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
      assert2(typeof handler === "function", "Handler should be a function");
      const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert2(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2") || "/";
        this.on(method, pathFull, opts, handler, store);
        this.on(method, pathOptional, opts, handler, store);
        return;
      }
      const route = path;
      if (this.ignoreDuplicateSlashes) {
        path = removeDuplicateSlashes(path);
      }
      if (this.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      const methods = Array.isArray(method) ? method : [method];
      for (const method2 of methods) {
        assert2(typeof method2 === "string", "Method should be a string");
        assert2(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
        this._on(method2, path, opts, handler, store, route);
      }
    };
    Router.prototype._on = function _on(method, path, opts, handler, store) {
      let constraints = {};
      if (opts.constraints !== void 0) {
        assert2(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
        if (Object.keys(opts.constraints).length !== 0) {
          constraints = opts.constraints;
        }
      }
      this.constrainer.validateConstraints(constraints);
      this.constrainer.noteUsage(constraints);
      if (this.trees[method] === void 0) {
        this.trees[method] = new StaticNode("/");
      }
      let pattern = path;
      if (pattern === "*" && this.trees[method].prefix.length !== 0) {
        const currentRoot = this.trees[method];
        this.trees[method] = new StaticNode("");
        this.trees[method].staticChildren["/"] = currentRoot;
      }
      let currentNode = this.trees[method];
      let parentNodePathIndex = currentNode.prefix.length;
      const params = [];
      for (let i = 0; i <= pattern.length; i++) {
        if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
          i++;
          continue;
        }
        const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
        const isWildcardNode = pattern.charCodeAt(i) === 42;
        if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
          let staticNodePath = pattern.slice(parentNodePathIndex, i);
          if (!this.caseSensitive) {
            staticNodePath = staticNodePath.toLowerCase();
          }
          staticNodePath = staticNodePath.replaceAll("::", ":");
          staticNodePath = staticNodePath.replaceAll("%", "%25");
          currentNode = currentNode.createStaticChild(staticNodePath);
        }
        if (isParametricNode) {
          let isRegexNode = false;
          let isParamSafe = true;
          let backtrack = "";
          const regexps = [];
          let lastParamStartIndex = i + 1;
          for (let j = lastParamStartIndex; ; j++) {
            const charCode = pattern.charCodeAt(j);
            const isRegexParam = charCode === 40;
            const isStaticPart = charCode === 45 || charCode === 46;
            const isEndOfNode = charCode === 47 || j === pattern.length;
            if (isRegexParam || isStaticPart || isEndOfNode) {
              const paramName = pattern.slice(lastParamStartIndex, j);
              params.push(paramName);
              isRegexNode = isRegexNode || isRegexParam || isStaticPart;
              if (isRegexParam) {
                const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
                const regexString = pattern.slice(j, endOfRegexIndex + 1);
                if (!this.allowUnsafeRegex) {
                  assert2(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
                }
                regexps.push(trimRegExpStartAndEnd(regexString));
                j = endOfRegexIndex + 1;
                isParamSafe = true;
              } else {
                regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
                isParamSafe = false;
              }
              const staticPartStartIndex = j;
              for (; j < pattern.length; j++) {
                const charCode2 = pattern.charCodeAt(j);
                if (charCode2 === 47) break;
                if (charCode2 === 58) {
                  const nextCharCode = pattern.charCodeAt(j + 1);
                  if (nextCharCode === 58) j++;
                  else break;
                }
              }
              let staticPart = pattern.slice(staticPartStartIndex, j);
              if (staticPart) {
                staticPart = staticPart.replaceAll("::", ":");
                staticPart = staticPart.replaceAll("%", "%25");
                regexps.push(backtrack = escapeRegExp(staticPart));
              }
              lastParamStartIndex = j + 1;
              if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
                const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
                const nodePath = pattern.slice(i, j);
                pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
                i += nodePattern.length;
                const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
                currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
                parentNodePathIndex = i + 1;
                break;
              }
            }
          }
        } else if (isWildcardNode) {
          params.push("*");
          currentNode = currentNode.createWildcardChild();
          parentNodePathIndex = i + 1;
          if (i !== pattern.length - 1) {
            throw new Error("Wildcard must be the last character in the route");
          }
        }
      }
      if (!this.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      if (pattern === "*") {
        pattern = "/*";
      }
      for (const existRoute of this.routes) {
        const routeConstraints = existRoute.opts.constraints || {};
        if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
          throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`);
        }
      }
      const route = { method, path, pattern, params, opts, handler, store };
      this.routes.push(route);
      currentNode.addRoute(route, this.constrainer);
    };
    Router.prototype.hasRoute = function hasRoute(method, path, constraints) {
      const route = this.findRoute(method, path, constraints);
      return route !== null;
    };
    Router.prototype.findRoute = function findNode(method, path, constraints = {}) {
      if (this.trees[method] === void 0) {
        return null;
      }
      let pattern = path;
      let currentNode = this.trees[method];
      let parentNodePathIndex = currentNode.prefix.length;
      const params = [];
      for (let i = 0; i <= pattern.length; i++) {
        if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
          i++;
          continue;
        }
        const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
        const isWildcardNode = pattern.charCodeAt(i) === 42;
        if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
          let staticNodePath = pattern.slice(parentNodePathIndex, i);
          if (!this.caseSensitive) {
            staticNodePath = staticNodePath.toLowerCase();
          }
          staticNodePath = staticNodePath.replaceAll("::", ":");
          staticNodePath = staticNodePath.replaceAll("%", "%25");
          currentNode = currentNode.getStaticChild(staticNodePath);
          if (currentNode === null) {
            return null;
          }
        }
        if (isParametricNode) {
          let isRegexNode = false;
          let isParamSafe = true;
          let backtrack = "";
          const regexps = [];
          let lastParamStartIndex = i + 1;
          for (let j = lastParamStartIndex; ; j++) {
            const charCode = pattern.charCodeAt(j);
            const isRegexParam = charCode === 40;
            const isStaticPart = charCode === 45 || charCode === 46;
            const isEndOfNode = charCode === 47 || j === pattern.length;
            if (isRegexParam || isStaticPart || isEndOfNode) {
              const paramName = pattern.slice(lastParamStartIndex, j);
              params.push(paramName);
              isRegexNode = isRegexNode || isRegexParam || isStaticPart;
              if (isRegexParam) {
                const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
                const regexString = pattern.slice(j, endOfRegexIndex + 1);
                if (!this.allowUnsafeRegex) {
                  assert2(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
                }
                regexps.push(trimRegExpStartAndEnd(regexString));
                j = endOfRegexIndex + 1;
                isParamSafe = false;
              } else {
                regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
                isParamSafe = false;
              }
              const staticPartStartIndex = j;
              for (; j < pattern.length; j++) {
                const charCode2 = pattern.charCodeAt(j);
                if (charCode2 === 47) break;
                if (charCode2 === 58) {
                  const nextCharCode = pattern.charCodeAt(j + 1);
                  if (nextCharCode === 58) j++;
                  else break;
                }
              }
              let staticPart = pattern.slice(staticPartStartIndex, j);
              if (staticPart) {
                staticPart = staticPart.replaceAll("::", ":");
                staticPart = staticPart.replaceAll("%", "%25");
                regexps.push(backtrack = escapeRegExp(staticPart));
              }
              lastParamStartIndex = j + 1;
              if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
                const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
                const nodePath = pattern.slice(i, j);
                pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
                i += nodePattern.length;
                const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
                currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
                if (currentNode === null) {
                  return null;
                }
                parentNodePathIndex = i + 1;
                break;
              }
            }
          }
        } else if (isWildcardNode) {
          params.push("*");
          currentNode = currentNode.getWildcardChild();
          parentNodePathIndex = i + 1;
          if (i !== pattern.length - 1) {
            throw new Error("Wildcard must be the last character in the route");
          }
        }
      }
      if (!this.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      for (const existRoute of this.routes) {
        const routeConstraints = existRoute.opts.constraints || {};
        if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
          return {
            handler: existRoute.handler,
            store: existRoute.store,
            params: existRoute.params
          };
        }
      }
      return null;
    };
    Router.prototype.hasConstraintStrategy = function(strategyName) {
      return this.constrainer.hasConstraintStrategy(strategyName);
    };
    Router.prototype.addConstraintStrategy = function(constraints) {
      this.constrainer.addConstraintStrategy(constraints);
      this._rebuild(this.routes);
    };
    Router.prototype.reset = function reset() {
      this.trees = {};
      this.routes = [];
    };
    Router.prototype.off = function off(method, path, constraints) {
      assert2(typeof path === "string", "Path should be a string");
      assert2(path.length > 0, "The path could not be empty");
      assert2(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
      assert2(
        typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null,
        "Constraints should be an object or undefined."
      );
      const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert2(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
        this.off(method, pathFull, constraints);
        this.off(method, pathOptional, constraints);
        return;
      }
      if (this.ignoreDuplicateSlashes) {
        path = removeDuplicateSlashes(path);
      }
      if (this.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      const methods = Array.isArray(method) ? method : [method];
      for (const method2 of methods) {
        this._off(method2, path, constraints);
      }
    };
    Router.prototype._off = function _off(method, path, constraints) {
      assert2(typeof method === "string", "Method should be a string");
      assert2(httpMethods.includes(method), `Method '${method}' is not an http method.`);
      function matcherWithoutConstraints(route) {
        return method !== route.method || path !== route.path;
      }
      function matcherWithConstraints(route) {
        return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {});
      }
      const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
      const newRoutes = this.routes.filter(predicate);
      this._rebuild(newRoutes);
    };
    Router.prototype.lookup = function lookup(req, res, ctx, done) {
      if (typeof ctx === "function") {
        done = ctx;
        ctx = void 0;
      }
      if (done === void 0) {
        const constraints = this.constrainer.deriveConstraints(req, ctx);
        const handle = this.find(req.method, req.url, constraints);
        return this.callHandler(handle, req, res, ctx);
      }
      this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
        if (err !== null) {
          done(err);
          return;
        }
        try {
          const handle = this.find(req.method, req.url, constraints);
          const result = this.callHandler(handle, req, res, ctx);
          done(null, result);
        } catch (err2) {
          done(err2);
        }
      });
    };
    Router.prototype.callHandler = function callHandler(handle, req, res, ctx) {
      if (handle === null) return this._defaultRoute(req, res, ctx);
      return ctx === void 0 ? handle.handler(req, res, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams);
    };
    Router.prototype.find = function find(method, path, derivedConstraints) {
      let currentNode = this.trees[method];
      if (currentNode === void 0) return null;
      if (path.charCodeAt(0) !== 47) {
        path = path.replace(FULL_PATH_REGEXP, "/");
      }
      if (this.ignoreDuplicateSlashes) {
        path = removeDuplicateSlashes(path);
      }
      let sanitizedUrl;
      let querystring2;
      let shouldDecodeParam;
      try {
        sanitizedUrl = safeDecodeURI(path, this.useSemicolonDelimiter);
        path = sanitizedUrl.path;
        querystring2 = sanitizedUrl.querystring;
        shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
      } catch (error48) {
        return this._onBadUrl(path);
      }
      if (this.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      const originPath = path;
      if (this.caseSensitive === false) {
        path = path.toLowerCase();
      }
      const maxParamLength = this.maxParamLength;
      let pathIndex = currentNode.prefix.length;
      const params = [];
      const pathLen = path.length;
      const brothersNodesStack = [];
      while (true) {
        if (pathIndex === pathLen && currentNode.isLeafNode) {
          const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
          if (handle !== null) {
            return {
              handler: handle.handler,
              store: handle.store,
              params: handle._createParamsObject(params),
              searchParams: this.querystringParser(querystring2)
            };
          }
        }
        let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);
        if (node === null) {
          if (brothersNodesStack.length === 0) {
            return null;
          }
          const brotherNodeState = brothersNodesStack.pop();
          pathIndex = brotherNodeState.brotherPathIndex;
          params.splice(brotherNodeState.paramsCount);
          node = brotherNodeState.brotherNode;
        }
        currentNode = node;
        if (currentNode.kind === NODE_TYPES.STATIC) {
          pathIndex += currentNode.prefix.length;
          continue;
        }
        if (currentNode.kind === NODE_TYPES.WILDCARD) {
          let param2 = originPath.slice(pathIndex);
          if (shouldDecodeParam) {
            param2 = safeDecodeURIComponent(param2);
          }
          params.push(param2);
          pathIndex = pathLen;
          continue;
        }
        let paramEndIndex = originPath.indexOf("/", pathIndex);
        if (paramEndIndex === -1) {
          paramEndIndex = pathLen;
        }
        let param = originPath.slice(pathIndex, paramEndIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        if (currentNode.isRegex) {
          const matchedParameters = currentNode.regex.exec(param);
          if (matchedParameters === null) continue;
          for (let i = 1; i < matchedParameters.length; i++) {
            const matchedParam = matchedParameters[i];
            if (matchedParam.length > maxParamLength) {
              return null;
            }
            params.push(matchedParam);
          }
        } else {
          if (param.length > maxParamLength) {
            return null;
          }
          params.push(param);
        }
        pathIndex = paramEndIndex;
      }
    };
    Router.prototype._rebuild = function(routes) {
      this.reset();
      for (const route of routes) {
        const { method, path, opts, handler, store } = route;
        this._on(method, path, opts, handler, store);
      }
    };
    Router.prototype._defaultRoute = function(req, res, ctx) {
      if (this.defaultRoute !== null) {
        return ctx === void 0 ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
      } else {
        res.statusCode = 404;
        res.end();
      }
    };
    Router.prototype._onBadUrl = function(path) {
      if (this.onBadUrl === null) {
        return null;
      }
      const onBadUrl = this.onBadUrl;
      return {
        handler: (req, res, ctx) => onBadUrl(path, req, res),
        params: {},
        store: null
      };
    };
    Router.prototype.prettyPrint = function(options = {}) {
      const method = options.method;
      options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
      let tree = null;
      if (method === void 0) {
        const { version: version3, host, ...constraints } = this.constrainer.strategies;
        constraints[httpMethodStrategy.name] = httpMethodStrategy;
        const mergedRouter = new Router({ ...this._opts, constraints });
        const mergedRoutes = this.routes.map((route) => {
          const constraints2 = {
            ...route.opts.constraints,
            [httpMethodStrategy.name]: route.method
          };
          return { ...route, method: "MERGED", opts: { constraints: constraints2 } };
        });
        mergedRouter._rebuild(mergedRoutes);
        tree = mergedRouter.trees.MERGED;
      } else {
        tree = this.trees[method];
      }
      if (tree == null) return "(empty tree)";
      return prettyPrintTree(tree, options);
    };
    for (const i in httpMethods) {
      if (!httpMethods.hasOwnProperty(i)) continue;
      const m2 = httpMethods[i];
      const methodName = m2.toLowerCase();
      Router.prototype[methodName] = function(path, handler, store) {
        return this.on(m2, path, handler, store);
      };
    }
    Router.prototype.all = function(path, handler, store) {
      this.on(httpMethods, path, handler, store);
    };
    Router.sanitizeUrlPath = function sanitizeUrlPath(url2, useSemicolonDelimiter) {
      const decoded = safeDecodeURI(url2, useSemicolonDelimiter);
      if (decoded.shouldDecodeParam) {
        return safeDecodeURIComponent(decoded.path);
      }
      return decoded.path;
    };
    module.exports = Router;
    function escapeRegExp(string6) {
      return string6.replace(ESCAPE_REGEXP, "\\$&");
    }
    function removeDuplicateSlashes(path) {
      return path.indexOf("//") !== -1 ? path.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, "/") : path;
    }
    function trimLastSlash(path) {
      if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
        return path.slice(0, -1);
      }
      return path;
    }
    function trimRegExpStartAndEnd(regexString) {
      if (regexString.charCodeAt(1) === 94) {
        regexString = regexString.slice(0, 1) + regexString.slice(2);
      }
      if (regexString.charCodeAt(regexString.length - 2) === 36) {
        regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
      }
      return regexString;
    }
    function getClosingParenthensePosition(path, idx) {
      let parentheses = 1;
      while (idx < path.length) {
        idx++;
        if (path.charCodeAt(idx) === 92) {
          idx++;
          continue;
        }
        if (path.charCodeAt(idx) === 41) {
          parentheses--;
        } else if (path.charCodeAt(idx) === 40) {
          parentheses++;
        }
        if (!parentheses) return idx;
      }
      throw new TypeError('Invalid regexp expression in "' + path + '"');
    }
    function defaultBuildPrettyMeta(route) {
      if (!route) return {};
      if (!route.store) return {};
      return Object.assign({}, route.store);
    }
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/headRoute.js
var require_headRoute = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/headRoute.js"(exports, module) {
    "use strict";
    function headRouteOnSendHandler(req, reply, payload, done) {
      if (payload === void 0) {
        reply.header("content-length", "0");
        done(null, null);
        return;
      }
      if (typeof payload.resume === "function") {
        payload.on("error", (err) => {
          reply.log.error({ err }, "Error on Stream found for HEAD route");
        });
        payload.resume();
        done(null, null);
        return;
      }
      const size = "" + Buffer.byteLength(payload);
      reply.header("content-length", size);
      done(null, null);
    }
    function parseHeadOnSendHandlers(onSendHandlers) {
      if (onSendHandlers == null) return headRouteOnSendHandler;
      return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
    }
    module.exports = {
      parseHeadOnSendHandlers
    };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/route.js
var require_route = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/route.js"(exports, module) {
    "use strict";
    var FindMyWay = require_find_my_way();
    var Context = require_context();
    var handleRequest = require_handleRequest();
    var { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = require_hooks();
    var { normalizeSchema } = require_schemas();
    var { parseHeadOnSendHandlers } = require_headRoute();
    var {
      compileSchemasForValidation,
      compileSchemasForSerialization
    } = require_validation();
    var {
      FST_ERR_SCH_VALIDATION_BUILD,
      FST_ERR_SCH_SERIALIZATION_BUILD,
      FST_ERR_DUPLICATED_ROUTE,
      FST_ERR_INVALID_URL,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
      FST_ERR_ROUTE_DUPLICATED_HANDLER,
      FST_ERR_ROUTE_HANDLER_NOT_FN,
      FST_ERR_ROUTE_MISSING_HANDLER,
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
      FST_ERR_ROUTE_METHOD_INVALID,
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER
    } = require_errors2();
    var { FSTDEP022 } = require_warnings();
    var {
      kRoutePrefix,
      kSupportedHTTPMethods,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kOptions,
      kReplySerializerDefault,
      kReplyIsError,
      kRequestPayloadStream,
      kDisableRequestLogging,
      kSchemaErrorFormatter,
      kErrorHandler,
      kHasBeenDecorated,
      kRequestAcceptVersion,
      kRouteByFastify,
      kRouteContext
    } = require_symbols2();
    var { buildErrorHandler } = require_error_handler();
    var { createChildLogger } = require_logger_factory();
    var { getGenReqId } = require_reqIdGenFactory();
    var routerKeys = [
      "allowUnsafeRegex",
      "buildPrettyMeta",
      "caseSensitive",
      "constraints",
      "defaultRoute",
      "ignoreDuplicateSlashes",
      "ignoreTrailingSlash",
      "maxParamLength",
      "onBadUrl",
      "querystringParser",
      "useSemicolonDelimiter"
    ];
    function buildRouting(options) {
      const router = FindMyWay(options.config);
      let avvio;
      let fourOhFour;
      let logger;
      let hasLogger;
      let setupResponseListeners;
      let throwIfAlreadyStarted;
      let disableRequestLogging;
      let ignoreTrailingSlash;
      let ignoreDuplicateSlashes;
      let return503OnClosing;
      let globalExposeHeadRoutes;
      let keepAliveConnections;
      let closing = false;
      return {
        /**
         * @param {import('../fastify').FastifyServerOptions} options
         * @param {*} fastifyArgs
         */
        setup(options2, fastifyArgs) {
          avvio = fastifyArgs.avvio;
          fourOhFour = fastifyArgs.fourOhFour;
          logger = fastifyArgs.logger;
          hasLogger = fastifyArgs.hasLogger;
          setupResponseListeners = fastifyArgs.setupResponseListeners;
          throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
          globalExposeHeadRoutes = options2.exposeHeadRoutes;
          disableRequestLogging = options2.disableRequestLogging;
          ignoreTrailingSlash = options2.routerOptions.ignoreTrailingSlash;
          ignoreDuplicateSlashes = options2.routerOptions.ignoreDuplicateSlashes;
          return503OnClosing = Object.hasOwn(options2, "return503OnClosing") ? options2.return503OnClosing : true;
          keepAliveConnections = fastifyArgs.keepAliveConnections;
        },
        routing: router.lookup.bind(router),
        // router func to find the right handler to call
        route,
        // configure a route in the fastify instance
        hasRoute,
        prepareRoute,
        routeHandler,
        closeRoutes: () => {
          closing = true;
        },
        printRoutes: router.prettyPrint.bind(router),
        addConstraintStrategy,
        hasConstraintStrategy,
        isAsyncConstraint,
        findRoute
      };
      function addConstraintStrategy(strategy) {
        throwIfAlreadyStarted("Cannot add constraint strategy!");
        return router.addConstraintStrategy(strategy);
      }
      function hasConstraintStrategy(strategyName) {
        return router.hasConstraintStrategy(strategyName);
      }
      function isAsyncConstraint() {
        return router.constrainer.asyncStrategiesInUse.size > 0;
      }
      function prepareRoute({ method, url: url2, options: options2, handler, isFastify }) {
        if (typeof url2 !== "string") {
          throw new FST_ERR_INVALID_URL(typeof url2);
        }
        if (!handler && typeof options2 === "function") {
          handler = options2;
          options2 = {};
        } else if (handler && typeof handler === "function") {
          if (Object.prototype.toString.call(options2) !== "[object Object]") {
            throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url2);
          } else if (options2.handler) {
            if (typeof options2.handler === "function") {
              throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url2);
            } else {
              throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url2);
            }
          }
        }
        options2 = Object.assign({}, options2, {
          method,
          url: url2,
          path: url2,
          handler: handler || options2 && options2.handler
        });
        return route.call(this, { options: options2, isFastify });
      }
      function hasRoute({ options: options2 }) {
        const normalizedMethod = options2.method?.toUpperCase() ?? "";
        return router.hasRoute(
          normalizedMethod,
          options2.url || "",
          options2.constraints
        );
      }
      function findRoute(options2) {
        const route2 = router.find(
          options2.method,
          options2.url || "",
          options2.constraints
        );
        if (route2) {
          return {
            handler: route2.handler,
            params: route2.params,
            searchParams: route2.searchParams
          };
        } else {
          return null;
        }
      }
      function route({ options: options2, isFastify }) {
        throwIfAlreadyStarted("Cannot add route!");
        const opts = { ...options2 };
        const path = opts.url || opts.path || "";
        if (!opts.handler) {
          throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path);
        }
        if (opts.errorHandler !== void 0 && typeof opts.errorHandler !== "function") {
          throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path);
        }
        validateBodyLimitOption(opts.bodyLimit);
        const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;
        let isGetRoute = false;
        let isHeadRoute = false;
        if (Array.isArray(opts.method)) {
          for (let i = 0; i < opts.method.length; ++i) {
            opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
            validateSchemaBodyOption.call(this, opts.method[i], path, opts.schema);
            isGetRoute = opts.method.includes("GET");
            isHeadRoute = opts.method.includes("HEAD");
          }
        } else {
          opts.method = normalizeAndValidateMethod.call(this, opts.method);
          validateSchemaBodyOption.call(this, opts.method, path, opts.schema);
          isGetRoute = opts.method === "GET";
          isHeadRoute = opts.method === "HEAD";
        }
        const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
        const prefix = this[kRoutePrefix];
        if (path === "/" && prefix.length > 0 && opts.method !== "HEAD") {
          switch (opts.prefixTrailingSlash) {
            case "slash":
              addNewRoute.call(this, { path, isFastify });
              break;
            case "no-slash":
              addNewRoute.call(this, { path: "", isFastify });
              break;
            case "both":
            default:
              addNewRoute.call(this, { path: "", isFastify });
              if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
                addNewRoute.call(this, { path, prefixing: true, isFastify });
              }
          }
        } else if (path[0] === "/" && prefix.endsWith("/")) {
          addNewRoute.call(this, { path: path.slice(1), isFastify });
        } else {
          addNewRoute.call(this, { path, isFastify });
        }
        return this;
        function addNewRoute({ path: path2, prefixing = false, isFastify: isFastify2 = false }) {
          const url2 = prefix + path2;
          opts.url = url2;
          opts.path = url2;
          opts.routePath = path2;
          opts.prefix = prefix;
          opts.logLevel = opts.logLevel || this[kLogLevel];
          if (this[kLogSerializers] || opts.logSerializers) {
            opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
          }
          if (opts.attachValidation == null) {
            opts.attachValidation = false;
          }
          if (prefixing === false) {
            for (const hook of this[kHooks].onRoute) {
              hook.call(this, opts);
            }
          }
          for (const hook of lifecycleHooks) {
            if (opts && hook in opts) {
              if (Array.isArray(opts[hook])) {
                for (const func of opts[hook]) {
                  if (typeof func !== "function") {
                    throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
                  }
                  if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                    if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  } else if (hook === "onRequestAbort") {
                    if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  } else {
                    if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  }
                }
              } else if (opts[hook] !== void 0 && typeof opts[hook] !== "function") {
                throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
              }
            }
          }
          const constraints = opts.constraints || {};
          const config3 = {
            ...opts.config,
            url: url2,
            method: opts.method
          };
          const context = new Context({
            schema: opts.schema,
            handler: opts.handler.bind(this),
            config: config3,
            errorHandler: opts.errorHandler,
            childLoggerFactory: opts.childLoggerFactory,
            bodyLimit: opts.bodyLimit,
            logLevel: opts.logLevel,
            logSerializers: opts.logSerializers,
            attachValidation: opts.attachValidation,
            schemaErrorFormatter: opts.schemaErrorFormatter,
            replySerializer: this[kReplySerializerDefault],
            validatorCompiler: opts.validatorCompiler,
            serializerCompiler: opts.serializerCompiler,
            exposeHeadRoute: shouldExposeHead,
            prefixTrailingSlash: opts.prefixTrailingSlash || "both",
            server: this,
            isFastify: isFastify2
          });
          const headHandler = router.findRoute("HEAD", opts.url, constraints);
          const hasHEADHandler = headHandler !== null;
          try {
            router.on(opts.method, opts.url, { constraints }, routeHandler, context);
          } catch (error48) {
            if (!context[kRouteByFastify]) {
              const isDuplicatedRoute = error48.message.includes(`Method '${opts.method}' already declared for route`);
              if (isDuplicatedRoute) {
                throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
              }
              throw error48;
            }
          }
          this.after((notHandledErr, done) => {
            context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
            context._parserOptions.limit = opts.bodyLimit || null;
            context.logLevel = opts.logLevel;
            context.logSerializers = opts.logSerializers;
            context.attachValidation = opts.attachValidation;
            context[kReplySerializerDefault] = this[kReplySerializerDefault];
            context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;
            avvio.once("preReady", () => {
              for (const hook of lifecycleHooks) {
                const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
                context[hook] = toSet.length ? toSet : null;
              }
              while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
                context.Request = context.Request.parent;
              }
              while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
                context.Reply = context.Reply.parent;
              }
              fourOhFour.setContext(this, context);
              if (opts.schema) {
                context.schema = normalizeSchema(context.schema, this.initialConfig);
                const schemaController = this[kSchemaController];
                if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
                  schemaController.setupValidator(this[kOptions]);
                }
                try {
                  const isCustom = typeof opts?.validatorCompiler === "function" || schemaController.isCustomValidatorCompiler;
                  compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
                } catch (error48) {
                  throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url2, error48.message);
                }
                if (opts.schema.response && !opts.serializerCompiler) {
                  schemaController.setupSerializer(this[kOptions]);
                }
                try {
                  compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
                } catch (error48) {
                  throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url2, error48.message);
                }
              }
            });
            done(notHandledErr);
          });
          if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
            const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
            prepareRoute.call(this, { method: "HEAD", url: path2, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
          }
        }
      }
      function routeHandler(req, res, params, context, query) {
        const id = getGenReqId(context.server, req);
        const loggerOpts = {
          level: context.logLevel
        };
        if (context.logSerializers) {
          loggerOpts.serializers = context.logSerializers;
        }
        const childLogger = createChildLogger(context, logger, req, id, loggerOpts);
        childLogger[kDisableRequestLogging] = disableRequestLogging;
        if (closing === true) {
          if (req.httpVersionMajor !== 2) {
            res.setHeader("Connection", "close");
          }
          if (return503OnClosing) {
            const headers = {
              "Content-Type": "application/json",
              "Content-Length": "80"
            };
            res.writeHead(503, headers);
            res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
            childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
            return;
          }
        }
        const connHeader = String.prototype.toLowerCase.call(req.headers.connection || "");
        if (connHeader === "keep-alive") {
          if (keepAliveConnections.has(req.socket) === false) {
            keepAliveConnections.add(req.socket);
            req.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
          }
        }
        if (req.headers[kRequestAcceptVersion] !== void 0) {
          req.headers["accept-version"] = req.headers[kRequestAcceptVersion];
          req.headers[kRequestAcceptVersion] = void 0;
        }
        const request = new context.Request(id, params, req, query, childLogger, context);
        const reply = new context.Reply(res, request, childLogger);
        if (disableRequestLogging === false) {
          childLogger.info({ req: request }, "incoming request");
        }
        if (hasLogger === true || context.onResponse !== null) {
          setupResponseListeners(reply);
        }
        if (context.onRequest !== null) {
          onRequestHookRunner(
            context.onRequest,
            request,
            reply,
            runPreParsing
          );
        } else {
          runPreParsing(null, request, reply);
        }
        if (context.onRequestAbort !== null) {
          req.on("close", () => {
            if (req.aborted) {
              onRequestAbortHookRunner(
                context.onRequestAbort,
                request,
                handleOnRequestAbortHooksErrors.bind(null, reply)
              );
            }
          });
        }
        if (context.onTimeout !== null) {
          if (!request.raw.socket._meta) {
            request.raw.socket.on("timeout", handleTimeout);
          }
          request.raw.socket._meta = { context, request, reply };
        }
      }
    }
    function handleOnRequestAbortHooksErrors(reply, err) {
      if (err) {
        reply.log.error({ err }, "onRequestAborted hook failed");
      }
    }
    function handleTimeout() {
      const { context, request, reply } = this._meta;
      onTimeoutHookRunner(
        context.onTimeout,
        request,
        reply,
        noop
      );
    }
    function normalizeAndValidateMethod(method) {
      if (typeof method !== "string") {
        throw new FST_ERR_ROUTE_METHOD_INVALID();
      }
      method = method.toUpperCase();
      if (!this[kSupportedHTTPMethods].bodyless.has(method) && !this[kSupportedHTTPMethods].bodywith.has(method)) {
        throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
      }
      return method;
    }
    function validateSchemaBodyOption(method, path, schema) {
      if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
        throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path);
      }
    }
    function validateBodyLimitOption(bodyLimit) {
      if (bodyLimit === void 0) return;
      if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
        throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
      }
    }
    function runPreParsing(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      request[kRequestPayloadStream] = request.raw;
      if (request[kRouteContext].preParsing !== null) {
        preParsingHookRunner(request[kRouteContext].preParsing, request, reply, handleRequest.bind(request.server));
      } else {
        handleRequest.call(request.server, null, request, reply);
      }
    }
    function buildRouterOptions(options, defaultOptions) {
      const routerOptions = options.routerOptions || /* @__PURE__ */ Object.create(null);
      const usedDeprecatedOptions = routerKeys.filter((key) => Object.hasOwn(options, key));
      if (usedDeprecatedOptions.length > 0) {
        FSTDEP022(usedDeprecatedOptions.join(", "));
      }
      for (const key of routerKeys) {
        if (!Object.hasOwn(routerOptions, key)) {
          routerOptions[key] = options[key] ?? defaultOptions[key];
        }
      }
      return routerOptions;
    }
    function removeTrackedSocket() {
      this.keepAliveConnections.delete(this.socket);
    }
    function noop() {
    }
    module.exports = { buildRouting, validateBodyLimitOption, buildRouterOptions };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/fourOhFour.js
var require_fourOhFour = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/fourOhFour.js"(exports, module) {
    "use strict";
    var FindMyWay = require_find_my_way();
    var Reply = require_reply();
    var Request2 = require_request();
    var Context = require_context();
    var {
      kRoutePrefix,
      kCanSetNotFoundHandler,
      kFourOhFourLevelInstance,
      kFourOhFourContext,
      kHooks,
      kErrorHandler
    } = require_symbols2();
    var { lifecycleHooks } = require_hooks();
    var { buildErrorHandler } = require_error_handler();
    var {
      FST_ERR_NOT_FOUND
    } = require_errors2();
    var { createChildLogger } = require_logger_factory();
    var { getGenReqId } = require_reqIdGenFactory();
    function fourOhFour(options) {
      const { logger, disableRequestLogging } = options;
      const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
      let _onBadUrlHandler = null;
      return { router, setNotFoundHandler, setContext, arrange404 };
      function arrange404(instance) {
        instance[kFourOhFourLevelInstance] = instance;
        instance[kCanSetNotFoundHandler] = true;
        router.onBadUrl = router.onBadUrl.bind(instance);
        router.defaultRoute = router.defaultRoute.bind(instance);
      }
      function basic404(request, reply) {
        const { url: url2, method } = request.raw;
        const message = `Route ${method}:${url2} not found`;
        if (!disableRequestLogging) {
          request.log.info(message);
        }
        reply.code(404).send({
          message,
          error: "Not Found",
          statusCode: 404
        });
      }
      function createOnBadUrl() {
        return function onBadUrl(path, req, res) {
          const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
          const id = getGenReqId(fourOhFourContext.server, req);
          const childLogger = createChildLogger(fourOhFourContext, logger, req, id);
          const request = new Request2(id, null, req, null, childLogger, fourOhFourContext);
          const reply = new Reply(res, request, childLogger);
          _onBadUrlHandler(request, reply);
        };
      }
      function setContext(instance, context) {
        const _404Context = Object.assign({}, instance[kFourOhFourContext]);
        _404Context.onSend = context.onSend;
        context[kFourOhFourContext] = _404Context;
      }
      function setNotFoundHandler(opts, handler, avvio, routeHandler) {
        if (this[kCanSetNotFoundHandler] === void 0) {
          this[kCanSetNotFoundHandler] = true;
        }
        if (this[kFourOhFourContext] === void 0) {
          this[kFourOhFourContext] = null;
        }
        const _fastify = this;
        const prefix = this[kRoutePrefix] || "/";
        if (this[kCanSetNotFoundHandler] === false) {
          throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
        }
        if (typeof opts === "object") {
          if (opts.preHandler) {
            if (Array.isArray(opts.preHandler)) {
              opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
            } else {
              opts.preHandler = opts.preHandler.bind(_fastify);
            }
          }
          if (opts.preValidation) {
            if (Array.isArray(opts.preValidation)) {
              opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
            } else {
              opts.preValidation = opts.preValidation.bind(_fastify);
            }
          }
        }
        if (typeof opts === "function") {
          handler = opts;
          opts = void 0;
        }
        opts = opts || {};
        if (handler) {
          this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
          handler = handler.bind(this);
          _onBadUrlHandler = handler;
        } else {
          handler = basic404;
          _onBadUrlHandler = basic404;
        }
        this.after((notHandledErr, done) => {
          _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
          done(notHandledErr);
        });
      }
      function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
        const context = new Context({
          schema: opts.schema,
          handler,
          config: opts.config || {},
          server: this
        });
        avvio.once("preReady", () => {
          const context2 = this[kFourOhFourContext];
          for (const hook of lifecycleHooks) {
            const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
            context2[hook] = toSet.length ? toSet : null;
          }
          context2.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
        });
        if (this[kFourOhFourContext] !== null && prefix === "/") {
          Object.assign(this[kFourOhFourContext], context);
          return;
        }
        this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
        router.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context);
        router.all(prefix, routeHandler, context);
      }
      function fourOhFourFallBack(req, res) {
        const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
        const id = getGenReqId(fourOhFourContext.server, req);
        const childLogger = createChildLogger(fourOhFourContext, logger, req, id);
        childLogger.info({ req }, "incoming request");
        const request = new Request2(id, null, req, null, childLogger, fourOhFourContext);
        const reply = new Reply(res, request, childLogger);
        request.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
        request.log.warn(router.prettyPrint());
        reply.code(404).send(new FST_ERR_NOT_FOUND());
      }
    }
    module.exports = fourOhFour;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/configValidator.js
var require_configValidator = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/configValidator.js"(exports, module) {
    "use strict";
    module.exports = validate10;
    module.exports.default = validate10;
    var schema11 = { "type": "object", "additionalProperties": false, "properties": { "connectionTimeout": { "type": "integer", "default": 0 }, "keepAliveTimeout": { "type": "integer", "default": 72e3 }, "forceCloseConnections": { "oneOf": [{ "type": "string", "pattern": "idle" }, { "type": "boolean" }] }, "maxRequestsPerSocket": { "type": "integer", "default": 0, "nullable": true }, "requestTimeout": { "type": "integer", "default": 0 }, "bodyLimit": { "type": "integer", "default": 1048576 }, "caseSensitive": { "type": "boolean", "default": true }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "http2": { "type": "boolean" }, "https": { "if": { "not": { "oneOf": [{ "type": "boolean" }, { "type": "null" }, { "type": "object", "additionalProperties": false, "required": ["allowHTTP1"], "properties": { "allowHTTP1": { "type": "boolean" } } }] } }, "then": { "setDefaultValue": true } }, "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "disableRequestLogging": { "type": "boolean", "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "onProtoPoisoning": { "type": "string", "default": "error" }, "onConstructorPoisoning": { "type": "string", "default": "error" }, "pluginTimeout": { "type": "integer", "default": 1e4 }, "requestIdHeader": { "anyOf": [{ "type": "boolean" }, { "type": "string" }], "default": false }, "requestIdLogLabel": { "type": "string", "default": "reqId" }, "http2SessionTimeout": { "type": "integer", "default": 72e3 }, "exposeHeadRoutes": { "type": "boolean", "default": true }, "useSemicolonDelimiter": { "type": "boolean", "default": false }, "routerOptions": { "type": "object", "additionalProperties": false, "properties": { "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "useSemicolonDelimiter": { "type": "boolean", "default": false } } }, "constraints": { "type": "object", "additionalProperties": { "type": "object", "required": ["name", "storage", "validate", "deriveConstraint"], "additionalProperties": true, "properties": { "name": { "type": "string" }, "storage": {}, "validate": {}, "deriveConstraint": {} } } } } };
    var func2 = Object.prototype.hasOwnProperty;
    var pattern0 = new RegExp("idle", "u");
    function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (errors === 0) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.connectionTimeout === void 0) {
            data.connectionTimeout = 0;
          }
          if (data.keepAliveTimeout === void 0) {
            data.keepAliveTimeout = 72e3;
          }
          if (data.maxRequestsPerSocket === void 0) {
            data.maxRequestsPerSocket = 0;
          }
          if (data.requestTimeout === void 0) {
            data.requestTimeout = 0;
          }
          if (data.bodyLimit === void 0) {
            data.bodyLimit = 1048576;
          }
          if (data.caseSensitive === void 0) {
            data.caseSensitive = true;
          }
          if (data.allowUnsafeRegex === void 0) {
            data.allowUnsafeRegex = false;
          }
          if (data.ignoreTrailingSlash === void 0) {
            data.ignoreTrailingSlash = false;
          }
          if (data.ignoreDuplicateSlashes === void 0) {
            data.ignoreDuplicateSlashes = false;
          }
          if (data.disableRequestLogging === void 0) {
            data.disableRequestLogging = false;
          }
          if (data.maxParamLength === void 0) {
            data.maxParamLength = 100;
          }
          if (data.onProtoPoisoning === void 0) {
            data.onProtoPoisoning = "error";
          }
          if (data.onConstructorPoisoning === void 0) {
            data.onConstructorPoisoning = "error";
          }
          if (data.pluginTimeout === void 0) {
            data.pluginTimeout = 1e4;
          }
          if (data.requestIdHeader === void 0) {
            data.requestIdHeader = false;
          }
          if (data.requestIdLogLabel === void 0) {
            data.requestIdLogLabel = "reqId";
          }
          if (data.http2SessionTimeout === void 0) {
            data.http2SessionTimeout = 72e3;
          }
          if (data.exposeHeadRoutes === void 0) {
            data.exposeHeadRoutes = true;
          }
          if (data.useSemicolonDelimiter === void 0) {
            data.useSemicolonDelimiter = false;
          }
          const _errs1 = errors;
          for (const key0 in data) {
            if (!func2.call(schema11.properties, key0)) {
              delete data[key0];
            }
          }
          if (_errs1 === errors) {
            let data0 = data.connectionTimeout;
            const _errs2 = errors;
            if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
              let dataType0 = typeof data0;
              let coerced0 = void 0;
              if (!(coerced0 !== void 0)) {
                if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
                  coerced0 = +data0;
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                  return false;
                }
              }
              if (coerced0 !== void 0) {
                data0 = coerced0;
                if (data !== void 0) {
                  data["connectionTimeout"] = coerced0;
                }
              }
            }
            var valid0 = _errs2 === errors;
            if (valid0) {
              let data1 = data.keepAliveTimeout;
              const _errs4 = errors;
              if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
                let dataType1 = typeof data1;
                let coerced1 = void 0;
                if (!(coerced1 !== void 0)) {
                  if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                    coerced1 = +data1;
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                    return false;
                  }
                }
                if (coerced1 !== void 0) {
                  data1 = coerced1;
                  if (data !== void 0) {
                    data["keepAliveTimeout"] = coerced1;
                  }
                }
              }
              var valid0 = _errs4 === errors;
              if (valid0) {
                if (data.forceCloseConnections !== void 0) {
                  let data2 = data.forceCloseConnections;
                  const _errs6 = errors;
                  const _errs7 = errors;
                  let valid1 = false;
                  let passing0 = null;
                  const _errs8 = errors;
                  if (typeof data2 !== "string") {
                    let dataType2 = typeof data2;
                    let coerced2 = void 0;
                    if (!(coerced2 !== void 0)) {
                      if (dataType2 == "number" || dataType2 == "boolean") {
                        coerced2 = "" + data2;
                      } else if (data2 === null) {
                        coerced2 = "";
                      } else {
                        const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err0];
                        } else {
                          vErrors.push(err0);
                        }
                        errors++;
                      }
                    }
                    if (coerced2 !== void 0) {
                      data2 = coerced2;
                      if (data !== void 0) {
                        data["forceCloseConnections"] = coerced2;
                      }
                    }
                  }
                  if (errors === _errs8) {
                    if (typeof data2 === "string") {
                      if (!pattern0.test(data2)) {
                        const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                        if (vErrors === null) {
                          vErrors = [err1];
                        } else {
                          vErrors.push(err1);
                        }
                        errors++;
                      }
                    }
                  }
                  var _valid0 = _errs8 === errors;
                  if (_valid0) {
                    valid1 = true;
                    passing0 = 0;
                  }
                  const _errs10 = errors;
                  if (typeof data2 !== "boolean") {
                    let coerced3 = void 0;
                    if (!(coerced3 !== void 0)) {
                      if (data2 === "false" || data2 === 0 || data2 === null) {
                        coerced3 = false;
                      } else if (data2 === "true" || data2 === 1) {
                        coerced3 = true;
                      } else {
                        const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                        if (vErrors === null) {
                          vErrors = [err2];
                        } else {
                          vErrors.push(err2);
                        }
                        errors++;
                      }
                    }
                    if (coerced3 !== void 0) {
                      data2 = coerced3;
                      if (data !== void 0) {
                        data["forceCloseConnections"] = coerced3;
                      }
                    }
                  }
                  var _valid0 = _errs10 === errors;
                  if (_valid0 && valid1) {
                    valid1 = false;
                    passing0 = [passing0, 1];
                  } else {
                    if (_valid0) {
                      valid1 = true;
                      passing0 = 1;
                    }
                  }
                  if (!valid1) {
                    const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                    if (vErrors === null) {
                      vErrors = [err3];
                    } else {
                      vErrors.push(err3);
                    }
                    errors++;
                    validate10.errors = vErrors;
                    return false;
                  } else {
                    errors = _errs7;
                    if (vErrors !== null) {
                      if (_errs7) {
                        vErrors.length = _errs7;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid0 = _errs6 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  let data3 = data.maxRequestsPerSocket;
                  const _errs12 = errors;
                  if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3)) && data3 !== null) {
                    let dataType4 = typeof data3;
                    let coerced4 = void 0;
                    if (!(coerced4 !== void 0)) {
                      if (dataType4 === "boolean" || data3 === null || dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1)) {
                        coerced4 = +data3;
                      } else if (data3 === "" || data3 === 0 || data3 === false) {
                        coerced4 = null;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced4 !== void 0) {
                      data3 = coerced4;
                      if (data !== void 0) {
                        data["maxRequestsPerSocket"] = coerced4;
                      }
                    }
                  }
                  var valid0 = _errs12 === errors;
                  if (valid0) {
                    let data4 = data.requestTimeout;
                    const _errs15 = errors;
                    if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                      let dataType5 = typeof data4;
                      let coerced5 = void 0;
                      if (!(coerced5 !== void 0)) {
                        if (dataType5 === "boolean" || data4 === null || dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1)) {
                          coerced5 = +data4;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                          return false;
                        }
                      }
                      if (coerced5 !== void 0) {
                        data4 = coerced5;
                        if (data !== void 0) {
                          data["requestTimeout"] = coerced5;
                        }
                      }
                    }
                    var valid0 = _errs15 === errors;
                    if (valid0) {
                      let data5 = data.bodyLimit;
                      const _errs17 = errors;
                      if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                        let dataType6 = typeof data5;
                        let coerced6 = void 0;
                        if (!(coerced6 !== void 0)) {
                          if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                            coerced6 = +data5;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                            return false;
                          }
                        }
                        if (coerced6 !== void 0) {
                          data5 = coerced6;
                          if (data !== void 0) {
                            data["bodyLimit"] = coerced6;
                          }
                        }
                      }
                      var valid0 = _errs17 === errors;
                      if (valid0) {
                        let data6 = data.caseSensitive;
                        const _errs19 = errors;
                        if (typeof data6 !== "boolean") {
                          let coerced7 = void 0;
                          if (!(coerced7 !== void 0)) {
                            if (data6 === "false" || data6 === 0 || data6 === null) {
                              coerced7 = false;
                            } else if (data6 === "true" || data6 === 1) {
                              coerced7 = true;
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                              return false;
                            }
                          }
                          if (coerced7 !== void 0) {
                            data6 = coerced7;
                            if (data !== void 0) {
                              data["caseSensitive"] = coerced7;
                            }
                          }
                        }
                        var valid0 = _errs19 === errors;
                        if (valid0) {
                          let data7 = data.allowUnsafeRegex;
                          const _errs21 = errors;
                          if (typeof data7 !== "boolean") {
                            let coerced8 = void 0;
                            if (!(coerced8 !== void 0)) {
                              if (data7 === "false" || data7 === 0 || data7 === null) {
                                coerced8 = false;
                              } else if (data7 === "true" || data7 === 1) {
                                coerced8 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced8 !== void 0) {
                              data7 = coerced8;
                              if (data !== void 0) {
                                data["allowUnsafeRegex"] = coerced8;
                              }
                            }
                          }
                          var valid0 = _errs21 === errors;
                          if (valid0) {
                            if (data.http2 !== void 0) {
                              let data8 = data.http2;
                              const _errs23 = errors;
                              if (typeof data8 !== "boolean") {
                                let coerced9 = void 0;
                                if (!(coerced9 !== void 0)) {
                                  if (data8 === "false" || data8 === 0 || data8 === null) {
                                    coerced9 = false;
                                  } else if (data8 === "true" || data8 === 1) {
                                    coerced9 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced9 !== void 0) {
                                  data8 = coerced9;
                                  if (data !== void 0) {
                                    data["http2"] = coerced9;
                                  }
                                }
                              }
                              var valid0 = _errs23 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.https !== void 0) {
                                let data9 = data.https;
                                const _errs25 = errors;
                                const _errs26 = errors;
                                let valid2 = true;
                                const _errs27 = errors;
                                const _errs28 = errors;
                                const _errs29 = errors;
                                const _errs30 = errors;
                                let valid4 = false;
                                let passing1 = null;
                                const _errs31 = errors;
                                if (typeof data9 !== "boolean") {
                                  let coerced10 = void 0;
                                  if (!(coerced10 !== void 0)) {
                                    if (data9 === "false" || data9 === 0 || data9 === null) {
                                      coerced10 = false;
                                    } else if (data9 === "true" || data9 === 1) {
                                      coerced10 = true;
                                    } else {
                                      const err4 = {};
                                      if (vErrors === null) {
                                        vErrors = [err4];
                                      } else {
                                        vErrors.push(err4);
                                      }
                                      errors++;
                                    }
                                  }
                                  if (coerced10 !== void 0) {
                                    data9 = coerced10;
                                    if (data !== void 0) {
                                      data["https"] = coerced10;
                                    }
                                  }
                                }
                                var _valid2 = _errs31 === errors;
                                if (_valid2) {
                                  valid4 = true;
                                  passing1 = 0;
                                }
                                const _errs33 = errors;
                                if (data9 !== null) {
                                  let coerced11 = void 0;
                                  if (!(coerced11 !== void 0)) {
                                    if (data9 === "" || data9 === 0 || data9 === false) {
                                      coerced11 = null;
                                    } else {
                                      const err5 = {};
                                      if (vErrors === null) {
                                        vErrors = [err5];
                                      } else {
                                        vErrors.push(err5);
                                      }
                                      errors++;
                                    }
                                  }
                                  if (coerced11 !== void 0) {
                                    data9 = coerced11;
                                    if (data !== void 0) {
                                      data["https"] = coerced11;
                                    }
                                  }
                                }
                                var _valid2 = _errs33 === errors;
                                if (_valid2 && valid4) {
                                  valid4 = false;
                                  passing1 = [passing1, 1];
                                } else {
                                  if (_valid2) {
                                    valid4 = true;
                                    passing1 = 1;
                                  }
                                  const _errs35 = errors;
                                  if (errors === _errs35) {
                                    if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                      let missing0;
                                      if (data9.allowHTTP1 === void 0 && (missing0 = "allowHTTP1")) {
                                        const err6 = {};
                                        if (vErrors === null) {
                                          vErrors = [err6];
                                        } else {
                                          vErrors.push(err6);
                                        }
                                        errors++;
                                      } else {
                                        const _errs37 = errors;
                                        for (const key1 in data9) {
                                          if (!(key1 === "allowHTTP1")) {
                                            delete data9[key1];
                                          }
                                        }
                                        if (_errs37 === errors) {
                                          if (data9.allowHTTP1 !== void 0) {
                                            let data10 = data9.allowHTTP1;
                                            if (typeof data10 !== "boolean") {
                                              let coerced12 = void 0;
                                              if (!(coerced12 !== void 0)) {
                                                if (data10 === "false" || data10 === 0 || data10 === null) {
                                                  coerced12 = false;
                                                } else if (data10 === "true" || data10 === 1) {
                                                  coerced12 = true;
                                                } else {
                                                  const err7 = {};
                                                  if (vErrors === null) {
                                                    vErrors = [err7];
                                                  } else {
                                                    vErrors.push(err7);
                                                  }
                                                  errors++;
                                                }
                                              }
                                              if (coerced12 !== void 0) {
                                                data10 = coerced12;
                                                if (data9 !== void 0) {
                                                  data9["allowHTTP1"] = coerced12;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    } else {
                                      const err8 = {};
                                      if (vErrors === null) {
                                        vErrors = [err8];
                                      } else {
                                        vErrors.push(err8);
                                      }
                                      errors++;
                                    }
                                  }
                                  var _valid2 = _errs35 === errors;
                                  if (_valid2 && valid4) {
                                    valid4 = false;
                                    passing1 = [passing1, 2];
                                  } else {
                                    if (_valid2) {
                                      valid4 = true;
                                      passing1 = 2;
                                    }
                                  }
                                }
                                if (!valid4) {
                                  const err9 = {};
                                  if (vErrors === null) {
                                    vErrors = [err9];
                                  } else {
                                    vErrors.push(err9);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs30;
                                  if (vErrors !== null) {
                                    if (_errs30) {
                                      vErrors.length = _errs30;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                var valid3 = _errs29 === errors;
                                if (valid3) {
                                  const err10 = {};
                                  if (vErrors === null) {
                                    vErrors = [err10];
                                  } else {
                                    vErrors.push(err10);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs28;
                                  if (vErrors !== null) {
                                    if (_errs28) {
                                      vErrors.length = _errs28;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                var _valid1 = _errs27 === errors;
                                errors = _errs26;
                                if (vErrors !== null) {
                                  if (_errs26) {
                                    vErrors.length = _errs26;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                                if (_valid1) {
                                  const _errs40 = errors;
                                  data["https"] = true;
                                  var _valid1 = _errs40 === errors;
                                  valid2 = _valid1;
                                }
                                if (!valid2) {
                                  const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                                  if (vErrors === null) {
                                    vErrors = [err11];
                                  } else {
                                    vErrors.push(err11);
                                  }
                                  errors++;
                                  validate10.errors = vErrors;
                                  return false;
                                }
                                var valid0 = _errs25 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                let data11 = data.ignoreTrailingSlash;
                                const _errs41 = errors;
                                if (typeof data11 !== "boolean") {
                                  let coerced13 = void 0;
                                  if (!(coerced13 !== void 0)) {
                                    if (data11 === "false" || data11 === 0 || data11 === null) {
                                      coerced13 = false;
                                    } else if (data11 === "true" || data11 === 1) {
                                      coerced13 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced13 !== void 0) {
                                    data11 = coerced13;
                                    if (data !== void 0) {
                                      data["ignoreTrailingSlash"] = coerced13;
                                    }
                                  }
                                }
                                var valid0 = _errs41 === errors;
                                if (valid0) {
                                  let data12 = data.ignoreDuplicateSlashes;
                                  const _errs43 = errors;
                                  if (typeof data12 !== "boolean") {
                                    let coerced14 = void 0;
                                    if (!(coerced14 !== void 0)) {
                                      if (data12 === "false" || data12 === 0 || data12 === null) {
                                        coerced14 = false;
                                      } else if (data12 === "true" || data12 === 1) {
                                        coerced14 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced14 !== void 0) {
                                      data12 = coerced14;
                                      if (data !== void 0) {
                                        data["ignoreDuplicateSlashes"] = coerced14;
                                      }
                                    }
                                  }
                                  var valid0 = _errs43 === errors;
                                  if (valid0) {
                                    let data13 = data.disableRequestLogging;
                                    const _errs45 = errors;
                                    if (typeof data13 !== "boolean") {
                                      let coerced15 = void 0;
                                      if (!(coerced15 !== void 0)) {
                                        if (data13 === "false" || data13 === 0 || data13 === null) {
                                          coerced15 = false;
                                        } else if (data13 === "true" || data13 === 1) {
                                          coerced15 = true;
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                          return false;
                                        }
                                      }
                                      if (coerced15 !== void 0) {
                                        data13 = coerced15;
                                        if (data !== void 0) {
                                          data["disableRequestLogging"] = coerced15;
                                        }
                                      }
                                    }
                                    var valid0 = _errs45 === errors;
                                    if (valid0) {
                                      let data14 = data.maxParamLength;
                                      const _errs47 = errors;
                                      if (!(typeof data14 == "number" && (!(data14 % 1) && !isNaN(data14)) && isFinite(data14))) {
                                        let dataType16 = typeof data14;
                                        let coerced16 = void 0;
                                        if (!(coerced16 !== void 0)) {
                                          if (dataType16 === "boolean" || data14 === null || dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1)) {
                                            coerced16 = +data14;
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                            return false;
                                          }
                                        }
                                        if (coerced16 !== void 0) {
                                          data14 = coerced16;
                                          if (data !== void 0) {
                                            data["maxParamLength"] = coerced16;
                                          }
                                        }
                                      }
                                      var valid0 = _errs47 === errors;
                                      if (valid0) {
                                        let data15 = data.onProtoPoisoning;
                                        const _errs49 = errors;
                                        if (typeof data15 !== "string") {
                                          let dataType17 = typeof data15;
                                          let coerced17 = void 0;
                                          if (!(coerced17 !== void 0)) {
                                            if (dataType17 == "number" || dataType17 == "boolean") {
                                              coerced17 = "" + data15;
                                            } else if (data15 === null) {
                                              coerced17 = "";
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          if (coerced17 !== void 0) {
                                            data15 = coerced17;
                                            if (data !== void 0) {
                                              data["onProtoPoisoning"] = coerced17;
                                            }
                                          }
                                        }
                                        var valid0 = _errs49 === errors;
                                        if (valid0) {
                                          let data16 = data.onConstructorPoisoning;
                                          const _errs51 = errors;
                                          if (typeof data16 !== "string") {
                                            let dataType18 = typeof data16;
                                            let coerced18 = void 0;
                                            if (!(coerced18 !== void 0)) {
                                              if (dataType18 == "number" || dataType18 == "boolean") {
                                                coerced18 = "" + data16;
                                              } else if (data16 === null) {
                                                coerced18 = "";
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                            if (coerced18 !== void 0) {
                                              data16 = coerced18;
                                              if (data !== void 0) {
                                                data["onConstructorPoisoning"] = coerced18;
                                              }
                                            }
                                          }
                                          var valid0 = _errs51 === errors;
                                          if (valid0) {
                                            let data17 = data.pluginTimeout;
                                            const _errs53 = errors;
                                            if (!(typeof data17 == "number" && (!(data17 % 1) && !isNaN(data17)) && isFinite(data17))) {
                                              let dataType19 = typeof data17;
                                              let coerced19 = void 0;
                                              if (!(coerced19 !== void 0)) {
                                                if (dataType19 === "boolean" || data17 === null || dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1)) {
                                                  coerced19 = +data17;
                                                } else {
                                                  validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                              }
                                              if (coerced19 !== void 0) {
                                                data17 = coerced19;
                                                if (data !== void 0) {
                                                  data["pluginTimeout"] = coerced19;
                                                }
                                              }
                                            }
                                            var valid0 = _errs53 === errors;
                                            if (valid0) {
                                              let data18 = data.requestIdHeader;
                                              const _errs55 = errors;
                                              const _errs56 = errors;
                                              let valid6 = false;
                                              const _errs57 = errors;
                                              if (typeof data18 !== "boolean") {
                                                let coerced20 = void 0;
                                                if (!(coerced20 !== void 0)) {
                                                  if (data18 === "false" || data18 === 0 || data18 === null) {
                                                    coerced20 = false;
                                                  } else if (data18 === "true" || data18 === 1) {
                                                    coerced20 = true;
                                                  } else {
                                                    const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                    if (vErrors === null) {
                                                      vErrors = [err12];
                                                    } else {
                                                      vErrors.push(err12);
                                                    }
                                                    errors++;
                                                  }
                                                }
                                                if (coerced20 !== void 0) {
                                                  data18 = coerced20;
                                                  if (data !== void 0) {
                                                    data["requestIdHeader"] = coerced20;
                                                  }
                                                }
                                              }
                                              var _valid3 = _errs57 === errors;
                                              valid6 = valid6 || _valid3;
                                              if (!valid6) {
                                                const _errs59 = errors;
                                                if (typeof data18 !== "string") {
                                                  let dataType21 = typeof data18;
                                                  let coerced21 = void 0;
                                                  if (!(coerced21 !== void 0)) {
                                                    if (dataType21 == "number" || dataType21 == "boolean") {
                                                      coerced21 = "" + data18;
                                                    } else if (data18 === null) {
                                                      coerced21 = "";
                                                    } else {
                                                      const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                      if (vErrors === null) {
                                                        vErrors = [err13];
                                                      } else {
                                                        vErrors.push(err13);
                                                      }
                                                      errors++;
                                                    }
                                                  }
                                                  if (coerced21 !== void 0) {
                                                    data18 = coerced21;
                                                    if (data !== void 0) {
                                                      data["requestIdHeader"] = coerced21;
                                                    }
                                                  }
                                                }
                                                var _valid3 = _errs59 === errors;
                                                valid6 = valid6 || _valid3;
                                              }
                                              if (!valid6) {
                                                const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err14];
                                                } else {
                                                  vErrors.push(err14);
                                                }
                                                errors++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors = _errs56;
                                                if (vErrors !== null) {
                                                  if (_errs56) {
                                                    vErrors.length = _errs56;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs55 === errors;
                                              if (valid0) {
                                                let data19 = data.requestIdLogLabel;
                                                const _errs61 = errors;
                                                if (typeof data19 !== "string") {
                                                  let dataType22 = typeof data19;
                                                  let coerced22 = void 0;
                                                  if (!(coerced22 !== void 0)) {
                                                    if (dataType22 == "number" || dataType22 == "boolean") {
                                                      coerced22 = "" + data19;
                                                    } else if (data19 === null) {
                                                      coerced22 = "";
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced22 !== void 0) {
                                                    data19 = coerced22;
                                                    if (data !== void 0) {
                                                      data["requestIdLogLabel"] = coerced22;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs61 === errors;
                                                if (valid0) {
                                                  let data20 = data.http2SessionTimeout;
                                                  const _errs63 = errors;
                                                  if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                                                    let dataType23 = typeof data20;
                                                    let coerced23 = void 0;
                                                    if (!(coerced23 !== void 0)) {
                                                      if (dataType23 === "boolean" || data20 === null || dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1)) {
                                                        coerced23 = +data20;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced23 !== void 0) {
                                                      data20 = coerced23;
                                                      if (data !== void 0) {
                                                        data["http2SessionTimeout"] = coerced23;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs63 === errors;
                                                  if (valid0) {
                                                    let data21 = data.exposeHeadRoutes;
                                                    const _errs65 = errors;
                                                    if (typeof data21 !== "boolean") {
                                                      let coerced24 = void 0;
                                                      if (!(coerced24 !== void 0)) {
                                                        if (data21 === "false" || data21 === 0 || data21 === null) {
                                                          coerced24 = false;
                                                        } else if (data21 === "true" || data21 === 1) {
                                                          coerced24 = true;
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                          return false;
                                                        }
                                                      }
                                                      if (coerced24 !== void 0) {
                                                        data21 = coerced24;
                                                        if (data !== void 0) {
                                                          data["exposeHeadRoutes"] = coerced24;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs65 === errors;
                                                    if (valid0) {
                                                      let data22 = data.useSemicolonDelimiter;
                                                      const _errs67 = errors;
                                                      if (typeof data22 !== "boolean") {
                                                        let coerced25 = void 0;
                                                        if (!(coerced25 !== void 0)) {
                                                          if (data22 === "false" || data22 === 0 || data22 === null) {
                                                            coerced25 = false;
                                                          } else if (data22 === "true" || data22 === 1) {
                                                            coerced25 = true;
                                                          } else {
                                                            validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                            return false;
                                                          }
                                                        }
                                                        if (coerced25 !== void 0) {
                                                          data22 = coerced25;
                                                          if (data !== void 0) {
                                                            data["useSemicolonDelimiter"] = coerced25;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs67 === errors;
                                                      if (valid0) {
                                                        if (data.routerOptions !== void 0) {
                                                          let data23 = data.routerOptions;
                                                          const _errs69 = errors;
                                                          if (errors === _errs69) {
                                                            if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
                                                              if (data23.ignoreTrailingSlash === void 0) {
                                                                data23.ignoreTrailingSlash = false;
                                                              }
                                                              if (data23.ignoreDuplicateSlashes === void 0) {
                                                                data23.ignoreDuplicateSlashes = false;
                                                              }
                                                              if (data23.maxParamLength === void 0) {
                                                                data23.maxParamLength = 100;
                                                              }
                                                              if (data23.allowUnsafeRegex === void 0) {
                                                                data23.allowUnsafeRegex = false;
                                                              }
                                                              if (data23.useSemicolonDelimiter === void 0) {
                                                                data23.useSemicolonDelimiter = false;
                                                              }
                                                              const _errs71 = errors;
                                                              for (const key2 in data23) {
                                                                if (!(key2 === "ignoreTrailingSlash" || key2 === "ignoreDuplicateSlashes" || key2 === "maxParamLength" || key2 === "allowUnsafeRegex" || key2 === "useSemicolonDelimiter")) {
                                                                  delete data23[key2];
                                                                }
                                                              }
                                                              if (_errs71 === errors) {
                                                                let data24 = data23.ignoreTrailingSlash;
                                                                const _errs72 = errors;
                                                                if (typeof data24 !== "boolean") {
                                                                  let coerced26 = void 0;
                                                                  if (!(coerced26 !== void 0)) {
                                                                    if (data24 === "false" || data24 === 0 || data24 === null) {
                                                                      coerced26 = false;
                                                                    } else if (data24 === "true" || data24 === 1) {
                                                                      coerced26 = true;
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/routerOptions/ignoreTrailingSlash", schemaPath: "#/properties/routerOptions/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  if (coerced26 !== void 0) {
                                                                    data24 = coerced26;
                                                                    if (data23 !== void 0) {
                                                                      data23["ignoreTrailingSlash"] = coerced26;
                                                                    }
                                                                  }
                                                                }
                                                                var valid7 = _errs72 === errors;
                                                                if (valid7) {
                                                                  let data25 = data23.ignoreDuplicateSlashes;
                                                                  const _errs74 = errors;
                                                                  if (typeof data25 !== "boolean") {
                                                                    let coerced27 = void 0;
                                                                    if (!(coerced27 !== void 0)) {
                                                                      if (data25 === "false" || data25 === 0 || data25 === null) {
                                                                        coerced27 = false;
                                                                      } else if (data25 === "true" || data25 === 1) {
                                                                        coerced27 = true;
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/routerOptions/ignoreDuplicateSlashes", schemaPath: "#/properties/routerOptions/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    if (coerced27 !== void 0) {
                                                                      data25 = coerced27;
                                                                      if (data23 !== void 0) {
                                                                        data23["ignoreDuplicateSlashes"] = coerced27;
                                                                      }
                                                                    }
                                                                  }
                                                                  var valid7 = _errs74 === errors;
                                                                  if (valid7) {
                                                                    let data26 = data23.maxParamLength;
                                                                    const _errs76 = errors;
                                                                    if (!(typeof data26 == "number" && (!(data26 % 1) && !isNaN(data26)) && isFinite(data26))) {
                                                                      let dataType28 = typeof data26;
                                                                      let coerced28 = void 0;
                                                                      if (!(coerced28 !== void 0)) {
                                                                        if (dataType28 === "boolean" || data26 === null || dataType28 === "string" && data26 && data26 == +data26 && !(data26 % 1)) {
                                                                          coerced28 = +data26;
                                                                        } else {
                                                                          validate10.errors = [{ instancePath: instancePath + "/routerOptions/maxParamLength", schemaPath: "#/properties/routerOptions/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      if (coerced28 !== void 0) {
                                                                        data26 = coerced28;
                                                                        if (data23 !== void 0) {
                                                                          data23["maxParamLength"] = coerced28;
                                                                        }
                                                                      }
                                                                    }
                                                                    var valid7 = _errs76 === errors;
                                                                    if (valid7) {
                                                                      let data27 = data23.allowUnsafeRegex;
                                                                      const _errs78 = errors;
                                                                      if (typeof data27 !== "boolean") {
                                                                        let coerced29 = void 0;
                                                                        if (!(coerced29 !== void 0)) {
                                                                          if (data27 === "false" || data27 === 0 || data27 === null) {
                                                                            coerced29 = false;
                                                                          } else if (data27 === "true" || data27 === 1) {
                                                                            coerced29 = true;
                                                                          } else {
                                                                            validate10.errors = [{ instancePath: instancePath + "/routerOptions/allowUnsafeRegex", schemaPath: "#/properties/routerOptions/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                            return false;
                                                                          }
                                                                        }
                                                                        if (coerced29 !== void 0) {
                                                                          data27 = coerced29;
                                                                          if (data23 !== void 0) {
                                                                            data23["allowUnsafeRegex"] = coerced29;
                                                                          }
                                                                        }
                                                                      }
                                                                      var valid7 = _errs78 === errors;
                                                                      if (valid7) {
                                                                        let data28 = data23.useSemicolonDelimiter;
                                                                        const _errs80 = errors;
                                                                        if (typeof data28 !== "boolean") {
                                                                          let coerced30 = void 0;
                                                                          if (!(coerced30 !== void 0)) {
                                                                            if (data28 === "false" || data28 === 0 || data28 === null) {
                                                                              coerced30 = false;
                                                                            } else if (data28 === "true" || data28 === 1) {
                                                                              coerced30 = true;
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/routerOptions/useSemicolonDelimiter", schemaPath: "#/properties/routerOptions/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          if (coerced30 !== void 0) {
                                                                            data28 = coerced30;
                                                                            if (data23 !== void 0) {
                                                                              data23["useSemicolonDelimiter"] = coerced30;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid7 = _errs80 === errors;
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/routerOptions", schemaPath: "#/properties/routerOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs69 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.constraints !== void 0) {
                                                            let data29 = data.constraints;
                                                            const _errs82 = errors;
                                                            if (errors === _errs82) {
                                                              if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                for (const key3 in data29) {
                                                                  let data30 = data29[key3];
                                                                  const _errs85 = errors;
                                                                  if (errors === _errs85) {
                                                                    if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
                                                                      let missing1;
                                                                      if (data30.name === void 0 && (missing1 = "name") || data30.storage === void 0 && (missing1 = "storage") || data30.validate === void 0 && (missing1 = "validate") || data30.deriveConstraint === void 0 && (missing1 = "deriveConstraint")) {
                                                                        validate10.errors = [{ instancePath: instancePath + "/constraints/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                        return false;
                                                                      } else {
                                                                        if (data30.name !== void 0) {
                                                                          let data31 = data30.name;
                                                                          if (typeof data31 !== "string") {
                                                                            let dataType31 = typeof data31;
                                                                            let coerced31 = void 0;
                                                                            if (!(coerced31 !== void 0)) {
                                                                              if (dataType31 == "number" || dataType31 == "boolean") {
                                                                                coerced31 = "" + data31;
                                                                              } else if (data31 === null) {
                                                                                coerced31 = "";
                                                                              } else {
                                                                                validate10.errors = [{ instancePath: instancePath + "/constraints/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                            }
                                                                            if (coerced31 !== void 0) {
                                                                              data31 = coerced31;
                                                                              if (data30 !== void 0) {
                                                                                data30["name"] = coerced31;
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/constraints/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid8 = _errs85 === errors;
                                                                  if (!valid8) {
                                                                    break;
                                                                  }
                                                                }
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs82 === errors;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
          return false;
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
    module.exports.defaultInitOptions = { "connectionTimeout": 0, "keepAliveTimeout": 72e3, "maxRequestsPerSocket": 0, "requestTimeout": 0, "bodyLimit": 1048576, "caseSensitive": true, "allowUnsafeRegex": false, "disableRequestLogging": false, "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "onProtoPoisoning": "error", "onConstructorPoisoning": "error", "pluginTimeout": 1e4, "requestIdHeader": false, "requestIdLogLabel": "reqId", "http2SessionTimeout": 72e3, "exposeHeadRoutes": true, "useSemicolonDelimiter": false, "allowErrorHandlerOverride": true, "routerOptions": { "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "allowUnsafeRegex": false, "useSemicolonDelimiter": false } };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/initialConfigValidation.js
var require_initialConfigValidation = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/initialConfigValidation.js"(exports, module) {
    "use strict";
    var validate = require_configValidator();
    var deepClone = require_rfdc()({ circles: true, proto: false });
    var { FST_ERR_INIT_OPTS_INVALID } = require_errors2();
    function validateInitialConfig(options) {
      const opts = deepClone(options);
      if (!validate(opts)) {
        const error48 = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e) => e.message)));
        error48.errors = validate.errors;
        throw error48;
      }
      return deepFreezeObject(opts);
    }
    function deepFreezeObject(object3) {
      const properties = Object.getOwnPropertyNames(object3);
      for (const name of properties) {
        const value = object3[name];
        if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
          continue;
        }
        object3[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
      }
      return Object.freeze(object3);
    }
    module.exports = validateInitialConfig;
    module.exports.defaultInitOptions = validate.defaultInitOptions;
    module.exports.utils = { deepFreezeObject };
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/pluginOverride.js
var require_pluginOverride = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/pluginOverride.js"(exports, module) {
    "use strict";
    var {
      kAvvioBoot,
      kChildren,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kPluginNameChain,
      kErrorHandlerAlreadySet
    } = require_symbols2();
    var Reply = require_reply();
    var Request2 = require_request();
    var SchemaController = require_schema_controller();
    var ContentTypeParser = require_contentTypeParser();
    var { buildHooks } = require_hooks();
    var pluginUtils = require_pluginUtils();
    module.exports = function override(old, fn, opts) {
      const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);
      const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
      if (shouldSkipOverride) {
        old[kPluginNameChain].push(fnName);
        return old;
      }
      const instance = Object.create(old);
      old[kChildren].push(instance);
      instance.ready = old[kAvvioBoot].bind(instance);
      instance[kChildren] = [];
      instance[kReply] = Reply.buildReply(instance[kReply]);
      instance[kRequest] = Request2.buildRequest(instance[kRequest]);
      instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
      instance[kHooks] = buildHooks(instance[kHooks]);
      instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
      instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
      instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
      instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
      instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
      instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);
      instance[kPluginNameChain] = [fnName];
      instance[kErrorHandlerAlreadySet] = false;
      if (instance[kLogSerializers] || opts.logSerializers) {
        instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
      }
      if (opts.prefix) {
        instance[kFourOhFour].arrange404(instance);
      }
      for (const hook of instance[kHooks].onRegister) hook.call(old, instance, opts);
      return instance;
    };
    function buildRoutePrefix(instancePrefix, pluginPrefix) {
      if (!pluginPrefix) {
        return instancePrefix;
      }
      if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
        pluginPrefix = pluginPrefix.slice(1);
      } else if (pluginPrefix[0] !== "/") {
        pluginPrefix = "/" + pluginPrefix;
      }
      return instancePrefix + pluginPrefix;
    }
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/noop-set.js
var require_noop_set = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/lib/noop-set.js"(exports, module) {
    "use strict";
    module.exports = function noopSet() {
      return {
        [Symbol.iterator]: function* () {
        },
        add() {
        },
        delete() {
        },
        has() {
          return true;
        }
      };
    };
  }
});

// node_modules/.pnpm/cookie@1.1.1/node_modules/cookie/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/cookie@1.1.1/node_modules/cookie/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCookie = parseCookie;
    exports.parse = parseCookie;
    exports.stringifyCookie = stringifyCookie;
    exports.stringifySetCookie = stringifySetCookie;
    exports.serialize = stringifySetCookie;
    exports.parseSetCookie = parseSetCookie;
    exports.stringifySetCookie = stringifySetCookie;
    exports.serialize = stringifySetCookie;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var maxAgeRegExp = /^-?\d+$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parseCookie(str, options) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options?.decode || decode3;
      let index2 = 0;
      do {
        const eqIdx = eqIndex(str, index2, len);
        if (eqIdx === -1)
          break;
        const endIdx = endIndex(str, index2, len);
        if (eqIdx > endIdx) {
          index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = valueSlice(str, index2, eqIdx);
        if (obj[key] === void 0) {
          obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));
        }
        index2 = endIdx + 1;
      } while (index2 < len);
      return obj;
    }
    function stringifyCookie(cookie, options) {
      const enc = options?.encode || encodeURIComponent;
      const cookieStrings = [];
      for (const name of Object.keys(cookie)) {
        const val = cookie[name];
        if (val === void 0)
          continue;
        if (!cookieNameRegExp.test(name)) {
          throw new TypeError(`cookie name is invalid: ${name}`);
        }
        const value = enc(val);
        if (!cookieValueRegExp.test(value)) {
          throw new TypeError(`cookie val is invalid: ${val}`);
        }
        cookieStrings.push(`${name}=${value}`);
      }
      return cookieStrings.join("; ");
    }
    function stringifySetCookie(_name, _val, _opts) {
      const cookie = typeof _name === "object" ? _name : { ..._opts, name: _name, value: String(_val) };
      const options = typeof _val === "object" ? _val : _opts;
      const enc = options?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(cookie.name)) {
        throw new TypeError(`argument name is invalid: ${cookie.name}`);
      }
      const value = cookie.value ? enc(cookie.value) : "";
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${cookie.value}`);
      }
      let str = cookie.name + "=" + value;
      if (cookie.maxAge !== void 0) {
        if (!Number.isInteger(cookie.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);
        }
        str += "; Max-Age=" + cookie.maxAge;
      }
      if (cookie.domain) {
        if (!domainValueRegExp.test(cookie.domain)) {
          throw new TypeError(`option domain is invalid: ${cookie.domain}`);
        }
        str += "; Domain=" + cookie.domain;
      }
      if (cookie.path) {
        if (!pathValueRegExp.test(cookie.path)) {
          throw new TypeError(`option path is invalid: ${cookie.path}`);
        }
        str += "; Path=" + cookie.path;
      }
      if (cookie.expires) {
        if (!isDate(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${cookie.expires}`);
        }
        str += "; Expires=" + cookie.expires.toUTCString();
      }
      if (cookie.httpOnly) {
        str += "; HttpOnly";
      }
      if (cookie.secure) {
        str += "; Secure";
      }
      if (cookie.partitioned) {
        str += "; Partitioned";
      }
      if (cookie.priority) {
        const priority = typeof cookie.priority === "string" ? cookie.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${cookie.priority}`);
        }
      }
      if (cookie.sameSite) {
        const sameSite = typeof cookie.sameSite === "string" ? cookie.sameSite.toLowerCase() : cookie.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);
        }
      }
      return str;
    }
    function parseSetCookie(str, options) {
      const dec = options?.decode || decode3;
      const len = str.length;
      const endIdx = endIndex(str, 0, len);
      const eqIdx = eqIndex(str, 0, endIdx);
      const setCookie = eqIdx === -1 ? { name: "", value: dec(valueSlice(str, 0, endIdx)) } : {
        name: valueSlice(str, 0, eqIdx),
        value: dec(valueSlice(str, eqIdx + 1, endIdx))
      };
      let index2 = endIdx + 1;
      while (index2 < len) {
        const endIdx2 = endIndex(str, index2, len);
        const eqIdx2 = eqIndex(str, index2, endIdx2);
        const attr = eqIdx2 === -1 ? valueSlice(str, index2, endIdx2) : valueSlice(str, index2, eqIdx2);
        const val = eqIdx2 === -1 ? void 0 : valueSlice(str, eqIdx2 + 1, endIdx2);
        switch (attr.toLowerCase()) {
          case "httponly":
            setCookie.httpOnly = true;
            break;
          case "secure":
            setCookie.secure = true;
            break;
          case "partitioned":
            setCookie.partitioned = true;
            break;
          case "domain":
            setCookie.domain = val;
            break;
          case "path":
            setCookie.path = val;
            break;
          case "max-age":
            if (val && maxAgeRegExp.test(val))
              setCookie.maxAge = Number(val);
            break;
          case "expires":
            if (!val)
              break;
            const date9 = new Date(val);
            if (Number.isFinite(date9.valueOf()))
              setCookie.expires = date9;
            break;
          case "priority":
            if (!val)
              break;
            const priority = val.toLowerCase();
            if (priority === "low" || priority === "medium" || priority === "high") {
              setCookie.priority = priority;
            }
            break;
          case "samesite":
            if (!val)
              break;
            const sameSite = val.toLowerCase();
            if (sameSite === "lax" || sameSite === "strict" || sameSite === "none") {
              setCookie.sameSite = sameSite;
            }
            break;
        }
        index2 = endIdx2 + 1;
      }
      return setCookie;
    }
    function endIndex(str, min, len) {
      const index2 = str.indexOf(";", min);
      return index2 === -1 ? len : index2;
    }
    function eqIndex(str, min, max) {
      const index2 = str.indexOf("=", min);
      return index2 < max ? index2 : -1;
    }
    function valueSlice(str, min, max) {
      let start = min;
      let end = max;
      do {
        const code = str.charCodeAt(start);
        if (code !== 32 && code !== 9)
          break;
      } while (++start < end);
      while (end > start) {
        const code = str.charCodeAt(end - 1);
        if (code !== 32 && code !== 9)
          break;
        end--;
      }
      return str.slice(start, end);
    }
    function decode3(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// node_modules/.pnpm/process-warning@4.0.1/node_modules/process-warning/index.js
var require_process_warning2 = __commonJS({
  "node_modules/.pnpm/process-warning@4.0.1/node_modules/process-warning/index.js"(exports, module) {
    "use strict";
    var { format } = __require("node:util");
    function createDeprecation(params) {
      return createWarning({ ...params, name: "DeprecationWarning" });
    }
    function createWarning({ name, code, message, unlimited = false } = {}) {
      if (!name) throw new Error("Warning name must not be empty");
      if (!code) throw new Error("Warning code must not be empty");
      if (!message) throw new Error("Warning message must not be empty");
      if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
      code = code.toUpperCase();
      let warningContainer = {
        [name]: function(a2, b2, c) {
          if (warning.emitted === true && warning.unlimited !== true) {
            return;
          }
          warning.emitted = true;
          process.emitWarning(warning.format(a2, b2, c), warning.name, warning.code);
        }
      };
      if (unlimited) {
        warningContainer = {
          [name]: function(a2, b2, c) {
            warning.emitted = true;
            process.emitWarning(warning.format(a2, b2, c), warning.name, warning.code);
          }
        };
      }
      const warning = warningContainer[name];
      warning.emitted = false;
      warning.message = message;
      warning.unlimited = unlimited;
      warning.code = code;
      warning.format = function(a2, b2, c) {
        let formatted;
        if (a2 && b2 && c) {
          formatted = format(message, a2, b2, c);
        } else if (a2 && b2) {
          formatted = format(message, a2, b2);
        } else if (a2) {
          formatted = format(message, a2);
        } else {
          formatted = message;
        }
        return formatted;
      };
      return warning;
    }
    var out = { createWarning, createDeprecation };
    module.exports = out;
    module.exports.default = out;
    module.exports.processWarning = out;
  }
});

// node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/parse-url.js
var require_parse_url = __commonJS({
  "node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/parse-url.js"(exports, module) {
    "use strict";
    var { URL: URL2 } = __require("node:url");
    var BASE_URL = "http://localhost";
    module.exports = function parseURL(url2, query) {
      if ((typeof url2 === "string" || Object.prototype.toString.call(url2) === "[object String]") && url2.startsWith("//")) {
        url2 = BASE_URL + url2;
      }
      const result = typeof url2 === "object" ? Object.assign(new URL2(BASE_URL), url2) : new URL2(url2, BASE_URL);
      if (typeof query === "string") {
        query = new URLSearchParams(query);
        for (const key of query.keys()) {
          result.searchParams.delete(key);
          for (const value of query.getAll(key)) {
            result.searchParams.append(key, value);
          }
        }
      } else {
        const merged = Object.assign({}, url2.query, query);
        for (const key in merged) {
          const value = merged[key];
          if (Array.isArray(value)) {
            result.searchParams.delete(key);
            for (const param of value) {
              result.searchParams.append(key, param);
            }
          } else {
            result.searchParams.set(key, value);
          }
        }
      }
      return result;
    };
  }
});

// node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/form-data.js
var require_form_data = __commonJS({
  "node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/form-data.js"(exports, module) {
    "use strict";
    var { randomUUID } = __require("node:crypto");
    var { Readable } = __require("node:stream");
    var textEncoder;
    function isFormDataLike(payload) {
      return payload && typeof payload === "object" && typeof payload.append === "function" && typeof payload.delete === "function" && typeof payload.get === "function" && typeof payload.getAll === "function" && typeof payload.has === "function" && typeof payload.set === "function" && payload[Symbol.toStringTag] === "FormData";
    }
    function formDataToStream(formdata) {
      textEncoder = textEncoder ?? new TextEncoder();
      const boundary = `----formdata-${randomUUID()}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const linebreak = new Uint8Array([13, 10]);
      async function* asyncIterator() {
        for (const [name, value] of formdata) {
          if (typeof value === "string") {
            yield textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"\r
\r
`);
            yield textEncoder.encode(`${normalizeLinefeeds(value)}\r
`);
          } else {
            let header = `${prefix}; name="${escape2(normalizeLinefeeds(name))}"`;
            value.name && (header += `; filename="${escape2(value.name)}"`);
            header += `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
            yield textEncoder.encode(header);
            if (value.stream) {
              yield* value.stream();
            } else {
              yield value;
            }
            yield linebreak;
          }
        }
        yield textEncoder.encode(`--${boundary}--`);
      }
      const stream = Readable.from(asyncIterator());
      return {
        stream,
        contentType: `multipart/form-data; boundary=${boundary}`
      };
    }
    module.exports.isFormDataLike = isFormDataLike;
    module.exports.formDataToStream = formDataToStream;
  }
});

// node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/request.js
var require_request2 = __commonJS({
  "node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/request.js"(exports, module) {
    "use strict";
    var { Readable, addAbortSignal } = __require("node:stream");
    var util = __require("node:util");
    var cookie = require_dist4();
    var assert2 = __require("node:assert");
    var { createDeprecation } = require_process_warning2();
    var parseURL = require_parse_url();
    var { isFormDataLike, formDataToStream } = require_form_data();
    var { EventEmitter } = __require("node:events");
    var FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
      name: "FastifyDeprecationLightMyRequest",
      code: "FST_LIGHTMYREQUEST_DEP01",
      message: 'You are accessing "request.connection", use "request.socket" instead.'
    });
    function hostHeaderFromURL(parsedURL) {
      return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
    }
    var MockSocket = class extends EventEmitter {
      constructor(remoteAddress) {
        super();
        this.remoteAddress = remoteAddress;
      }
    };
    function CustomRequest(options) {
      return new _CustomLMRRequest(this);
      function _CustomLMRRequest(obj) {
        Request2.call(obj, {
          ...options,
          Request: void 0
        });
        Object.assign(this, obj);
        for (const fn of Object.keys(Request2.prototype)) {
          this.constructor.prototype[fn] = Request2.prototype[fn];
        }
        util.inherits(this.constructor, options.Request);
        return this;
      }
    }
    function Request2(options) {
      Readable.call(this, {
        autoDestroy: false
      });
      const parsedURL = parseURL(options.url || options.path, options.query);
      this.url = parsedURL.pathname + parsedURL.search;
      this.aborted = false;
      this.httpVersionMajor = 1;
      this.httpVersionMinor = 1;
      this.httpVersion = "1.1";
      this.method = options.method ? options.method.toUpperCase() : "GET";
      this.headers = {};
      this.rawHeaders = [];
      const headers = options.headers || {};
      for (const field in headers) {
        const fieldLowerCase = field.toLowerCase();
        if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers[field] === void 0) {
          this.headers[fieldLowerCase] = void 0;
          continue;
        }
        const value = headers[field];
        assert2(value !== void 0, 'invalid value "undefined" for header ' + field);
        this.headers[fieldLowerCase] = "" + value;
      }
      if ("user-agent" in this.headers === false) {
        this.headers["user-agent"] = "lightMyRequest";
      }
      this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
      if (options.cookies) {
        const { cookies } = options;
        const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
        if (this.headers.cookie) {
          cookieValues.unshift(this.headers.cookie);
        }
        this.headers.cookie = cookieValues.join("; ");
      }
      this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
      Object.defineProperty(this, "connection", {
        get() {
          FST_LIGHTMYREQUEST_DEP01();
          return this.socket;
        },
        configurable: true
      });
      let payload = options.payload || options.body || null;
      let payloadResume = payload && typeof payload.resume === "function";
      if (isFormDataLike(payload)) {
        const stream = formDataToStream(payload);
        payload = stream.stream;
        payloadResume = true;
        this.headers["content-type"] = stream.contentType;
        this.headers["transfer-encoding"] = "chunked";
      }
      if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
        payload = JSON.stringify(payload);
        if ("content-type" in this.headers === false) {
          this.headers["content-type"] = "application/json";
        }
      }
      if (payload && !payloadResume && !Object.hasOwn(this.headers, "content-length")) {
        this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
      }
      for (const header of Object.keys(this.headers)) {
        this.rawHeaders.push(header, this.headers[header]);
      }
      this._lightMyRequest = {
        payload,
        isDone: false,
        simulate: options.simulate || {},
        payloadAsStream: options.payloadAsStream,
        signal: options.signal
      };
      const signal = options.signal;
      if (signal) {
        addAbortSignal(signal, this);
      }
      {
        const payload2 = this._lightMyRequest.payload;
        if (payload2?._readableState) {
          this._read = readStream;
          payload2.on("error", (err) => {
            this.destroy(err);
          });
          payload2.on("end", () => {
            this.push(null);
          });
        } else {
          this._read = readEverythingElse;
        }
      }
      return this;
    }
    function readStream() {
      const payload = this._lightMyRequest.payload;
      let more = true;
      let pushed = false;
      let chunk;
      while (more && (chunk = payload.read())) {
        pushed = true;
        more = this.push(chunk);
      }
      if (more && !pushed) {
        this._lightMyRequest.payload.once("readable", this._read.bind(this));
      }
    }
    function readEverythingElse() {
      setImmediate(() => {
        if (this._lightMyRequest.isDone) {
          if (this._lightMyRequest.simulate.end !== false) {
            this.push(null);
          }
          return;
        }
        this._lightMyRequest.isDone = true;
        if (this._lightMyRequest.payload) {
          if (this._lightMyRequest.simulate.split) {
            this.push(this._lightMyRequest.payload.slice(0, 1));
            this.push(this._lightMyRequest.payload.slice(1));
          } else {
            this.push(this._lightMyRequest.payload);
          }
        }
        if (this._lightMyRequest.simulate.error) {
          this.emit("error", new Error("Simulated"));
        }
        if (this._lightMyRequest.simulate.close) {
          this.emit("close");
        }
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
      });
    }
    util.inherits(Request2, Readable);
    util.inherits(CustomRequest, Request2);
    Request2.prototype.destroy = function(error48) {
      if (this.destroyed || this._lightMyRequest.isDone) return;
      this.destroyed = true;
      if (error48) {
        this._error = true;
        process.nextTick(() => this.emit("error", error48));
      }
      process.nextTick(() => this.emit("close"));
    };
    module.exports = Request2;
    module.exports.Request = Request2;
    module.exports.CustomRequest = CustomRequest;
  }
});

// node_modules/.pnpm/set-cookie-parser@2.7.2/node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/.pnpm/set-cookie-parser@2.7.2/node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isForbiddenKey(key) {
      return typeof key !== "string" || key in {};
    }
    function createNullObj() {
      return /* @__PURE__ */ Object.create(null);
    }
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (isForbiddenKey(name)) {
        return null;
      }
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser: failed to decode cookie value. Set options.decodeValues=false to disable decoding.",
          e
        );
      }
      var cookie = createNullObj();
      cookie.name = name;
      cookie.value = value;
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        if (isForbiddenKey(key)) {
          return;
        }
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          var n = parseInt(value2, 10);
          if (!Number.isNaN(n)) cookie.maxAge = n;
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else if (key) {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse3(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return createNullObj();
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        }).filter(Boolean);
      } else {
        var cookies = createNullObj();
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          if (cookie && !isForbiddenKey(cookie.name)) {
            cookies2[cookie.name] = cookie;
          }
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse3;
    module.exports.parse = parse3;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/response.js
var require_response = __commonJS({
  "node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/response.js"(exports, module) {
    "use strict";
    var http = __require("node:http");
    var { Writable, Readable, addAbortSignal } = __require("node:stream");
    var util = __require("node:util");
    var setCookie = require_set_cookie();
    function Response2(req, onEnd, reject) {
      http.ServerResponse.call(this, req);
      if (req._lightMyRequest?.payloadAsStream) {
        const read = this.emit.bind(this, "drain");
        this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read }) };
        const signal = req._lightMyRequest.signal;
        if (signal) {
          addAbortSignal(signal, this._lightMyRequest.stream);
        }
      } else {
        this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
      }
      this.setHeader("foo", "bar");
      this.removeHeader("foo");
      this.assignSocket(getNullSocket());
      this._promiseCallback = typeof reject === "function";
      let called = false;
      const onEndSuccess = (payload) => {
        if (called) return;
        called = true;
        if (this._promiseCallback) {
          return process.nextTick(() => onEnd(payload));
        }
        process.nextTick(() => onEnd(null, payload));
      };
      this._lightMyRequest.onEndSuccess = onEndSuccess;
      let finished = false;
      const onEndFailure = (err) => {
        if (called) {
          if (this._lightMyRequest.stream && !finished) {
            if (!err) {
              err = new Error("response destroyed before completion");
              err.code = "LIGHT_ECONNRESET";
            }
            this._lightMyRequest.stream.destroy(err);
            this._lightMyRequest.stream.on("error", () => {
            });
          }
          return;
        }
        called = true;
        if (!err) {
          err = new Error("response destroyed before completion");
          err.code = "LIGHT_ECONNRESET";
        }
        if (this._promiseCallback) {
          return process.nextTick(() => reject(err));
        }
        process.nextTick(() => onEnd(err, null));
      };
      if (this._lightMyRequest.stream) {
        this.once("finish", () => {
          finished = true;
          this._lightMyRequest.stream.push(null);
        });
      } else {
        this.once("finish", () => {
          const res = generatePayload(this);
          res.raw.req = req;
          onEndSuccess(res);
        });
      }
      this.connection.once("error", onEndFailure);
      this.once("error", onEndFailure);
      this.once("close", onEndFailure);
    }
    util.inherits(Response2, http.ServerResponse);
    Response2.prototype.setTimeout = function(msecs, callback) {
      this.timeoutHandle = setTimeout(() => {
        this.emit("timeout");
      }, msecs);
      this.on("timeout", callback);
      return this;
    };
    Response2.prototype.writeHead = function() {
      const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);
      copyHeaders(this);
      if (this._lightMyRequest.stream) {
        this._lightMyRequest.onEndSuccess(generatePayload(this));
      }
      return result;
    };
    Response2.prototype.write = function(data, encoding, callback) {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
      http.ServerResponse.prototype.write.call(this, data, encoding, callback);
      if (this._lightMyRequest.stream) {
        return this._lightMyRequest.stream.push(Buffer.from(data, encoding));
      } else {
        this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
        return true;
      }
    };
    Response2.prototype.end = function(data, encoding, callback) {
      if (data) {
        this.write(data, encoding);
      }
      http.ServerResponse.prototype.end.call(this, callback);
      this.emit("finish");
      this.destroy();
    };
    Response2.prototype.destroy = function(error48) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (error48) {
        process.nextTick(() => this.emit("error", error48));
      }
      process.nextTick(() => this.emit("close"));
    };
    Response2.prototype.addTrailers = function(trailers) {
      for (const key in trailers) {
        this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
      }
    };
    function generatePayload(response) {
      if (response._lightMyRequest.headers === null) {
        copyHeaders(response);
      }
      serializeHeaders(response);
      const res = {
        raw: {
          res: response
        },
        headers: response._lightMyRequest.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {},
        get cookies() {
          return setCookie.parse(this);
        }
      };
      res.trailers = response._lightMyRequest.trailers;
      if (response._lightMyRequest.payloadChunks) {
        const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
        res.rawPayload = rawBuffer;
        res.payload = rawBuffer.toString();
        res.body = res.payload;
        res.json = function parseJsonPayload() {
          return JSON.parse(res.payload);
        };
      } else {
        res.json = function() {
          throw new Error("Response payload is not available with payloadAsStream: true");
        };
      }
      res.stream = function streamPayload() {
        if (response._lightMyRequest.stream) {
          return response._lightMyRequest.stream;
        }
        return Readable.from(response._lightMyRequest.payloadChunks);
      };
      return res;
    }
    function getNullSocket() {
      return new Writable({
        write(_chunk, _encoding, callback) {
          setImmediate(callback);
        }
      });
    }
    function serializeHeaders(response) {
      const headers = response._lightMyRequest.headers;
      for (const headerName of Object.keys(headers)) {
        const headerValue = headers[headerName];
        if (Array.isArray(headerValue)) {
          headers[headerName] = headerValue.map((value) => "" + value);
        } else {
          headers[headerName] = "" + headerValue;
        }
      }
    }
    function copyHeaders(response) {
      response._lightMyRequest.headers = Object.assign({}, response.getHeaders());
      ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
        const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
        const field = response._header?.match(regex);
        if (field) {
          response._lightMyRequest.headers[name.toLowerCase()] = field[1];
        }
      });
    }
    module.exports = Response2;
  }
});

// node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/config-validator.js
var require_config_validator = __commonJS({
  "node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/lib/config-validator.js"(exports, module) {
    "use strict";
    module.exports = validate10;
    module.exports.default = validate10;
    var schema11 = { "type": "object", "properties": { "url": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "protocol": { "type": "string" }, "hostname": { "type": "string" }, "pathname": { "type": "string" } }, "additionalProperties": true, "required": ["pathname"] }] }, "path": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "protocol": { "type": "string" }, "hostname": { "type": "string" }, "pathname": { "type": "string" } }, "additionalProperties": true, "required": ["pathname"] }] }, "cookies": { "type": "object", "additionalProperties": true }, "headers": { "type": "object", "additionalProperties": true }, "query": { "anyOf": [{ "type": "object", "additionalProperties": true }, { "type": "string" }] }, "simulate": { "type": "object", "properties": { "end": { "type": "boolean" }, "split": { "type": "boolean" }, "error": { "type": "boolean" }, "close": { "type": "boolean" } } }, "authority": { "type": "string" }, "remoteAddress": { "type": "string" }, "method": { "type": "string", "enum": ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] }, "validate": { "type": "boolean" } }, "additionalProperties": true, "oneOf": [{ "required": ["url"] }, { "required": ["path"] }] };
    function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing0;
        if (data.url === void 0 && (missing0 = "url")) {
          const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs3 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing1;
        if (data.path === void 0 && (missing1 = "path")) {
          const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
      }
      var _valid0 = _errs3 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors++;
        validate10.errors = vErrors;
        return false;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      if (errors === 0) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.url !== void 0) {
            let data0 = data.url;
            const _errs5 = errors;
            const _errs6 = errors;
            let valid2 = false;
            let passing1 = null;
            const _errs7 = errors;
            if (typeof data0 !== "string") {
              let dataType0 = typeof data0;
              let coerced0 = void 0;
              if (!(coerced0 !== void 0)) {
                if (dataType0 == "number" || dataType0 == "boolean") {
                  coerced0 = "" + data0;
                } else if (data0 === null) {
                  coerced0 = "";
                } else {
                  const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err3];
                  } else {
                    vErrors.push(err3);
                  }
                  errors++;
                }
              }
              if (coerced0 !== void 0) {
                data0 = coerced0;
                if (data !== void 0) {
                  data["url"] = coerced0;
                }
              }
            }
            var _valid1 = _errs7 === errors;
            if (_valid1) {
              valid2 = true;
              passing1 = 0;
            }
            const _errs9 = errors;
            if (errors === _errs9) {
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                let missing2;
                if (data0.pathname === void 0 && (missing2 = "pathname")) {
                  const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                  if (vErrors === null) {
                    vErrors = [err4];
                  } else {
                    vErrors.push(err4);
                  }
                  errors++;
                } else {
                  if (data0.protocol !== void 0) {
                    let data1 = data0.protocol;
                    const _errs12 = errors;
                    if (typeof data1 !== "string") {
                      let dataType1 = typeof data1;
                      let coerced1 = void 0;
                      if (!(coerced1 !== void 0)) {
                        if (dataType1 == "number" || dataType1 == "boolean") {
                          coerced1 = "" + data1;
                        } else if (data1 === null) {
                          coerced1 = "";
                        } else {
                          const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err5];
                          } else {
                            vErrors.push(err5);
                          }
                          errors++;
                        }
                      }
                      if (coerced1 !== void 0) {
                        data1 = coerced1;
                        if (data0 !== void 0) {
                          data0["protocol"] = coerced1;
                        }
                      }
                    }
                    var valid3 = _errs12 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.hostname !== void 0) {
                      let data2 = data0.hostname;
                      const _errs14 = errors;
                      if (typeof data2 !== "string") {
                        let dataType2 = typeof data2;
                        let coerced2 = void 0;
                        if (!(coerced2 !== void 0)) {
                          if (dataType2 == "number" || dataType2 == "boolean") {
                            coerced2 = "" + data2;
                          } else if (data2 === null) {
                            coerced2 = "";
                          } else {
                            const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err6];
                            } else {
                              vErrors.push(err6);
                            }
                            errors++;
                          }
                        }
                        if (coerced2 !== void 0) {
                          data2 = coerced2;
                          if (data0 !== void 0) {
                            data0["hostname"] = coerced2;
                          }
                        }
                      }
                      var valid3 = _errs14 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data0.pathname !== void 0) {
                        let data3 = data0.pathname;
                        const _errs16 = errors;
                        if (typeof data3 !== "string") {
                          let dataType3 = typeof data3;
                          let coerced3 = void 0;
                          if (!(coerced3 !== void 0)) {
                            if (dataType3 == "number" || dataType3 == "boolean") {
                              coerced3 = "" + data3;
                            } else if (data3 === null) {
                              coerced3 = "";
                            } else {
                              const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err7];
                              } else {
                                vErrors.push(err7);
                              }
                              errors++;
                            }
                          }
                          if (coerced3 !== void 0) {
                            data3 = coerced3;
                            if (data0 !== void 0) {
                              data0["pathname"] = coerced3;
                            }
                          }
                        }
                        var valid3 = _errs16 === errors;
                      } else {
                        var valid3 = true;
                      }
                    }
                  }
                }
              } else {
                const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
            var _valid1 = _errs9 === errors;
            if (_valid1 && valid2) {
              valid2 = false;
              passing1 = [passing1, 1];
            } else {
              if (_valid1) {
                valid2 = true;
                passing1 = 1;
              }
            }
            if (!valid2) {
              const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
              validate10.errors = vErrors;
              return false;
            } else {
              errors = _errs6;
              if (vErrors !== null) {
                if (_errs6) {
                  vErrors.length = _errs6;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs5 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.path !== void 0) {
              let data4 = data.path;
              const _errs18 = errors;
              const _errs19 = errors;
              let valid4 = false;
              let passing2 = null;
              const _errs20 = errors;
              if (typeof data4 !== "string") {
                let dataType4 = typeof data4;
                let coerced4 = void 0;
                if (!(coerced4 !== void 0)) {
                  if (dataType4 == "number" || dataType4 == "boolean") {
                    coerced4 = "" + data4;
                  } else if (data4 === null) {
                    coerced4 = "";
                  } else {
                    const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err10];
                    } else {
                      vErrors.push(err10);
                    }
                    errors++;
                  }
                }
                if (coerced4 !== void 0) {
                  data4 = coerced4;
                  if (data !== void 0) {
                    data["path"] = coerced4;
                  }
                }
              }
              var _valid2 = _errs20 === errors;
              if (_valid2) {
                valid4 = true;
                passing2 = 0;
              }
              const _errs22 = errors;
              if (errors === _errs22) {
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  let missing3;
                  if (data4.pathname === void 0 && (missing3 = "pathname")) {
                    const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors++;
                  } else {
                    if (data4.protocol !== void 0) {
                      let data5 = data4.protocol;
                      const _errs25 = errors;
                      if (typeof data5 !== "string") {
                        let dataType5 = typeof data5;
                        let coerced5 = void 0;
                        if (!(coerced5 !== void 0)) {
                          if (dataType5 == "number" || dataType5 == "boolean") {
                            coerced5 = "" + data5;
                          } else if (data5 === null) {
                            coerced5 = "";
                          } else {
                            const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err12];
                            } else {
                              vErrors.push(err12);
                            }
                            errors++;
                          }
                        }
                        if (coerced5 !== void 0) {
                          data5 = coerced5;
                          if (data4 !== void 0) {
                            data4["protocol"] = coerced5;
                          }
                        }
                      }
                      var valid5 = _errs25 === errors;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data4.hostname !== void 0) {
                        let data6 = data4.hostname;
                        const _errs27 = errors;
                        if (typeof data6 !== "string") {
                          let dataType6 = typeof data6;
                          let coerced6 = void 0;
                          if (!(coerced6 !== void 0)) {
                            if (dataType6 == "number" || dataType6 == "boolean") {
                              coerced6 = "" + data6;
                            } else if (data6 === null) {
                              coerced6 = "";
                            } else {
                              const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err13];
                              } else {
                                vErrors.push(err13);
                              }
                              errors++;
                            }
                          }
                          if (coerced6 !== void 0) {
                            data6 = coerced6;
                            if (data4 !== void 0) {
                              data4["hostname"] = coerced6;
                            }
                          }
                        }
                        var valid5 = _errs27 === errors;
                      } else {
                        var valid5 = true;
                      }
                      if (valid5) {
                        if (data4.pathname !== void 0) {
                          let data7 = data4.pathname;
                          const _errs29 = errors;
                          if (typeof data7 !== "string") {
                            let dataType7 = typeof data7;
                            let coerced7 = void 0;
                            if (!(coerced7 !== void 0)) {
                              if (dataType7 == "number" || dataType7 == "boolean") {
                                coerced7 = "" + data7;
                              } else if (data7 === null) {
                                coerced7 = "";
                              } else {
                                const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                if (vErrors === null) {
                                  vErrors = [err14];
                                } else {
                                  vErrors.push(err14);
                                }
                                errors++;
                              }
                            }
                            if (coerced7 !== void 0) {
                              data7 = coerced7;
                              if (data4 !== void 0) {
                                data4["pathname"] = coerced7;
                              }
                            }
                          }
                          var valid5 = _errs29 === errors;
                        } else {
                          var valid5 = true;
                        }
                      }
                    }
                  }
                } else {
                  const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err15];
                  } else {
                    vErrors.push(err15);
                  }
                  errors++;
                }
              }
              var _valid2 = _errs22 === errors;
              if (_valid2 && valid4) {
                valid4 = false;
                passing2 = [passing2, 1];
              } else {
                if (_valid2) {
                  valid4 = true;
                  passing2 = 1;
                }
              }
              if (!valid4) {
                const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors++;
                validate10.errors = vErrors;
                return false;
              } else {
                errors = _errs19;
                if (vErrors !== null) {
                  if (_errs19) {
                    vErrors.length = _errs19;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid1 = _errs18 === errors;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data.cookies !== void 0) {
                let data8 = data.cookies;
                const _errs31 = errors;
                if (errors === _errs31) {
                  if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                    validate10.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs31 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data.headers !== void 0) {
                  let data9 = data.headers;
                  const _errs34 = errors;
                  if (errors === _errs34) {
                    if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                      validate10.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                  }
                  var valid1 = _errs34 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data.query !== void 0) {
                    let data10 = data.query;
                    const _errs37 = errors;
                    const _errs38 = errors;
                    let valid6 = false;
                    const _errs39 = errors;
                    if (errors === _errs39) {
                      if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                        const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                        if (vErrors === null) {
                          vErrors = [err17];
                        } else {
                          vErrors.push(err17);
                        }
                        errors++;
                      }
                    }
                    var _valid3 = _errs39 === errors;
                    valid6 = valid6 || _valid3;
                    if (!valid6) {
                      const _errs42 = errors;
                      if (typeof data10 !== "string") {
                        let dataType8 = typeof data10;
                        let coerced8 = void 0;
                        if (!(coerced8 !== void 0)) {
                          if (dataType8 == "number" || dataType8 == "boolean") {
                            coerced8 = "" + data10;
                          } else if (data10 === null) {
                            coerced8 = "";
                          } else {
                            const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err18];
                            } else {
                              vErrors.push(err18);
                            }
                            errors++;
                          }
                        }
                        if (coerced8 !== void 0) {
                          data10 = coerced8;
                          if (data !== void 0) {
                            data["query"] = coerced8;
                          }
                        }
                      }
                      var _valid3 = _errs42 === errors;
                      valid6 = valid6 || _valid3;
                    }
                    if (!valid6) {
                      const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                      if (vErrors === null) {
                        vErrors = [err19];
                      } else {
                        vErrors.push(err19);
                      }
                      errors++;
                      validate10.errors = vErrors;
                      return false;
                    } else {
                      errors = _errs38;
                      if (vErrors !== null) {
                        if (_errs38) {
                          vErrors.length = _errs38;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid1 = _errs37 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data.simulate !== void 0) {
                      let data11 = data.simulate;
                      const _errs44 = errors;
                      if (errors === _errs44) {
                        if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                          if (data11.end !== void 0) {
                            let data12 = data11.end;
                            const _errs46 = errors;
                            if (typeof data12 !== "boolean") {
                              let coerced9 = void 0;
                              if (!(coerced9 !== void 0)) {
                                if (data12 === "false" || data12 === 0 || data12 === null) {
                                  coerced9 = false;
                                } else if (data12 === "true" || data12 === 1) {
                                  coerced9 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced9 !== void 0) {
                                data12 = coerced9;
                                if (data11 !== void 0) {
                                  data11["end"] = coerced9;
                                }
                              }
                            }
                            var valid7 = _errs46 === errors;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.split !== void 0) {
                              let data13 = data11.split;
                              const _errs48 = errors;
                              if (typeof data13 !== "boolean") {
                                let coerced10 = void 0;
                                if (!(coerced10 !== void 0)) {
                                  if (data13 === "false" || data13 === 0 || data13 === null) {
                                    coerced10 = false;
                                  } else if (data13 === "true" || data13 === 1) {
                                    coerced10 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced10 !== void 0) {
                                  data13 = coerced10;
                                  if (data11 !== void 0) {
                                    data11["split"] = coerced10;
                                  }
                                }
                              }
                              var valid7 = _errs48 === errors;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.error !== void 0) {
                                let data14 = data11.error;
                                const _errs50 = errors;
                                if (typeof data14 !== "boolean") {
                                  let coerced11 = void 0;
                                  if (!(coerced11 !== void 0)) {
                                    if (data14 === "false" || data14 === 0 || data14 === null) {
                                      coerced11 = false;
                                    } else if (data14 === "true" || data14 === 1) {
                                      coerced11 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced11 !== void 0) {
                                    data14 = coerced11;
                                    if (data11 !== void 0) {
                                      data11["error"] = coerced11;
                                    }
                                  }
                                }
                                var valid7 = _errs50 === errors;
                              } else {
                                var valid7 = true;
                              }
                              if (valid7) {
                                if (data11.close !== void 0) {
                                  let data15 = data11.close;
                                  const _errs52 = errors;
                                  if (typeof data15 !== "boolean") {
                                    let coerced12 = void 0;
                                    if (!(coerced12 !== void 0)) {
                                      if (data15 === "false" || data15 === 0 || data15 === null) {
                                        coerced12 = false;
                                      } else if (data15 === "true" || data15 === 1) {
                                        coerced12 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced12 !== void 0) {
                                      data15 = coerced12;
                                      if (data11 !== void 0) {
                                        data11["close"] = coerced12;
                                      }
                                    }
                                  }
                                  var valid7 = _errs52 === errors;
                                } else {
                                  var valid7 = true;
                                }
                              }
                            }
                          }
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                          return false;
                        }
                      }
                      var valid1 = _errs44 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data.authority !== void 0) {
                        let data16 = data.authority;
                        const _errs54 = errors;
                        if (typeof data16 !== "string") {
                          let dataType13 = typeof data16;
                          let coerced13 = void 0;
                          if (!(coerced13 !== void 0)) {
                            if (dataType13 == "number" || dataType13 == "boolean") {
                              coerced13 = "" + data16;
                            } else if (data16 === null) {
                              coerced13 = "";
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced13 !== void 0) {
                            data16 = coerced13;
                            if (data !== void 0) {
                              data["authority"] = coerced13;
                            }
                          }
                        }
                        var valid1 = _errs54 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data.remoteAddress !== void 0) {
                          let data17 = data.remoteAddress;
                          const _errs56 = errors;
                          if (typeof data17 !== "string") {
                            let dataType14 = typeof data17;
                            let coerced14 = void 0;
                            if (!(coerced14 !== void 0)) {
                              if (dataType14 == "number" || dataType14 == "boolean") {
                                coerced14 = "" + data17;
                              } else if (data17 === null) {
                                coerced14 = "";
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced14 !== void 0) {
                              data17 = coerced14;
                              if (data !== void 0) {
                                data["remoteAddress"] = coerced14;
                              }
                            }
                          }
                          var valid1 = _errs56 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data.method !== void 0) {
                            let data18 = data.method;
                            const _errs58 = errors;
                            if (typeof data18 !== "string") {
                              let dataType15 = typeof data18;
                              let coerced15 = void 0;
                              if (!(coerced15 !== void 0)) {
                                if (dataType15 == "number" || dataType15 == "boolean") {
                                  coerced15 = "" + data18;
                                } else if (data18 === null) {
                                  coerced15 = "";
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                              }
                              if (coerced15 !== void 0) {
                                data18 = coerced15;
                                if (data !== void 0) {
                                  data["method"] = coerced15;
                                }
                              }
                            }
                            if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "QUERY" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "query" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                              validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                              return false;
                            }
                            var valid1 = _errs58 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data.validate !== void 0) {
                              let data19 = data.validate;
                              const _errs60 = errors;
                              if (typeof data19 !== "boolean") {
                                let coerced16 = void 0;
                                if (!(coerced16 !== void 0)) {
                                  if (data19 === "false" || data19 === 0 || data19 === null) {
                                    coerced16 = false;
                                  } else if (data19 === "true" || data19 === 1) {
                                    coerced16 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced16 !== void 0) {
                                  data19 = coerced16;
                                  if (data !== void 0) {
                                    data["validate"] = coerced16;
                                  }
                                }
                              }
                              var valid1 = _errs60 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
          return false;
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/index.js
var require_light_my_request = __commonJS({
  "node_modules/.pnpm/light-my-request@6.6.0/node_modules/light-my-request/index.js"(exports, module) {
    "use strict";
    var assert2 = __require("node:assert");
    var Request2 = require_request2();
    var Response2 = require_response();
    var errorMessage = "The dispatch function has already been invoked";
    var optsValidator = require_config_validator();
    function inject(dispatchFunc, options, callback) {
      if (callback === void 0) {
        return new Chain(dispatchFunc, options);
      } else {
        return doInject(dispatchFunc, options, callback);
      }
    }
    function supportStream1(req, next) {
      const payload = req._lightMyRequest.payload;
      if (!payload || payload._readableState || typeof payload.resume !== "function") {
        return next();
      }
      const chunks = [];
      payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
      payload.on("end", () => {
        const payload2 = Buffer.concat(chunks);
        req.headers["content-length"] = req.headers["content-length"] || "" + payload2.length;
        delete req.headers["transfer-encoding"];
        req._lightMyRequest.payload = payload2;
        return next();
      });
      payload.resume();
    }
    function makeRequest(dispatchFunc, server, req, res) {
      req.once("error", function(err) {
        if (this.destroyed) res.destroy(err);
      });
      req.once("close", function() {
        if (this.destroyed && !this._error) {
          res.destroy();
        }
      });
      return supportStream1(req, () => dispatchFunc.call(server, req, res));
    }
    function doInject(dispatchFunc, options, callback) {
      options = typeof options === "string" ? { url: options } : options;
      if (options.validate !== false) {
        assert2(typeof dispatchFunc === "function", "dispatchFunc should be a function");
        const isOptionValid = optsValidator(options);
        if (!isOptionValid) {
          throw new Error(optsValidator.errors.map((e) => e.message));
        }
      }
      const server = options.server || {};
      const RequestConstructor = options.Request ? Request2.CustomRequest : Request2;
      if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
        Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
        Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response2.prototype);
      }
      if (typeof callback === "function") {
        const req = new RequestConstructor(options);
        const res = new Response2(req, callback);
        return makeRequest(dispatchFunc, server, req, res);
      } else {
        return new Promise((resolve, reject) => {
          const req = new RequestConstructor(options);
          const res = new Response2(req, resolve, reject);
          makeRequest(dispatchFunc, server, req, res);
        });
      }
    }
    function Chain(dispatch, option) {
      if (typeof option === "string") {
        this.option = { url: option };
      } else {
        this.option = Object.assign({}, option);
      }
      this.dispatch = dispatch;
      this._hasInvoked = false;
      this._promise = null;
      if (this.option.autoStart !== false) {
        process.nextTick(() => {
          if (!this._hasInvoked) {
            this.end();
          }
        });
      }
    }
    var httpMethods = [
      "delete",
      "get",
      "head",
      "options",
      "patch",
      "post",
      "put",
      "trace"
    ];
    httpMethods.forEach((method) => {
      Chain.prototype[method] = function(url2) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option.url = url2;
        this.option.method = method.toUpperCase();
        return this;
      };
    });
    var chainMethods = [
      "body",
      "cookies",
      "headers",
      "payload",
      "query"
    ];
    chainMethods.forEach((method) => {
      Chain.prototype[method] = function(value) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option[method] = value;
        return this;
      };
    });
    Chain.prototype.end = function(callback) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this._hasInvoked = true;
      if (typeof callback === "function") {
        doInject(this.dispatch, this.option, callback);
      } else {
        this._promise = doInject(this.dispatch, this.option);
        return this._promise;
      }
    };
    Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
      if (method === "constructor") return;
      Chain.prototype[method] = function(...args) {
        if (!this._promise) {
          if (this._hasInvoked === true) {
            throw new Error(errorMessage);
          }
          this._hasInvoked = true;
          this._promise = doInject(this.dispatch, this.option);
        }
        return this._promise[method](...args);
      };
    });
    function isInjection(obj) {
      return obj instanceof Request2 || obj instanceof Response2 || obj?.constructor?.name === "_CustomLMRRequest";
    }
    module.exports = inject;
    module.exports.default = inject;
    module.exports.inject = inject;
    module.exports.isInjection = isInjection;
  }
});

// node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/fastify.js
var require_fastify = __commonJS({
  "node_modules/.pnpm/fastify@5.6.1/node_modules/fastify/fastify.js"(exports, module) {
    "use strict";
    var VERSION = "5.6.1";
    var Avvio = require_boot();
    var http = __require("node:http");
    var diagnostics = __require("node:diagnostics_channel");
    var lightMyRequest;
    var {
      kAvvioBoot,
      kChildren,
      kServerBindings,
      kBodyLimit,
      kSupportedHTTPMethods,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kRequestAcceptVersion,
      kReplySerializerDefault,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kState,
      kOptions,
      kPluginNameChain,
      kSchemaErrorFormatter,
      kErrorHandler,
      kKeepAliveConnections,
      kChildLoggerFactory,
      kGenReqId,
      kErrorHandlerAlreadySet
    } = require_symbols2();
    var { createServer } = require_server();
    var Reply = require_reply();
    var Request2 = require_request();
    var Context = require_context();
    var decorator = require_decorate();
    var ContentTypeParser = require_contentTypeParser();
    var SchemaController = require_schema_controller();
    var { Hooks, hookRunnerApplication, supportedHooks } = require_hooks();
    var { createChildLogger, defaultChildLoggerFactory, createLogger } = require_logger_factory();
    var pluginUtils = require_pluginUtils();
    var { getGenReqId, reqIdGenFactory } = require_reqIdGenFactory();
    var { buildRouting, validateBodyLimitOption, buildRouterOptions } = require_route();
    var build404 = require_fourOhFour();
    var getSecuredInitialConfig = require_initialConfigValidation();
    var override = require_pluginOverride();
    var noopSet = require_noop_set();
    var {
      appendStackTrace,
      AVVIO_ERRORS_MAP,
      ...errorCodes
    } = require_errors2();
    var PonyPromise = require_promise();
    var { defaultInitOptions } = getSecuredInitialConfig;
    var {
      FST_ERR_ASYNC_CONSTRAINT,
      FST_ERR_BAD_URL,
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
      FST_ERR_OPTIONS_NOT_OBJ,
      FST_ERR_QSP_NOT_FN,
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
      FST_ERR_INSTANCE_ALREADY_LISTENING,
      FST_ERR_REOPENED_CLOSE_SERVER,
      FST_ERR_ROUTE_REWRITE_NOT_STR,
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
      FST_ERR_ERROR_HANDLER_NOT_FN,
      FST_ERR_ERROR_HANDLER_ALREADY_SET,
      FST_ERR_ROUTE_METHOD_INVALID
    } = errorCodes;
    var { buildErrorHandler } = require_error_handler();
    var { FSTWRN004 } = require_warnings();
    var initChannel = diagnostics.channel("fastify.initialization");
    function defaultBuildPrettyMeta(route) {
      const cleanKeys = {};
      const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
      allowedProps.concat(supportedHooks).forEach((k) => {
        cleanKeys[k] = route.store[k];
      });
      return Object.assign({}, cleanKeys);
    }
    function fastify(options) {
      if (options && typeof options !== "object") {
        throw new FST_ERR_OPTIONS_NOT_OBJ();
      } else {
        options = Object.assign({}, options);
      }
      if (options.querystringParser && typeof options.querystringParser !== "function" || options.routerOptions?.querystringParser && typeof options.routerOptions.querystringParser !== "function") {
        throw new FST_ERR_QSP_NOT_FN(typeof (options.querystringParser ?? options.routerOptions.querystringParser));
      }
      if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
        throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
      }
      validateBodyLimitOption(options.bodyLimit);
      const requestIdHeader = typeof options.requestIdHeader === "string" && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : options.requestIdHeader === true && "request-id";
      const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
      const requestIdLogLabel = options.requestIdLogLabel || "reqId";
      const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
      const disableRequestLogging = options.disableRequestLogging || false;
      const ajvOptions = Object.assign({
        customOptions: {},
        plugins: []
      }, options.ajv);
      const frameworkErrors = options.frameworkErrors;
      if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
        throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
      }
      if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
        throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
      }
      const { logger, hasLogger } = createLogger(options);
      options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
      options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
      options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
      options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
      options.logger = logger;
      options.requestIdHeader = requestIdHeader;
      options.requestIdLogLabel = requestIdLogLabel;
      options.disableRequestLogging = disableRequestLogging;
      options.ajv = ajvOptions;
      options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
      options.allowErrorHandlerOverride = options.allowErrorHandlerOverride ?? defaultInitOptions.allowErrorHandlerOverride;
      const initialConfig = getSecuredInitialConfig(options);
      options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
      options.routerOptions = buildRouterOptions(options, {
        defaultRoute,
        onBadUrl,
        ignoreTrailingSlash: defaultInitOptions.ignoreTrailingSlash,
        ignoreDuplicateSlashes: defaultInitOptions.ignoreDuplicateSlashes,
        maxParamLength: defaultInitOptions.maxParamLength,
        allowUnsafeRegex: defaultInitOptions.allowUnsafeRegex,
        buildPrettyMeta: defaultBuildPrettyMeta,
        useSemicolonDelimiter: defaultInitOptions.useSemicolonDelimiter
      });
      const router = buildRouting({
        config: options.routerOptions
      });
      const fourOhFour = build404(options);
      const httpHandler = wrapRouting(router, options);
      options.http2SessionTimeout = initialConfig.http2SessionTimeout;
      const { server, listen } = createServer(options, httpHandler);
      const serverHasCloseAllConnections = typeof server.closeAllConnections === "function";
      const serverHasCloseIdleConnections = typeof server.closeIdleConnections === "function";
      const serverHasCloseHttp2Sessions = typeof server.closeHttp2Sessions === "function";
      let forceCloseConnections = options.forceCloseConnections;
      if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
        throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE();
      } else if (typeof forceCloseConnections !== "boolean") {
        forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
      }
      const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? /* @__PURE__ */ new Set() : noopSet();
      const setupResponseListeners = Reply.setupResponseListeners;
      const schemaController = SchemaController.buildSchemaController(null, options.schemaController);
      const fastify2 = {
        // Fastify internals
        [kState]: {
          listening: false,
          closing: false,
          started: false,
          ready: false,
          booting: false,
          aborted: false,
          readyResolver: null
        },
        [kKeepAliveConnections]: keepAliveConnections,
        [kSupportedHTTPMethods]: {
          bodyless: /* @__PURE__ */ new Set([
            // Standard
            "GET",
            "HEAD",
            "TRACE"
          ]),
          bodywith: /* @__PURE__ */ new Set([
            // Standard
            "DELETE",
            "OPTIONS",
            "PATCH",
            "PUT",
            "POST"
          ])
        },
        [kOptions]: options,
        [kChildren]: [],
        [kServerBindings]: [],
        [kBodyLimit]: bodyLimit,
        [kRoutePrefix]: "",
        [kLogLevel]: "",
        [kLogSerializers]: null,
        [kHooks]: new Hooks(),
        [kSchemaController]: schemaController,
        [kSchemaErrorFormatter]: null,
        [kErrorHandler]: buildErrorHandler(),
        [kErrorHandlerAlreadySet]: false,
        [kChildLoggerFactory]: defaultChildLoggerFactory,
        [kReplySerializerDefault]: null,
        [kContentTypeParser]: new ContentTypeParser(
          bodyLimit,
          options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning,
          options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning
        ),
        [kReply]: Reply.buildReply(Reply),
        [kRequest]: Request2.buildRequest(Request2, options.trustProxy),
        [kFourOhFour]: fourOhFour,
        [pluginUtils.kRegisteredPlugins]: [],
        [kPluginNameChain]: ["fastify"],
        [kAvvioBoot]: null,
        [kGenReqId]: genReqId,
        // routing method
        routing: httpHandler,
        // routes shorthand methods
        delete: function _delete(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "DELETE", url: url2, options: options2, handler });
        },
        get: function _get(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "GET", url: url2, options: options2, handler });
        },
        head: function _head(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "HEAD", url: url2, options: options2, handler });
        },
        trace: function _trace(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "TRACE", url: url2, options: options2, handler });
        },
        patch: function _patch(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "PATCH", url: url2, options: options2, handler });
        },
        post: function _post(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "POST", url: url2, options: options2, handler });
        },
        put: function _put(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "PUT", url: url2, options: options2, handler });
        },
        options: function _options(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: "OPTIONS", url: url2, options: options2, handler });
        },
        all: function _all(url2, options2, handler) {
          return router.prepareRoute.call(this, { method: this.supportedMethods, url: url2, options: options2, handler });
        },
        // extended route
        route: function _route(options2) {
          return router.route.call(this, { options: options2 });
        },
        hasRoute: function _route(options2) {
          return router.hasRoute.call(this, { options: options2 });
        },
        findRoute: function _findRoute(options2) {
          return router.findRoute(options2);
        },
        // expose logger instance
        log: logger,
        // type provider
        withTypeProvider,
        // hooks
        addHook,
        // schemas
        addSchema,
        getSchema: schemaController.getSchema.bind(schemaController),
        getSchemas: schemaController.getSchemas.bind(schemaController),
        setValidatorCompiler,
        setSerializerCompiler,
        setSchemaController,
        setReplySerializer,
        setSchemaErrorFormatter,
        // set generated request id
        setGenReqId,
        // custom parsers
        addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
        hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
        getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
        defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
        removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
        removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
        // Fastify architecture methods (initialized by Avvio)
        register: null,
        after: null,
        ready: null,
        onClose: null,
        close: null,
        printPlugins: null,
        hasPlugin: function(name) {
          return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
        },
        // http server
        listen,
        server,
        addresses: function() {
          const binded = this[kServerBindings].map((b2) => b2.address());
          binded.push(this.server.address());
          return binded.filter((adr) => adr);
        },
        // extend fastify objects
        decorate: decorator.add,
        hasDecorator: decorator.exist,
        decorateReply: decorator.decorateReply,
        decorateRequest: decorator.decorateRequest,
        hasRequestDecorator: decorator.existRequest,
        hasReplyDecorator: decorator.existReply,
        getDecorator: decorator.getInstanceDecorator,
        addHttpMethod,
        // fake http injection
        inject,
        // pretty print of the registered routes
        printRoutes,
        // custom error handling
        setNotFoundHandler,
        setErrorHandler,
        // child logger
        setChildLoggerFactory,
        // Set fastify initial configuration options read-only object
        initialConfig,
        // constraint strategies
        addConstraintStrategy: router.addConstraintStrategy.bind(router),
        hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
      };
      Object.defineProperties(fastify2, {
        listeningOrigin: {
          get() {
            const address = this.addresses().slice(-1).pop();
            if (typeof address === "string") {
              return address;
            }
            const host = address.family === "IPv6" ? `[${address.address}]` : address.address;
            return `${this[kOptions].https ? "https" : "http"}://${host}:${address.port}`;
          }
        },
        pluginName: {
          configurable: true,
          get() {
            if (this[kPluginNameChain].length > 1) {
              return this[kPluginNameChain].join(" -> ");
            }
            return this[kPluginNameChain][0];
          }
        },
        prefix: {
          configurable: true,
          get() {
            return this[kRoutePrefix];
          }
        },
        validatorCompiler: {
          configurable: true,
          get() {
            return this[kSchemaController].getValidatorCompiler();
          }
        },
        serializerCompiler: {
          configurable: true,
          get() {
            return this[kSchemaController].getSerializerCompiler();
          }
        },
        childLoggerFactory: {
          configurable: true,
          get() {
            return this[kChildLoggerFactory];
          }
        },
        version: {
          configurable: true,
          get() {
            return VERSION;
          }
        },
        errorHandler: {
          configurable: true,
          get() {
            return this[kErrorHandler].func;
          }
        },
        genReqId: {
          configurable: true,
          get() {
            return this[kGenReqId];
          }
        },
        supportedMethods: {
          configurable: false,
          get() {
            return [
              ...this[kSupportedHTTPMethods].bodyless,
              ...this[kSupportedHTTPMethods].bodywith
            ];
          }
        }
      });
      if (options.schemaErrorFormatter) {
        validateSchemaErrorFormatter(options.schemaErrorFormatter);
        fastify2[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify2);
      }
      const avvioPluginTimeout = Number(options.pluginTimeout);
      const avvio = Avvio(fastify2, {
        autostart: false,
        timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
        expose: {
          use: "register"
        }
      });
      avvio.override = override;
      avvio.on("start", () => fastify2[kState].started = true);
      fastify2[kAvvioBoot] = fastify2.ready;
      fastify2.ready = ready;
      fastify2.printPlugins = avvio.prettyPrint.bind(avvio);
      avvio.once("preReady", () => {
        fastify2.onClose((instance, done) => {
          fastify2[kState].closing = true;
          router.closeRoutes();
          hookRunnerApplication("preClose", fastify2[kAvvioBoot], fastify2, function() {
            if (fastify2[kState].listening) {
              if (forceCloseConnections === "idle") {
                instance.server.closeIdleConnections();
              } else if (serverHasCloseAllConnections && forceCloseConnections) {
                instance.server.closeAllConnections();
              } else if (forceCloseConnections === true) {
                for (const conn of fastify2[kKeepAliveConnections]) {
                  conn.destroy();
                  fastify2[kKeepAliveConnections].delete(conn);
                }
              }
            }
            if (serverHasCloseHttp2Sessions) {
              instance.server.closeHttp2Sessions();
            }
            if (!options.serverFactory || fastify2[kState].listening) {
              instance.server.close(function(err) {
                if (err && err.code !== "ERR_SERVER_NOT_RUNNING") {
                  done(null);
                } else {
                  done();
                }
              });
            } else {
              process.nextTick(done, null);
            }
          });
        });
      });
      const onBadUrlContext = new Context({
        server: fastify2,
        config: {}
      });
      fastify2.setNotFoundHandler();
      fourOhFour.arrange404(fastify2);
      router.setup(options, {
        avvio,
        fourOhFour,
        logger,
        hasLogger,
        setupResponseListeners,
        throwIfAlreadyStarted,
        keepAliveConnections
      });
      server.on("clientError", options.clientErrorHandler.bind(fastify2));
      if (initChannel.hasSubscribers) {
        initChannel.publish({ fastify: fastify2 });
      }
      if ("asyncDispose" in Symbol) {
        fastify2[Symbol.asyncDispose] = function dispose() {
          return fastify2.close();
        };
      }
      return fastify2;
      function throwIfAlreadyStarted(msg) {
        if (fastify2[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
      }
      function inject(opts, cb) {
        if (lightMyRequest === void 0) {
          lightMyRequest = require_light_my_request();
        }
        if (fastify2[kState].started) {
          if (fastify2[kState].closing) {
            const error48 = new FST_ERR_REOPENED_CLOSE_SERVER();
            if (cb) {
              cb(error48);
              return;
            } else {
              return Promise.reject(error48);
            }
          }
          return lightMyRequest(httpHandler, opts, cb);
        }
        if (cb) {
          this.ready((err) => {
            if (err) cb(err, null);
            else lightMyRequest(httpHandler, opts, cb);
          });
        } else {
          return lightMyRequest((req, res) => {
            this.ready(function(err) {
              if (err) {
                res.emit("error", err);
                return;
              }
              httpHandler(req, res);
            });
          }, opts);
        }
      }
      function ready(cb) {
        if (this[kState].readyResolver !== null) {
          if (cb != null) {
            this[kState].readyResolver.promise.then(() => cb(null, fastify2), cb);
            return;
          }
          return this[kState].readyResolver.promise;
        }
        process.nextTick(runHooks);
        this[kState].readyResolver = PonyPromise.withResolvers();
        if (!cb) {
          return this[kState].readyResolver.promise;
        } else {
          this[kState].readyResolver.promise.then(() => cb(null, fastify2), cb);
        }
        function runHooks() {
          fastify2[kAvvioBoot]((err, done) => {
            if (err || fastify2[kState].started || fastify2[kState].ready || fastify2[kState].booting) {
              manageErr(err);
            } else {
              fastify2[kState].booting = true;
              hookRunnerApplication("onReady", fastify2[kAvvioBoot], fastify2, manageErr);
            }
            done();
          });
        }
        function manageErr(err) {
          err = err != null && AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
          if (err) {
            return fastify2[kState].readyResolver.reject(err);
          }
          fastify2[kState].readyResolver.resolve(fastify2);
          fastify2[kState].booting = false;
          fastify2[kState].ready = true;
          fastify2[kState].readyResolver = null;
        }
      }
      function withTypeProvider() {
        return this;
      }
      function addHook(name, fn) {
        throwIfAlreadyStarted('Cannot call "addHook"!');
        if (fn == null) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
        }
        if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
          if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else if (name === "onReady" || name === "onListen") {
          if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else if (name === "onRequestAbort") {
          if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else {
          if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        }
        if (name === "onClose") {
          this.onClose(fn.bind(this));
        } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
          this[kHooks].add(name, fn);
        } else {
          this.after((err, done) => {
            try {
              _addHook.call(this, name, fn);
              done(err);
            } catch (err2) {
              done(err2);
            }
          });
        }
        return this;
        function _addHook(name2, fn2) {
          this[kHooks].add(name2, fn2);
          this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
        }
      }
      function addSchema(schema) {
        throwIfAlreadyStarted('Cannot call "addSchema"!');
        this[kSchemaController].add(schema);
        this[kChildren].forEach((child) => child.addSchema(schema));
        return this;
      }
      function defaultClientErrorHandler(err, socket) {
        if (err.code === "ECONNRESET" || socket.destroyed) {
          return;
        }
        let body, errorCode, errorStatus, errorLabel;
        if (err.code === "ERR_HTTP_REQUEST_TIMEOUT") {
          errorCode = "408";
          errorStatus = http.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
          errorLabel = "timeout";
        } else if (err.code === "HPE_HEADER_OVERFLOW") {
          errorCode = "431";
          errorStatus = http.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
          errorLabel = "header_overflow";
        } else {
          errorCode = "400";
          errorStatus = http.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
          errorLabel = "error";
        }
        this.log.trace({ err }, `client ${errorLabel}`);
        if (socket.writable) {
          socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
        }
        socket.destroy(err);
      }
      function defaultRoute(req, res) {
        if (req.headers["accept-version"] !== void 0) {
          req.headers[kRequestAcceptVersion] = req.headers["accept-version"];
          req.headers["accept-version"] = void 0;
        }
        fourOhFour.router.lookup(req, res);
      }
      function onBadUrl(path, req, res) {
        if (frameworkErrors) {
          const id = getGenReqId(onBadUrlContext.server, req);
          const childLogger = createChildLogger(onBadUrlContext, logger, req, id);
          const request = new Request2(id, null, req, null, childLogger, onBadUrlContext);
          const reply = new Reply(res, request, childLogger);
          if (disableRequestLogging === false) {
            childLogger.info({ req: request }, "incoming request");
          }
          return frameworkErrors(new FST_ERR_BAD_URL(path), request, reply);
        }
        const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path}' is not a valid url component","statusCode":400}`;
        res.writeHead(400, {
          "Content-Type": "application/json",
          "Content-Length": body.length
        });
        res.end(body);
      }
      function buildAsyncConstraintCallback(isAsync, req, res) {
        if (isAsync === false) return void 0;
        return function onAsyncConstraintError(err) {
          if (err) {
            if (frameworkErrors) {
              const id = getGenReqId(onBadUrlContext.server, req);
              const childLogger = createChildLogger(onBadUrlContext, logger, req, id);
              const request = new Request2(id, null, req, null, childLogger, onBadUrlContext);
              const reply = new Reply(res, request, childLogger);
              if (disableRequestLogging === false) {
                childLogger.info({ req: request }, "incoming request");
              }
              return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request, reply);
            }
            const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
            res.writeHead(500, {
              "Content-Type": "application/json",
              "Content-Length": body.length
            });
            res.end(body);
          }
        };
      }
      function setNotFoundHandler(opts, handler) {
        throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
        fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
        return this;
      }
      function setValidatorCompiler(validatorCompiler2) {
        throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
        this[kSchemaController].setValidatorCompiler(validatorCompiler2);
        return this;
      }
      function setSchemaErrorFormatter(errorFormatter) {
        throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
        validateSchemaErrorFormatter(errorFormatter);
        this[kSchemaErrorFormatter] = errorFormatter.bind(this);
        return this;
      }
      function setSerializerCompiler(serializerCompiler2) {
        throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
        this[kSchemaController].setSerializerCompiler(serializerCompiler2);
        return this;
      }
      function setSchemaController(schemaControllerOpts) {
        throwIfAlreadyStarted('Cannot call "setSchemaController"!');
        const old = this[kSchemaController];
        const schemaController2 = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
        this[kSchemaController] = schemaController2;
        this.getSchema = schemaController2.getSchema.bind(schemaController2);
        this.getSchemas = schemaController2.getSchemas.bind(schemaController2);
        return this;
      }
      function setReplySerializer(replySerializer) {
        throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
        this[kReplySerializerDefault] = replySerializer;
        return this;
      }
      function setErrorHandler(func) {
        throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
        if (typeof func !== "function") {
          throw new FST_ERR_ERROR_HANDLER_NOT_FN();
        }
        if (!options.allowErrorHandlerOverride && this[kErrorHandlerAlreadySet]) {
          throw new FST_ERR_ERROR_HANDLER_ALREADY_SET();
        } else if (this[kErrorHandlerAlreadySet]) {
          FSTWRN004("To disable this behavior, set 'allowErrorHandlerOverride' to false or ignore this message. For more information, visit: https://fastify.dev/docs/latest/Reference/Server/#allowerrorhandleroverride");
        }
        this[kErrorHandlerAlreadySet] = true;
        this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
        return this;
      }
      function setChildLoggerFactory(factory) {
        throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
        this[kChildLoggerFactory] = factory;
        return this;
      }
      function printRoutes(opts = {}) {
        opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
        return router.printRoutes(opts);
      }
      function wrapRouting(router2, { rewriteUrl, logger: logger2 }) {
        let isAsync;
        return function preRouting(req, res) {
          if (isAsync === void 0) isAsync = router2.isAsyncConstraint();
          if (rewriteUrl) {
            req.originalUrl = req.url;
            const url2 = rewriteUrl.call(fastify2, req);
            if (typeof url2 === "string") {
              req.url = url2;
            } else {
              const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url2);
              req.destroy(err);
            }
          }
          router2.routing(req, res, buildAsyncConstraintCallback(isAsync, req, res));
        };
      }
      function setGenReqId(func) {
        throwIfAlreadyStarted('Cannot call "setGenReqId"!');
        this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
        return this;
      }
      function addHttpMethod(method, { hasBody = false } = {}) {
        if (typeof method !== "string" || http.METHODS.indexOf(method) === -1) {
          throw new FST_ERR_ROUTE_METHOD_INVALID();
        }
        if (hasBody === true) {
          this[kSupportedHTTPMethods].bodywith.add(method);
          this[kSupportedHTTPMethods].bodyless.delete(method);
        } else {
          this[kSupportedHTTPMethods].bodywith.delete(method);
          this[kSupportedHTTPMethods].bodyless.add(method);
        }
        const _method = method.toLowerCase();
        if (!this.hasDecorator(_method)) {
          this.decorate(_method, function(url2, options2, handler) {
            return router.prepareRoute.call(this, { method, url: url2, options: options2, handler });
          });
        }
        return this;
      }
    }
    function validateSchemaErrorFormatter(schemaErrorFormatter) {
      if (typeof schemaErrorFormatter !== "function") {
        throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
      } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
        throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
      }
    }
    module.exports = fastify;
    module.exports.errorCodes = errorCodes;
    module.exports.fastify = fastify;
    module.exports.default = fastify;
  }
});

// node_modules/.pnpm/fastify-plugin@5.1.0/node_modules/fastify-plugin/lib/getPluginName.js
var require_getPluginName = __commonJS({
  "node_modules/.pnpm/fastify-plugin@5.1.0/node_modules/fastify-plugin/lib/getPluginName.js"(exports, module) {
    "use strict";
    var fpStackTracePattern = /at\s(?:.*\.)?plugin\s.*\n\s*(.*)/;
    var fileNamePattern = /(\w*(\.\w*)*)\..*/;
    module.exports = function getPluginName(fn) {
      if (fn.name.length > 0) return fn.name;
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 10;
      try {
        throw new Error("anonymous function");
      } catch (e) {
        Error.stackTraceLimit = stackTraceLimit;
        return extractPluginName(e.stack);
      }
    };
    function extractPluginName(stack) {
      const m2 = stack.match(fpStackTracePattern);
      return m2 ? m2[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
    }
    module.exports.extractPluginName = extractPluginName;
  }
});

// node_modules/.pnpm/fastify-plugin@5.1.0/node_modules/fastify-plugin/lib/toCamelCase.js
var require_toCamelCase = __commonJS({
  "node_modules/.pnpm/fastify-plugin@5.1.0/node_modules/fastify-plugin/lib/toCamelCase.js"(exports, module) {
    "use strict";
    module.exports = function toCamelCase2(name) {
      if (name[0] === "@") {
        name = name.slice(1).replace("/", "-");
      }
      return name.replace(/-(.)/g, function(match2, g1) {
        return g1.toUpperCase();
      });
    };
  }
});

// node_modules/.pnpm/fastify-plugin@5.1.0/node_modules/fastify-plugin/plugin.js
var require_plugin2 = __commonJS({
  "node_modules/.pnpm/fastify-plugin@5.1.0/node_modules/fastify-plugin/plugin.js"(exports, module) {
    "use strict";
    var getPluginName = require_getPluginName();
    var toCamelCase2 = require_toCamelCase();
    var count = 0;
    function plugin(fn, options = {}) {
      let autoName = false;
      if (fn.default !== void 0) {
        fn = fn.default;
      }
      if (typeof fn !== "function") {
        throw new TypeError(
          `fastify-plugin expects a function, instead got a '${typeof fn}'`
        );
      }
      if (typeof options === "string") {
        options = {
          fastify: options
        };
      }
      if (typeof options !== "object" || Array.isArray(options) || options === null) {
        throw new TypeError("The options object should be an object");
      }
      if (options.fastify !== void 0 && typeof options.fastify !== "string") {
        throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
      }
      if (!options.name) {
        autoName = true;
        options.name = getPluginName(fn) + "-auto-" + count++;
      }
      fn[/* @__PURE__ */ Symbol.for("skip-override")] = options.encapsulate !== true;
      fn[/* @__PURE__ */ Symbol.for("fastify.display-name")] = options.name;
      fn[/* @__PURE__ */ Symbol.for("plugin-meta")] = options;
      if (!fn.default) {
        fn.default = fn;
      }
      const camelCase = toCamelCase2(options.name);
      if (!autoName && !fn[camelCase]) {
        fn[camelCase] = fn;
      }
      return fn;
    }
    module.exports = plugin;
    module.exports.default = plugin;
    module.exports.fastifyPlugin = plugin;
  }
});

// node_modules/.pnpm/@fastify+cors@11.2.0/node_modules/@fastify/cors/vary.js
var require_vary = __commonJS({
  "node_modules/.pnpm/@fastify+cors@11.2.0/node_modules/@fastify/cors/vary.js"(exports, module) {
    "use strict";
    var { FifoMap: FifoCache } = require_toad_cache();
    var validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
    function validateFieldname(fieldname) {
      if (validFieldnameRE.test(fieldname) === false) {
        throw new TypeError("Fieldname contains invalid characters.");
      }
    }
    function parse3(header) {
      header = header.trim().toLowerCase();
      const result = [];
      if (header.length === 0) {
      } else if (header.indexOf(",") === -1) {
        result.push(header);
      } else {
        const il = header.length;
        let i = 0;
        let pos = 0;
        let char2;
        for (i; i < il; ++i) {
          char2 = header[i];
          if (char2 === " ") {
            pos = i + 1;
          } else if (char2 === ",") {
            if (pos !== i) {
              result.push(header.slice(pos, i));
            }
            pos = i + 1;
          }
        }
        if (pos !== i) {
          result.push(header.slice(pos, i));
        }
      }
      return result;
    }
    function createAddFieldnameToVary(fieldname) {
      const headerCache = new FifoCache(1e3);
      validateFieldname(fieldname);
      return function(reply) {
        let header = reply.getHeader("Vary");
        if (!header) {
          reply.header("Vary", fieldname);
          return;
        }
        if (header === "*") {
          return;
        }
        if (fieldname === "*") {
          reply.header("Vary", "*");
          return;
        }
        if (Array.isArray(header)) {
          header = header.join(", ");
        }
        if (headerCache.get(header) === void 0) {
          const vals = parse3(header);
          if (vals.indexOf("*") !== -1) {
            headerCache.set(header, "*");
          } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
            headerCache.set(header, header + ", " + fieldname);
          } else {
            headerCache.set(header, null);
          }
        }
        const cached2 = headerCache.get(header);
        if (cached2 !== null) {
          reply.header("Vary", cached2);
        }
      };
    }
    module.exports.createAddFieldnameToVary = createAddFieldnameToVary;
    module.exports.addOriginToVaryHeader = createAddFieldnameToVary("Origin");
    module.exports.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary("Access-Control-Request-Headers");
    module.exports.parse = parse3;
  }
});

// node_modules/.pnpm/@fastify+cors@11.2.0/node_modules/@fastify/cors/index.js
var require_cors = __commonJS({
  "node_modules/.pnpm/@fastify+cors@11.2.0/node_modules/@fastify/cors/index.js"(exports, module) {
    "use strict";
    var fp = require_plugin2();
    var {
      addAccessControlRequestHeadersToVaryHeader,
      addOriginToVaryHeader
    } = require_vary();
    var defaultOptions = {
      origin: "*",
      methods: "GET,HEAD,POST",
      hook: "onRequest",
      preflightContinue: false,
      optionsSuccessStatus: 204,
      credentials: false,
      exposedHeaders: null,
      allowedHeaders: null,
      maxAge: null,
      preflight: true,
      strictPreflight: true
    };
    var validHooks = [
      "onRequest",
      "preParsing",
      "preValidation",
      "preHandler",
      "preSerialization",
      "onSend"
    ];
    var hookWithPayload = [
      "preSerialization",
      "preParsing",
      "onSend"
    ];
    function validateHook(value, next) {
      if (validHooks.indexOf(value) !== -1) {
        return;
      }
      next(new TypeError("@fastify/cors: Invalid hook option provided."));
    }
    function fastifyCors(fastify, opts, next) {
      fastify.decorateRequest("corsPreflightEnabled", false);
      let hideOptionsRoute = true;
      let logLevel;
      if (typeof opts === "function") {
        handleCorsOptionsDelegator(opts, fastify, { hook: defaultOptions.hook }, next);
      } else if (opts.delegator) {
        const { delegator, ...options } = opts;
        handleCorsOptionsDelegator(delegator, fastify, options, next);
      } else {
        const corsOptions = normalizeCorsOptions(opts);
        validateHook(corsOptions.hook, next);
        if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
          fastify.addHook(corsOptions.hook, function handleCors(req, reply, _payload, next2) {
            addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
          });
        } else {
          fastify.addHook(corsOptions.hook, function handleCors(req, reply, next2) {
            addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
          });
        }
      }
      if (opts.logLevel !== void 0) logLevel = opts.logLevel;
      if (opts.hideOptionsRoute !== void 0) hideOptionsRoute = opts.hideOptionsRoute;
      fastify.options("*", { schema: { hide: hideOptionsRoute }, logLevel }, (req, reply) => {
        if (!req.corsPreflightEnabled) {
          reply.callNotFound();
          return;
        }
        reply.send();
      });
      next();
    }
    function handleCorsOptionsDelegator(optionsResolver, fastify, opts, next) {
      const hook = opts?.hook || defaultOptions.hook;
      validateHook(hook, next);
      if (optionsResolver.length === 2) {
        if (hookWithPayload.indexOf(hook) !== -1) {
          fastify.addHook(hook, function handleCors(req, reply, _payload, next2) {
            handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
          });
        } else {
          fastify.addHook(hook, function handleCors(req, reply, next2) {
            handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
          });
        }
      } else {
        if (hookWithPayload.indexOf(hook) !== -1) {
          fastify.addHook(hook, function handleCors(req, reply, _payload, next2) {
            const ret = optionsResolver(req);
            if (ret && typeof ret.then === "function") {
              ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
              return;
            }
            next2(new Error("Invalid CORS origin option"));
          });
        } else {
          fastify.addHook(hook, function handleCors(req, reply, next2) {
            const ret = optionsResolver(req);
            if (ret && typeof ret.then === "function") {
              ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
              return;
            }
            next2(new Error("Invalid CORS origin option"));
          });
        }
      }
    }
    function handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next) {
      optionsResolver(req, (err, options) => {
        if (err) {
          next(err);
        } else {
          addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next);
        }
      });
    }
    function normalizeCorsOptions(opts, dynamic) {
      const corsOptions = { ...defaultOptions, ...opts };
      if (Array.isArray(opts.origin) && opts.origin.indexOf("*") !== -1) {
        corsOptions.origin = "*";
      }
      if (Number.isInteger(corsOptions.cacheControl)) {
        corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
      } else if (typeof corsOptions.cacheControl !== "string") {
        corsOptions.cacheControl = null;
      }
      corsOptions.dynamic = dynamic || false;
      return corsOptions;
    }
    function addCorsHeadersHandler(fastify, globalOptions, req, reply, next) {
      const options = { ...globalOptions, ...req.routeOptions.config?.cors };
      if (typeof options.origin !== "string" && options.origin !== false || options.dynamic) {
        addOriginToVaryHeader(reply);
      }
      const resolveOriginOption = typeof options.origin === "function" ? resolveOriginWrapper(fastify, options.origin) : (_, cb) => cb(null, options.origin);
      resolveOriginOption(req, (error48, resolvedOriginOption) => {
        if (error48 !== null) {
          return next(error48);
        }
        if (resolvedOriginOption === false) {
          return next();
        }
        if (req.routeOptions.config?.cors === false) {
          return next();
        }
        if (!resolvedOriginOption) {
          return next(new Error("Invalid CORS origin option"));
        }
        addCorsHeaders(req, reply, resolvedOriginOption, options);
        if (req.raw.method === "OPTIONS" && options.preflight === true) {
          if (options.strictPreflight === true && (!req.headers.origin || !req.headers["access-control-request-method"])) {
            reply.status(400).type("text/plain").send("Invalid Preflight Request");
            return;
          }
          req.corsPreflightEnabled = true;
          addPreflightHeaders(req, reply, options);
          if (!options.preflightContinue) {
            reply.code(options.optionsSuccessStatus).header("Content-Length", "0").send();
            return;
          }
        }
        return next();
      });
    }
    function addCorsHeaders(req, reply, originOption, corsOptions) {
      const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
      if (origin) {
        reply.header("Access-Control-Allow-Origin", origin);
      }
      if (corsOptions.credentials) {
        reply.header("Access-Control-Allow-Credentials", "true");
      }
      if (corsOptions.exposedHeaders !== null) {
        reply.header(
          "Access-Control-Expose-Headers",
          Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(", ") : corsOptions.exposedHeaders
        );
      }
    }
    function addPreflightHeaders(req, reply, corsOptions) {
      reply.header(
        "Access-Control-Allow-Methods",
        Array.isArray(corsOptions.methods) ? corsOptions.methods.join(", ") : corsOptions.methods
      );
      if (corsOptions.allowedHeaders === null) {
        addAccessControlRequestHeadersToVaryHeader(reply);
        const reqAllowedHeaders = req.headers["access-control-request-headers"];
        if (reqAllowedHeaders !== void 0) {
          reply.header("Access-Control-Allow-Headers", reqAllowedHeaders);
        }
      } else {
        reply.header(
          "Access-Control-Allow-Headers",
          Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(", ") : corsOptions.allowedHeaders
        );
      }
      if (corsOptions.maxAge !== null) {
        reply.header("Access-Control-Max-Age", String(corsOptions.maxAge));
      }
      if (corsOptions.cacheControl) {
        reply.header("Cache-Control", corsOptions.cacheControl);
      }
    }
    function resolveOriginWrapper(fastify, origin) {
      return function(req, cb) {
        const result = origin.call(fastify, req.headers.origin, cb);
        if (result && typeof result.then === "function") {
          result.then((res) => cb(null, res), cb);
        }
      };
    }
    function getAccessControlAllowOriginHeader(reqOrigin, originOption) {
      if (typeof originOption === "string") {
        return originOption;
      }
      return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false;
    }
    function isRequestOriginAllowed(reqOrigin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (let i = 0; i < allowedOrigin.length; ++i) {
          if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (typeof allowedOrigin === "string") {
        return reqOrigin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        allowedOrigin.lastIndex = 0;
        return allowedOrigin.test(reqOrigin);
      } else {
        return !!allowedOrigin;
      }
    }
    var _fastifyCors = fp(fastifyCors, {
      fastify: "5.x",
      name: "@fastify/cors"
    });
    module.exports = _fastifyCors;
    module.exports.fastifyCors = _fastifyCors;
    module.exports.default = _fastifyCors;
  }
});

// src/lib/config.ts
var config_exports = {};
__export(config_exports, {
  config: () => config2
});
var config2;
var init_config = __esm({
  "src/lib/config.ts"() {
    config2 = {
      PORT: process.env.PORT ? Number(process.env.PORT) : 3e3,
      DATABASE_URL: process.env.DATABASE_URL || "",
      // Polar.sh Configuration
      POLAR_ACCESS_TOKEN: process.env.POLAR_ACCESS_TOKEN || "",
      POLAR_ORGANIZATION_ID: process.env.POLAR_ORGANIZATION_ID || "",
      POLAR_WEBHOOK_SECRET: process.env.POLAR_WEBHOOK_SECRET || "",
      POLAR_SERVER: process.env.POLAR_SERVER || "sandbox",
      POLAR_PRODUCT_ID: process.env.POLAR_PRODUCT_ID || "",
      // Razorpay Configuration (supports existing KEY_ID/KEY_SECRET fallbacks)
      RAZORPAY_KEY_ID: process.env.RAZORPAY_KEY_ID || process.env.KEY_ID || "",
      RAZORPAY_KEY_SECRET: process.env.RAZORPAY_KEY_SECRET || process.env.KEY_SECRET || "",
      RAZORPAY_WEBHOOK_SECRET: process.env.RAZORPAY_WEBHOOK_SECRET || "",
      RAZORPAY_CURRENCY: process.env.RAZORPAY_CURRENCY || "INR",
      // Checkout URLs
      SUCCESS_URL: process.env.SUCCESS_URL || "http://localhost:3000/checkout/success",
      RETURN_URL: process.env.RETURN_URL || "http://localhost:3000"
    };
  }
});

// node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
    var Stream = __require("stream").Stream;
    var util = __require("util");
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
    var util = __require("util");
    var Stream = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module) {
    module.exports = require_db();
  }
});

// node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db2 = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match2 && db2[match2[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match2 && exports.extensions[match2[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db2).forEach(function forEachMimeType(type) {
        var mime = db2[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db2[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module) {
    module.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module) {
    var defer = require_defer();
    module.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module) {
    module.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module) {
    var async = require_async();
    var abort = require_abort();
    module.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error48, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error48) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error48, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module) {
    module.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a2, b2) {
          return sortMethod(list[a2], list[b2]);
        });
      }
      return initState;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module) {
    var abort = require_abort();
    var async = require_async();
    module.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error48, result) {
          if (error48) {
            callback(error48, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = serialOrdered;
    module.exports.ascending = ascending;
    module.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error48, result) {
        if (error48) {
          callback(error48, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a2, b2) {
      return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
    }
    function descending(a2, b2) {
      return -1 * ascending(a2, b2);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module) {
    var serialOrdered = require_serialOrdered();
    module.exports = serial2;
    function serial2(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module) {
    module.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range2 = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref3 = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type2 = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri2 = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a2) {
      return a2 !== a2;
    };
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign(number6) {
      if ($isNaN(number6) || number6 === 0) {
        return number6;
      }
      return number6 < 0 ? -1 : 1;
    };
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b2) {
      var arr = [];
      for (var i = 0; i < a2.length; i += 1) {
        arr[i] = a2[i];
      }
      for (var j = 0; j < b2.length; j += 1) {
        arr[j + a2.length] = b2[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type2();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc2 = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc2 && typeof desc2.get === "function" ? callBind([desc2.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O2) {
      return reflectGetProto(O2);
    } : originalGetProto ? function getProto(O2) {
      if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O2);
    } : getDunderProto ? function getProto(O2) {
      return getDunderProto(O2);
    } : null;
  }
});

// node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range2();
    var $ReferenceError = require_ref3();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type2();
    var $URIError = require_uri2();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn2 = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string6) {
      var first = $strSlice(string6, 0, 1);
      var last = $strSlice(string6, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string6, rePropName, function(match2, number6, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number6 || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn2(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn2(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc2 = $gOPD(value, part);
            isOwn = !!desc2;
            if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
              value = desc2.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn2(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn2 = require_hasown();
    var $TypeError = require_type2();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module.exports = function setToStringTag(object3, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn2(object3, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object3, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object3[toStringTag] = value;
        }
      }
    };
  }
});

// node_modules/.pnpm/form-data@4.0.5/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/.pnpm/form-data@4.0.5/node_modules/form-data/lib/populate.js"(exports, module) {
    "use strict";
    module.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/.pnpm/form-data@4.0.5/node_modules/form-data/lib/form_data.js
var require_form_data2 = __commonJS({
  "node_modules/.pnpm/form-data@4.0.5/node_modules/form-data/lib/form_data.js"(exports, module) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = __require("util");
    var path = __require("path");
    var http = __require("http");
    var https = __require("https");
    var parseUrl = __require("url").parse;
    var fs = __require("fs");
    var Stream = __require("stream").Stream;
    var crypto3 = __require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn2 = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn2(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn2(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn2(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn2(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn2(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn2(value, "httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn2(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn2(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto3.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error48, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error48, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2.prototype, "FormData");
    module.exports = FormData2;
  }
});

// node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = __require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname3 = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname3 !== "string" || !hostname3 || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname3 = hostname3.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname3, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname3, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname3 !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname3, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m2 = s * 60;
    var h = m2 * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match2 = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error48) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error48) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error48) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error48) {
        return "[UnexpectedJSONParseError]: " + error48.message;
      }
    };
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = __require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error48) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node2();
    }
  }
});

// node_modules/.pnpm/follow-redirects@1.15.11/node_modules/follow-redirects/debug.js
var require_debug3 = __commonJS({
  "node_modules/.pnpm/follow-redirects@1.15.11/node_modules/follow-redirects/debug.js"(exports, module) {
    var debug;
    module.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error48) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/.pnpm/follow-redirects@1.15.11/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/.pnpm/follow-redirects@1.15.11/node_modules/follow-redirects/index.js"(exports, module) {
    var url2 = __require("url");
    var URL2 = url2.URL;
    var http = __require("http");
    var https = __require("https");
    var Writable = __require("stream").Writable;
    var assert2 = __require("assert");
    var debug = require_debug3();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert2(new URL2(""));
    } catch (error48) {
      useNativeURL = error48.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error48) {
      destroyRequest(this._currentRequest, error48);
      destroy.call(this, error48);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a2, b2) {
        return this._currentRequest[method](a2, b2);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error48) {
          if (request === self2._currentRequest) {
            if (error48) {
              self2.emit("error", error48);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap2(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert2.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error48) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error48);
    }
    function isSubdomain(subdomain, domain2) {
      assert2(isString(subdomain) && isString(domain2));
      var dot = subdomain.length - domain2.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain2);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module.exports = wrap2({ http, https });
    module.exports.wrap = wrap2;
  }
});

// node_modules/.pnpm/axios@1.13.5/node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "node_modules/.pnpm/axios@1.13.5/node_modules/axios/dist/node/axios.cjs"(exports, module) {
    "use strict";
    var FormData$1 = require_form_data2();
    var crypto3 = __require("crypto");
    var url2 = __require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = __require("http");
    var https = __require("https");
    var http2 = __require("http2");
    var util = __require("util");
    var followRedirects = require_follow_redirects();
    var zlib = __require("zlib");
    var stream = __require("stream");
    var events = __require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto3);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url2);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var http2__default = /* @__PURE__ */ _interopDefaultLegacy(http2);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap2() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction$1 = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject2 = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject3 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject2(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject2(val) && isFunction$1(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = [
      "ReadableStream",
      "Request",
      "Response",
      "Headers"
    ].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge2() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return;
        }
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject3(result[targetKey]) && isPlainObject3(val)) {
          result[targetKey] = merge2(result[targetKey], val);
        } else if (isPlainObject3(val)) {
          result[targetKey] = merge2({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend2 = (a2, b2, thisArg, { allOwnKeys } = {}) => {
      forEach(
        b2,
        (val, key) => {
          if (thisArg && isFunction$1(val)) {
            Object.defineProperty(a2, key, {
              value: bind(val, thisArg),
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            Object.defineProperty(a2, key, {
              value: val,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        },
        { allOwnKeys }
      );
      return a2;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors) => {
      constructor.prototype = Object.create(
        superConstructor.prototype,
        descriptors
      );
      Object.defineProperty(constructor.prototype, "constructor", {
        value: constructor,
        writable: true,
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase2 = (str) => {
      return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      });
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject2(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener(
          "message",
          ({ source, data }) => {
            if (source === _global && data === token) {
              callbacks.length && callbacks.shift()();
            }
          },
          false
        );
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(typeof setImmediate === "function", isFunction$1(_global.postMessage));
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject: isObject2,
      isPlainObject: isPlainObject3,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge: merge2,
      extend: extend2,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase: toCamelCase2,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    var AxiosError = class _AxiosError extends Error {
      static from(error48, code, config3, request, response, customProps) {
        const axiosError = new _AxiosError(error48.message, code || error48.code, config3, request, response);
        axiosError.cause = error48;
        axiosError.name = error48.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      }
      /**
       * Create an Error with the specified message, config, error code, request and response.
       *
       * @param {string} message The error message.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [config] The config.
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       *
       * @returns {Error} The created error.
       */
      constructor(message, code, config3, request, response) {
        super(message);
        this.name = "AxiosError";
        this.isAxiosError = true;
        code && (this.code = code);
        config3 && (this.config = config3);
        request && (this.request = request);
        if (response) {
          this.response = response;
          this.status = response.status;
        }
      }
      toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    };
    AxiosError.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE";
    AxiosError.ERR_BAD_OPTION = "ERR_BAD_OPTION";
    AxiosError.ECONNABORTED = "ECONNABORTED";
    AxiosError.ETIMEDOUT = "ETIMEDOUT";
    AxiosError.ERR_NETWORK = "ERR_NETWORK";
    AxiosError.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS";
    AxiosError.ERR_DEPRECATED = "ERR_DEPRECATED";
    AxiosError.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE";
    AxiosError.ERR_BAD_REQUEST = "ERR_BAD_REQUEST";
    AxiosError.ERR_CANCELED = "ERR_CANCELED";
    AxiosError.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT";
    AxiosError.ERR_INVALID_URL = "ERR_INVALID_URL";
    var AxiosError$1 = AxiosError;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index2) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
        return charMap[match2];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode2 = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode2(pair[0]) + "=" + _encode2(pair[1]);
      }, "").join("&");
    };
    function encode3(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url3, params, options) {
      if (!params) {
        return url3;
      }
      const _encode2 = options && options.encode || encode3;
      const _options = utils$1.isFunction(options) ? {
        serialize: options
      } : options;
      const serializeFn = _options && _options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, _options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, _options).toString(_encode2);
      }
      if (serializedParams) {
        const hashmarkIndex = url3.indexOf("#");
        if (hashmarkIndex !== -1) {
          url3 = url3.slice(0, hashmarkIndex);
        }
        url3 += (url3.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url3;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       * @param {Object} options The options for the interceptor, synchronous and runWhen
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false,
      legacyInterceptorReqResOrdering: true
    };
    var URLSearchParams2 = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams2,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
        return match2[0] === "[]" ? "" : match2[1] || match2[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index2) {
        let name = path[index2++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index2);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
        i = line2.indexOf(":");
        key = line2.substring(0, i).trim().toLowerCase();
        val = line2.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = /* @__PURE__ */ Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match2;
      while (match2 = tokensRE.exec(str)) {
        tokens[match2[1]] = match2[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char2, str) => {
        return char2.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config3 = this || defaults$1;
      const context = response || config3;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform3(fn) {
        data = fn.call(config3, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    var CanceledError = class extends AxiosError$1 {
      /**
       * A `CanceledError` is an object that is thrown when an operation is canceled.
       *
       * @param {string=} message The message.
       * @param {Object=} config The config.
       * @param {Object=} request The request.
       *
       * @returns {CanceledError} The created error.
       */
      constructor(message, config3, request) {
        super(message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config3, request);
        this.name = "CanceledError";
        this.__CANCEL__ = true;
      }
    };
    var CanceledError$1 = CanceledError;
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError$1(
          "Request failed with status code " + response.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url3) {
      if (typeof url3 !== "string") {
        return false;
      }
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url3);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.13.5";
    function parseProtocol(url3) {
      const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url3);
      return match2 && match2[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match2 = DATA_URL_PATTERN.exec(uri);
        if (!match2) {
          throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
        }
        const mime = match2[1];
        const isBase64 = match2[2];
        const body = match2[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError$1("Unsupported protocol " + protocol, AxiosError$1.ERR_NOT_SUPPORT);
    }
    var kInternals = /* @__PURE__ */ Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match2) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match2]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from((async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      })());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp2 = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp2 = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp2;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    function estimateDataURLDecodedBytes(url3) {
      if (!url3 || typeof url3 !== "string") return 0;
      if (!url3.startsWith("data:")) return 0;
      const comma = url3.indexOf(",");
      if (comma < 0) return 0;
      const meta3 = url3.slice(5, comma);
      const body = url3.slice(comma + 1);
      const isBase64 = /;base64/i.test(meta3);
      if (isBase64) {
        let effectiveLen = body.length;
        const len = body.length;
        for (let i = 0; i < len; i++) {
          if (body.charCodeAt(i) === 37 && i + 2 < len) {
            const a2 = body.charCodeAt(i + 1);
            const b2 = body.charCodeAt(i + 2);
            const isHex = (a2 >= 48 && a2 <= 57 || a2 >= 65 && a2 <= 70 || a2 >= 97 && a2 <= 102) && (b2 >= 48 && b2 <= 57 || b2 >= 65 && b2 <= 70 || b2 >= 97 && b2 <= 102);
            if (isHex) {
              effectiveLen -= 2;
              i += 2;
            }
          }
        }
        let pad = 0;
        let idx = len - 1;
        const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
        body.charCodeAt(j - 1) === 51 && // '3'
        (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
        if (idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
            idx--;
          } else if (tailIsPct3D(idx)) {
            pad++;
            idx -= 3;
          }
        }
        if (pad === 1 && idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
          } else if (tailIsPct3D(idx)) {
            pad++;
          }
        }
        const groups = Math.floor(effectiveLen / 4);
        const bytes = groups * 3 - (pad || 0);
        return bytes > 0 ? bytes : 0;
      }
      return Buffer.byteLength(body, "utf8");
    }
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    var Http2Sessions = class {
      constructor() {
        this.sessions = /* @__PURE__ */ Object.create(null);
      }
      getSession(authority, options) {
        options = Object.assign({
          sessionTimeout: 1e3
        }, options);
        let authoritySessions = this.sessions[authority];
        if (authoritySessions) {
          let len = authoritySessions.length;
          for (let i = 0; i < len; i++) {
            const [sessionHandle, sessionOptions] = authoritySessions[i];
            if (!sessionHandle.destroyed && !sessionHandle.closed && util__default["default"].isDeepStrictEqual(sessionOptions, options)) {
              return sessionHandle;
            }
          }
        }
        const session = http2__default["default"].connect(authority, options);
        let removed;
        const removeSession = () => {
          if (removed) {
            return;
          }
          removed = true;
          let entries = authoritySessions, len = entries.length, i = len;
          while (i--) {
            if (entries[i][0] === session) {
              if (len === 1) {
                delete this.sessions[authority];
              } else {
                entries.splice(i, 1);
              }
              return;
            }
          }
        };
        const originalRequestFn = session.request;
        const { sessionTimeout } = options;
        if (sessionTimeout != null) {
          let timer;
          let streamsCount = 0;
          session.request = function() {
            const stream2 = originalRequestFn.apply(this, arguments);
            streamsCount++;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            stream2.once("close", () => {
              if (!--streamsCount) {
                timer = setTimeout(() => {
                  timer = null;
                  removeSession();
                }, sessionTimeout);
              }
            });
            return stream2;
          };
        }
        session.once("close", removeSession);
        let entry = [
          session,
          options
        ];
        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
        return session;
      }
    };
    var http2Sessions = new Http2Sessions();
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          const validProxyAuth = Boolean(proxy.auth.username || proxy.auth.password);
          if (validProxyAuth) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          } else if (typeof proxy.auth === "object") {
            throw new AxiosError$1("Invalid proxy authorization", AxiosError$1.ERR_BAD_OPTION, { proxy });
          }
          const base643 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base643;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var http2Transport = {
      request(options, cb) {
        const authority = options.protocol + "//" + options.hostname + ":" + (options.port || (options.protocol === "https:" ? 443 : 80));
        const { http2Options, headers } = options;
        const session = http2Sessions.getSession(authority, http2Options);
        const {
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_STATUS
        } = http2__default["default"].constants;
        const http2Headers = {
          [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
          [HTTP2_HEADER_METHOD]: options.method,
          [HTTP2_HEADER_PATH]: options.path
        };
        utils$1.forEach(headers, (header, name) => {
          name.charAt(0) !== ":" && (http2Headers[name] = header);
        });
        const req = session.request(http2Headers);
        req.once("response", (responseHeaders) => {
          const response = req;
          responseHeaders = Object.assign({}, responseHeaders);
          const status = responseHeaders[HTTP2_HEADER_STATUS];
          delete responseHeaders[HTTP2_HEADER_STATUS];
          response.headers = responseHeaders;
          response.statusCode = +status;
          cb(response);
        });
        return req;
      }
    };
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config3) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family, httpVersion = 1, http2Options } = config3;
        const { responseType, responseEncoding } = config3;
        const method = config3.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        httpVersion = +httpVersion;
        if (Number.isNaN(httpVersion)) {
          throw TypeError(`Invalid protocol version: '${config3.httpVersion}' is not a number`);
        }
        if (httpVersion !== 1 && httpVersion !== 2) {
          throw TypeError(`Unsupported protocol version '${httpVersion}'`);
        }
        const isHttp2 = httpVersion === 2;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname3, opt, cb) => {
            _lookup(hostname3, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const abortEmitter = new events.EventEmitter();
        function abort(reason) {
          try {
            abortEmitter.emit("abort", !reason || reason.type ? new CanceledError$1(null, config3, req) : reason);
          } catch (err) {
            console.warn("emit error", err);
          }
        }
        abortEmitter.once("abort", reject);
        const onFinished = () => {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(abort);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", abort);
          }
          abortEmitter.removeAllListeners();
        };
        if (config3.cancelToken || config3.signal) {
          config3.cancelToken && config3.cancelToken.subscribe(abort);
          if (config3.signal) {
            config3.signal.aborted ? abort() : config3.signal.addEventListener("abort", abort);
          }
        }
        onDone((response, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
            return;
          }
          const { data: data2 } = response;
          if (data2 instanceof stream__default["default"].Readable || data2 instanceof stream__default["default"].Duplex) {
            const offListeners = stream__default["default"].finished(data2, () => {
              offListeners();
              onFinished();
            });
          } else {
            onFinished();
          }
        });
        const fullPath = buildFullPath(config3.baseURL, config3.url, config3.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config3.maxContentLength > -1) {
            const dataUrl = String(config3.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config3.maxContentLength) {
              return reject(new AxiosError$1(
                "maxContentLength size of " + config3.maxContentLength + " exceeded",
                AxiosError$1.ERR_BAD_RESPONSE,
                config3
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config: config3
            });
          }
          try {
            convertedData = fromDataURI(config3.url, responseType === "blob", {
              Blob: config3.env && config3.env.Blob
            });
          } catch (err) {
            throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config3);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config: config3
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError$1(
            "Unsupported protocol " + protocol,
            AxiosError$1.ERR_BAD_REQUEST,
            config3
          ));
        }
        const headers = AxiosHeaders$1.from(config3.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config3;
        const maxRate = config3.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data)) ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError$1(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError$1.ERR_BAD_REQUEST,
              config3
            ));
          }
          headers.setContentLength(data.length, false);
          if (config3.maxBodyLength > -1 && data.length > config3.maxBodyLength) {
            return reject(new AxiosError$1(
              "Request body larger than maxBodyLength limit",
              AxiosError$1.ERR_BAD_REQUEST,
              config3
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config3.auth) {
          const username = config3.auth.username || "";
          const password = config3.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path;
        try {
          path = buildURL(
            parsed.pathname + parsed.search,
            config3.params,
            config3.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config3;
          customErr.url = config3.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path,
          method,
          headers: headers.toJSON(),
          agents: { http: config3.httpAgent, https: config3.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {},
          http2Options
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config3.socketPath) {
          options.socketPath = config3.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config3.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config3.httpsAgent : config3.httpAgent;
        if (isHttp2) {
          transport = http2Transport;
        } else {
          if (config3.transport) {
            transport = config3.transport;
          } else if (config3.maxRedirects === 0) {
            transport = isHttpsRequest ? https__default["default"] : http__default["default"];
          } else {
            if (config3.maxRedirects) {
              options.maxRedirects = config3.maxRedirects;
            }
            if (config3.beforeRedirect) {
              options.beforeRedirects.config = config3.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
        }
        if (config3.maxBodyLength > -1) {
          options.maxBodyLength = config3.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config3.insecureHTTPParser) {
          options.insecureHTTPParser = config3.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = utils$1.toFiniteNumber(res.headers["content-length"]);
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config3.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config: config3,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config3.maxContentLength > -1 && totalResponseBytes > config3.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                abort(new AxiosError$1(
                  "maxContentLength size of " + config3.maxContentLength + " exceeded",
                  AxiosError$1.ERR_BAD_RESPONSE,
                  config3,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError$1(
                "stream has been aborted",
                AxiosError$1.ERR_BAD_RESPONSE,
                config3,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError$1.from(err, null, config3, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError$1.from(err, null, config3, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          abortEmitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        abortEmitter.once("abort", (err) => {
          if (req.close) {
            req.close();
          } else {
            req.destroy(err);
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError$1.from(err, null, config3, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config3.timeout) {
          const timeout = parseInt(config3.timeout, 10);
          if (Number.isNaN(timeout)) {
            abort(new AxiosError$1(
              "error trying to parse `config.timeout` to int",
              AxiosError$1.ERR_BAD_OPTION_VALUE,
              config3,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config3.timeout ? "timeout of " + config3.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config3.transitional || transitionalDefaults;
            if (config3.timeoutErrorMessage) {
              timeoutErrorMessage = config3.timeoutErrorMessage;
            }
            abort(new AxiosError$1(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
              config3,
              req
            ));
          });
        } else {
          req.setTimeout(0);
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError$1("Request stream has been aborted", config3, req));
            }
          });
          data.pipe(req);
        } else {
          data && req.write(data);
          req.end();
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url3) => {
      url3 = new URL(url3, platform.origin);
      return origin2.protocol === url3.protocol && origin2.host === url3.host && (isMSIE || origin2.port === url3.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain2, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path)) {
            cookie.push(`path=${path}`);
          }
          if (utils$1.isString(domain2)) {
            cookie.push(`domain=${domain2}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name) {
          if (typeof document === "undefined") return null;
          const match2 = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
          return match2 ? decodeURIComponent(match2[1]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config22) {
      config22 = config22 || {};
      const config3 = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a2, b2, prop, caseless) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(a2, b2, prop, caseless);
        } else if (!utils$1.isUndefined(a2)) {
          return getMergedValue(void 0, a2, prop, caseless);
        }
      }
      function valueFromConfig2(a2, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a2, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$1.isUndefined(a2)) {
          return getMergedValue(void 0, a2);
        }
      }
      function mergeDirectKeys(a2, b2, prop) {
        if (prop in config22) {
          return getMergedValue(a2, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a2);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
      };
      utils$1.forEach(
        Object.keys({ ...config1, ...config22 }),
        function computeConfigValue(prop) {
          if (prop === "__proto__" || prop === "constructor" || prop === "prototype")
            return;
          const merge3 = utils$1.hasOwnProp(mergeMap, prop) ? mergeMap[prop] : mergeDeepProperties;
          const configValue = merge3(config1[prop], config22[prop], prop);
          utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
        }
      );
      return config3;
    }
    var resolveConfig = (config3) => {
      const newConfig = mergeConfig({}, config3);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config3.params, config3.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config3) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config3);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config3,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config3, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config3, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError$1(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
            config3,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError$1(null, config3, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config3));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted2;
        const onabort = function(reason) {
          if (!aborted2) {
            aborted2 = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError$1(`timeout of ${timeout}ms exceeded`, AxiosError$1.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var { isFunction } = utils$1;
    var globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
      Request: Request2,
      Response: Response2
    }))(utils$1.global);
    var {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder$1
    } = utils$1.global;
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var factory = (env2) => {
      env2 = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env2);
      const { fetch: envFetch, Request: Request2, Response: Response2 } = env2;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction(Request2);
      const isResponseSupported = isFunction(Response2);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
      const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request2(str).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request2(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response2("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config3) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config3);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request2(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config3) => {
        let {
          url: url3,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config3);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request2(url3, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request2(url3, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url3, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response2(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config3);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config3,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config3, request, err && err.response),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError$1.from(err, err && err.code, config3, request, err && err.response);
        }
      };
    };
    var seedCache = /* @__PURE__ */ new Map();
    var getFetch = (config3) => {
      let env2 = config3 && config3.env || {};
      const { fetch: fetch2, Request: Request2, Response: Response2 } = env2;
      const seeds = [
        Request2,
        Response2,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map2 = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map2.get(seed);
        target === void 0 && map2.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env2));
        map2 = target;
      }
      return target;
    };
    getFetch();
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter(adapters2, config3) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError$1(`Unknown adapter '${id}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config3)))) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config3) {
      if (config3.cancelToken) {
        config3.cancelToken.throwIfRequested();
      }
      if (config3.signal && config3.signal.aborted) {
        throw new CanceledError$1(null, config3);
      }
    }
    function dispatchRequest(config3) {
      throwIfCancellationRequested(config3);
      config3.headers = AxiosHeaders$1.from(config3.headers);
      config3.data = transformData.call(
        config3,
        config3.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config3.method) !== -1) {
        config3.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config3.adapter || defaults$1.adapter, config3);
      return adapter(config3).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config3);
        response.data = transformData.call(
          config3,
          config3.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config3);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config3,
              config3.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version3, message) {
      function formatMessage(opt, desc2) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc2 + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError$1(
            formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
            AxiosError$1.ERR_DEPRECATED
          );
        }
        if (version3 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version3 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config3) {
        try {
          return await this._request(configOrUrl, config3);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config3) {
        if (typeof configOrUrl === "string") {
          config3 = config3 || {};
          config3.url = configOrUrl;
        } else {
          config3 = configOrUrl || {};
        }
        config3 = mergeConfig(this.defaults, config3);
        const { transitional, paramsSerializer, headers } = config3;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean),
            legacyInterceptorReqResOrdering: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config3.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config3.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config3.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config3.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config3, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config3.method = (config3.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config3.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config3.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config3) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          const transitional2 = config3.transitional || transitionalDefaults;
          const legacyInterceptorReqResOrdering = transitional2 && transitional2.legacyInterceptorReqResOrdering;
          if (legacyInterceptorReqResOrdering) {
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          } else {
            requestInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          }
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise2;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise2 = Promise.resolve(config3);
          while (i < len) {
            promise2 = promise2.then(chain[i++], chain[i++]);
          }
          return promise2;
        }
        len = requestInterceptorChain.length;
        let newConfig = config3;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error48) {
            onRejected.call(this, error48);
            break;
          }
        }
        try {
          promise2 = dispatchRequest.call(this, newConfig);
        } catch (error48) {
          return Promise.reject(error48);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise2;
      }
      getUri(config3) {
        config3 = mergeConfig(this.defaults, config3);
        const fullPath = buildFullPath(config3.baseURL, config3.url, config3.allowAbsoluteUrls);
        return buildURL(fullPath, config3.params, config3.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url3, config3) {
        return this.request(mergeConfig(config3 || {}, {
          method,
          url: url3,
          data: (config3 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url3, data, config3) {
          return this.request(mergeConfig(config3 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url3,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise2 = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise2.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise2;
        };
        executor(function cancel(message, config3, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError$1(message, config3, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError$1;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError$1;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/utils/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/utils/nodeify.js"(exports, module) {
    "use strict";
    var nodeify = function nodeify2(promise2, cb) {
      if (!cb) {
        return promise2.then(function(response) {
          return response.data;
        });
      }
      return promise2.then(function(response) {
        cb(null, response.data);
      }).catch(function(error48) {
        cb(error48, null);
      });
    };
    module.exports = nodeify;
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/utils/razorpay-utils.js
var require_razorpay_utils = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/utils/razorpay-utils.js"(exports, module) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var crypto3 = __require("crypto");
    function getDateInSecs(date9) {
      return +new Date(date9) / 1e3;
    }
    function normalizeDate(date9) {
      return isNumber(date9) ? date9 : getDateInSecs(date9);
    }
    function isNumber(num) {
      return !isNaN(Number(num));
    }
    function isNonNullObject(input) {
      return !!input && (typeof input === "undefined" ? "undefined" : _typeof(input)) === "object" && !Array.isArray(input);
    }
    function normalizeBoolean(bool) {
      if (bool === void 0) {
        return bool;
      }
      return bool ? 1 : 0;
    }
    function isDefined(value) {
      return typeof value !== "undefined";
    }
    function normalizeNotes() {
      var notes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var normalizedNotes = {};
      for (var key in notes) {
        normalizedNotes["notes[" + key + "]"] = notes[key];
      }
      return normalizedNotes;
    }
    function prettify(val) {
      return JSON.stringify(val, null, 2);
    }
    function getTestError(summary, expectedVal, gotVal) {
      return new Error("\n" + summary + "\n" + ("Expected(" + (typeof expectedVal === "undefined" ? "undefined" : _typeof(expectedVal)) + ")\n" + prettify(expectedVal) + "\n\n") + ("Got(" + (typeof gotVal === "undefined" ? "undefined" : _typeof(gotVal)) + ")\n" + prettify(gotVal)));
    }
    function validateWebhookSignature(body, signature, secret) {
      var crypto4 = __require("crypto");
      if (!isDefined(body) || !isDefined(signature) || !isDefined(secret)) {
        throw Error("Invalid Parameters: Please give request body,signature sent in X-Razorpay-Signature header and webhook secret from dashboard as parameters");
      }
      body = body.toString();
      var expectedSignature = crypto4.createHmac("sha256", secret).update(body).digest("hex");
      return expectedSignature === signature;
    }
    function validatePaymentVerification() {
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var signature = arguments[1];
      var secret = arguments[2];
      var paymentId = params.payment_id;
      if (!secret) {
        throw new Error("secret is mandatory");
      }
      if (isDefined(params.order_id) === true) {
        var orderId = params.order_id;
        var payload = orderId + "|" + paymentId;
      } else if (isDefined(params.subscription_id) === true) {
        var subscriptionId = params.subscription_id;
        var payload = paymentId + "|" + subscriptionId;
      } else if (isDefined(params.payment_link_id) === true) {
        var paymentLinkId = params.payment_link_id;
        var paymentLinkRefId = params.payment_link_reference_id;
        var paymentLinkStatus = params.payment_link_status;
        var payload = paymentLinkId + "|" + paymentLinkRefId + "|" + paymentLinkStatus + "|" + paymentId;
      } else {
        throw new Error("Either order_id or subscription_id is mandatory");
      }
      return validateWebhookSignature(payload, signature, secret);
    }
    function generateOnboardingSignature() {
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var secret = arguments[1];
      var jsonStr = JSON.stringify(params);
      return encrypt(jsonStr, secret);
    }
    function encrypt(dataToEncrypt, secret) {
      try {
        var keyBytes = Buffer.from(secret.slice(0, 16), "utf8");
        var iv = Buffer.alloc(12);
        keyBytes.copy(iv, 0, 0, 12);
        var cipher = crypto3.createCipheriv("aes-128-gcm", keyBytes, iv);
        var encryptedData = cipher.update(dataToEncrypt, "utf8");
        encryptedData = Buffer.concat([encryptedData, cipher.final()]);
        var authTag = cipher.getAuthTag();
        var finalData = Buffer.concat([encryptedData, authTag]);
        return finalData.toString("hex");
      } catch (err) {
        throw new Error("Encryption failed: " + err.message);
      }
    }
    function isValidUrl(url2) {
      try {
        new URL(url2);
        return true;
      } catch (error48) {
        return false;
      }
    }
    module.exports = {
      normalizeNotes,
      normalizeDate,
      normalizeBoolean,
      isNumber,
      getDateInSecs,
      prettify,
      isDefined,
      isNonNullObject,
      getTestError,
      validateWebhookSignature,
      validatePaymentVerification,
      isValidUrl,
      generateOnboardingSignature
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/api.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass = /* @__PURE__ */ (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios().default;
    var nodeify = require_nodeify();
    var _require = require_razorpay_utils();
    var isNonNullObject = _require.isNonNullObject;
    var allowedHeaders = {
      "X-Razorpay-Account": "",
      "Content-Type": "application/json"
    };
    function getValidHeaders(headers) {
      var result = {};
      if (!isNonNullObject(headers)) {
        return result;
      }
      return Object.keys(headers).reduce(function(result2, headerName) {
        if (allowedHeaders.hasOwnProperty(headerName)) {
          result2[headerName] = headers[headerName];
        }
        return result2;
      }, result);
    }
    function normalizeError(err) {
      throw {
        statusCode: err.response.status,
        error: err.response.data.error
      };
    }
    var API = (function() {
      function API2(options) {
        _classCallCheck(this, API2);
        this.version = "v1";
        this.rq = axios.create(this._createConfig(options));
      }
      _createClass(API2, [{
        key: "_createConfig",
        value: function _createConfig(options) {
          var config3 = {
            baseURL: options.hostUrl,
            headers: Object.assign({ "User-Agent": options.ua }, getValidHeaders(options.headers))
          };
          if (options.key_id && options.key_secret) {
            config3.auth = {
              username: options.key_id,
              password: options.key_secret
            };
          }
          if (options.oauthToken) {
            config3.headers = _extends({
              "Authorization": "Bearer " + options.oauthToken
            }, config3.headers);
          }
          return config3;
        }
      }, {
        key: "getEntityUrl",
        value: function getEntityUrl(params) {
          return params.hasOwnProperty("version") ? "/" + params.version + params.url : "/" + this.version + params.url;
        }
      }, {
        key: "get",
        value: function get(params, cb) {
          return nodeify(this.rq.get(this.getEntityUrl(params), {
            params: params.data
          }).catch(normalizeError), cb);
        }
      }, {
        key: "post",
        value: function post(params, cb) {
          return nodeify(this.rq.post(this.getEntityUrl(params), params.data).catch(normalizeError), cb);
        }
        // postFormData method for file uploads.
      }, {
        key: "postFormData",
        value: function postFormData(params, cb) {
          return nodeify(this.rq.post(this.getEntityUrl(params), params.formData, {
            "headers": {
              "Content-Type": "multipart/form-data"
            }
          }).catch(normalizeError), cb);
        }
      }, {
        key: "put",
        value: function put(params, cb) {
          return nodeify(this.rq.put(this.getEntityUrl(params), params.data).catch(normalizeError), cb);
        }
      }, {
        key: "patch",
        value: function patch(params, cb) {
          return nodeify(this.rq.patch(this.getEntityUrl(params), params.data).catch(normalizeError), cb);
        }
      }, {
        key: "delete",
        value: function _delete(params, cb) {
          return nodeify(this.rq.delete(this.getEntityUrl(params)).catch(normalizeError), cb);
        }
      }]);
      return API2;
    })();
    module.exports = API;
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/package.json
var require_package3 = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/package.json"(exports, module) {
    module.exports = {
      name: "razorpay",
      version: "2.9.6",
      description: "Official Node SDK for Razorpay API",
      main: "dist/razorpay",
      typings: "dist/razorpay",
      scripts: {
        prepublish: "npm test",
        clean: "rm -rf dist && mkdir dist",
        "cp-types": "mkdir dist/types && cp lib/types/* dist/types && cp lib/utils/*d.ts dist/utils",
        "cp-ts": "cp lib/razorpay.d.ts dist/ && cp lib/oAuthTokenClient.d.ts dist/ && npm run cp-types",
        "build:commonjs": "babel lib -d dist",
        build: "npm run clean && npm run build:commonjs && npm run cp-ts",
        debug: "npm run build && node-debug examples/index.js",
        test: "npm run build && mocha --recursive --require babel-register test/ && nyc --reporter=text mocha",
        coverage: "nyc report --reporter=text-lcov > coverage.lcov"
      },
      repository: {
        type: "git",
        url: "https://github.com/razorpay/razorpay-node.git"
      },
      keywords: [
        "razorpay",
        "payments",
        "node",
        "nodejs",
        "razorpay-node"
      ],
      files: [
        "dist"
      ],
      mocha: {
        recursive: true,
        "full-trace": true
      },
      license: "MIT",
      devDependencies: {
        "@types/node": "^20.12.12",
        "babel-cli": "^6.26.0",
        "babel-preset-env": "^1.7.0",
        "babel-preset-stage-0": "^6.24.0",
        "babel-register": "^6.26.0",
        chai: "^4.3.4",
        "deep-equal": "^2.0.5",
        mocha: "^9.0.0",
        nock: "^13.1.1",
        nyc: "^15.1.0",
        typescript: "^4.9.4"
      },
      dependencies: {
        axios: "^1.6.8"
      }
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/accounts.js
var require_accounts = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/accounts.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    module.exports = function(api) {
      var BASE_URL = "/accounts";
      return {
        create: function create(params, callback) {
          return api.post({
            version: "v2",
            url: "" + BASE_URL,
            data: params
          }, callback);
        },
        edit: function edit(accountId, params, callback) {
          return api.patch({
            version: "v2",
            url: BASE_URL + "/" + accountId,
            data: params
          }, callback);
        },
        fetch: function fetch2(accountId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId
          }, callback);
        },
        delete: function _delete(accountId, callback) {
          return api.delete({
            version: "v2",
            url: BASE_URL + "/" + accountId
          }, callback);
        },
        uploadAccountDoc: function uploadAccountDoc(accountId, params, callback) {
          var file2 = params.file, rest = _objectWithoutProperties(params, ["file"]);
          return api.postFormData({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/documents",
            formData: _extends({
              file: file2.value
            }, rest)
          }, callback);
        },
        fetchAccountDoc: function fetchAccountDoc(accountId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/documents"
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/stakeholders.js
var require_stakeholders = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/stakeholders.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    module.exports = function(api) {
      var BASE_URL = "/accounts";
      return {
        create: function create(accountId, params, callback) {
          return api.post({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/stakeholders",
            data: params
          }, callback);
        },
        edit: function edit(accountId, stakeholderId, params, callback) {
          return api.patch({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/stakeholders/" + stakeholderId,
            data: params
          }, callback);
        },
        fetch: function fetch2(accountId, stakeholderId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/stakeholders/" + stakeholderId
          }, callback);
        },
        all: function all(accountId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/stakeholders"
          }, callback);
        },
        uploadStakeholderDoc: function uploadStakeholderDoc(accountId, stakeholderId, params, callback) {
          var file2 = params.file, rest = _objectWithoutProperties(params, ["file"]);
          return api.postFormData({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/stakeholders/" + stakeholderId + "/documents",
            formData: _extends({
              file: file2.value
            }, rest)
          }, callback);
        },
        fetchStakeholderDoc: function fetchStakeholderDoc(accountId, stakeholderId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/stakeholders/" + stakeholderId + "/documents"
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/payments.js
var require_payments = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/payments.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    var ID_REQUIRED_MSG = "`payment_id` is mandatory";
    var BASE_URL = "/payments";
    module.exports = function(api) {
      return {
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip;
          var expand = void 0;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          if (params.hasOwnProperty("expand[]")) {
            expand = { "expand[]": params["expand[]"] };
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: "" + BASE_URL,
            data: {
              from,
              to,
              count,
              skip,
              expand
            }
          }, callback);
        },
        fetch: function fetch2(paymentId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var expand = void 0;
          if (!paymentId) {
            throw new Error("`payment_id` is mandatory");
          }
          if (params.hasOwnProperty("expand[]")) {
            expand = { "expand[]": params["expand[]"] };
          }
          return api.get({
            url: BASE_URL + "/" + paymentId,
            data: {
              expand
            }
          }, callback);
        },
        capture: function capture(paymentId, amount, currency, callback) {
          if (!paymentId) {
            throw new Error("`payment_id` is mandatory");
          }
          if (!amount) {
            throw new Error("`amount` is mandatory");
          }
          var payload = {
            amount
          };
          if (typeof currency === "function" && !callback) {
            callback = currency;
            currency = void 0;
          } else if (typeof currency === "string") {
            payload.currency = currency;
          }
          return api.post({
            url: BASE_URL + "/" + paymentId + "/capture",
            data: payload
          }, callback);
        },
        createPaymentJson: function createPaymentJson(params, callback) {
          var url2 = BASE_URL + "/create/json", rest = _objectWithoutProperties(params, []), data = Object.assign(rest);
          return api.post({
            url: url2,
            data
          }, callback);
        },
        createRecurringPayment: function createRecurringPayment(params, callback) {
          return api.post({
            url: BASE_URL + "/create/recurring",
            data: params
          }, callback);
        },
        edit: function edit(paymentId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!paymentId) {
            throw new Error("`payment_id` is mandatory");
          }
          return api.patch({
            url: BASE_URL + "/" + paymentId,
            data: params
          }, callback);
        },
        refund: function refund(paymentId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!paymentId) {
            throw new Error("`payment_id` is mandatory");
          }
          return api.post({
            url: BASE_URL + "/" + paymentId + "/refund",
            data: params
          }, callback);
        },
        fetchMultipleRefund: function fetchMultipleRefund(paymentId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL + "/" + paymentId + "/refunds";
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        fetchRefund: function fetchRefund(paymentId, refundId, callback) {
          if (!paymentId) {
            throw new Error("payment Id` is mandatory");
          }
          if (!refundId) {
            throw new Error("refund Id` is mandatory");
          }
          return api.get({
            url: BASE_URL + "/" + paymentId + "/refunds/" + refundId
          }, callback);
        },
        fetchTransfer: function fetchTransfer(paymentId, callback) {
          if (!paymentId) {
            throw new Error("payment Id` is mandatory");
          }
          return api.get({
            url: BASE_URL + "/" + paymentId + "/transfers"
          }, callback);
        },
        transfer: function transfer(paymentId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!paymentId) {
            throw new Error("`payment_id` is mandatory");
          }
          return api.post({
            url: BASE_URL + "/" + paymentId + "/transfers",
            data: params
          }, callback);
        },
        bankTransfer: function bankTransfer(paymentId, callback) {
          if (!paymentId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          return api.get({
            url: BASE_URL + "/" + paymentId + "/bank_transfer"
          }, callback);
        },
        fetchCardDetails: function fetchCardDetails(paymentId, callback) {
          if (!paymentId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          return api.get({
            url: BASE_URL + "/" + paymentId + "/card"
          }, callback);
        },
        fetchPaymentDowntime: function fetchPaymentDowntime(callback) {
          return api.get({
            url: BASE_URL + "/downtimes"
          }, callback);
        },
        fetchPaymentDowntimeById: function fetchPaymentDowntimeById(downtimeId, callback) {
          if (!downtimeId) {
            return Promise.reject("Downtime Id is mandatory");
          }
          return api.get({
            url: BASE_URL + "/downtimes/" + downtimeId
          }, callback);
        },
        otpGenerate: function otpGenerate(paymentId, callback) {
          if (!paymentId) {
            return Promise.reject("payment Id is mandatory");
          }
          return api.post({
            url: BASE_URL + "/" + paymentId + "/otp_generate"
          }, callback);
        },
        otpSubmit: function otpSubmit(paymentId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!paymentId) {
            return Promise.reject("payment Id is mandatory");
          }
          return api.post({
            url: BASE_URL + "/" + paymentId + "/otp/submit",
            data: params
          }, callback);
        },
        otpResend: function otpResend(paymentId, callback) {
          if (!paymentId) {
            return Promise.reject("payment Id is mandatory");
          }
          return api.post({
            url: BASE_URL + "/" + paymentId + "/otp/resend"
          }, callback);
        },
        createUpi: function createUpi() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL + "/create/upi", rest = _objectWithoutProperties(params, []), data = Object.assign(rest);
          return api.post({
            url: url2,
            data
          }, callback);
        },
        validateVpa: function validateVpa() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL + "/validate/vpa", rest = _objectWithoutProperties(params, []), data = Object.assign(rest);
          return api.post({
            url: url2,
            data
          }, callback);
        },
        fetchPaymentMethods: function fetchPaymentMethods(callback) {
          var url2 = "/methods";
          return api.get({
            url: url2
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/refunds.js
var require_refunds = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/refunds.js"(exports, module) {
    "use strict";
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    var normalizeNotes = _require.normalizeNotes;
    module.exports = function(api) {
      return {
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, payment_id = params.payment_id;
          var url2 = "/refunds";
          if (payment_id) {
            url2 = "/payments/" + payment_id + "/refunds";
          }
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: {
              from,
              to,
              count,
              skip
            }
          }, callback);
        },
        edit: function edit(refundId, params, callback) {
          if (!refundId) {
            throw new Error("refund Id is mandatory");
          }
          return api.patch({
            url: "/refunds/" + refundId,
            data: params
          }, callback);
        },
        fetch: function fetch2(refundId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var payment_id = params.payment_id;
          if (!refundId) {
            throw new Error("`refund_id` is mandatory");
          }
          var url2 = "/refunds/" + refundId;
          if (payment_id) {
            url2 = "/payments/" + payment_id + url2;
          }
          return api.get({
            url: url2
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/orders.js
var require_orders = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/orders.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function(api) {
      return {
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, authorized = params.authorized, receipt = params.receipt;
          var expand = void 0;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          if (params.hasOwnProperty("expand[]")) {
            expand = { "expand[]": params["expand[]"] };
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          authorized = authorized;
          return api.get({
            url: "/orders",
            data: {
              from,
              to,
              count,
              skip,
              authorized,
              receipt,
              expand
            }
          }, callback);
        },
        fetch: function fetch2(orderId, callback) {
          if (!orderId) {
            throw new Error("`order_id` is mandatory");
          }
          return api.get({
            url: "/orders/" + orderId
          }, callback);
        },
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var currency = params.currency, otherParams = _objectWithoutProperties(params, ["currency"]);
          currency = currency || "INR";
          var data = Object.assign(_extends({
            currency
          }, otherParams));
          return api.post({
            url: "/orders",
            data
          }, callback);
        },
        edit: function edit(orderId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!orderId) {
            throw new Error("`order_id` is mandatory");
          }
          return api.patch({
            url: "/orders/" + orderId,
            data: params
          }, callback);
        },
        fetchPayments: function fetchPayments(orderId, callback) {
          if (!orderId) {
            throw new Error("`order_id` is mandatory");
          }
          return api.get({
            url: "/orders/" + orderId + "/payments"
          }, callback);
        },
        fetchTransferOrder: function fetchTransferOrder(orderId, callback) {
          if (!orderId) {
            throw new Error("`order_id` is mandatory");
          }
          return api.get({
            url: "/orders/" + orderId + "/?expand[]=transfers&status"
          }, callback);
        },
        viewRtoReview: function viewRtoReview(orderId, callback) {
          return api.post({
            url: "/orders/" + orderId + "/rto_review"
          }, callback);
        },
        editFulfillment: function editFulfillment(orderId) {
          var param = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          return api.post({
            url: "/orders/" + orderId + "/fulfillment",
            data: param
          });
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/customers.js
var require_customers = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/customers.js"(exports, module) {
    "use strict";
    module.exports = function(api) {
      return {
        create: function create(params, callback) {
          return api.post({
            url: "/customers",
            data: params
          }, callback);
        },
        edit: function edit(customerId, params, callback) {
          return api.put({
            url: "/customers/" + customerId,
            data: params
          }, callback);
        },
        fetch: function fetch2(customerId, callback) {
          return api.get({
            url: "/customers/" + customerId
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var count = params.count, skip = params.skip;
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: "/customers",
            data: {
              count,
              skip
            }
          }, callback);
        },
        fetchTokens: function fetchTokens(customerId, callback) {
          return api.get({
            url: "/customers/" + customerId + "/tokens"
          }, callback);
        },
        fetchToken: function fetchToken(customerId, tokenId, callback) {
          return api.get({
            url: "/customers/" + customerId + "/tokens/" + tokenId
          }, callback);
        },
        deleteToken: function deleteToken(customerId, tokenId, callback) {
          return api.delete({
            url: "/customers/" + customerId + "/tokens/" + tokenId
          }, callback);
        },
        addBankAccount: function addBankAccount(customerId, params, callback) {
          return api.post({
            url: "/customers/" + customerId + "/bank_account",
            data: params
          }, callback);
        },
        deleteBankAccount: function deleteBankAccount(customerId, bankId, callback) {
          return api.delete({
            url: "/customers/" + customerId + "/bank_account/" + bankId
          }, callback);
        },
        requestEligibilityCheck: function requestEligibilityCheck(params, callback) {
          return api.post({
            url: "/customers/eligibility",
            data: params
          }, callback);
        },
        fetchEligibility: function fetchEligibility(eligibilityId, callback) {
          return api.get({
            url: "/customers/eligibility/" + eligibilityId
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/transfers.js
var require_transfers = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/transfers.js"(exports, module) {
    "use strict";
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function(api) {
      return {
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, payment_id = params.payment_id, recipient_settlement_id = params.recipient_settlement_id;
          var url2 = "/transfers";
          if (payment_id) {
            url2 = "/payments/" + payment_id + "/transfers";
          }
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: {
              from,
              to,
              count,
              skip,
              recipient_settlement_id
            }
          }, callback);
        },
        fetch: function fetch2(transferId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var payment_id = params.payment_id;
          if (!transferId) {
            throw new Error("`transfer_id` is mandatory");
          }
          var url2 = "/transfers/" + transferId;
          return api.get({
            url: url2
          }, callback);
        },
        create: function create(params, callback) {
          return api.post({
            url: "/transfers",
            data: params
          }, callback);
        },
        edit: function edit(transferId, params, callback) {
          return api.patch({
            url: "/transfers/" + transferId,
            data: params
          }, callback);
        },
        reverse: function reverse(transferId, params, callback) {
          if (!transferId) {
            throw new Error("`transfer_id` is mandatory");
          }
          var url2 = "/transfers/" + transferId + "/reversals";
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        fetchSettlements: function fetchSettlements(callback) {
          return api.get({
            url: "/transfers?expand[]=recipient_settlement"
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/tokens.js
var require_tokens2 = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/tokens.js"(exports, module) {
    "use strict";
    var _require = require_razorpay_utils();
    var normalizeNotes = _require.normalizeNotes;
    module.exports = function(api) {
      var BASE_URL = "/tokens";
      return {
        create: function create(params, callback) {
          return api.post({
            url: "" + BASE_URL,
            data: params
          }, callback);
        },
        fetch: function fetch2(params, callback) {
          return api.post({
            url: BASE_URL + "/fetch",
            data: params
          }, callback);
        },
        delete: function _delete(params, callback) {
          return api.post({
            url: BASE_URL + "/delete",
            data: params
          }, callback);
        },
        processPaymentOnAlternatePAorPG: function processPaymentOnAlternatePAorPG(params, callback) {
          return api.post({
            url: BASE_URL + "/service_provider_tokens/token_transactional_data",
            data: params
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/virtualAccounts.js
var require_virtualAccounts = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/virtualAccounts.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    var normalizeNotes = _require.normalizeNotes;
    var BASE_URL = "/virtual_accounts";
    var ID_REQUIRED_MSG = "`virtual_account_id` is mandatory";
    module.exports = function(api) {
      return {
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, otherParams = _objectWithoutProperties(params, ["from", "to", "count", "skip"]);
          var url2 = BASE_URL;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: _extends({
              from,
              to,
              count,
              skip
            }, otherParams)
          }, callback);
        },
        fetch: function fetch2(virtualAccountId, callback) {
          if (!virtualAccountId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          var url2 = BASE_URL + "/" + virtualAccountId;
          return api.get({
            url: url2
          }, callback);
        },
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          return api.post({
            url: BASE_URL,
            data: params
          }, callback);
        },
        close: function close(virtualAccountId, callback) {
          if (!virtualAccountId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          return api.post({
            url: BASE_URL + "/" + virtualAccountId + "/close"
          }, callback);
        },
        fetchPayments: function fetchPayments(virtualAccountId, callback) {
          if (!virtualAccountId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          var url2 = BASE_URL + "/" + virtualAccountId + "/payments";
          return api.get({
            url: url2
          }, callback);
        },
        addReceiver: function addReceiver(virtualAccountId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!virtualAccountId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          return api.post({
            url: BASE_URL + "/" + virtualAccountId + "/receivers",
            data: params
          }, callback);
        },
        allowedPayer: function allowedPayer(virtualAccountId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!virtualAccountId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          return api.post({
            url: BASE_URL + "/" + virtualAccountId + "/allowed_payers",
            data: params
          }, callback);
        },
        deleteAllowedPayer: function deleteAllowedPayer(virtualAccountId, allowedPayerId, callback) {
          if (!virtualAccountId) {
            return Promise.reject(ID_REQUIRED_MSG);
          }
          if (!allowedPayerId) {
            return Promise.reject("allowed payer id is mandatory");
          }
          return api.delete({
            url: BASE_URL + "/" + virtualAccountId + "/allowed_payers/" + allowedPayerId
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/invoices.js
var require_invoices = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/invoices.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function invoicesApi(api) {
      var BASE_URL = "/invoices", MISSING_ID_ERROR = "Invoice ID is mandatory";
      return {
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL;
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        edit: function edit(invoiceId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var url2 = BASE_URL + "/" + invoiceId;
          if (!invoiceId) {
            return Promise.reject("Invoice ID is mandatory");
          }
          return api.patch({
            url: url2,
            data: params
          }, callback);
        },
        issue: function issue2(invoiceId, callback) {
          if (!invoiceId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + invoiceId + "/issue";
          return api.post({
            url: url2
          }, callback);
        },
        delete: function _delete(invoiceId, callback) {
          if (!invoiceId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + invoiceId;
          return api.delete({
            url: url2
          }, callback);
        },
        cancel: function cancel(invoiceId, callback) {
          if (!invoiceId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + invoiceId + "/cancel";
          return api.post({
            url: url2
          }, callback);
        },
        fetch: function fetch2(invoiceId, callback) {
          if (!invoiceId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + invoiceId;
          return api.get({
            url: url2
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        notifyBy: function notifyBy(invoiceId, medium, callback) {
          if (!invoiceId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          if (!medium) {
            return Promise.reject("`medium` is required");
          }
          var url2 = BASE_URL + "/" + invoiceId + "/notify_by/" + medium;
          return api.post({
            url: url2
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/iins.js
var require_iins = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/iins.js"(exports, module) {
    "use strict";
    module.exports = function(api) {
      var BASE_URL = "/iins";
      return {
        fetch: function fetch2(tokenIin, callback) {
          return api.get({
            url: BASE_URL + "/" + tokenIin
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          return api.get({
            url: BASE_URL + "/list",
            data: params
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/paymentLink.js
var require_paymentLink = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/paymentLink.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function paymentLinkApi(api) {
      var BASE_URL = "/payment_links", MISSING_ID_ERROR = "Payment Link ID is mandatory";
      return {
        create: function create(params, callback) {
          var url2 = BASE_URL;
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        cancel: function cancel(paymentLinkId, callback) {
          if (!paymentLinkId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + paymentLinkId + "/cancel";
          return api.post({
            url: url2
          }, callback);
        },
        fetch: function fetch2(paymentLinkId, callback) {
          if (!paymentLinkId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + paymentLinkId;
          return api.get({
            url: url2
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        edit: function edit(paymentLinkId, params, callback) {
          return api.patch({
            url: BASE_URL + "/" + paymentLinkId,
            data: params
          }, callback);
        },
        notifyBy: function notifyBy(paymentLinkId, medium, callback) {
          if (!paymentLinkId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          if (!medium) {
            return Promise.reject("`medium` is required");
          }
          var url2 = BASE_URL + "/" + paymentLinkId + "/notify_by/" + medium;
          return api.post({
            url: url2
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/plans.js
var require_plans = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/plans.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function plansApi(api) {
      var BASE_URL = "/plans", MISSING_ID_ERROR = "Plan ID is mandatory";
      return {
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL;
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        fetch: function fetch2(planId, callback) {
          if (!planId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + planId;
          return api.get({ url: url2 }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/products.js
var require_products = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/products.js"(exports, module) {
    "use strict";
    module.exports = function(api) {
      var BASE_URL = "/accounts";
      return {
        requestProductConfiguration: function requestProductConfiguration(accountId, params, callback) {
          return api.post({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/products",
            data: params
          }, callback);
        },
        edit: function edit(accountId, productId, params, callback) {
          return api.patch({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/products/" + productId,
            data: params
          }, callback);
        },
        fetch: function fetch2(accountId, productId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/products/" + productId
          }, callback);
        },
        fetchTnc: function fetchTnc(productName, callback) {
          return api.get({
            version: "v2",
            url: "/products/" + productName + "/tnc"
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/subscriptions.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function subscriptionsApi(api) {
      var BASE_URL = "/subscriptions", MISSING_ID_ERROR = "Subscription ID is mandatory";
      return {
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL;
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        fetch: function fetch2(subscriptionId, callback) {
          if (!subscriptionId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + subscriptionId;
          return api.get({ url: url2 }, callback);
        },
        update: function update(subscriptionId, params, callback) {
          var url2 = BASE_URL + "/" + subscriptionId;
          if (!subscriptionId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          return api.patch({
            url: url2,
            data: params
          }, callback);
        },
        pendingUpdate: function pendingUpdate(subscriptionId, callback) {
          var url2 = BASE_URL + "/" + subscriptionId + "/retrieve_scheduled_changes";
          if (!subscriptionId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          return api.get({ url: url2 }, callback);
        },
        cancelScheduledChanges: function cancelScheduledChanges(subscriptionId, callback) {
          var url2 = BASE_URL + "/" + subscriptionId + "/cancel_scheduled_changes";
          if (!subscriptionId) {
            return Promise.reject("Subscription Id is mandatory");
          }
          return api.post({
            url: url2
          }, callback);
        },
        pause: function pause(subscriptionId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var url2 = BASE_URL + "/" + subscriptionId + "/pause";
          if (!subscriptionId) {
            return Promise.reject("Subscription Id is mandatory");
          }
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        resume: function resume(subscriptionId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var url2 = BASE_URL + "/" + subscriptionId + "/resume";
          if (!subscriptionId) {
            return Promise.reject("Subscription Id is mandatory");
          }
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        deleteOffer: function deleteOffer(subscriptionId, offerId, callback) {
          var url2 = BASE_URL + "/" + subscriptionId + "/" + offerId;
          if (!subscriptionId) {
            return Promise.reject("Subscription Id is mandatory");
          }
          return api.delete({
            url: url2
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        cancel: function cancel(subscriptionId) {
          var cancelAtCycleEnd = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var callback = arguments[2];
          var url2 = BASE_URL + "/" + subscriptionId + "/cancel";
          if (!subscriptionId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          return api.post(_extends({
            url: url2
          }, cancelAtCycleEnd && { data: { cancel_at_cycle_end: 1 } }), callback);
        },
        createAddon: function createAddon(subscriptionId, params, callback) {
          var url2 = BASE_URL + "/" + subscriptionId + "/addons";
          if (!subscriptionId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          return api.post({
            url: url2,
            data: _extends({}, params)
          }, callback);
        },
        createRegistrationLink: function createRegistrationLink() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          return api.post({
            url: "/subscription_registration/auth_links",
            data: params
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/addons.js
var require_addons = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/addons.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function(api) {
      var BASE_URL = "/addons", MISSING_ID_ERROR = "Addon ID is mandatory";
      return {
        fetch: function fetch2(addonId, callback) {
          if (!addonId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + addonId;
          return api.get({
            url: url2
          }, callback);
        },
        delete: function _delete(addonId, callback) {
          if (!addonId) {
            return Promise.reject(MISSING_ID_ERROR);
          }
          var url2 = BASE_URL + "/" + addonId;
          return api.delete({
            url: url2
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/settlements.js
var require_settlements = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/settlements.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    module.exports = function(api) {
      var BASE_URL = "/settlements";
      return {
        createOndemandSettlement: function createOndemandSettlement() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL + "/ondemand";
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        fetch: function fetch2(settlementId, callback) {
          if (!settlementId) {
            return Promise.reject("settlement Id is mandatroy");
          }
          return api.get({
            url: BASE_URL + "/" + settlementId
          }, callback);
        },
        fetchOndemandSettlementById: function fetchOndemandSettlementById(settlementId) {
          var param = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var expand = void 0;
          if (!settlementId) {
            return Promise.reject("settlment Id is mandatroy");
          }
          if (param.hasOwnProperty("expand[]")) {
            expand = { "expand[]": param["expand[]"] };
          }
          return api.get({
            url: BASE_URL + "/ondemand/" + settlementId,
            data: {
              expand
            }
          }, callback);
        },
        fetchAllOndemandSettlement: function fetchAllOndemandSettlement() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var expand = void 0;
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL + "/ondemand";
          if (params.hasOwnProperty("expand[]")) {
            expand = { "expand[]": params["expand[]"] };
          }
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip,
              expand
            })
          }, callback);
        },
        reports: function reports() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var day = params.day, count = params.count, skip = params.skip, url2 = BASE_URL + "/recon/combined";
          return api.get({
            url: url2,
            data: _extends({}, params, {
              day,
              count,
              skip
            })
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/qrCode.js
var require_qrCode = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/qrCode.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    module.exports = function(api) {
      var BASE_URL = "/payments/qr_codes";
      return {
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var url2 = BASE_URL;
          return api.post({
            url: url2,
            data: params
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL;
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        fetchAllPayments: function fetchAllPayments(qrCodeId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, url2 = BASE_URL + "/" + qrCodeId + "/payments";
          return api.get({
            url: url2,
            data: _extends({}, params, {
              from,
              to,
              count,
              skip
            })
          }, callback);
        },
        fetch: function fetch2(qrCodeId, callback) {
          if (!qrCodeId) {
            return Promise.reject("qrCode Id is mandatroy");
          }
          return api.get({
            url: BASE_URL + "/" + qrCodeId
          }, callback);
        },
        close: function close(qrCodeId, callback) {
          if (!qrCodeId) {
            return Promise.reject("qrCode Id is mandatroy");
          }
          var url2 = BASE_URL + "/" + qrCodeId + "/close";
          return api.post({
            url: url2
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/fundAccount.js
var require_fundAccount = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/fundAccount.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    module.exports = function(api) {
      return {
        create: function create(params, callback) {
          return api.post({
            url: "/fund_accounts",
            data: _extends({}, params)
          }, callback);
        },
        fetch: function fetch2(customerId, callback) {
          if (!customerId) {
            return Promise.reject("Customer Id is mandatroy");
          }
          return api.get({
            url: "/fund_accounts?customer_id=" + customerId
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/items.js
var require_items2 = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/items.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function(api) {
      return {
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var from = params.from, to = params.to, count = params.count, skip = params.skip, authorized = params.authorized, receipt = params.receipt;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: "/items",
            data: {
              from,
              to,
              count,
              skip,
              authorized,
              receipt
            }
          }, callback);
        },
        fetch: function fetch2(itemId, callback) {
          if (!itemId) {
            throw new Error("`item_id` is mandatory");
          }
          return api.get({
            url: "/items/" + itemId
          }, callback);
        },
        create: function create() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var amount = params.amount, currency = params.currency, rest = _objectWithoutProperties(params, ["amount", "currency"]);
          currency = currency || "INR";
          if (!amount) {
            throw new Error("`amount` is mandatory");
          }
          var data = Object.assign(_extends({
            currency,
            amount
          }, rest));
          return api.post({
            url: "/items",
            data
          }, callback);
        },
        edit: function edit(itemId) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var callback = arguments[2];
          if (!itemId) {
            throw new Error("`item_id` is mandatory");
          }
          var url2 = "/items/" + itemId;
          return api.patch({
            url: url2,
            data: params
          }, callback);
        },
        delete: function _delete(itemId, callback) {
          if (!itemId) {
            throw new Error("`item_id` is mandatory");
          }
          return api.delete({
            url: "/items/" + itemId
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/cards.js
var require_cards = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/cards.js"(exports, module) {
    "use strict";
    module.exports = function(api) {
      return {
        fetch: function fetch2(itemId, callback) {
          if (!itemId) {
            throw new Error("`card_id` is mandatory");
          }
          return api.get({
            url: "/cards/" + itemId
          }, callback);
        },
        requestCardReference: function requestCardReference(params, callback) {
          return api.post({
            url: "/cards/fingerprints",
            data: params
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/webhooks.js
var require_webhooks = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/webhooks.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _require = require_razorpay_utils();
    var normalizeDate = _require.normalizeDate;
    module.exports = function(api) {
      var BASE_URL = "/accounts";
      return {
        create: function create(params, accountId, callback) {
          var payload = { url: "/webhooks", data: params };
          if (accountId) {
            payload = {
              version: "v2",
              url: BASE_URL + "/" + accountId + "/webhooks",
              data: params
            };
          }
          return api.post(payload, callback);
        },
        edit: function edit(params, webhookId, accountId, callback) {
          if (accountId && webhookId) {
            return api.patch({
              version: "v2",
              url: BASE_URL + "/" + accountId + "/webhooks/" + webhookId,
              data: params
            }, callback);
          }
          return api.put({
            url: "/webhooks/" + webhookId,
            data: params
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var accountId = arguments[1];
          var callback = arguments[2];
          var from = params.from, to = params.to, count = params.count, skip = params.skip;
          if (from) {
            from = normalizeDate(from);
          }
          if (to) {
            to = normalizeDate(to);
          }
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          var data = _extends({}, params, { from, to, count, skip });
          if (accountId) {
            return api.get({
              version: "v2",
              url: BASE_URL + "/" + accountId + "/webhooks/",
              data
            }, callback);
          }
          return api.get({
            url: "/webhooks",
            data
          }, callback);
        },
        fetch: function fetch2(webhookId, accountId, callback) {
          return api.get({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/webhooks/" + webhookId
          }, callback);
        },
        delete: function _delete(webhookId, accountId, callback) {
          return api.delete({
            version: "v2",
            url: BASE_URL + "/" + accountId + "/webhooks/" + webhookId
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/documents.js
var require_documents = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/documents.js"(exports, module) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    module.exports = function(api) {
      var BASE_URL = "/documents";
      return {
        create: function create(params, callback) {
          var file2 = params.file, rest = _objectWithoutProperties(params, ["file"]);
          return api.postFormData({
            url: "" + BASE_URL,
            formData: _extends({
              file: file2.value
            }, rest)
          }, callback);
        },
        fetch: function fetch2(documentId, callback) {
          return api.get({
            url: BASE_URL + "/" + documentId
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/disputes.js
var require_disputes = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/resources/disputes.js"(exports, module) {
    "use strict";
    module.exports = function(api) {
      var BASE_URL = "/disputes";
      return {
        fetch: function fetch2(disputeId, callback) {
          return api.get({
            url: BASE_URL + "/" + disputeId
          }, callback);
        },
        all: function all() {
          var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments[1];
          var count = params.count, skip = params.skip;
          count = Number(count) || 10;
          skip = Number(skip) || 0;
          return api.get({
            url: "" + BASE_URL,
            data: {
              count,
              skip
            }
          }, callback);
        },
        accept: function accept(disputeId, callback) {
          return api.post({
            url: BASE_URL + "/" + disputeId + "/accept"
          }, callback);
        },
        contest: function contest(disputeId, param, callback) {
          return api.patch({
            url: BASE_URL + "/" + disputeId + "/contest",
            data: param
          }, callback);
        }
      };
    };
  }
});

// node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/razorpay.js
var require_razorpay = __commonJS({
  "node_modules/.pnpm/razorpay@2.9.6/node_modules/razorpay/dist/razorpay.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var API = require_api();
    var pkg = require_package3();
    var _require = require_razorpay_utils();
    var _validateWebhookSignature = _require.validateWebhookSignature;
    var Razorpay2 = (function() {
      _createClass(Razorpay3, null, [{
        key: "validateWebhookSignature",
        value: function validateWebhookSignature() {
          return _validateWebhookSignature.apply(void 0, arguments);
        }
      }]);
      function Razorpay3() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Razorpay3);
        var key_id = options.key_id, key_secret = options.key_secret, oauthToken = options.oauthToken, headers = options.headers;
        if (!key_id && !oauthToken) {
          throw new Error("`key_id` or `oauthToken` is mandatory");
        }
        this.key_id = key_id;
        this.key_secret = key_secret;
        this.oauthToken = oauthToken;
        this.api = new API({
          hostUrl: "https://api.razorpay.com",
          ua: "razorpay-node@" + Razorpay3.VERSION,
          key_id,
          key_secret,
          headers,
          oauthToken
        });
        this.addResources();
      }
      _createClass(Razorpay3, [{
        key: "addResources",
        value: function addResources() {
          Object.assign(this, {
            accounts: require_accounts()(this.api),
            stakeholders: require_stakeholders()(this.api),
            payments: require_payments()(this.api),
            refunds: require_refunds()(this.api),
            orders: require_orders()(this.api),
            customers: require_customers()(this.api),
            transfers: require_transfers()(this.api),
            tokens: require_tokens2()(this.api),
            virtualAccounts: require_virtualAccounts()(this.api),
            invoices: require_invoices()(this.api),
            iins: require_iins()(this.api),
            paymentLink: require_paymentLink()(this.api),
            plans: require_plans()(this.api),
            products: require_products()(this.api),
            subscriptions: require_subscriptions()(this.api),
            addons: require_addons()(this.api),
            settlements: require_settlements()(this.api),
            qrCode: require_qrCode()(this.api),
            fundAccount: require_fundAccount()(this.api),
            items: require_items2()(this.api),
            cards: require_cards()(this.api),
            webhooks: require_webhooks()(this.api),
            documents: require_documents()(this.api),
            disputes: require_disputes()(this.api)
          });
        }
      }]);
      return Razorpay3;
    })();
    Razorpay2.VERSION = pkg.version;
    module.exports = Razorpay2;
  }
});

// node_modules/.pnpm/standardwebhooks@1.0.0/node_modules/standardwebhooks/dist/timing_safe_equal.js
var require_timing_safe_equal = __commonJS({
  "node_modules/.pnpm/standardwebhooks@1.0.0/node_modules/standardwebhooks/dist/timing_safe_equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timingSafeEqual = void 0;
    function assert2(expr, msg = "") {
      if (!expr) {
        throw new Error(msg);
      }
    }
    function timingSafeEqual(a2, b2) {
      if (a2.byteLength !== b2.byteLength) {
        return false;
      }
      if (!(a2 instanceof DataView)) {
        a2 = new DataView(ArrayBuffer.isView(a2) ? a2.buffer : a2);
      }
      if (!(b2 instanceof DataView)) {
        b2 = new DataView(ArrayBuffer.isView(b2) ? b2.buffer : b2);
      }
      assert2(a2 instanceof DataView);
      assert2(b2 instanceof DataView);
      const length = a2.byteLength;
      let out = 0;
      let i = -1;
      while (++i < length) {
        out |= a2.getUint8(i) ^ b2.getUint8(i);
      }
      return out === 0;
    }
    exports.timingSafeEqual = timingSafeEqual;
  }
});

// node_modules/.pnpm/@stablelib+base64@1.0.1/node_modules/@stablelib/base64/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@stablelib+base64@1.0.1/node_modules/@stablelib/base64/lib/base64.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3) if (b3.hasOwnProperty(p2)) d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var INVALID_BYTE = 256;
    var Coder = (
      /** @class */
      (function() {
        function Coder2(_paddingCharacter) {
          if (_paddingCharacter === void 0) {
            _paddingCharacter = "=";
          }
          this._paddingCharacter = _paddingCharacter;
        }
        Coder2.prototype.encodedLength = function(length) {
          if (!this._paddingCharacter) {
            return (length * 8 + 5) / 6 | 0;
          }
          return (length + 2) / 3 * 4 | 0;
        };
        Coder2.prototype.encode = function(data) {
          var out = "";
          var i = 0;
          for (; i < data.length - 2; i += 3) {
            var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
            out += this._encodeByte(c >>> 3 * 6 & 63);
            out += this._encodeByte(c >>> 2 * 6 & 63);
            out += this._encodeByte(c >>> 1 * 6 & 63);
            out += this._encodeByte(c >>> 0 * 6 & 63);
          }
          var left = data.length - i;
          if (left > 0) {
            var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);
            out += this._encodeByte(c >>> 3 * 6 & 63);
            out += this._encodeByte(c >>> 2 * 6 & 63);
            if (left === 2) {
              out += this._encodeByte(c >>> 1 * 6 & 63);
            } else {
              out += this._paddingCharacter || "";
            }
            out += this._paddingCharacter || "";
          }
          return out;
        };
        Coder2.prototype.maxDecodedLength = function(length) {
          if (!this._paddingCharacter) {
            return (length * 6 + 7) / 8 | 0;
          }
          return length / 4 * 3 | 0;
        };
        Coder2.prototype.decodedLength = function(s) {
          return this.maxDecodedLength(s.length - this._getPaddingLength(s));
        };
        Coder2.prototype.decode = function(s) {
          if (s.length === 0) {
            return new Uint8Array(0);
          }
          var paddingLength = this._getPaddingLength(s);
          var length = s.length - paddingLength;
          var out = new Uint8Array(this.maxDecodedLength(length));
          var op = 0;
          var i = 0;
          var haveBad = 0;
          var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
          for (; i < length - 4; i += 4) {
            v0 = this._decodeChar(s.charCodeAt(i + 0));
            v1 = this._decodeChar(s.charCodeAt(i + 1));
            v2 = this._decodeChar(s.charCodeAt(i + 2));
            v3 = this._decodeChar(s.charCodeAt(i + 3));
            out[op++] = v0 << 2 | v1 >>> 4;
            out[op++] = v1 << 4 | v2 >>> 2;
            out[op++] = v2 << 6 | v3;
            haveBad |= v0 & INVALID_BYTE;
            haveBad |= v1 & INVALID_BYTE;
            haveBad |= v2 & INVALID_BYTE;
            haveBad |= v3 & INVALID_BYTE;
          }
          if (i < length - 1) {
            v0 = this._decodeChar(s.charCodeAt(i));
            v1 = this._decodeChar(s.charCodeAt(i + 1));
            out[op++] = v0 << 2 | v1 >>> 4;
            haveBad |= v0 & INVALID_BYTE;
            haveBad |= v1 & INVALID_BYTE;
          }
          if (i < length - 2) {
            v2 = this._decodeChar(s.charCodeAt(i + 2));
            out[op++] = v1 << 4 | v2 >>> 2;
            haveBad |= v2 & INVALID_BYTE;
          }
          if (i < length - 3) {
            v3 = this._decodeChar(s.charCodeAt(i + 3));
            out[op++] = v2 << 6 | v3;
            haveBad |= v3 & INVALID_BYTE;
          }
          if (haveBad !== 0) {
            throw new Error("Base64Coder: incorrect characters for decoding");
          }
          return out;
        };
        Coder2.prototype._encodeByte = function(b2) {
          var result = b2;
          result += 65;
          result += 25 - b2 >>> 8 & 0 - 65 - 26 + 97;
          result += 51 - b2 >>> 8 & 26 - 97 - 52 + 48;
          result += 61 - b2 >>> 8 & 52 - 48 - 62 + 43;
          result += 62 - b2 >>> 8 & 62 - 43 - 63 + 47;
          return String.fromCharCode(result);
        };
        Coder2.prototype._decodeChar = function(c) {
          var result = INVALID_BYTE;
          result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
          result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
          result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
          result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
          result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
          return result;
        };
        Coder2.prototype._getPaddingLength = function(s) {
          var paddingLength = 0;
          if (this._paddingCharacter) {
            for (var i = s.length - 1; i >= 0; i--) {
              if (s[i] !== this._paddingCharacter) {
                break;
              }
              paddingLength++;
            }
            if (s.length < 4 || paddingLength > 2) {
              throw new Error("Base64Coder: incorrect padding");
            }
          }
          return paddingLength;
        };
        return Coder2;
      })()
    );
    exports.Coder = Coder;
    var stdCoder = new Coder();
    function encode3(data) {
      return stdCoder.encode(data);
    }
    exports.encode = encode3;
    function decode3(s) {
      return stdCoder.decode(s);
    }
    exports.decode = decode3;
    var URLSafeCoder = (
      /** @class */
      (function(_super) {
        __extends(URLSafeCoder2, _super);
        function URLSafeCoder2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        URLSafeCoder2.prototype._encodeByte = function(b2) {
          var result = b2;
          result += 65;
          result += 25 - b2 >>> 8 & 0 - 65 - 26 + 97;
          result += 51 - b2 >>> 8 & 26 - 97 - 52 + 48;
          result += 61 - b2 >>> 8 & 52 - 48 - 62 + 45;
          result += 62 - b2 >>> 8 & 62 - 45 - 63 + 95;
          return String.fromCharCode(result);
        };
        URLSafeCoder2.prototype._decodeChar = function(c) {
          var result = INVALID_BYTE;
          result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
          result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
          result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
          result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
          result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
          return result;
        };
        return URLSafeCoder2;
      })(Coder)
    );
    exports.URLSafeCoder = URLSafeCoder;
    var urlSafeCoder = new URLSafeCoder();
    function encodeURLSafe(data) {
      return urlSafeCoder.encode(data);
    }
    exports.encodeURLSafe = encodeURLSafe;
    function decodeURLSafe(s) {
      return urlSafeCoder.decode(s);
    }
    exports.decodeURLSafe = decodeURLSafe;
    exports.encodedLength = function(length) {
      return stdCoder.encodedLength(length);
    };
    exports.maxDecodedLength = function(length) {
      return stdCoder.maxDecodedLength(length);
    };
    exports.decodedLength = function(s) {
      return stdCoder.decodedLength(s);
    };
  }
});

// node_modules/.pnpm/fast-sha256@1.3.0/node_modules/fast-sha256/sha256.js
var require_sha256 = __commonJS({
  "node_modules/.pnpm/fast-sha256@1.3.0/node_modules/fast-sha256/sha256.js"(exports, module) {
    (function(root, factory) {
      var exports2 = {};
      factory(exports2);
      var sha256 = exports2["default"];
      for (var k in exports2) {
        sha256[k] = exports2[k];
      }
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = sha256;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return sha256;
        });
      } else {
        root.sha256 = sha256;
      }
    })(exports, function(exports2) {
      "use strict";
      exports2.__esModule = true;
      exports2.digestLength = 32;
      exports2.blockSize = 64;
      var K = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      function hashBlocks(w, v2, p2, pos, len) {
        var a2, b2, c, d2, e, f, g, h, u, i, j, t1, t2;
        while (len >= 64) {
          a2 = v2[0];
          b2 = v2[1];
          c = v2[2];
          d2 = v2[3];
          e = v2[4];
          f = v2[5];
          g = v2[6];
          h = v2[7];
          for (i = 0; i < 16; i++) {
            j = pos + i * 4;
            w[i] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
          }
          for (i = 16; i < 64; i++) {
            u = w[i - 2];
            t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i - 15];
            t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
          }
          for (i = 0; i < 64; i++) {
            t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
            t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c ^ b2 & c) | 0;
            h = g;
            g = f;
            f = e;
            e = d2 + t1 | 0;
            d2 = c;
            c = b2;
            b2 = a2;
            a2 = t1 + t2 | 0;
          }
          v2[0] += a2;
          v2[1] += b2;
          v2[2] += c;
          v2[3] += d2;
          v2[4] += e;
          v2[5] += f;
          v2[6] += g;
          v2[7] += h;
          pos += 64;
          len -= 64;
        }
        return pos;
      }
      var Hash = (
        /** @class */
        (function() {
          function Hash2() {
            this.digestLength = exports2.digestLength;
            this.blockSize = exports2.blockSize;
            this.state = new Int32Array(8);
            this.temp = new Int32Array(64);
            this.buffer = new Uint8Array(128);
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
            this.reset();
          }
          Hash2.prototype.reset = function() {
            this.state[0] = 1779033703;
            this.state[1] = 3144134277;
            this.state[2] = 1013904242;
            this.state[3] = 2773480762;
            this.state[4] = 1359893119;
            this.state[5] = 2600822924;
            this.state[6] = 528734635;
            this.state[7] = 1541459225;
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
            return this;
          };
          Hash2.prototype.clean = function() {
            for (var i = 0; i < this.buffer.length; i++) {
              this.buffer[i] = 0;
            }
            for (var i = 0; i < this.temp.length; i++) {
              this.temp[i] = 0;
            }
            this.reset();
          };
          Hash2.prototype.update = function(data, dataLength) {
            if (dataLength === void 0) {
              dataLength = data.length;
            }
            if (this.finished) {
              throw new Error("SHA256: can't update because hash was finished.");
            }
            var dataPos = 0;
            this.bytesHashed += dataLength;
            if (this.bufferLength > 0) {
              while (this.bufferLength < 64 && dataLength > 0) {
                this.buffer[this.bufferLength++] = data[dataPos++];
                dataLength--;
              }
              if (this.bufferLength === 64) {
                hashBlocks(this.temp, this.state, this.buffer, 0, 64);
                this.bufferLength = 0;
              }
            }
            if (dataLength >= 64) {
              dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
              dataLength %= 64;
            }
            while (dataLength > 0) {
              this.buffer[this.bufferLength++] = data[dataPos++];
              dataLength--;
            }
            return this;
          };
          Hash2.prototype.finish = function(out) {
            if (!this.finished) {
              var bytesHashed = this.bytesHashed;
              var left = this.bufferLength;
              var bitLenHi = bytesHashed / 536870912 | 0;
              var bitLenLo = bytesHashed << 3;
              var padLength = bytesHashed % 64 < 56 ? 64 : 128;
              this.buffer[left] = 128;
              for (var i = left + 1; i < padLength - 8; i++) {
                this.buffer[i] = 0;
              }
              this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
              this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
              this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
              this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
              this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
              this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
              this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
              this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
              hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
              this.finished = true;
            }
            for (var i = 0; i < 8; i++) {
              out[i * 4 + 0] = this.state[i] >>> 24 & 255;
              out[i * 4 + 1] = this.state[i] >>> 16 & 255;
              out[i * 4 + 2] = this.state[i] >>> 8 & 255;
              out[i * 4 + 3] = this.state[i] >>> 0 & 255;
            }
            return this;
          };
          Hash2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          Hash2.prototype._saveState = function(out) {
            for (var i = 0; i < this.state.length; i++) {
              out[i] = this.state[i];
            }
          };
          Hash2.prototype._restoreState = function(from, bytesHashed) {
            for (var i = 0; i < this.state.length; i++) {
              this.state[i] = from[i];
            }
            this.bytesHashed = bytesHashed;
            this.finished = false;
            this.bufferLength = 0;
          };
          return Hash2;
        })()
      );
      exports2.Hash = Hash;
      var HMAC = (
        /** @class */
        (function() {
          function HMAC2(key) {
            this.inner = new Hash();
            this.outer = new Hash();
            this.blockSize = this.inner.blockSize;
            this.digestLength = this.inner.digestLength;
            var pad = new Uint8Array(this.blockSize);
            if (key.length > this.blockSize) {
              new Hash().update(key).finish(pad).clean();
            } else {
              for (var i = 0; i < key.length; i++) {
                pad[i] = key[i];
              }
            }
            for (var i = 0; i < pad.length; i++) {
              pad[i] ^= 54;
            }
            this.inner.update(pad);
            for (var i = 0; i < pad.length; i++) {
              pad[i] ^= 54 ^ 92;
            }
            this.outer.update(pad);
            this.istate = new Uint32Array(8);
            this.ostate = new Uint32Array(8);
            this.inner._saveState(this.istate);
            this.outer._saveState(this.ostate);
            for (var i = 0; i < pad.length; i++) {
              pad[i] = 0;
            }
          }
          HMAC2.prototype.reset = function() {
            this.inner._restoreState(this.istate, this.inner.blockSize);
            this.outer._restoreState(this.ostate, this.outer.blockSize);
            return this;
          };
          HMAC2.prototype.clean = function() {
            for (var i = 0; i < this.istate.length; i++) {
              this.ostate[i] = this.istate[i] = 0;
            }
            this.inner.clean();
            this.outer.clean();
          };
          HMAC2.prototype.update = function(data) {
            this.inner.update(data);
            return this;
          };
          HMAC2.prototype.finish = function(out) {
            if (this.outer.finished) {
              this.outer.finish(out);
            } else {
              this.inner.finish(out);
              this.outer.update(out, this.digestLength).finish(out);
            }
            return this;
          };
          HMAC2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          return HMAC2;
        })()
      );
      exports2.HMAC = HMAC;
      function hash2(data) {
        var h = new Hash().update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.hash = hash2;
      exports2["default"] = hash2;
      function hmac(key, data) {
        var h = new HMAC(key).update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.hmac = hmac;
      function fillBuffer(buffer, hmac2, info, counter) {
        var num = counter[0];
        if (num === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        hmac2.reset();
        if (num > 1) {
          hmac2.update(buffer);
        }
        if (info) {
          hmac2.update(info);
        }
        hmac2.update(counter);
        hmac2.finish(buffer);
        counter[0]++;
      }
      var hkdfSalt = new Uint8Array(exports2.digestLength);
      function hkdf(key, salt, info, length) {
        if (salt === void 0) {
          salt = hkdfSalt;
        }
        if (length === void 0) {
          length = 32;
        }
        var counter = new Uint8Array([1]);
        var okm = hmac(salt, key);
        var hmac_ = new HMAC(okm);
        var buffer = new Uint8Array(hmac_.digestLength);
        var bufpos = buffer.length;
        var out = new Uint8Array(length);
        for (var i = 0; i < length; i++) {
          if (bufpos === buffer.length) {
            fillBuffer(buffer, hmac_, info, counter);
            bufpos = 0;
          }
          out[i] = buffer[bufpos++];
        }
        hmac_.clean();
        buffer.fill(0);
        counter.fill(0);
        return out;
      }
      exports2.hkdf = hkdf;
      function pbkdf2(password, salt, iterations, dkLen) {
        var prf = new HMAC(password);
        var len = prf.digestLength;
        var ctr = new Uint8Array(4);
        var t = new Uint8Array(len);
        var u = new Uint8Array(len);
        var dk = new Uint8Array(dkLen);
        for (var i = 0; i * len < dkLen; i++) {
          var c = i + 1;
          ctr[0] = c >>> 24 & 255;
          ctr[1] = c >>> 16 & 255;
          ctr[2] = c >>> 8 & 255;
          ctr[3] = c >>> 0 & 255;
          prf.reset();
          prf.update(salt);
          prf.update(ctr);
          prf.finish(u);
          for (var j = 0; j < len; j++) {
            t[j] = u[j];
          }
          for (var j = 2; j <= iterations; j++) {
            prf.reset();
            prf.update(u).finish(u);
            for (var k = 0; k < len; k++) {
              t[k] ^= u[k];
            }
          }
          for (var j = 0; j < len && i * len + j < dkLen; j++) {
            dk[i * len + j] = t[j];
          }
        }
        for (var i = 0; i < len; i++) {
          t[i] = u[i] = 0;
        }
        for (var i = 0; i < 4; i++) {
          ctr[i] = 0;
        }
        prf.clean();
        return dk;
      }
      exports2.pbkdf2 = pbkdf2;
    });
  }
});

// node_modules/.pnpm/standardwebhooks@1.0.0/node_modules/standardwebhooks/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/.pnpm/standardwebhooks@1.0.0/node_modules/standardwebhooks/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Webhook = exports.WebhookVerificationError = void 0;
    var timing_safe_equal_1 = require_timing_safe_equal();
    var base643 = require_base64();
    var sha256 = require_sha256();
    var WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
    var ExtendableError = class _ExtendableError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _ExtendableError.prototype);
        this.name = "ExtendableError";
        this.stack = new Error(message).stack;
      }
    };
    var WebhookVerificationError2 = class _WebhookVerificationError2 extends ExtendableError {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _WebhookVerificationError2.prototype);
        this.name = "WebhookVerificationError";
      }
    };
    exports.WebhookVerificationError = WebhookVerificationError2;
    var Webhook2 = class _Webhook {
      constructor(secret, options) {
        if (!secret) {
          throw new Error("Secret can't be empty.");
        }
        if ((options === null || options === void 0 ? void 0 : options.format) === "raw") {
          if (secret instanceof Uint8Array) {
            this.key = secret;
          } else {
            this.key = Uint8Array.from(secret, (c) => c.charCodeAt(0));
          }
        } else {
          if (typeof secret !== "string") {
            throw new Error("Expected secret to be of type string");
          }
          if (secret.startsWith(_Webhook.prefix)) {
            secret = secret.substring(_Webhook.prefix.length);
          }
          this.key = base643.decode(secret);
        }
      }
      verify(payload, headers_) {
        const headers = {};
        for (const key of Object.keys(headers_)) {
          headers[key.toLowerCase()] = headers_[key];
        }
        const msgId = headers["webhook-id"];
        const msgSignature = headers["webhook-signature"];
        const msgTimestamp = headers["webhook-timestamp"];
        if (!msgSignature || !msgId || !msgTimestamp) {
          throw new WebhookVerificationError2("Missing required headers");
        }
        const timestamp2 = this.verifyTimestamp(msgTimestamp);
        const computedSignature = this.sign(msgId, timestamp2, payload);
        const expectedSignature = computedSignature.split(",")[1];
        const passedSignatures = msgSignature.split(" ");
        const encoder = new globalThis.TextEncoder();
        for (const versionedSignature of passedSignatures) {
          const [version3, signature] = versionedSignature.split(",");
          if (version3 !== "v1") {
            continue;
          }
          if ((0, timing_safe_equal_1.timingSafeEqual)(encoder.encode(signature), encoder.encode(expectedSignature))) {
            return JSON.parse(payload.toString());
          }
        }
        throw new WebhookVerificationError2("No matching signature found");
      }
      sign(msgId, timestamp2, payload) {
        if (typeof payload === "string") {
        } else if (payload.constructor.name === "Buffer") {
          payload = payload.toString();
        } else {
          throw new Error("Expected payload to be of type string or Buffer.");
        }
        const encoder = new TextEncoder();
        const timestampNumber = Math.floor(timestamp2.getTime() / 1e3);
        const toSign = encoder.encode(`${msgId}.${timestampNumber}.${payload}`);
        const expectedSignature = base643.encode(sha256.hmac(this.key, toSign));
        return `v1,${expectedSignature}`;
      }
      verifyTimestamp(timestampHeader) {
        const now = Math.floor(Date.now() / 1e3);
        const timestamp2 = parseInt(timestampHeader, 10);
        if (isNaN(timestamp2)) {
          throw new WebhookVerificationError2("Invalid Signature Headers");
        }
        if (now - timestamp2 > WEBHOOK_TOLERANCE_IN_SECONDS) {
          throw new WebhookVerificationError2("Message timestamp too old");
        }
        if (timestamp2 > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
          throw new WebhookVerificationError2("Message timestamp too new");
        }
        return new Date(timestamp2 * 1e3);
      }
    };
    exports.Webhook = Webhook2;
    Webhook2.prefix = "whsec_";
  }
});

// node_modules/.pnpm/dotenv@17.2.3/node_modules/dotenv/config.js
(function() {
  require_main().config(
    Object.assign(
      {},
      require_env_options(),
      require_cli_options()(process.argv)
    )
  );
})();

// api/_serverless.ts
var import_fastify2 = __toESM(require_fastify(), 1);
var import_cors = __toESM(require_cors(), 1);

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a3;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = /* @__PURE__ */ Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v2]) => v2);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match2 = stepString.match(/\d?e-(\d?)/);
    if (match2?.[1]) {
      stepDecCount = Number.parseInt(match2[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object3, key, getter) {
  let value = void 0;
  Object.defineProperty(object3, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v2) {
      Object.defineProperty(object3, key, {
        value: v2
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a2, b2) {
  const def = mergeDefs(a2._zod.def, {
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b2._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b2._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a2, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x2, startIndex = 0) {
  if (x2.aborted === true)
    return true;
  for (let i = startIndex; i < x2.issues.length; i++) {
    if (x2.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a3;
    (_a3 = iss).path ?? (_a3.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config3.customError?.(iss)) ?? unwrapMessage(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b2) => b2.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a3, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a3 = curr.properties)[el] ?? (_a3[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a2, b2) => (a2.path ?? []).length - (b2.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a3;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a3 = inst._zod).onattach ?? (_a3.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a3;
    (_a3 = inst2._zod.bag).multipleOf ?? (_a3.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a3, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a3 = inst._zod).check ?? (_a3.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line2 of dedented) {
      this.content.push(line2);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x2) => `  ${x2}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a3;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc2 = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc2?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values)
          propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v2] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v2) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v2 of values) {
        if (map2.has(v2)) {
          throw new Error(`Duplicate discriminator value "${String(v2)}"`);
        }
        map2.set(v2, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b2) {
  if (a2 === b2) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b2 instanceof Date && +a2 === +b2) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject(a2) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([...v2].filter((x2) => x2 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v2) => stringifyPrimitive(v2));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be2 = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be2} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be2} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be2 = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be2} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be2} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text2) => {
  return text2.charAt(0).toUpperCase() + text2.slice(1);
};
function getUnitTypeFromNumber(number6) {
  const abs = Math.abs(number6);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/registries.js
var _a;
var $output = /* @__PURE__ */ Symbol("ZodOutput");
var $input = /* @__PURE__ */ Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...this.get(p2) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
    falsyArray = falsyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a3;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a3 = result.schema).default ?? (_a3.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io2, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io: io2, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json4 = _json;
  json4.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json4.minLength = minimum;
  if (typeof maximum === "number")
    json4.maxLength = maximum;
  if (format) {
    json4.format = formatMap[format] ?? format;
    if (json4.format === "")
      delete json4.format;
    if (format === "time") {
      delete json4.format;
    }
  }
  if (contentEncoding)
    json4.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json4.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json4.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json4 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json4.type = "integer";
  else
    json4.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json4.minimum = exclusiveMinimum;
      json4.exclusiveMinimum = true;
    } else {
      json4.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json4.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json4.minimum;
      else
        delete json4.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json4.maximum = exclusiveMaximum;
      json4.exclusiveMaximum = true;
    } else {
      json4.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json4.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json4.maximum;
      else
        delete json4.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json4.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json4, _params) => {
  json4.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json4, _params) => {
  if (ctx.target === "openapi-3.0") {
    json4.type = "string";
    json4.nullable = true;
    json4.enum = [null];
  } else {
    json4.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json4, _params) => {
  json4.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json4, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v2) => typeof v2 === "number"))
    json4.type = "number";
  if (values.every((v2) => typeof v2 === "string"))
    json4.type = "string";
  json4.enum = values;
};
var literalProcessor = (schema, ctx, json4, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json4.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json4.enum = [val];
    } else {
      json4.const = val;
    }
  } else {
    if (vals.every((v2) => typeof v2 === "number"))
      json4.type = "number";
    if (vals.every((v2) => typeof v2 === "string"))
      json4.type = "string";
    if (vals.every((v2) => typeof v2 === "boolean"))
      json4.type = "boolean";
    if (vals.every((v2) => v2 === null))
      json4.type = "null";
    json4.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json4, _params) => {
  const _json = json4;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json4, _params) => {
  const _json = json4;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m2) => ({ contentMediaType: m2 }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
var successProcessor = (_schema, _ctx, json4, _params) => {
  json4.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json4 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json4.minItems = minimum;
  if (typeof maximum === "number")
    json4.maxItems = maximum;
  json4.type = "array";
  json4.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json4 = _json;
  const def = schema._zod.def;
  json4.type = "object";
  json4.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json4.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v2 = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v2.optin === void 0;
    } else {
      return v2.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json4.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json4.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json4.additionalProperties = false;
  } else if (def.catchall) {
    json4.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x2, i) => process2(x2, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json4.oneOf = options;
  } else {
    json4.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  const a2 = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b2 = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a2) ? a2.allOf : [a2],
    ...isSimpleIntersection(b2) ? b2.allOf : [b2]
  ];
  json4.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json4 = _json;
  const def = schema._zod.def;
  json4.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x2, i) => process2(x2, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json4.prefixItems = prefixItems;
    if (rest) {
      json4.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json4.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json4.items.anyOf.push(rest);
    }
    json4.minItems = prefixItems.length;
    if (!rest) {
      json4.maxItems = prefixItems.length;
    }
  } else {
    json4.items = prefixItems;
    if (rest) {
      json4.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json4.minItems = minimum;
  if (typeof maximum === "number")
    json4.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json4 = _json;
  const def = schema._zod.def;
  json4.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json4.patternProperties = {};
    for (const pattern of patterns) {
      json4.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json4.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json4.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v2) => typeof v2 === "string" || typeof v2 === "number");
    if (validKeyValues.length > 0) {
      json4.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json4.nullable = true;
  } else {
    json4.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json4.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json4._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json4.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json4, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json4.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator = class {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/.pnpm/fastify-type-provider-zod@6.1.0_@fastify+swagger@9.6.1_fastify@5.6.1_openapi-types@12.1.3_zod@4.3.6/node_modules/fastify-type-provider-zod/dist/esm/errors.js
var import_error = __toESM(require_error(), 1);
var InvalidSchemaError = (0, import_error.default)("FST_ERR_INVALID_SCHEMA", "Invalid schema passed: %s", 500);
var ZodFastifySchemaValidationErrorSymbol = /* @__PURE__ */ Symbol.for("ZodFastifySchemaValidationError");
var ResponseSerializationBase = (0, import_error.default)(
  "FST_ERR_RESPONSE_SERIALIZATION",
  "Response doesn't match the schema",
  500
);
var ResponseSerializationError = class extends ResponseSerializationBase {
  constructor(method, url2, options) {
    super({ cause: options.cause });
    this.method = method;
    this.url = url2;
    this.cause = options.cause;
  }
  cause;
};
function omit2(obj, keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}
function createValidationError(error48) {
  return error48.issues.map((issue2) => {
    return {
      [ZodFastifySchemaValidationErrorSymbol]: true,
      keyword: issue2.code,
      instancePath: `/${issue2.path.join("/")}`,
      schemaPath: `#/${issue2.path.join("/")}/${issue2.code}`,
      message: issue2.message,
      params: {
        ...omit2(issue2, ["path", "code", "message"])
      }
    };
  });
}

// node_modules/.pnpm/fastify-type-provider-zod@6.1.0_@fastify+swagger@9.6.1_fastify@5.6.1_openapi-types@12.1.3_zod@4.3.6/node_modules/fastify-type-provider-zod/dist/esm/json-to-oas.js
var getOASVersion = (documentObject) => {
  const openapiVersion = documentObject.openapiObject.openapi || "3.0.3";
  if (openapiVersion.startsWith("3.1")) {
    return "3.1";
  }
  if (openapiVersion.startsWith("3.0")) {
    return "3.0";
  }
  throw new Error("Unsupported OpenAPI document object");
};
var jsonSchemaToOAS_3_0 = (jsonSchema2) => {
  const clone2 = { ...jsonSchema2 };
  for (const key of [
    "$schema",
    "$id",
    "unevaluatedProperties",
    "dependentSchemas",
    "patternProperties",
    "propertyNames",
    "contentEncoding",
    "contentMediaType"
  ]) {
    delete clone2[key];
  }
  const recursive = (v2) => Array.isArray(v2) ? v2.map(jsonSchemaToOAS_3_0) : jsonSchemaToOAS_3_0(v2);
  if (clone2.properties) {
    for (const [k, v2] of Object.entries(clone2.properties)) {
      clone2.properties[k] = jsonSchemaToOAS_3_0(v2);
    }
  }
  if (clone2.items && !Array.isArray(clone2.items)) {
    clone2.items = recursive(clone2.items);
  }
  for (const key of ["allOf", "anyOf", "oneOf", "not", "then", "else", "if", "contains"]) {
    if (clone2[key]) {
      clone2[key] = recursive(clone2[key]);
    }
  }
  return clone2;
};
var jsonSchemaToOAS_3_1 = (jsonSchema2) => {
  return jsonSchema2;
};
var jsonSchemaToOAS = (jsonSchema2, oasVersion) => {
  switch (oasVersion) {
    case "3.0":
      return jsonSchemaToOAS_3_0(jsonSchema2);
    case "3.1":
      return jsonSchemaToOAS_3_1(jsonSchema2);
    default:
      throw new Error(`Unsupported OpenAPI version: ${oasVersion}`);
  }
};

// node_modules/.pnpm/fastify-type-provider-zod@6.1.0_@fastify+swagger@9.6.1_fastify@5.6.1_openapi-types@12.1.3_zod@4.3.6/node_modules/fastify-type-provider-zod/dist/esm/zod-to-json.js
var getSchemaId = (id, io2) => {
  return io2 === "input" ? `${id}Input` : id;
};
var getReferenceUri = (id, io2) => {
  return `#/components/schemas/${getSchemaId(id, io2)}`;
};
function isZodDate(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "date";
}
function isZodUnion(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "union";
}
function isZodUndefined(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "undefined";
}
var getOverride = (ctx, io2) => {
  if (isZodUnion(ctx.zodSchema)) {
    ctx.jsonSchema.anyOf = ctx.jsonSchema.anyOf?.filter((schema) => Object.keys(schema).length > 0);
  }
  if (isZodDate(ctx.zodSchema)) {
    if (io2 === "output") {
      ctx.jsonSchema.type = "string";
      ctx.jsonSchema.format = "date-time";
    }
  }
  if (isZodUndefined(ctx.zodSchema)) {
    if (io2 === "output") {
      ctx.jsonSchema.type = "null";
    }
  }
};
var zodSchemaToJson = (zodSchema, registry2, io2, oasVersion, config3 = {}) => {
  const defaultTarget = oasVersion === "3.0" ? "openapi-3.0" : "draft-2020-12";
  const target = config3?.target ?? defaultTarget;
  const schemaRegistryEntry = registry2.get(zodSchema);
  if (schemaRegistryEntry?.id) {
    return {
      $ref: getReferenceUri(schemaRegistryEntry.id, io2)
    };
  }
  const tempID = "GEN";
  const tempRegistry = new $ZodRegistry();
  tempRegistry.add(zodSchema, { id: tempID });
  const {
    schemas: { [tempID]: result }
  } = toJSONSchema(tempRegistry, {
    target,
    metadata: registry2,
    io: io2,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    /**
     * The uri option only allows customizing the base path of the `$ref`, and it automatically appends a path to it.
     * As a workaround, we set a placeholder that looks something like this:
     *
     * |       marker          | always added by zod | meta.id |
     * |__SCHEMA__PLACEHOLDER__|      #/$defs/       | User    |
     *
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/User"`
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/Group"`
     *
     * @see jsonSchemaReplaceRef
     * @see https://github.com/colinhacks/zod/issues/4750
     */
    uri: () => `__SCHEMA__PLACEHOLDER__`,
    override: (ctx) => getOverride(ctx, io2)
  });
  const jsonSchema2 = { ...result };
  delete jsonSchema2.id;
  const normalizeId = (raw) => raw.replace(/^#\/(?:\$defs|definitions|components\/schemas)\//, "");
  const jsonSchemaReplaceRef = JSON.stringify(jsonSchema2).replaceAll(
    /"__SCHEMA__PLACEHOLDER__(?:(?:#\/(?:\$defs|definitions|components\/schemas)\/))?([^"]+)"/g,
    (_, raw) => {
      const id = normalizeId(raw);
      return `"${getReferenceUri(id, io2)}"`;
    }
  );
  return JSON.parse(jsonSchemaReplaceRef);
};
var zodRegistryToJson = (registry2, io2, config3 = {}) => {
  const { target = "draft-2020-12" } = config3;
  const result = toJSONSchema(registry2, {
    target,
    io: io2,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    uri: (id) => getReferenceUri(id, io2),
    override: (ctx) => getOverride(ctx, io2)
  }).schemas;
  const jsonSchemas = {};
  for (const id in result) {
    const jsonSchema2 = { ...result[id] };
    delete jsonSchema2.id;
    jsonSchemas[getSchemaId(id, io2)] = jsonSchema2;
  }
  return jsonSchemas;
};

// node_modules/.pnpm/fastify-type-provider-zod@6.1.0_@fastify+swagger@9.6.1_fastify@5.6.1_openapi-types@12.1.3_zod@4.3.6/node_modules/fastify-type-provider-zod/dist/esm/core.js
var defaultSkipList = [
  "/documentation/",
  "/documentation/initOAuth",
  "/documentation/json",
  "/documentation/uiConfig",
  "/documentation/yaml",
  "/documentation/*",
  "/documentation/static/*"
];
var createJsonSchemaTransform = ({
  skipList = defaultSkipList,
  schemaRegistry = globalRegistry,
  zodToJsonConfig = {}
}) => {
  return (input) => {
    if ("swaggerObject" in input) {
      throw new Error("OpenAPI 2.0 is not supported");
    }
    const { schema, url: url2 } = input;
    if (!schema) {
      return {
        schema,
        url: url2
      };
    }
    const { response, headers, querystring, body, params, hide, ...rest } = schema;
    const transformed = {};
    if (skipList.includes(url2) || hide) {
      transformed.hide = true;
      return { schema: transformed, url: url2 };
    }
    const zodSchemas = { headers, querystring, body, params };
    const oasVersion = getOASVersion(input);
    for (const prop in zodSchemas) {
      const zodSchema = zodSchemas[prop];
      if (zodSchema) {
        const jsonSchema2 = zodSchemaToJson(
          zodSchema,
          schemaRegistry,
          "input",
          oasVersion,
          zodToJsonConfig
        );
        const oasSchema = jsonSchemaToOAS(jsonSchema2, oasVersion);
        transformed[prop] = oasSchema;
      }
    }
    if (response) {
      transformed.response = {};
      for (const prop in response) {
        const zodSchema = resolveSchema(response[prop]);
        const jsonSchema2 = zodSchemaToJson(
          zodSchema,
          schemaRegistry,
          "output",
          oasVersion,
          zodToJsonConfig
        );
        if (jsonSchema2.type === "null") {
          transformed.response[prop] = jsonSchema2;
          continue;
        }
        const oasSchema = jsonSchemaToOAS(jsonSchema2, oasVersion);
        transformed.response[prop] = oasSchema;
      }
    }
    for (const prop in rest) {
      const meta3 = rest[prop];
      if (meta3) {
        transformed[prop] = meta3;
      }
    }
    return { schema: transformed, url: url2 };
  };
};
var jsonSchemaTransform = createJsonSchemaTransform({});
var createJsonSchemaTransformObject = ({
  schemaRegistry = globalRegistry,
  zodToJsonConfig = {}
}) => (input) => {
  if ("swaggerObject" in input) {
    throw new Error("OpenAPI 2.0 is not supported");
  }
  const oasVersion = getOASVersion(input);
  const inputSchemas = zodRegistryToJson(schemaRegistry, "input", zodToJsonConfig);
  const outputSchemas = zodRegistryToJson(schemaRegistry, "output", zodToJsonConfig);
  for (const key in outputSchemas) {
    if (inputSchemas[key]) {
      throw new Error(
        `Collision detected for schema "${key}". The is already an input schema with the same name.`
      );
    }
  }
  const jsonSchemas = {
    ...inputSchemas,
    ...outputSchemas
  };
  const oasSchemas = Object.fromEntries(
    Object.entries(jsonSchemas).map(([key, value]) => [key, jsonSchemaToOAS(value, oasVersion)])
  );
  return {
    ...input.openapiObject,
    components: {
      ...input.openapiObject.components,
      schemas: {
        ...input.openapiObject.components?.schemas,
        ...oasSchemas
      }
    }
  };
};
var jsonSchemaTransformObject = createJsonSchemaTransformObject({});
var validatorCompiler = ({ schema }) => (data) => {
  const result = safeParse(schema, data);
  if (result.error) {
    return { error: createValidationError(result.error) };
  }
  return { value: result.data };
};
function resolveSchema(maybeSchema) {
  if (maybeSchema instanceof $ZodType) {
    return maybeSchema;
  }
  if ("properties" in maybeSchema && maybeSchema.properties instanceof $ZodType) {
    return maybeSchema.properties;
  }
  throw new InvalidSchemaError(JSON.stringify(maybeSchema));
}
var createSerializerCompiler = (options) => ({ schema: maybeSchema, method, url: url2 }) => (data) => {
  const schema = resolveSchema(maybeSchema);
  const result = safeParse(schema, data);
  if (result.error) {
    throw new ResponseSerializationError(method, url2, {
      cause: result.error
    });
  }
  return JSON.stringify(result.data, options?.replacer);
};
var serializerCompiler = createSerializerCompiler({});

// src/routes/index.ts
async function rootRoute(fastify) {
  fastify.get("/", async function handler(request, reply) {
    reply.type("text/html");
    return "Hello World";
  });
}

// src/routes/health/index.ts
async function healthRoute(fastify) {
  fastify.get("/", async (request, reply) => {
    return {
      status: "healthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime()
    };
  });
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/url.js
var hasOwn = Object.prototype.hasOwnProperty;
function pathToFunc(pathPattern, options) {
  const paramRE = /\{([a-zA-Z0-9_][a-zA-Z0-9_-]*?)\}/g;
  return function buildURLPath(params = {}) {
    return pathPattern.replace(paramRE, function(_, placeholder) {
      if (!hasOwn.call(params, placeholder)) {
        throw new Error(`Parameter '${placeholder}' is required`);
      }
      const value = params[placeholder];
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Parameter '${placeholder}' must be a string or number`);
      }
      return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
    });
  };
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/config.js
var ServerProduction = "production";
var ServerSandbox = "sandbox";
var ServerList = {
  [ServerProduction]: "https://api.polar.sh",
  [ServerSandbox]: "https://sandbox-api.polar.sh"
};
function serverURLFromOptions(options) {
  let serverURL = options.serverURL;
  const params = {};
  if (!serverURL) {
    const server = options.server ?? ServerProduction;
    serverURL = ServerList[server] || "";
  }
  const u = pathToFunc(serverURL)(params);
  return new URL(u);
}
var SDK_METADATA = {
  language: "typescript",
  openapiDocVersion: "0.1.0",
  sdkVersion: "0.42.5",
  genVersion: "2.801.0",
  userAgent: "speakeasy-sdk/typescript 0.42.5 2.801.0 0.1.0 @polar-sh/sdk"
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/http.js
var DEFAULT_FETCHER = (input, init) => {
  if (init == null) {
    return fetch(input);
  } else {
    return fetch(input, init);
  }
};
var HTTPClient = class _HTTPClient {
  constructor(options = {}) {
    this.options = options;
    this.requestHooks = [];
    this.requestErrorHooks = [];
    this.responseHooks = [];
    this.fetcher = options.fetcher || DEFAULT_FETCHER;
  }
  async request(request) {
    let req = request;
    for (const hook of this.requestHooks) {
      const nextRequest = await hook(req);
      if (nextRequest) {
        req = nextRequest;
      }
    }
    try {
      const res = await this.fetcher(req);
      for (const hook of this.responseHooks) {
        await hook(res, req);
      }
      return res;
    } catch (err) {
      for (const hook of this.requestErrorHooks) {
        await hook(err, req);
      }
      throw err;
    }
  }
  addHook(...args) {
    if (args[0] === "beforeRequest") {
      this.requestHooks.push(args[1]);
    } else if (args[0] === "requestError") {
      this.requestErrorHooks.push(args[1]);
    } else if (args[0] === "response") {
      this.responseHooks.push(args[1]);
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    return this;
  }
  removeHook(...args) {
    let target;
    if (args[0] === "beforeRequest") {
      target = this.requestHooks;
    } else if (args[0] === "requestError") {
      target = this.requestErrorHooks;
    } else if (args[0] === "response") {
      target = this.responseHooks;
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    const index2 = target.findIndex((v2) => v2 === args[1]);
    if (index2 >= 0) {
      target.splice(index2, 1);
    }
    return this;
  }
  clone() {
    const child = new _HTTPClient(this.options);
    child.requestHooks = this.requestHooks.slice();
    child.requestErrorHooks = this.requestErrorHooks.slice();
    child.responseHooks = this.responseHooks.slice();
    return child;
  }
};
var mediaParamSeparator = /\s*;\s*/g;
function matchContentType(response, pattern) {
  if (pattern === "*") {
    return true;
  }
  let contentType = response.headers.get("content-type")?.trim() || "application/octet-stream";
  contentType = contentType.toLowerCase();
  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
  const [wantType = "", ...wantParams] = wantParts;
  if (wantType.split("/").length !== 2) {
    return false;
  }
  const gotParts = contentType.split(mediaParamSeparator);
  const [gotType = "", ...gotParams] = gotParts;
  const [type = "", subtype = ""] = gotType.split("/");
  if (!type || !subtype) {
    return false;
  }
  if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
    return false;
  }
  if (gotParams.length < wantParams.length) {
    return false;
  }
  const params = new Set(gotParams);
  for (const wantParam of wantParams) {
    if (!params.has(wantParam)) {
      return false;
    }
  }
  return true;
}
var codeRangeRE = new RegExp("^[0-9]xx$", "i");
function matchStatusCode(response, codes) {
  const actual = `${response.status}`;
  const expectedCodes = Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }
  return expectedCodes.some((ec) => {
    const code = `${ec}`;
    if (code === "default") {
      return true;
    }
    if (!codeRangeRE.test(`${code}`)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
function matchResponse(response, code, contentTypePattern) {
  return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
function isConnectionError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
  const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
  const isBunErr = "name" in err && err.name === "ConnectionError";
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
function isTimeoutError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "TimeoutError";
  const isLegacyNative = "code" in err && err.code === 23;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
function isAbortError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "AbortError";
  const isLegacyNative = "code" in err && err.code === 20;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/mini/schemas.js
var ZodMiniType = /* @__PURE__ */ $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }, { parent: true });
  };
  inst.with = inst.check;
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.apply = (fn) => fn(inst);
});
var ZodMiniString = /* @__PURE__ */ $constructor("ZodMiniString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function string2(params) {
  return _string(ZodMiniString, params);
}
var ZodMiniStringFormat = /* @__PURE__ */ $constructor("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  ZodMiniString.init(inst, def);
});
var ZodMiniNumber = /* @__PURE__ */ $constructor("ZodMiniNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function number2(params) {
  return _number(ZodMiniNumber, params);
}
var ZodMiniNumberFormat = /* @__PURE__ */ $constructor("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodMiniNumber.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function int(params) {
  return _int(ZodMiniNumberFormat, params);
}
var ZodMiniBoolean = /* @__PURE__ */ $constructor("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function boolean2(params) {
  return _boolean(ZodMiniBoolean, params);
}
var ZodMiniBigInt = /* @__PURE__ */ $constructor("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniAny = /* @__PURE__ */ $constructor("ZodMiniAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function any() {
  return _any(ZodMiniAny);
}
var ZodMiniUnknown = /* @__PURE__ */ $constructor("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function unknown() {
  return _unknown(ZodMiniUnknown);
}
var ZodMiniVoid = /* @__PURE__ */ $constructor("ZodMiniVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function _void2(params) {
  return _void(ZodMiniVoid, params);
}
var ZodMiniDate = /* @__PURE__ */ $constructor("ZodMiniDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function date2(params) {
  return _date(ZodMiniDate, params);
}
var ZodMiniArray = /* @__PURE__ */ $constructor("ZodMiniArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function array(element, params) {
  return new ZodMiniArray({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
var ZodMiniObject = /* @__PURE__ */ $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  defineLazy(inst, "shape", () => def.shape);
});
// @__NO_SIDE_EFFECTS__
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams(params)
  };
  return new ZodMiniObject(def);
}
var ZodMiniUnion = /* @__PURE__ */ $constructor("ZodMiniUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function union(options, params) {
  return new ZodMiniUnion({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
var ZodMiniIntersection = /* @__PURE__ */ $constructor("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function intersection(left, right) {
  return new ZodMiniIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodMiniRecord = /* @__PURE__ */ $constructor("ZodMiniRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function record(keyType, valueType, params) {
  return new ZodMiniRecord({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
var ZodMiniEnum = /* @__PURE__ */ $constructor("ZodMiniEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodMiniType.init(inst, def);
  inst.options = Object.values(def.entries);
});
// @__NO_SIDE_EFFECTS__
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new ZodMiniEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
var ZodMiniLiteral = /* @__PURE__ */ $constructor("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function literal(value, params) {
  return new ZodMiniLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
var ZodMiniTransform = /* @__PURE__ */ $constructor("ZodMiniTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function transform(fn) {
  return new ZodMiniTransform({
    type: "transform",
    transform: fn
  });
}
var ZodMiniOptional = /* @__PURE__ */ $constructor("ZodMiniOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function optional(innerType) {
  return new ZodMiniOptional({
    type: "optional",
    innerType
  });
}
var ZodMiniNullable = /* @__PURE__ */ $constructor("ZodMiniNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function nullable(innerType) {
  return new ZodMiniNullable({
    type: "nullable",
    innerType
  });
}
var ZodMiniDefault = /* @__PURE__ */ $constructor("ZodMiniDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function _default2(innerType, defaultValue) {
  return new ZodMiniDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
var ZodMiniPipe = /* @__PURE__ */ $constructor("ZodMiniPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function pipe(in_, out) {
  return new ZodMiniPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodMiniLazy = /* @__PURE__ */ $constructor("ZodMiniLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function _lazy2(getter) {
  return new ZodMiniLazy({
    type: "lazy",
    getter
  });
}
var ZodMiniCustom = /* @__PURE__ */ $constructor("ZodMiniCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodMiniType.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function custom(fn, _params) {
  return _custom(ZodMiniCustom, fn ?? (() => true), _params);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/mini/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  date: () => date3,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodMiniISODateTime = /* @__PURE__ */ $constructor("ZodMiniISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function datetime2(params) {
  return _isoDateTime(ZodMiniISODateTime, params);
}
var ZodMiniISODate = /* @__PURE__ */ $constructor("ZodMiniISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function date3(params) {
  return _isoDate(ZodMiniISODate, params);
}
var ZodMiniISOTime = /* @__PURE__ */ $constructor("ZodMiniISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function time2(params) {
  return _isoTime(ZodMiniISOTime, params);
}
var ZodMiniISODuration = /* @__PURE__ */ $constructor("ZodMiniISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
// @__NO_SIDE_EFFECTS__
function duration2(params) {
  return _isoDuration(ZodMiniISODuration, params);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/mini/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint2,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
// @__NO_SIDE_EFFECTS__
function string3(params) {
  return _coercedString(ZodMiniString, params);
}
// @__NO_SIDE_EFFECTS__
function number3(params) {
  return _coercedNumber(ZodMiniNumber, params);
}
// @__NO_SIDE_EFFECTS__
function boolean3(params) {
  return _coercedBoolean(ZodMiniBoolean, params);
}
// @__NO_SIDE_EFFECTS__
function bigint2(params) {
  return _coercedBigint(ZodMiniBigInt, params);
}
// @__NO_SIDE_EFFECTS__
function date4(params) {
  return _coercedDate(ZodMiniDate, params);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/sdkvalidationerror.js
var SDKValidationError = class extends Error {
  // Allows for backwards compatibility for `instanceof` checks of `ResponseValidationError`
  static [Symbol.hasInstance](instance) {
    if (!(instance instanceof Error))
      return false;
    if (!("rawValue" in instance))
      return false;
    if (!("rawMessage" in instance))
      return false;
    if (!("pretty" in instance))
      return false;
    if (typeof instance.pretty !== "function")
      return false;
    return true;
  }
  constructor(message, cause, rawValue) {
    super(`${message}: ${cause}`);
    this.name = "SDKValidationError";
    this.cause = cause;
    this.rawValue = rawValue;
    this.rawMessage = message;
  }
  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  pretty() {
    if (this.cause instanceof $ZodError) {
      return `${this.rawMessage}
${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
};
function formatZodError(err) {
  return prettifyError(err);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/types/fp.js
function OK(value) {
  return { ok: true, value };
}
function ERR(error48) {
  return { ok: false, error: error48 };
}
async function unwrapAsync(pr) {
  const r = await pr;
  if (!r.ok) {
    throw r.error;
  }
  return r.value;
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/schemas.js
function safeParse2(rawValue, fn, errorMessage) {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new SDKValidationError(errorMessage, err, rawValue));
  }
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/primitives.js
function remap(inp, mappings) {
  let out = {};
  if (!Object.keys(mappings).length) {
    out = inp;
    return out;
  }
  for (const [k, v2] of Object.entries(inp)) {
    const j = mappings[k];
    if (j === null) {
      continue;
    }
    out[j ?? k] = v2;
  }
  return out;
}
function compactMap(values) {
  const out = {};
  for (const [k, v2] of Object.entries(values)) {
    if (typeof v2 !== "undefined") {
      out[k] = v2;
    }
  }
  return out;
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustomproperties.js
var BenefitCustomProperties$inboundSchema = object({
  note: nullable(string2())
});
var BenefitCustomProperties$outboundSchema = object({
  note: nullable(string2())
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/types/rfcdate.js
var dateRE = /^\d{4}-\d{2}-\d{2}$/;
var RFCDate = class _RFCDate {
  /**
   * Creates a new RFCDate instance using today's date.
   */
  static today() {
    return new _RFCDate(/* @__PURE__ */ new Date());
  }
  /**
   * Creates a new RFCDate instance using the provided input.
   * If a string is used then in must be in the format YYYY-MM-DD.
   *
   * @param date A Date object or a date string in YYYY-MM-DD format
   * @example
   * new RFCDate("2022-01-01")
   * @example
   * new RFCDate(new Date())
   */
  constructor(date9) {
    if (typeof date9 === "string" && !dateRE.test(date9)) {
      throw new RangeError("RFCDate: date strings must be in the format YYYY-MM-DD: " + date9);
    }
    const value = new Date(date9);
    if (isNaN(+value)) {
      throw new RangeError("RFCDate: invalid date provided: " + date9);
    }
    this.serialized = value.toISOString().slice(0, "YYYY-MM-DD".length);
    if (!dateRE.test(this.serialized)) {
      throw new TypeError(`RFCDate: failed to build valid date with given value: ${date9} serialized to ${this.serialized}`);
    }
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return this.serialized;
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/types/unrecognized.js
var globalCount = 0;
var refCount = 0;
function startCountingUnrecognized() {
  refCount++;
  const start = globalCount;
  return {
    /**
     * Ends counting and returns the delta.
     * @param delta - If provided, only this amount is added to the parent counter
     *   (used for nested unions where we only want to record the winning option's count).
     *   If not provided, records all counts since start().
     */
    end: (delta) => {
      const count = globalCount - start;
      globalCount = start + (delta ?? count);
      if (--refCount === 0)
        globalCount = 0;
      return count;
    }
  };
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/types/smartUnion.js
function smartUnion(options) {
  return pipe(unknown(), transform((input, ctx) => {
    const candidates = [];
    const errors = options.map(() => []);
    const parentUnrecognizedCtr = startCountingUnrecognized();
    for (const [i, option] of options.entries()) {
      const unrecognizedCtr = startCountingUnrecognized();
      const result = option.safeParse(input);
      const inexactCount = unrecognizedCtr.end();
      const zeroDefaultCount = 0;
      if (result.success) {
        candidates.push({
          data: result.data,
          inexactCount,
          zeroDefaultCount,
          fieldCount: -1
          // We'll count this later if needed
        });
        continue;
      }
      errors[i].push(...result.error.issues);
    }
    if (candidates.length === 0) {
      parentUnrecognizedCtr.end(0);
      ctx.issues.push({
        input,
        code: "invalid_union",
        errors
      });
      return NEVER;
    }
    let best = candidates[0];
    for (const candidate of candidates) {
      if (candidates.length > 1) {
        candidate.fieldCount = countFieldsRecursive(candidate.data);
      }
      best = better(candidate, best);
    }
    parentUnrecognizedCtr.end(best.inexactCount);
    return best.data;
  }));
}
function better(a2, b2) {
  const actualFieldCountA = a2.fieldCount - a2.zeroDefaultCount;
  const actualFieldCountB = b2.fieldCount - b2.zeroDefaultCount;
  if (actualFieldCountA !== actualFieldCountB) {
    return actualFieldCountA > actualFieldCountB ? a2 : b2;
  }
  return a2.inexactCount < b2.inexactCount ? a2 : b2;
}
function countFieldsRecursive(parsed) {
  let fieldCount = 0;
  const queue = [parsed];
  let index2 = 0;
  while (index2 < queue.length) {
    const value = queue[index2++];
    if (value === void 0) {
      continue;
    }
    const type = typeof value;
    if (value === null || type === "number" || type === "string" || type === "boolean" || type === "bigint" || value instanceof Date || value instanceof RFCDate) {
      fieldCount++;
      continue;
    }
    if (Array.isArray(value)) {
      queue.push(...value);
      continue;
    }
    if (type === "object") {
      queue.push(...Object.values(value));
    }
  }
  return fieldCount;
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metadataoutputtype.js
var MetadataOutputType$inboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var MetadataOutputType$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustom.js
var BenefitCustom$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("custom"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: BenefitCustomProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitCustom$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: literal("custom"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: BenefitCustomProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscordproperties.js
var BenefitDiscordProperties$inboundSchema = pipe(object({
  guild_id: string2(),
  role_id: string2(),
  kick_member: boolean2(),
  guild_token: string2()
}), transform((v2) => {
  return remap(v2, {
    "guild_id": "guildId",
    "role_id": "roleId",
    "kick_member": "kickMember",
    "guild_token": "guildToken"
  });
}));
var BenefitDiscordProperties$outboundSchema = pipe(object({
  guildId: string2(),
  roleId: string2(),
  kickMember: boolean2(),
  guildToken: string2()
}), transform((v2) => {
  return remap(v2, {
    guildId: "guild_id",
    roleId: "role_id",
    kickMember: "kick_member",
    guildToken: "guild_token"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscord.js
var BenefitDiscord$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("discord"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: BenefitDiscordProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitDiscord$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: literal("discord"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: BenefitDiscordProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadablesproperties.js
var BenefitDownloadablesProperties$inboundSchema = object({
  archived: record(string2(), boolean2()),
  files: array(string2())
});
var BenefitDownloadablesProperties$outboundSchema = object({
  archived: record(string2(), boolean2()),
  files: array(string2())
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadables.js
var BenefitDownloadables$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("downloadables"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: BenefitDownloadablesProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitDownloadables$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: literal("downloadables"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: BenefitDownloadablesProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepositoryproperties.js
var Permission = {
  Pull: "pull",
  Triage: "triage",
  Push: "push",
  Maintain: "maintain",
  Admin: "admin"
};
var Permission$inboundSchema = _enum2(Permission);
var Permission$outboundSchema = Permission$inboundSchema;
var BenefitGitHubRepositoryProperties$inboundSchema = pipe(object({
  repository_owner: string2(),
  repository_name: string2(),
  permission: Permission$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "repository_owner": "repositoryOwner",
    "repository_name": "repositoryName"
  });
}));
var BenefitGitHubRepositoryProperties$outboundSchema = pipe(object({
  repositoryOwner: string2(),
  repositoryName: string2(),
  permission: Permission$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    repositoryOwner: "repository_owner",
    repositoryName: "repository_name"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepository.js
var BenefitGitHubRepository$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("github_repository"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: BenefitGitHubRepositoryProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitGitHubRepository$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: literal("github_repository"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: BenefitGitHubRepositoryProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyactivationproperties.js
var BenefitLicenseKeyActivationProperties$inboundSchema = pipe(object({
  limit: int(),
  enable_customer_admin: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "enable_customer_admin": "enableCustomerAdmin"
  });
}));
var BenefitLicenseKeyActivationProperties$outboundSchema = pipe(object({
  limit: int(),
  enableCustomerAdmin: boolean2()
}), transform((v2) => {
  return remap(v2, {
    enableCustomerAdmin: "enable_customer_admin"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyexpirationproperties.js
var Timeframe = {
  Year: "year",
  Month: "month",
  Day: "day"
};
var Timeframe$inboundSchema = _enum2(Timeframe);
var Timeframe$outboundSchema = Timeframe$inboundSchema;
var BenefitLicenseKeyExpirationProperties$inboundSchema = object({
  ttl: int(),
  timeframe: Timeframe$inboundSchema
});
var BenefitLicenseKeyExpirationProperties$outboundSchema = object({
  ttl: int(),
  timeframe: Timeframe$outboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeysproperties.js
var BenefitLicenseKeysProperties$inboundSchema = pipe(object({
  prefix: nullable(string2()),
  expires: nullable(BenefitLicenseKeyExpirationProperties$inboundSchema),
  activations: nullable(BenefitLicenseKeyActivationProperties$inboundSchema),
  limit_usage: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    "limit_usage": "limitUsage"
  });
}));
var BenefitLicenseKeysProperties$outboundSchema = pipe(object({
  prefix: nullable(string2()),
  expires: nullable(BenefitLicenseKeyExpirationProperties$outboundSchema),
  activations: nullable(BenefitLicenseKeyActivationProperties$outboundSchema),
  limitUsage: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    limitUsage: "limit_usage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeys.js
var BenefitLicenseKeys$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("license_keys"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: BenefitLicenseKeysProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitLicenseKeys$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: literal("license_keys"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: BenefitLicenseKeysProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercreditproperties.js
var BenefitMeterCreditProperties$inboundSchema = pipe(object({
  units: int(),
  rollover: boolean2(),
  meter_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "meter_id": "meterId"
  });
}));
var BenefitMeterCreditProperties$outboundSchema = pipe(object({
  units: int(),
  rollover: boolean2(),
  meterId: string2()
}), transform((v2) => {
  return remap(v2, {
    meterId: "meter_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercredit.js
var BenefitMeterCredit$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("meter_credit"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: BenefitMeterCreditProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitMeterCredit$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: literal("meter_credit"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: BenefitMeterCreditProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefit.js
var Benefit$inboundSchema = union([
  BenefitCustom$inboundSchema,
  BenefitDiscord$inboundSchema,
  BenefitGitHubRepository$inboundSchema,
  BenefitDownloadables$inboundSchema,
  BenefitLicenseKeys$inboundSchema,
  BenefitMeterCredit$inboundSchema
]);
var Benefit$outboundSchema = union([
  BenefitCustom$outboundSchema,
  BenefitDiscord$outboundSchema,
  BenefitGitHubRepository$outboundSchema,
  BenefitDownloadables$outboundSchema,
  BenefitLicenseKeys$outboundSchema,
  BenefitMeterCredit$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookbenefitcreatedpayload.js
var WebhookBenefitCreatedPayload$inboundSchema = object({
  type: literal("benefit.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Benefit$inboundSchema
});
var WebhookBenefitCreatedPayload$outboundSchema = object({
  type: literal("benefit.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Benefit$outboundSchema
});
function webhookBenefitCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookBenefitCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookBenefitCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantcustomproperties.js
var BenefitGrantCustomProperties$inboundSchema = object({});
var BenefitGrantCustomProperties$outboundSchema = object({});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgranterror.js
var BenefitGrantError$inboundSchema = object({
  message: string2(),
  type: string2(),
  timestamp: string2()
});
var BenefitGrantError$outboundSchema = object({
  message: string2(),
  type: string2(),
  timestamp: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/address.js
var CountryAlpha2 = {
  Ad: "AD",
  Ae: "AE",
  Af: "AF",
  Ag: "AG",
  Ai: "AI",
  Al: "AL",
  Am: "AM",
  Ao: "AO",
  Aq: "AQ",
  Ar: "AR",
  As: "AS",
  At: "AT",
  Au: "AU",
  Aw: "AW",
  Ax: "AX",
  Az: "AZ",
  Ba: "BA",
  Bb: "BB",
  Bd: "BD",
  Be: "BE",
  Bf: "BF",
  Bg: "BG",
  Bh: "BH",
  Bi: "BI",
  Bj: "BJ",
  Bl: "BL",
  Bm: "BM",
  Bn: "BN",
  Bo: "BO",
  Bq: "BQ",
  Br: "BR",
  Bs: "BS",
  Bt: "BT",
  Bv: "BV",
  Bw: "BW",
  By: "BY",
  Bz: "BZ",
  Ca: "CA",
  Cc: "CC",
  Cd: "CD",
  Cf: "CF",
  Cg: "CG",
  Ch: "CH",
  Ci: "CI",
  Ck: "CK",
  Cl: "CL",
  Cm: "CM",
  Cn: "CN",
  Co: "CO",
  Cr: "CR",
  Cu: "CU",
  Cv: "CV",
  Cw: "CW",
  Cx: "CX",
  Cy: "CY",
  Cz: "CZ",
  De: "DE",
  Dj: "DJ",
  Dk: "DK",
  Dm: "DM",
  Do: "DO",
  Dz: "DZ",
  Ec: "EC",
  Ee: "EE",
  Eg: "EG",
  Eh: "EH",
  Er: "ER",
  Es: "ES",
  Et: "ET",
  Fi: "FI",
  Fj: "FJ",
  Fk: "FK",
  Fm: "FM",
  Fo: "FO",
  Fr: "FR",
  Ga: "GA",
  Gb: "GB",
  Gd: "GD",
  Ge: "GE",
  Gf: "GF",
  Gg: "GG",
  Gh: "GH",
  Gi: "GI",
  Gl: "GL",
  Gm: "GM",
  Gn: "GN",
  Gp: "GP",
  Gq: "GQ",
  Gr: "GR",
  Gs: "GS",
  Gt: "GT",
  Gu: "GU",
  Gw: "GW",
  Gy: "GY",
  Hk: "HK",
  Hm: "HM",
  Hn: "HN",
  Hr: "HR",
  Ht: "HT",
  Hu: "HU",
  Id: "ID",
  Ie: "IE",
  Il: "IL",
  Im: "IM",
  In: "IN",
  Io: "IO",
  Iq: "IQ",
  Ir: "IR",
  Is: "IS",
  It: "IT",
  Je: "JE",
  Jm: "JM",
  Jo: "JO",
  Jp: "JP",
  Ke: "KE",
  Kg: "KG",
  Kh: "KH",
  Ki: "KI",
  Km: "KM",
  Kn: "KN",
  Kp: "KP",
  Kr: "KR",
  Kw: "KW",
  Ky: "KY",
  Kz: "KZ",
  La: "LA",
  Lb: "LB",
  Lc: "LC",
  Li: "LI",
  Lk: "LK",
  Lr: "LR",
  Ls: "LS",
  Lt: "LT",
  Lu: "LU",
  Lv: "LV",
  Ly: "LY",
  Ma: "MA",
  Mc: "MC",
  Md: "MD",
  Me: "ME",
  Mf: "MF",
  Mg: "MG",
  Mh: "MH",
  Mk: "MK",
  Ml: "ML",
  Mm: "MM",
  Mn: "MN",
  Mo: "MO",
  Mp: "MP",
  Mq: "MQ",
  Mr: "MR",
  Ms: "MS",
  Mt: "MT",
  Mu: "MU",
  Mv: "MV",
  Mw: "MW",
  Mx: "MX",
  My: "MY",
  Mz: "MZ",
  Na: "NA",
  Nc: "NC",
  Ne: "NE",
  Nf: "NF",
  Ng: "NG",
  Ni: "NI",
  Nl: "NL",
  No: "NO",
  Np: "NP",
  Nr: "NR",
  Nu: "NU",
  Nz: "NZ",
  Om: "OM",
  Pa: "PA",
  Pe: "PE",
  Pf: "PF",
  Pg: "PG",
  Ph: "PH",
  Pk: "PK",
  Pl: "PL",
  Pm: "PM",
  Pn: "PN",
  Pr: "PR",
  Ps: "PS",
  Pt: "PT",
  Pw: "PW",
  Py: "PY",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Rs: "RS",
  Ru: "RU",
  Rw: "RW",
  Sa: "SA",
  Sb: "SB",
  Sc: "SC",
  Sd: "SD",
  Se: "SE",
  Sg: "SG",
  Sh: "SH",
  Si: "SI",
  Sj: "SJ",
  Sk: "SK",
  Sl: "SL",
  Sm: "SM",
  Sn: "SN",
  So: "SO",
  Sr: "SR",
  Ss: "SS",
  St: "ST",
  Sv: "SV",
  Sx: "SX",
  Sy: "SY",
  Sz: "SZ",
  Tc: "TC",
  Td: "TD",
  Tf: "TF",
  Tg: "TG",
  Th: "TH",
  Tj: "TJ",
  Tk: "TK",
  Tl: "TL",
  Tm: "TM",
  Tn: "TN",
  To: "TO",
  Tr: "TR",
  Tt: "TT",
  Tv: "TV",
  Tw: "TW",
  Tz: "TZ",
  Ua: "UA",
  Ug: "UG",
  Um: "UM",
  Us: "US",
  Uy: "UY",
  Uz: "UZ",
  Va: "VA",
  Vc: "VC",
  Ve: "VE",
  Vg: "VG",
  Vi: "VI",
  Vn: "VN",
  Vu: "VU",
  Wf: "WF",
  Ws: "WS",
  Ye: "YE",
  Yt: "YT",
  Za: "ZA",
  Zm: "ZM",
  Zw: "ZW"
};
var CountryAlpha2$inboundSchema = _enum2(CountryAlpha2);
var CountryAlpha2$outboundSchema = CountryAlpha2$inboundSchema;
var Address$inboundSchema = pipe(object({
  line1: optional(nullable(string2())),
  line2: optional(nullable(string2())),
  postal_code: optional(nullable(string2())),
  city: optional(nullable(string2())),
  state: optional(nullable(string2())),
  country: CountryAlpha2$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "postal_code": "postalCode"
  });
}));
var Address$outboundSchema = pipe(object({
  line1: optional(nullable(string2())),
  line2: optional(nullable(string2())),
  postalCode: optional(nullable(string2())),
  city: optional(nullable(string2())),
  state: optional(nullable(string2())),
  country: CountryAlpha2$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    postalCode: "postal_code"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customertype.js
var CustomerType = {
  Individual: "individual",
  Team: "team"
};
var CustomerType$inboundSchema = _enum2(CustomerType);
var CustomerType$outboundSchema = CustomerType$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/taxidformat.js
var TaxIDFormat = {
  AdNrt: "ad_nrt",
  AeTrn: "ae_trn",
  ArCuit: "ar_cuit",
  AuAbn: "au_abn",
  AuArn: "au_arn",
  BgUic: "bg_uic",
  BhVat: "bh_vat",
  BoTin: "bo_tin",
  BrCnpj: "br_cnpj",
  BrCpf: "br_cpf",
  CaBn: "ca_bn",
  CaGstHst: "ca_gst_hst",
  CaPstBc: "ca_pst_bc",
  CaPstMb: "ca_pst_mb",
  CaPstSk: "ca_pst_sk",
  CaQst: "ca_qst",
  ChUid: "ch_uid",
  ChVat: "ch_vat",
  ClTin: "cl_tin",
  CnTin: "cn_tin",
  CoNit: "co_nit",
  CrTin: "cr_tin",
  DeStn: "de_stn",
  DoRcn: "do_rcn",
  EcRuc: "ec_ruc",
  EgTin: "eg_tin",
  EsCif: "es_cif",
  EuOssVat: "eu_oss_vat",
  EuVat: "eu_vat",
  GbVat: "gb_vat",
  GeVat: "ge_vat",
  HkBr: "hk_br",
  HrOib: "hr_oib",
  HuTin: "hu_tin",
  IdNpwp: "id_npwp",
  IlVat: "il_vat",
  InGst: "in_gst",
  IsVat: "is_vat",
  JpCn: "jp_cn",
  JpRn: "jp_rn",
  JpTrn: "jp_trn",
  KePin: "ke_pin",
  KrBrn: "kr_brn",
  KzBin: "kz_bin",
  LiUid: "li_uid",
  MxRfc: "mx_rfc",
  MyFrp: "my_frp",
  MyItn: "my_itn",
  MySst: "my_sst",
  NgTin: "ng_tin",
  NoVat: "no_vat",
  NoVoec: "no_voec",
  NzGst: "nz_gst",
  OmVat: "om_vat",
  PeRuc: "pe_ruc",
  PhTin: "ph_tin",
  RoTin: "ro_tin",
  RsPib: "rs_pib",
  RuInn: "ru_inn",
  RuKpp: "ru_kpp",
  SaVat: "sa_vat",
  SgGst: "sg_gst",
  SgUen: "sg_uen",
  SiTin: "si_tin",
  SvNit: "sv_nit",
  ThVat: "th_vat",
  TrTin: "tr_tin",
  TwVat: "tw_vat",
  UaVat: "ua_vat",
  UsEin: "us_ein",
  UyRuc: "uy_ruc",
  VeRif: "ve_rif",
  VnTin: "vn_tin",
  ZaVat: "za_vat"
};
var TaxIDFormat$inboundSchema = _enum2(TaxIDFormat);
var TaxIDFormat$outboundSchema = TaxIDFormat$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customer.js
var CustomerTaxId$inboundSchema = smartUnion([string2(), TaxIDFormat$inboundSchema]);
var CustomerTaxId$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var Customer$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_id: nullable(string2()),
  email: string2(),
  email_verified: boolean2(),
  type: optional(nullable(CustomerType$inboundSchema)),
  name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  organization_id: string2(),
  deleted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  avatar_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "external_id": "externalId",
    "email_verified": "emailVerified",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "organization_id": "organizationId",
    "deleted_at": "deletedAt",
    "avatar_url": "avatarUrl"
  });
}));
var Customer$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  externalId: nullable(string2()),
  email: string2(),
  emailVerified: boolean2(),
  type: optional(nullable(CustomerType$outboundSchema)),
  name: nullable(string2()),
  billingAddress: nullable(Address$outboundSchema),
  taxId: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema])))),
  organizationId: string2(),
  deletedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  avatarUrl: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    externalId: "external_id",
    emailVerified: "email_verified",
    billingAddress: "billing_address",
    taxId: "tax_id",
    organizationId: "organization_id",
    deletedAt: "deleted_at",
    avatarUrl: "avatar_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/memberrole.js
var MemberRole = {
  Owner: "owner",
  BillingManager: "billing_manager",
  Member: "member"
};
var MemberRole$inboundSchema = _enum2(MemberRole);
var MemberRole$outboundSchema = MemberRole$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/member.js
var Member$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  email: string2(),
  name: nullable(string2()),
  external_id: nullable(string2()),
  role: MemberRole$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "customer_id": "customerId",
    "external_id": "externalId"
  });
}));
var Member$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  customerId: string2(),
  email: string2(),
  name: nullable(string2()),
  externalId: nullable(string2()),
  role: MemberRole$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    customerId: "customer_id",
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantcustomwebhook.js
var BenefitGrantCustomWebhook$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  member: optional(nullable(Member$inboundSchema)),
  benefit: BenefitCustom$inboundSchema,
  properties: BenefitGrantCustomProperties$inboundSchema,
  previous_properties: optional(nullable(BenefitGrantCustomProperties$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "previous_properties": "previousProperties"
  });
}));
var BenefitGrantCustomWebhook$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  grantedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isGranted: boolean2(),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isRevoked: boolean2(),
  subscriptionId: nullable(string2()),
  orderId: nullable(string2()),
  customerId: string2(),
  memberId: optional(nullable(string2())),
  benefitId: string2(),
  error: optional(nullable(BenefitGrantError$outboundSchema)),
  customer: Customer$outboundSchema,
  member: optional(nullable(Member$outboundSchema)),
  benefit: BenefitCustom$outboundSchema,
  properties: BenefitGrantCustomProperties$outboundSchema,
  previousProperties: optional(nullable(BenefitGrantCustomProperties$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    isGranted: "is_granted",
    revokedAt: "revoked_at",
    isRevoked: "is_revoked",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    benefitId: "benefit_id",
    previousProperties: "previous_properties"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantdiscordproperties.js
var BenefitGrantDiscordProperties$inboundSchema = pipe(object({
  account_id: optional(nullable(string2())),
  guild_id: optional(string2()),
  role_id: optional(string2()),
  granted_account_id: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "account_id": "accountId",
    "guild_id": "guildId",
    "role_id": "roleId",
    "granted_account_id": "grantedAccountId"
  });
}));
var BenefitGrantDiscordProperties$outboundSchema = pipe(object({
  accountId: optional(nullable(string2())),
  guildId: optional(string2()),
  roleId: optional(string2()),
  grantedAccountId: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    accountId: "account_id",
    guildId: "guild_id",
    roleId: "role_id",
    grantedAccountId: "granted_account_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantdiscordwebhook.js
var BenefitGrantDiscordWebhook$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  member: optional(nullable(Member$inboundSchema)),
  benefit: BenefitDiscord$inboundSchema,
  properties: BenefitGrantDiscordProperties$inboundSchema,
  previous_properties: optional(nullable(BenefitGrantDiscordProperties$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "previous_properties": "previousProperties"
  });
}));
var BenefitGrantDiscordWebhook$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  grantedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isGranted: boolean2(),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isRevoked: boolean2(),
  subscriptionId: nullable(string2()),
  orderId: nullable(string2()),
  customerId: string2(),
  memberId: optional(nullable(string2())),
  benefitId: string2(),
  error: optional(nullable(BenefitGrantError$outboundSchema)),
  customer: Customer$outboundSchema,
  member: optional(nullable(Member$outboundSchema)),
  benefit: BenefitDiscord$outboundSchema,
  properties: BenefitGrantDiscordProperties$outboundSchema,
  previousProperties: optional(nullable(BenefitGrantDiscordProperties$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    isGranted: "is_granted",
    revokedAt: "revoked_at",
    isRevoked: "is_revoked",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    benefitId: "benefit_id",
    previousProperties: "previous_properties"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantdownloadablesproperties.js
var BenefitGrantDownloadablesProperties$inboundSchema = object({
  files: optional(array(string2()))
});
var BenefitGrantDownloadablesProperties$outboundSchema = object({
  files: optional(array(string2()))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantdownloadableswebhook.js
var BenefitGrantDownloadablesWebhook$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  member: optional(nullable(Member$inboundSchema)),
  benefit: BenefitDownloadables$inboundSchema,
  properties: BenefitGrantDownloadablesProperties$inboundSchema,
  previous_properties: optional(nullable(BenefitGrantDownloadablesProperties$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "previous_properties": "previousProperties"
  });
}));
var BenefitGrantDownloadablesWebhook$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  grantedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isGranted: boolean2(),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isRevoked: boolean2(),
  subscriptionId: nullable(string2()),
  orderId: nullable(string2()),
  customerId: string2(),
  memberId: optional(nullable(string2())),
  benefitId: string2(),
  error: optional(nullable(BenefitGrantError$outboundSchema)),
  customer: Customer$outboundSchema,
  member: optional(nullable(Member$outboundSchema)),
  benefit: BenefitDownloadables$outboundSchema,
  properties: BenefitGrantDownloadablesProperties$outboundSchema,
  previousProperties: optional(nullable(BenefitGrantDownloadablesProperties$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    isGranted: "is_granted",
    revokedAt: "revoked_at",
    isRevoked: "is_revoked",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    benefitId: "benefit_id",
    previousProperties: "previous_properties"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantgithubrepositoryproperties.js
var BenefitGrantGitHubRepositoryPropertiesPermission = {
  Pull: "pull",
  Triage: "triage",
  Push: "push",
  Maintain: "maintain",
  Admin: "admin"
};
var BenefitGrantGitHubRepositoryPropertiesPermission$inboundSchema = _enum2(BenefitGrantGitHubRepositoryPropertiesPermission);
var BenefitGrantGitHubRepositoryPropertiesPermission$outboundSchema = BenefitGrantGitHubRepositoryPropertiesPermission$inboundSchema;
var BenefitGrantGitHubRepositoryProperties$inboundSchema = pipe(object({
  account_id: optional(nullable(string2())),
  repository_owner: optional(string2()),
  repository_name: optional(string2()),
  permission: optional(BenefitGrantGitHubRepositoryPropertiesPermission$inboundSchema),
  granted_account_id: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "account_id": "accountId",
    "repository_owner": "repositoryOwner",
    "repository_name": "repositoryName",
    "granted_account_id": "grantedAccountId"
  });
}));
var BenefitGrantGitHubRepositoryProperties$outboundSchema = pipe(object({
  accountId: optional(nullable(string2())),
  repositoryOwner: optional(string2()),
  repositoryName: optional(string2()),
  permission: optional(BenefitGrantGitHubRepositoryPropertiesPermission$outboundSchema),
  grantedAccountId: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    accountId: "account_id",
    repositoryOwner: "repository_owner",
    repositoryName: "repository_name",
    grantedAccountId: "granted_account_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantgithubrepositorywebhook.js
var BenefitGrantGitHubRepositoryWebhook$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  member: optional(nullable(Member$inboundSchema)),
  benefit: BenefitGitHubRepository$inboundSchema,
  properties: BenefitGrantGitHubRepositoryProperties$inboundSchema,
  previous_properties: optional(nullable(BenefitGrantGitHubRepositoryProperties$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "previous_properties": "previousProperties"
  });
}));
var BenefitGrantGitHubRepositoryWebhook$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  grantedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isGranted: boolean2(),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isRevoked: boolean2(),
  subscriptionId: nullable(string2()),
  orderId: nullable(string2()),
  customerId: string2(),
  memberId: optional(nullable(string2())),
  benefitId: string2(),
  error: optional(nullable(BenefitGrantError$outboundSchema)),
  customer: Customer$outboundSchema,
  member: optional(nullable(Member$outboundSchema)),
  benefit: BenefitGitHubRepository$outboundSchema,
  properties: BenefitGrantGitHubRepositoryProperties$outboundSchema,
  previousProperties: optional(nullable(BenefitGrantGitHubRepositoryProperties$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    isGranted: "is_granted",
    revokedAt: "revoked_at",
    isRevoked: "is_revoked",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    benefitId: "benefit_id",
    previousProperties: "previous_properties"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantlicensekeysproperties.js
var BenefitGrantLicenseKeysProperties$inboundSchema = pipe(object({
  license_key_id: optional(string2()),
  display_key: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "license_key_id": "licenseKeyId",
    "display_key": "displayKey"
  });
}));
var BenefitGrantLicenseKeysProperties$outboundSchema = pipe(object({
  licenseKeyId: optional(string2()),
  displayKey: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    licenseKeyId: "license_key_id",
    displayKey: "display_key"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantlicensekeyswebhook.js
var BenefitGrantLicenseKeysWebhook$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  member: optional(nullable(Member$inboundSchema)),
  benefit: BenefitLicenseKeys$inboundSchema,
  properties: BenefitGrantLicenseKeysProperties$inboundSchema,
  previous_properties: optional(nullable(BenefitGrantLicenseKeysProperties$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "previous_properties": "previousProperties"
  });
}));
var BenefitGrantLicenseKeysWebhook$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  grantedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isGranted: boolean2(),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isRevoked: boolean2(),
  subscriptionId: nullable(string2()),
  orderId: nullable(string2()),
  customerId: string2(),
  memberId: optional(nullable(string2())),
  benefitId: string2(),
  error: optional(nullable(BenefitGrantError$outboundSchema)),
  customer: Customer$outboundSchema,
  member: optional(nullable(Member$outboundSchema)),
  benefit: BenefitLicenseKeys$outboundSchema,
  properties: BenefitGrantLicenseKeysProperties$outboundSchema,
  previousProperties: optional(nullable(BenefitGrantLicenseKeysProperties$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    isGranted: "is_granted",
    revokedAt: "revoked_at",
    isRevoked: "is_revoked",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    benefitId: "benefit_id",
    previousProperties: "previous_properties"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantmetercreditproperties.js
var BenefitGrantMeterCreditProperties$inboundSchema = pipe(object({
  last_credited_meter_id: optional(string2()),
  last_credited_units: optional(int()),
  last_credited_at: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "last_credited_meter_id": "lastCreditedMeterId",
    "last_credited_units": "lastCreditedUnits",
    "last_credited_at": "lastCreditedAt"
  });
}));
var BenefitGrantMeterCreditProperties$outboundSchema = pipe(object({
  lastCreditedMeterId: optional(string2()),
  lastCreditedUnits: optional(int()),
  lastCreditedAt: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    lastCreditedMeterId: "last_credited_meter_id",
    lastCreditedUnits: "last_credited_units",
    lastCreditedAt: "last_credited_at"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantmetercreditwebhook.js
var BenefitGrantMeterCreditWebhook$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  member: optional(nullable(Member$inboundSchema)),
  benefit: BenefitMeterCredit$inboundSchema,
  properties: BenefitGrantMeterCreditProperties$inboundSchema,
  previous_properties: optional(nullable(BenefitGrantMeterCreditProperties$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "previous_properties": "previousProperties"
  });
}));
var BenefitGrantMeterCreditWebhook$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  grantedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isGranted: boolean2(),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  isRevoked: boolean2(),
  subscriptionId: nullable(string2()),
  orderId: nullable(string2()),
  customerId: string2(),
  memberId: optional(nullable(string2())),
  benefitId: string2(),
  error: optional(nullable(BenefitGrantError$outboundSchema)),
  customer: Customer$outboundSchema,
  member: optional(nullable(Member$outboundSchema)),
  benefit: BenefitMeterCredit$outboundSchema,
  properties: BenefitGrantMeterCreditProperties$outboundSchema,
  previousProperties: optional(nullable(BenefitGrantMeterCreditProperties$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    isGranted: "is_granted",
    revokedAt: "revoked_at",
    isRevoked: "is_revoked",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    benefitId: "benefit_id",
    previousProperties: "previous_properties"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantwebhook.js
var BenefitGrantWebhook$inboundSchema = smartUnion([
  BenefitGrantDiscordWebhook$inboundSchema,
  BenefitGrantCustomWebhook$inboundSchema,
  BenefitGrantGitHubRepositoryWebhook$inboundSchema,
  BenefitGrantDownloadablesWebhook$inboundSchema,
  BenefitGrantLicenseKeysWebhook$inboundSchema,
  BenefitGrantMeterCreditWebhook$inboundSchema
]);
var BenefitGrantWebhook$outboundSchema = smartUnion([
  BenefitGrantDiscordWebhook$outboundSchema,
  BenefitGrantCustomWebhook$outboundSchema,
  BenefitGrantGitHubRepositoryWebhook$outboundSchema,
  BenefitGrantDownloadablesWebhook$outboundSchema,
  BenefitGrantLicenseKeysWebhook$outboundSchema,
  BenefitGrantMeterCreditWebhook$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookbenefitgrantcreatedpayload.js
var WebhookBenefitGrantCreatedPayload$inboundSchema = object({
  type: literal("benefit_grant.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: BenefitGrantWebhook$inboundSchema
});
var WebhookBenefitGrantCreatedPayload$outboundSchema = object({
  type: literal("benefit_grant.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: BenefitGrantWebhook$outboundSchema
});
function webhookBenefitGrantCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookBenefitGrantCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookBenefitGrantCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookbenefitgrantcycledpayload.js
var WebhookBenefitGrantCycledPayload$inboundSchema = object({
  type: literal("benefit_grant.cycled"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: BenefitGrantWebhook$inboundSchema
});
var WebhookBenefitGrantCycledPayload$outboundSchema = object({
  type: literal("benefit_grant.cycled"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: BenefitGrantWebhook$outboundSchema
});
function webhookBenefitGrantCycledPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookBenefitGrantCycledPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookBenefitGrantCycledPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookbenefitgrantrevokedpayload.js
var WebhookBenefitGrantRevokedPayload$inboundSchema = object({
  type: literal("benefit_grant.revoked"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: BenefitGrantWebhook$inboundSchema
});
var WebhookBenefitGrantRevokedPayload$outboundSchema = object({
  type: literal("benefit_grant.revoked"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: BenefitGrantWebhook$outboundSchema
});
function webhookBenefitGrantRevokedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookBenefitGrantRevokedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookBenefitGrantRevokedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookbenefitgrantupdatedpayload.js
var WebhookBenefitGrantUpdatedPayload$inboundSchema = object({
  type: literal("benefit_grant.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: BenefitGrantWebhook$inboundSchema
});
var WebhookBenefitGrantUpdatedPayload$outboundSchema = object({
  type: literal("benefit_grant.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: BenefitGrantWebhook$outboundSchema
});
function webhookBenefitGrantUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookBenefitGrantUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookBenefitGrantUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookbenefitupdatedpayload.js
var WebhookBenefitUpdatedPayload$inboundSchema = object({
  type: literal("benefit.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Benefit$inboundSchema
});
var WebhookBenefitUpdatedPayload$outboundSchema = object({
  type: literal("benefit.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Benefit$outboundSchema
});
function webhookBenefitUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookBenefitUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookBenefitUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcheckboxproperties.js
var CustomFieldCheckboxProperties$inboundSchema = pipe(object({
  form_label: optional(string2()),
  form_help_text: optional(string2()),
  form_placeholder: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "form_label": "formLabel",
    "form_help_text": "formHelpText",
    "form_placeholder": "formPlaceholder"
  });
}));
var CustomFieldCheckboxProperties$outboundSchema = pipe(object({
  formLabel: optional(string2()),
  formHelpText: optional(string2()),
  formPlaceholder: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    formLabel: "form_label",
    formHelpText: "form_help_text",
    formPlaceholder: "form_placeholder"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcheckbox.js
var CustomFieldCheckbox$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  type: literal("checkbox"),
  slug: string2(),
  name: string2(),
  organization_id: string2(),
  properties: CustomFieldCheckboxProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var CustomFieldCheckbox$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  type: literal("checkbox"),
  slug: string2(),
  name: string2(),
  organizationId: string2(),
  properties: CustomFieldCheckboxProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfielddateproperties.js
var CustomFieldDateProperties$inboundSchema = pipe(object({
  form_label: optional(string2()),
  form_help_text: optional(string2()),
  form_placeholder: optional(string2()),
  ge: optional(int()),
  le: optional(int())
}), transform((v2) => {
  return remap(v2, {
    "form_label": "formLabel",
    "form_help_text": "formHelpText",
    "form_placeholder": "formPlaceholder"
  });
}));
var CustomFieldDateProperties$outboundSchema = pipe(object({
  formLabel: optional(string2()),
  formHelpText: optional(string2()),
  formPlaceholder: optional(string2()),
  ge: optional(int()),
  le: optional(int())
}), transform((v2) => {
  return remap(v2, {
    formLabel: "form_label",
    formHelpText: "form_help_text",
    formPlaceholder: "form_placeholder"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfielddate.js
var CustomFieldDate$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  type: literal("date"),
  slug: string2(),
  name: string2(),
  organization_id: string2(),
  properties: CustomFieldDateProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var CustomFieldDate$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  type: literal("date"),
  slug: string2(),
  name: string2(),
  organizationId: string2(),
  properties: CustomFieldDateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldnumberproperties.js
var CustomFieldNumberProperties$inboundSchema = pipe(object({
  form_label: optional(string2()),
  form_help_text: optional(string2()),
  form_placeholder: optional(string2()),
  ge: optional(int()),
  le: optional(int())
}), transform((v2) => {
  return remap(v2, {
    "form_label": "formLabel",
    "form_help_text": "formHelpText",
    "form_placeholder": "formPlaceholder"
  });
}));
var CustomFieldNumberProperties$outboundSchema = pipe(object({
  formLabel: optional(string2()),
  formHelpText: optional(string2()),
  formPlaceholder: optional(string2()),
  ge: optional(int()),
  le: optional(int())
}), transform((v2) => {
  return remap(v2, {
    formLabel: "form_label",
    formHelpText: "form_help_text",
    formPlaceholder: "form_placeholder"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldnumber.js
var CustomFieldNumber$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  type: literal("number"),
  slug: string2(),
  name: string2(),
  organization_id: string2(),
  properties: CustomFieldNumberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var CustomFieldNumber$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  type: literal("number"),
  slug: string2(),
  name: string2(),
  organizationId: string2(),
  properties: CustomFieldNumberProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldselectoption.js
var CustomFieldSelectOption$inboundSchema = object({
  value: string2(),
  label: string2()
});
var CustomFieldSelectOption$outboundSchema = object({
  value: string2(),
  label: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldselectproperties.js
var CustomFieldSelectProperties$inboundSchema = pipe(object({
  form_label: optional(string2()),
  form_help_text: optional(string2()),
  form_placeholder: optional(string2()),
  options: array(CustomFieldSelectOption$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "form_label": "formLabel",
    "form_help_text": "formHelpText",
    "form_placeholder": "formPlaceholder"
  });
}));
var CustomFieldSelectProperties$outboundSchema = pipe(object({
  formLabel: optional(string2()),
  formHelpText: optional(string2()),
  formPlaceholder: optional(string2()),
  options: array(CustomFieldSelectOption$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    formLabel: "form_label",
    formHelpText: "form_help_text",
    formPlaceholder: "form_placeholder"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldselect.js
var CustomFieldSelect$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  type: literal("select"),
  slug: string2(),
  name: string2(),
  organization_id: string2(),
  properties: CustomFieldSelectProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var CustomFieldSelect$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  type: literal("select"),
  slug: string2(),
  name: string2(),
  organizationId: string2(),
  properties: CustomFieldSelectProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldtextproperties.js
var CustomFieldTextProperties$inboundSchema = pipe(object({
  form_label: optional(string2()),
  form_help_text: optional(string2()),
  form_placeholder: optional(string2()),
  textarea: optional(boolean2()),
  min_length: optional(int()),
  max_length: optional(int())
}), transform((v2) => {
  return remap(v2, {
    "form_label": "formLabel",
    "form_help_text": "formHelpText",
    "form_placeholder": "formPlaceholder",
    "min_length": "minLength",
    "max_length": "maxLength"
  });
}));
var CustomFieldTextProperties$outboundSchema = pipe(object({
  formLabel: optional(string2()),
  formHelpText: optional(string2()),
  formPlaceholder: optional(string2()),
  textarea: optional(boolean2()),
  minLength: optional(int()),
  maxLength: optional(int())
}), transform((v2) => {
  return remap(v2, {
    formLabel: "form_label",
    formHelpText: "form_help_text",
    formPlaceholder: "form_placeholder",
    minLength: "min_length",
    maxLength: "max_length"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldtext.js
var CustomFieldText$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  type: literal("text"),
  slug: string2(),
  name: string2(),
  organization_id: string2(),
  properties: CustomFieldTextProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var CustomFieldText$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  type: literal("text"),
  slug: string2(),
  name: string2(),
  organizationId: string2(),
  properties: CustomFieldTextProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfield.js
var CustomField$inboundSchema = union([
  CustomFieldCheckbox$inboundSchema,
  CustomFieldDate$inboundSchema,
  CustomFieldNumber$inboundSchema,
  CustomFieldSelect$inboundSchema,
  CustomFieldText$inboundSchema
]);
var CustomField$outboundSchema = union([
  CustomFieldCheckbox$outboundSchema,
  CustomFieldDate$outboundSchema,
  CustomFieldNumber$outboundSchema,
  CustomFieldSelect$outboundSchema,
  CustomFieldText$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/attachedcustomfield.js
var AttachedCustomField$inboundSchema = pipe(object({
  custom_field_id: string2(),
  custom_field: CustomField$inboundSchema,
  order: int(),
  required: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "custom_field_id": "customFieldId",
    "custom_field": "customField"
  });
}));
var AttachedCustomField$outboundSchema = pipe(object({
  customFieldId: string2(),
  customField: CustomField$outboundSchema,
  order: int(),
  required: boolean2()
}), transform((v2) => {
  return remap(v2, {
    customFieldId: "custom_field_id",
    customField: "custom_field"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/billingaddressfieldmode.js
var BillingAddressFieldMode = {
  Required: "required",
  Optional: "optional",
  Disabled: "disabled"
};
var BillingAddressFieldMode$inboundSchema = _enum2(BillingAddressFieldMode);
var BillingAddressFieldMode$outboundSchema = BillingAddressFieldMode$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutbillingaddressfields.js
var CheckoutBillingAddressFields$inboundSchema = pipe(object({
  country: BillingAddressFieldMode$inboundSchema,
  state: BillingAddressFieldMode$inboundSchema,
  city: BillingAddressFieldMode$inboundSchema,
  postal_code: BillingAddressFieldMode$inboundSchema,
  line1: BillingAddressFieldMode$inboundSchema,
  line2: BillingAddressFieldMode$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "postal_code": "postalCode"
  });
}));
var CheckoutBillingAddressFields$outboundSchema = pipe(object({
  country: BillingAddressFieldMode$outboundSchema,
  state: BillingAddressFieldMode$outboundSchema,
  city: BillingAddressFieldMode$outboundSchema,
  postalCode: BillingAddressFieldMode$outboundSchema,
  line1: BillingAddressFieldMode$outboundSchema,
  line2: BillingAddressFieldMode$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    postalCode: "postal_code"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountduration.js
var DiscountDuration = {
  Once: "once",
  Forever: "forever",
  Repeating: "repeating"
};
var DiscountDuration$inboundSchema = _enum2(DiscountDuration);
var DiscountDuration$outboundSchema = DiscountDuration$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discounttype.js
var DiscountType = {
  Fixed: "fixed",
  Percentage: "percentage"
};
var DiscountType$inboundSchema = _enum2(DiscountType);
var DiscountType$outboundSchema = DiscountType$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutdiscountfixedonceforeverduration.js
var CheckoutDiscountFixedOnceForeverDuration$inboundSchema = object({
  duration: DiscountDuration$inboundSchema,
  type: DiscountType$inboundSchema,
  amount: int(),
  currency: string2(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
});
var CheckoutDiscountFixedOnceForeverDuration$outboundSchema = object({
  duration: DiscountDuration$outboundSchema,
  type: DiscountType$outboundSchema,
  amount: int(),
  currency: string2(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutdiscountfixedrepeatduration.js
var CheckoutDiscountFixedRepeatDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  duration_in_months: int(),
  type: DiscountType$inboundSchema,
  amount: int(),
  currency: string2(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "duration_in_months": "durationInMonths"
  });
}));
var CheckoutDiscountFixedRepeatDuration$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  durationInMonths: int(),
  type: DiscountType$outboundSchema,
  amount: int(),
  currency: string2(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    durationInMonths: "duration_in_months"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutdiscountpercentageonceforeverduration.js
var CheckoutDiscountPercentageOnceForeverDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  type: DiscountType$inboundSchema,
  basis_points: int(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "basis_points": "basisPoints"
  });
}));
var CheckoutDiscountPercentageOnceForeverDuration$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  type: DiscountType$outboundSchema,
  basisPoints: int(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    basisPoints: "basis_points"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutdiscountpercentagerepeatduration.js
var CheckoutDiscountPercentageRepeatDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  duration_in_months: int(),
  type: DiscountType$inboundSchema,
  basis_points: int(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "duration_in_months": "durationInMonths",
    "basis_points": "basisPoints"
  });
}));
var CheckoutDiscountPercentageRepeatDuration$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  durationInMonths: int(),
  type: DiscountType$outboundSchema,
  basisPoints: int(),
  id: string2(),
  name: string2(),
  code: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    durationInMonths: "duration_in_months",
    basisPoints: "basis_points"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefittype.js
var BenefitType = {
  Custom: "custom",
  Discord: "discord",
  GithubRepository: "github_repository",
  Downloadables: "downloadables",
  LicenseKeys: "license_keys",
  MeterCredit: "meter_credit"
};
var BenefitType$inboundSchema = _enum2(BenefitType);
var BenefitType$outboundSchema = BenefitType$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitpublic.js
var BenefitPublic$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: BenefitType$inboundSchema,
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));
var BenefitPublic$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  type: BenefitType$outboundSchema,
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organizationId: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricesource.js
var ProductPriceSource = {
  Catalog: "catalog",
  AdHoc: "ad_hoc"
};
var ProductPriceSource$inboundSchema = _enum2(ProductPriceSource);
var ProductPriceSource$outboundSchema = ProductPriceSource$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionrecurringinterval.js
var SubscriptionRecurringInterval = {
  Day: "day",
  Week: "week",
  Month: "month",
  Year: "year"
};
var SubscriptionRecurringInterval$inboundSchema = _enum2(SubscriptionRecurringInterval);
var SubscriptionRecurringInterval$outboundSchema = SubscriptionRecurringInterval$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/legacyrecurringproductpricecustom.js
var LegacyRecurringProductPriceCustom$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("custom"),
  is_archived: boolean2(),
  product_id: string2(),
  type: literal("recurring"),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  price_currency: string2(),
  minimum_amount: int(),
  maximum_amount: nullable(int()),
  preset_amount: nullable(int()),
  legacy: literal(true)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "price_currency": "priceCurrency",
    "minimum_amount": "minimumAmount",
    "maximum_amount": "maximumAmount",
    "preset_amount": "presetAmount"
  });
}));
var LegacyRecurringProductPriceCustom$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("custom"),
  isArchived: boolean2(),
  productId: string2(),
  type: literal("recurring"),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  priceCurrency: string2(),
  minimumAmount: int(),
  maximumAmount: nullable(int()),
  presetAmount: nullable(int()),
  legacy: literal(true)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval",
    priceCurrency: "price_currency",
    minimumAmount: "minimum_amount",
    maximumAmount: "maximum_amount",
    presetAmount: "preset_amount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/legacyrecurringproductpricefixed.js
var LegacyRecurringProductPriceFixed$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("fixed"),
  is_archived: boolean2(),
  product_id: string2(),
  type: literal("recurring"),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  price_currency: string2(),
  price_amount: int(),
  legacy: literal(true)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "price_currency": "priceCurrency",
    "price_amount": "priceAmount"
  });
}));
var LegacyRecurringProductPriceFixed$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("fixed"),
  isArchived: boolean2(),
  productId: string2(),
  type: literal("recurring"),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  priceCurrency: string2(),
  priceAmount: int(),
  legacy: literal(true)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval",
    priceCurrency: "price_currency",
    priceAmount: "price_amount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/legacyrecurringproductpricefree.js
var LegacyRecurringProductPriceFree$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("free"),
  is_archived: boolean2(),
  product_id: string2(),
  type: literal("recurring"),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  legacy: literal(true)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval"
  });
}));
var LegacyRecurringProductPriceFree$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("free"),
  isArchived: boolean2(),
  productId: string2(),
  type: literal("recurring"),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  legacy: literal(true)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/legacyrecurringproductprice.js
var LegacyRecurringProductPrice$inboundSchema = union([
  LegacyRecurringProductPriceCustom$inboundSchema,
  LegacyRecurringProductPriceFixed$inboundSchema,
  LegacyRecurringProductPriceFree$inboundSchema
]);
var LegacyRecurringProductPrice$outboundSchema = union([
  LegacyRecurringProductPriceCustom$outboundSchema,
  LegacyRecurringProductPriceFixed$outboundSchema,
  LegacyRecurringProductPriceFree$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productmediafileread.js
var ProductMediaFileRead$inboundSchema = pipe(object({
  id: string2(),
  organization_id: string2(),
  name: string2(),
  path: string2(),
  mime_type: string2(),
  size: int(),
  storage_version: nullable(string2()),
  checksum_etag: nullable(string2()),
  checksum_sha256_base64: nullable(string2()),
  checksum_sha256_hex: nullable(string2()),
  last_modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  version: nullable(string2()),
  service: literal("product_media"),
  is_uploaded: boolean2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  size_readable: string2(),
  public_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "mime_type": "mimeType",
    "storage_version": "storageVersion",
    "checksum_etag": "checksumEtag",
    "checksum_sha256_base64": "checksumSha256Base64",
    "checksum_sha256_hex": "checksumSha256Hex",
    "last_modified_at": "lastModifiedAt",
    "is_uploaded": "isUploaded",
    "created_at": "createdAt",
    "size_readable": "sizeReadable",
    "public_url": "publicUrl"
  });
}));
var ProductMediaFileRead$outboundSchema = pipe(object({
  id: string2(),
  organizationId: string2(),
  name: string2(),
  path: string2(),
  mimeType: string2(),
  size: int(),
  storageVersion: nullable(string2()),
  checksumEtag: nullable(string2()),
  checksumSha256Base64: nullable(string2()),
  checksumSha256Hex: nullable(string2()),
  lastModifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  version: nullable(string2()),
  service: literal("product_media"),
  isUploaded: boolean2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  sizeReadable: string2(),
  publicUrl: string2()
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    mimeType: "mime_type",
    storageVersion: "storage_version",
    checksumEtag: "checksum_etag",
    checksumSha256Base64: "checksum_sha256_base64",
    checksumSha256Hex: "checksum_sha256_hex",
    lastModifiedAt: "last_modified_at",
    isUploaded: "is_uploaded",
    createdAt: "created_at",
    sizeReadable: "size_readable",
    publicUrl: "public_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricetype.js
var ProductPriceType = {
  OneTime: "one_time",
  Recurring: "recurring"
};
var ProductPriceType$inboundSchema = _enum2(ProductPriceType);
var ProductPriceType$outboundSchema = ProductPriceType$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricecustom.js
var ProductPriceCustom$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("custom"),
  is_archived: boolean2(),
  product_id: string2(),
  type: ProductPriceType$inboundSchema,
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  price_currency: string2(),
  minimum_amount: int(),
  maximum_amount: nullable(int()),
  preset_amount: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "price_currency": "priceCurrency",
    "minimum_amount": "minimumAmount",
    "maximum_amount": "maximumAmount",
    "preset_amount": "presetAmount"
  });
}));
var ProductPriceCustom$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("custom"),
  isArchived: boolean2(),
  productId: string2(),
  type: ProductPriceType$outboundSchema,
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  priceCurrency: string2(),
  minimumAmount: int(),
  maximumAmount: nullable(int()),
  presetAmount: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval",
    priceCurrency: "price_currency",
    minimumAmount: "minimum_amount",
    maximumAmount: "maximum_amount",
    presetAmount: "preset_amount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricefixed.js
var ProductPriceFixed$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("fixed"),
  is_archived: boolean2(),
  product_id: string2(),
  type: ProductPriceType$inboundSchema,
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  price_currency: string2(),
  price_amount: int()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "price_currency": "priceCurrency",
    "price_amount": "priceAmount"
  });
}));
var ProductPriceFixed$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("fixed"),
  isArchived: boolean2(),
  productId: string2(),
  type: ProductPriceType$outboundSchema,
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  priceCurrency: string2(),
  priceAmount: int()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval",
    priceCurrency: "price_currency",
    priceAmount: "price_amount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricefree.js
var ProductPriceFree$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("free"),
  is_archived: boolean2(),
  product_id: string2(),
  type: ProductPriceType$inboundSchema,
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval"
  });
}));
var ProductPriceFree$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("free"),
  isArchived: boolean2(),
  productId: string2(),
  type: ProductPriceType$outboundSchema,
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricemeter.js
var ProductPriceMeter$inboundSchema = object({
  id: string2(),
  name: string2()
});
var ProductPriceMeter$outboundSchema = object({
  id: string2(),
  name: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricemeteredunit.js
var ProductPriceMeteredUnit$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("metered_unit"),
  is_archived: boolean2(),
  product_id: string2(),
  type: ProductPriceType$inboundSchema,
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  price_currency: string2(),
  unit_amount: string2(),
  cap_amount: nullable(int()),
  meter_id: string2(),
  meter: ProductPriceMeter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "price_currency": "priceCurrency",
    "unit_amount": "unitAmount",
    "cap_amount": "capAmount",
    "meter_id": "meterId"
  });
}));
var ProductPriceMeteredUnit$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("metered_unit"),
  isArchived: boolean2(),
  productId: string2(),
  type: ProductPriceType$outboundSchema,
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  priceCurrency: string2(),
  unitAmount: string2(),
  capAmount: nullable(int()),
  meterId: string2(),
  meter: ProductPriceMeter$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval",
    priceCurrency: "price_currency",
    unitAmount: "unit_amount",
    capAmount: "cap_amount",
    meterId: "meter_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpriceseattier.js
var ProductPriceSeatTier$inboundSchema = pipe(object({
  min_seats: int(),
  max_seats: optional(nullable(int())),
  price_per_seat: int()
}), transform((v2) => {
  return remap(v2, {
    "min_seats": "minSeats",
    "max_seats": "maxSeats",
    "price_per_seat": "pricePerSeat"
  });
}));
var ProductPriceSeatTier$outboundSchema = pipe(object({
  minSeats: int(),
  maxSeats: optional(nullable(int())),
  pricePerSeat: int()
}), transform((v2) => {
  return remap(v2, {
    minSeats: "min_seats",
    maxSeats: "max_seats",
    pricePerSeat: "price_per_seat"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpriceseattiersoutput.js
var ProductPriceSeatTiersOutput$inboundSchema = pipe(object({
  tiers: array(ProductPriceSeatTier$inboundSchema),
  minimum_seats: int(),
  maximum_seats: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    "minimum_seats": "minimumSeats",
    "maximum_seats": "maximumSeats"
  });
}));
var ProductPriceSeatTiersOutput$outboundSchema = pipe(object({
  tiers: array(ProductPriceSeatTier$outboundSchema),
  minimumSeats: int(),
  maximumSeats: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    minimumSeats: "minimum_seats",
    maximumSeats: "maximum_seats"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpriceseatbased.js
var ProductPriceSeatBased$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  source: ProductPriceSource$inboundSchema,
  amount_type: literal("seat_based"),
  is_archived: boolean2(),
  product_id: string2(),
  type: ProductPriceType$inboundSchema,
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  price_currency: string2(),
  seat_tiers: ProductPriceSeatTiersOutput$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "amount_type": "amountType",
    "is_archived": "isArchived",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "price_currency": "priceCurrency",
    "seat_tiers": "seatTiers"
  });
}));
var ProductPriceSeatBased$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  source: ProductPriceSource$outboundSchema,
  amountType: literal("seat_based"),
  isArchived: boolean2(),
  productId: string2(),
  type: ProductPriceType$outboundSchema,
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  priceCurrency: string2(),
  seatTiers: ProductPriceSeatTiersOutput$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    amountType: "amount_type",
    isArchived: "is_archived",
    productId: "product_id",
    recurringInterval: "recurring_interval",
    priceCurrency: "price_currency",
    seatTiers: "seat_tiers"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productprice.js
var ProductPrice$inboundSchema = union([
  ProductPriceCustom$inboundSchema,
  ProductPriceFixed$inboundSchema,
  ProductPriceFree$inboundSchema,
  ProductPriceMeteredUnit$inboundSchema,
  ProductPriceSeatBased$inboundSchema
]);
var ProductPrice$outboundSchema = union([
  ProductPriceCustom$outboundSchema,
  ProductPriceFixed$outboundSchema,
  ProductPriceFree$outboundSchema,
  ProductPriceMeteredUnit$outboundSchema,
  ProductPriceSeatBased$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/trialinterval.js
var TrialInterval = {
  Day: "day",
  Week: "week",
  Month: "month",
  Year: "year"
};
var TrialInterval$inboundSchema = _enum2(TrialInterval);
var TrialInterval$outboundSchema = TrialInterval$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutproduct.js
var CheckoutProductPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutProductPrices$outboundSchema = smartUnion([
  LegacyRecurringProductPrice$outboundSchema,
  ProductPrice$outboundSchema
]);
var CheckoutProduct$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2(),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  benefits: array(BenefitPublic$inboundSchema),
  medias: array(ProductMediaFileRead$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));
var CheckoutProduct$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialInterval: nullable(TrialInterval$outboundSchema),
  trialIntervalCount: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  recurringIntervalCount: nullable(int()),
  isRecurring: boolean2(),
  isArchived: boolean2(),
  organizationId: string2(),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$outboundSchema,
    ProductPrice$outboundSchema
  ])),
  benefits: array(BenefitPublic$outboundSchema),
  medias: array(ProductMediaFileRead$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count",
    isRecurring: "is_recurring",
    isArchived: "is_archived",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutstatus.js
var CheckoutStatus = {
  Open: "open",
  Expired: "expired",
  Confirmed: "confirmed",
  Succeeded: "succeeded",
  Failed: "failed"
};
var CheckoutStatus$inboundSchema = _enum2(CheckoutStatus);
var CheckoutStatus$outboundSchema = CheckoutStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/paymentprocessor.js
var PaymentProcessor = {
  Stripe: "stripe"
};
var PaymentProcessor$inboundSchema = _enum2(PaymentProcessor);
var PaymentProcessor$outboundSchema = PaymentProcessor$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkout.js
var CheckoutCustomFieldData$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
]);
var CheckoutCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var CheckoutProductPrice$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutProductPrice$outboundSchema = smartUnion([
  LegacyRecurringProductPrice$outboundSchema,
  ProductPrice$outboundSchema
]);
var CheckoutPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutPrices$outboundSchema = smartUnion([
  LegacyRecurringProductPrice$outboundSchema,
  ProductPrice$outboundSchema
]);
var CheckoutDiscount$inboundSchema = smartUnion([
  CheckoutDiscountFixedRepeatDuration$inboundSchema,
  CheckoutDiscountFixedOnceForeverDuration$inboundSchema,
  CheckoutDiscountPercentageRepeatDuration$inboundSchema,
  CheckoutDiscountPercentageOnceForeverDuration$inboundSchema
]);
var CheckoutDiscount$outboundSchema = smartUnion([
  CheckoutDiscountFixedRepeatDuration$outboundSchema,
  CheckoutDiscountFixedOnceForeverDuration$outboundSchema,
  CheckoutDiscountPercentageRepeatDuration$outboundSchema,
  CheckoutDiscountPercentageOnceForeverDuration$outboundSchema
]);
var CustomerMetadata$inboundSchema = smartUnion([string2(), int(), boolean2()]);
var CustomerMetadata$outboundSchema = smartUnion([string2(), int(), boolean2()]);
var Checkout$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  custom_field_data: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
  ])))),
  payment_processor: PaymentProcessor$inboundSchema,
  status: CheckoutStatus$inboundSchema,
  client_secret: string2(),
  url: string2(),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  success_url: string2(),
  return_url: nullable(string2()),
  embed_origin: nullable(string2()),
  amount: int(),
  seats: optional(nullable(int())),
  price_per_seat: optional(nullable(int())),
  discount_amount: int(),
  net_amount: int(),
  tax_amount: nullable(int()),
  total_amount: int(),
  currency: string2(),
  allow_trial: nullable(boolean2()),
  active_trial_interval: nullable(TrialInterval$inboundSchema),
  active_trial_interval_count: nullable(int()),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2(),
  product_id: nullable(string2()),
  product_price_id: nullable(string2()),
  discount_id: nullable(string2()),
  allow_discount_codes: boolean2(),
  require_billing_address: boolean2(),
  is_discount_applicable: boolean2(),
  is_free_product_price: boolean2(),
  is_payment_required: boolean2(),
  is_payment_setup_required: boolean2(),
  is_payment_form_required: boolean2(),
  customer_id: nullable(string2()),
  is_business_customer: boolean2(),
  customer_name: nullable(string2()),
  customer_email: nullable(string2()),
  customer_ip_address: nullable(string2()),
  customer_billing_name: nullable(string2()),
  customer_billing_address: nullable(Address$inboundSchema),
  customer_tax_id: nullable(string2()),
  payment_processor_metadata: record(string2(), string2()),
  billing_address_fields: CheckoutBillingAddressFields$inboundSchema,
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_customer_id: nullable(string2()),
  customer_external_id: nullable(string2()),
  products: array(CheckoutProduct$inboundSchema),
  product: nullable(CheckoutProduct$inboundSchema),
  product_price: nullable(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  prices: nullable(record(string2(), array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])))),
  discount: nullable(smartUnion([
    CheckoutDiscountFixedRepeatDuration$inboundSchema,
    CheckoutDiscountFixedOnceForeverDuration$inboundSchema,
    CheckoutDiscountPercentageRepeatDuration$inboundSchema,
    CheckoutDiscountPercentageOnceForeverDuration$inboundSchema
  ])),
  subscription_id: nullable(string2()),
  attached_custom_fields: nullable(array(AttachedCustomField$inboundSchema)),
  customer_metadata: record(string2(), smartUnion([string2(), int(), boolean2()]))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "custom_field_data": "customFieldData",
    "payment_processor": "paymentProcessor",
    "client_secret": "clientSecret",
    "expires_at": "expiresAt",
    "success_url": "successUrl",
    "return_url": "returnUrl",
    "embed_origin": "embedOrigin",
    "price_per_seat": "pricePerSeat",
    "discount_amount": "discountAmount",
    "net_amount": "netAmount",
    "tax_amount": "taxAmount",
    "total_amount": "totalAmount",
    "allow_trial": "allowTrial",
    "active_trial_interval": "activeTrialInterval",
    "active_trial_interval_count": "activeTrialIntervalCount",
    "trial_end": "trialEnd",
    "organization_id": "organizationId",
    "product_id": "productId",
    "product_price_id": "productPriceId",
    "discount_id": "discountId",
    "allow_discount_codes": "allowDiscountCodes",
    "require_billing_address": "requireBillingAddress",
    "is_discount_applicable": "isDiscountApplicable",
    "is_free_product_price": "isFreeProductPrice",
    "is_payment_required": "isPaymentRequired",
    "is_payment_setup_required": "isPaymentSetupRequired",
    "is_payment_form_required": "isPaymentFormRequired",
    "customer_id": "customerId",
    "is_business_customer": "isBusinessCustomer",
    "customer_name": "customerName",
    "customer_email": "customerEmail",
    "customer_ip_address": "customerIpAddress",
    "customer_billing_name": "customerBillingName",
    "customer_billing_address": "customerBillingAddress",
    "customer_tax_id": "customerTaxId",
    "payment_processor_metadata": "paymentProcessorMetadata",
    "billing_address_fields": "billingAddressFields",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "external_customer_id": "externalCustomerId",
    "customer_external_id": "customerExternalId",
    "product_price": "productPrice",
    "subscription_id": "subscriptionId",
    "attached_custom_fields": "attachedCustomFields",
    "customer_metadata": "customerMetadata"
  });
}));
var Checkout$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  paymentProcessor: PaymentProcessor$outboundSchema,
  status: CheckoutStatus$outboundSchema,
  clientSecret: string2(),
  url: string2(),
  expiresAt: pipe(date2(), transform((v2) => v2.toISOString())),
  successUrl: string2(),
  returnUrl: nullable(string2()),
  embedOrigin: nullable(string2()),
  amount: int(),
  seats: optional(nullable(int())),
  pricePerSeat: optional(nullable(int())),
  discountAmount: int(),
  netAmount: int(),
  taxAmount: nullable(int()),
  totalAmount: int(),
  currency: string2(),
  allowTrial: nullable(boolean2()),
  activeTrialInterval: nullable(TrialInterval$outboundSchema),
  activeTrialIntervalCount: nullable(int()),
  trialEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  organizationId: string2(),
  productId: nullable(string2()),
  productPriceId: nullable(string2()),
  discountId: nullable(string2()),
  allowDiscountCodes: boolean2(),
  requireBillingAddress: boolean2(),
  isDiscountApplicable: boolean2(),
  isFreeProductPrice: boolean2(),
  isPaymentRequired: boolean2(),
  isPaymentSetupRequired: boolean2(),
  isPaymentFormRequired: boolean2(),
  customerId: nullable(string2()),
  isBusinessCustomer: boolean2(),
  customerName: nullable(string2()),
  customerEmail: nullable(string2()),
  customerIpAddress: nullable(string2()),
  customerBillingName: nullable(string2()),
  customerBillingAddress: nullable(Address$outboundSchema),
  customerTaxId: nullable(string2()),
  paymentProcessorMetadata: record(string2(), string2()),
  billingAddressFields: CheckoutBillingAddressFields$outboundSchema,
  trialInterval: nullable(TrialInterval$outboundSchema),
  trialIntervalCount: nullable(int()),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  externalCustomerId: nullable(string2()),
  customerExternalId: nullable(string2()),
  products: array(CheckoutProduct$outboundSchema),
  product: nullable(CheckoutProduct$outboundSchema),
  productPrice: nullable(smartUnion([
    LegacyRecurringProductPrice$outboundSchema,
    ProductPrice$outboundSchema
  ])),
  prices: nullable(record(string2(), array(smartUnion([
    LegacyRecurringProductPrice$outboundSchema,
    ProductPrice$outboundSchema
  ])))),
  discount: nullable(smartUnion([
    CheckoutDiscountFixedRepeatDuration$outboundSchema,
    CheckoutDiscountFixedOnceForeverDuration$outboundSchema,
    CheckoutDiscountPercentageRepeatDuration$outboundSchema,
    CheckoutDiscountPercentageOnceForeverDuration$outboundSchema
  ])),
  subscriptionId: nullable(string2()),
  attachedCustomFields: nullable(array(AttachedCustomField$outboundSchema)),
  customerMetadata: record(string2(), smartUnion([string2(), int(), boolean2()]))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    customFieldData: "custom_field_data",
    paymentProcessor: "payment_processor",
    clientSecret: "client_secret",
    expiresAt: "expires_at",
    successUrl: "success_url",
    returnUrl: "return_url",
    embedOrigin: "embed_origin",
    pricePerSeat: "price_per_seat",
    discountAmount: "discount_amount",
    netAmount: "net_amount",
    taxAmount: "tax_amount",
    totalAmount: "total_amount",
    allowTrial: "allow_trial",
    activeTrialInterval: "active_trial_interval",
    activeTrialIntervalCount: "active_trial_interval_count",
    trialEnd: "trial_end",
    organizationId: "organization_id",
    productId: "product_id",
    productPriceId: "product_price_id",
    discountId: "discount_id",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    isDiscountApplicable: "is_discount_applicable",
    isFreeProductPrice: "is_free_product_price",
    isPaymentRequired: "is_payment_required",
    isPaymentSetupRequired: "is_payment_setup_required",
    isPaymentFormRequired: "is_payment_form_required",
    customerId: "customer_id",
    isBusinessCustomer: "is_business_customer",
    customerName: "customer_name",
    customerEmail: "customer_email",
    customerIpAddress: "customer_ip_address",
    customerBillingName: "customer_billing_name",
    customerBillingAddress: "customer_billing_address",
    customerTaxId: "customer_tax_id",
    paymentProcessorMetadata: "payment_processor_metadata",
    billingAddressFields: "billing_address_fields",
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    externalCustomerId: "external_customer_id",
    customerExternalId: "customer_external_id",
    productPrice: "product_price",
    subscriptionId: "subscription_id",
    attachedCustomFields: "attached_custom_fields",
    customerMetadata: "customer_metadata"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcheckoutcreatedpayload.js
var WebhookCheckoutCreatedPayload$inboundSchema = object({
  type: literal("checkout.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Checkout$inboundSchema
});
var WebhookCheckoutCreatedPayload$outboundSchema = object({
  type: literal("checkout.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Checkout$outboundSchema
});
function webhookCheckoutCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCheckoutCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCheckoutCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcheckoutupdatedpayload.js
var WebhookCheckoutUpdatedPayload$inboundSchema = object({
  type: literal("checkout.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Checkout$inboundSchema
});
var WebhookCheckoutUpdatedPayload$outboundSchema = object({
  type: literal("checkout.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Checkout$outboundSchema
});
function webhookCheckoutUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCheckoutUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCheckoutUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomercreatedpayload.js
var WebhookCustomerCreatedPayload$inboundSchema = object({
  type: literal("customer.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Customer$inboundSchema
});
var WebhookCustomerCreatedPayload$outboundSchema = object({
  type: literal("customer.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Customer$outboundSchema
});
function webhookCustomerCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomerdeletedpayload.js
var WebhookCustomerDeletedPayload$inboundSchema = object({
  type: literal("customer.deleted"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Customer$inboundSchema
});
var WebhookCustomerDeletedPayload$outboundSchema = object({
  type: literal("customer.deleted"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Customer$outboundSchema
});
function webhookCustomerDeletedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerDeletedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerDeletedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/seatstatus.js
var SeatStatus = {
  Pending: "pending",
  Claimed: "claimed",
  Revoked: "revoked"
};
var SeatStatus$inboundSchema = _enum2(SeatStatus);
var SeatStatus$outboundSchema = SeatStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerseat.js
var CustomerSeat$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  subscription_id: optional(nullable(string2())),
  order_id: optional(nullable(string2())),
  status: SeatStatus$inboundSchema,
  customer_id: optional(nullable(string2())),
  member_id: optional(nullable(string2())),
  email: optional(nullable(string2())),
  customer_email: optional(nullable(string2())),
  invitation_token_expires_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  claimed_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  seat_metadata: optional(nullable(record(string2(), any())))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "customer_email": "customerEmail",
    "invitation_token_expires_at": "invitationTokenExpiresAt",
    "claimed_at": "claimedAt",
    "revoked_at": "revokedAt",
    "seat_metadata": "seatMetadata"
  });
}));
var CustomerSeat$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  subscriptionId: optional(nullable(string2())),
  orderId: optional(nullable(string2())),
  status: SeatStatus$outboundSchema,
  customerId: optional(nullable(string2())),
  memberId: optional(nullable(string2())),
  email: optional(nullable(string2())),
  customerEmail: optional(nullable(string2())),
  invitationTokenExpiresAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  claimedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  revokedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  seatMetadata: optional(nullable(record(string2(), any())))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    subscriptionId: "subscription_id",
    orderId: "order_id",
    customerId: "customer_id",
    memberId: "member_id",
    customerEmail: "customer_email",
    invitationTokenExpiresAt: "invitation_token_expires_at",
    claimedAt: "claimed_at",
    revokedAt: "revoked_at",
    seatMetadata: "seat_metadata"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomerseatassignedpayload.js
var WebhookCustomerSeatAssignedPayload$inboundSchema = object({
  type: literal("customer_seat.assigned"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: CustomerSeat$inboundSchema
});
var WebhookCustomerSeatAssignedPayload$outboundSchema = object({
  type: literal("customer_seat.assigned"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: CustomerSeat$outboundSchema
});
function webhookCustomerSeatAssignedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerSeatAssignedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerSeatAssignedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomerseatclaimedpayload.js
var WebhookCustomerSeatClaimedPayload$inboundSchema = object({
  type: literal("customer_seat.claimed"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: CustomerSeat$inboundSchema
});
var WebhookCustomerSeatClaimedPayload$outboundSchema = object({
  type: literal("customer_seat.claimed"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: CustomerSeat$outboundSchema
});
function webhookCustomerSeatClaimedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerSeatClaimedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerSeatClaimedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomerseatrevokedpayload.js
var WebhookCustomerSeatRevokedPayload$inboundSchema = object({
  type: literal("customer_seat.revoked"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: CustomerSeat$inboundSchema
});
var WebhookCustomerSeatRevokedPayload$outboundSchema = object({
  type: literal("customer_seat.revoked"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: CustomerSeat$outboundSchema
});
function webhookCustomerSeatRevokedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerSeatRevokedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerSeatRevokedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerstatebenefitgrant.js
var CustomerStateBenefitGrantProperties$inboundSchema = smartUnion([
  BenefitGrantDiscordProperties$inboundSchema,
  BenefitGrantGitHubRepositoryProperties$inboundSchema,
  BenefitGrantDownloadablesProperties$inboundSchema,
  BenefitGrantLicenseKeysProperties$inboundSchema,
  BenefitGrantCustomProperties$inboundSchema
]);
var CustomerStateBenefitGrantProperties$outboundSchema = smartUnion([
  BenefitGrantDiscordProperties$outboundSchema,
  BenefitGrantGitHubRepositoryProperties$outboundSchema,
  BenefitGrantDownloadablesProperties$outboundSchema,
  BenefitGrantLicenseKeysProperties$outboundSchema,
  BenefitGrantCustomProperties$outboundSchema
]);
var CustomerStateBenefitGrant$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  granted_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  benefit_id: string2(),
  benefit_type: BenefitType$inboundSchema,
  benefit_metadata: record(string2(), MetadataOutputType$inboundSchema),
  properties: smartUnion([
    BenefitGrantDiscordProperties$inboundSchema,
    BenefitGrantGitHubRepositoryProperties$inboundSchema,
    BenefitGrantDownloadablesProperties$inboundSchema,
    BenefitGrantLicenseKeysProperties$inboundSchema,
    BenefitGrantCustomProperties$inboundSchema
  ])
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "benefit_id": "benefitId",
    "benefit_type": "benefitType",
    "benefit_metadata": "benefitMetadata"
  });
}));
var CustomerStateBenefitGrant$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  grantedAt: pipe(date2(), transform((v2) => v2.toISOString())),
  benefitId: string2(),
  benefitType: BenefitType$outboundSchema,
  benefitMetadata: record(string2(), MetadataOutputType$outboundSchema),
  properties: smartUnion([
    BenefitGrantDiscordProperties$outboundSchema,
    BenefitGrantGitHubRepositoryProperties$outboundSchema,
    BenefitGrantDownloadablesProperties$outboundSchema,
    BenefitGrantLicenseKeysProperties$outboundSchema,
    BenefitGrantCustomProperties$outboundSchema
  ])
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    grantedAt: "granted_at",
    benefitId: "benefit_id",
    benefitType: "benefit_type",
    benefitMetadata: "benefit_metadata"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerstatemeter.js
var CustomerStateMeter$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  meter_id: string2(),
  consumed_units: number2(),
  credited_units: int(),
  balance: number2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "meter_id": "meterId",
    "consumed_units": "consumedUnits",
    "credited_units": "creditedUnits"
  });
}));
var CustomerStateMeter$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  meterId: string2(),
  consumedUnits: number2(),
  creditedUnits: int(),
  balance: number2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    meterId: "meter_id",
    consumedUnits: "consumed_units",
    creditedUnits: "credited_units"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerstatesubscriptionmeter.js
var CustomerStateSubscriptionMeter$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  consumed_units: number2(),
  credited_units: int(),
  amount: int(),
  meter_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "consumed_units": "consumedUnits",
    "credited_units": "creditedUnits",
    "meter_id": "meterId"
  });
}));
var CustomerStateSubscriptionMeter$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  consumedUnits: number2(),
  creditedUnits: int(),
  amount: int(),
  meterId: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    consumedUnits: "consumed_units",
    creditedUnits: "credited_units",
    meterId: "meter_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerstatesubscription.js
var Status = {
  Active: "active",
  Trialing: "trialing"
};
var CustomerStateSubscriptionCustomFieldData$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
]);
var CustomerStateSubscriptionCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var Status$inboundSchema = _enum2(Status);
var Status$outboundSchema = Status$inboundSchema;
var CustomerStateSubscription$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  custom_field_data: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
  ])))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  status: Status$inboundSchema,
  amount: int(),
  currency: string2(),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  current_period_start: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  current_period_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_start: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  cancel_at_period_end: boolean2(),
  canceled_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  started_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  product_id: string2(),
  discount_id: nullable(string2()),
  meters: array(CustomerStateSubscriptionMeter$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "custom_field_data": "customFieldData",
    "recurring_interval": "recurringInterval",
    "current_period_start": "currentPeriodStart",
    "current_period_end": "currentPeriodEnd",
    "trial_start": "trialStart",
    "trial_end": "trialEnd",
    "cancel_at_period_end": "cancelAtPeriodEnd",
    "canceled_at": "canceledAt",
    "started_at": "startedAt",
    "ends_at": "endsAt",
    "product_id": "productId",
    "discount_id": "discountId"
  });
}));
var CustomerStateSubscription$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  status: Status$outboundSchema,
  amount: int(),
  currency: string2(),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  currentPeriodStart: pipe(date2(), transform((v2) => v2.toISOString())),
  currentPeriodEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialStart: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  cancelAtPeriodEnd: boolean2(),
  canceledAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  startedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  productId: string2(),
  discountId: nullable(string2()),
  meters: array(CustomerStateSubscriptionMeter$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    customFieldData: "custom_field_data",
    recurringInterval: "recurring_interval",
    currentPeriodStart: "current_period_start",
    currentPeriodEnd: "current_period_end",
    trialStart: "trial_start",
    trialEnd: "trial_end",
    cancelAtPeriodEnd: "cancel_at_period_end",
    canceledAt: "canceled_at",
    startedAt: "started_at",
    endsAt: "ends_at",
    productId: "product_id",
    discountId: "discount_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerstate.js
var CustomerStateTaxId$inboundSchema = smartUnion([string2(), TaxIDFormat$inboundSchema]);
var CustomerStateTaxId$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var CustomerState$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_id: nullable(string2()),
  email: string2(),
  email_verified: boolean2(),
  type: optional(nullable(CustomerType$inboundSchema)),
  name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  organization_id: string2(),
  deleted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  active_subscriptions: array(CustomerStateSubscription$inboundSchema),
  granted_benefits: array(CustomerStateBenefitGrant$inboundSchema),
  active_meters: array(CustomerStateMeter$inboundSchema),
  avatar_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "external_id": "externalId",
    "email_verified": "emailVerified",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "organization_id": "organizationId",
    "deleted_at": "deletedAt",
    "active_subscriptions": "activeSubscriptions",
    "granted_benefits": "grantedBenefits",
    "active_meters": "activeMeters",
    "avatar_url": "avatarUrl"
  });
}));
var CustomerState$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  externalId: nullable(string2()),
  email: string2(),
  emailVerified: boolean2(),
  type: optional(nullable(CustomerType$outboundSchema)),
  name: nullable(string2()),
  billingAddress: nullable(Address$outboundSchema),
  taxId: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema])))),
  organizationId: string2(),
  deletedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  activeSubscriptions: array(CustomerStateSubscription$outboundSchema),
  grantedBenefits: array(CustomerStateBenefitGrant$outboundSchema),
  activeMeters: array(CustomerStateMeter$outboundSchema),
  avatarUrl: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    externalId: "external_id",
    emailVerified: "email_verified",
    billingAddress: "billing_address",
    taxId: "tax_id",
    organizationId: "organization_id",
    deletedAt: "deleted_at",
    activeSubscriptions: "active_subscriptions",
    grantedBenefits: "granted_benefits",
    activeMeters: "active_meters",
    avatarUrl: "avatar_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomerstatechangedpayload.js
var WebhookCustomerStateChangedPayload$inboundSchema = object({
  type: literal("customer.state_changed"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: CustomerState$inboundSchema
});
var WebhookCustomerStateChangedPayload$outboundSchema = object({
  type: literal("customer.state_changed"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: CustomerState$outboundSchema
});
function webhookCustomerStateChangedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerStateChangedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerStateChangedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookcustomerupdatedpayload.js
var WebhookCustomerUpdatedPayload$inboundSchema = object({
  type: literal("customer.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Customer$inboundSchema
});
var WebhookCustomerUpdatedPayload$outboundSchema = object({
  type: literal("customer.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Customer$outboundSchema
});
function webhookCustomerUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookCustomerUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookCustomerUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountfixedonceforeverdurationbase.js
var DiscountFixedOnceForeverDurationBase$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  type: DiscountType$inboundSchema,
  amount: int(),
  currency: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));
var DiscountFixedOnceForeverDurationBase$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  type: DiscountType$outboundSchema,
  amount: int(),
  currency: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  name: string2(),
  code: nullable(string2()),
  startsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  maxRedemptions: nullable(int()),
  redemptionsCount: int(),
  organizationId: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    redemptionsCount: "redemptions_count",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountfixedrepeatdurationbase.js
var DiscountFixedRepeatDurationBase$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  duration_in_months: int(),
  type: DiscountType$inboundSchema,
  amount: int(),
  currency: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "duration_in_months": "durationInMonths",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));
var DiscountFixedRepeatDurationBase$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  durationInMonths: int(),
  type: DiscountType$outboundSchema,
  amount: int(),
  currency: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  name: string2(),
  code: nullable(string2()),
  startsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  maxRedemptions: nullable(int()),
  redemptionsCount: int(),
  organizationId: string2()
}), transform((v2) => {
  return remap(v2, {
    durationInMonths: "duration_in_months",
    createdAt: "created_at",
    modifiedAt: "modified_at",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    redemptionsCount: "redemptions_count",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountpercentageonceforeverdurationbase.js
var DiscountPercentageOnceForeverDurationBase$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  type: DiscountType$inboundSchema,
  basis_points: int(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "basis_points": "basisPoints",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));
var DiscountPercentageOnceForeverDurationBase$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  type: DiscountType$outboundSchema,
  basisPoints: int(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  name: string2(),
  code: nullable(string2()),
  startsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  maxRedemptions: nullable(int()),
  redemptionsCount: int(),
  organizationId: string2()
}), transform((v2) => {
  return remap(v2, {
    basisPoints: "basis_points",
    createdAt: "created_at",
    modifiedAt: "modified_at",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    redemptionsCount: "redemptions_count",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountpercentagerepeatdurationbase.js
var DiscountPercentageRepeatDurationBase$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  duration_in_months: int(),
  type: DiscountType$inboundSchema,
  basis_points: int(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "duration_in_months": "durationInMonths",
    "basis_points": "basisPoints",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));
var DiscountPercentageRepeatDurationBase$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  durationInMonths: int(),
  type: DiscountType$outboundSchema,
  basisPoints: int(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  name: string2(),
  code: nullable(string2()),
  startsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  maxRedemptions: nullable(int()),
  redemptionsCount: int(),
  organizationId: string2()
}), transform((v2) => {
  return remap(v2, {
    durationInMonths: "duration_in_months",
    basisPoints: "basis_points",
    createdAt: "created_at",
    modifiedAt: "modified_at",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    redemptionsCount: "redemptions_count",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderbillingreason.js
var OrderBillingReason = {
  Purchase: "purchase",
  SubscriptionCreate: "subscription_create",
  SubscriptionCycle: "subscription_cycle",
  SubscriptionUpdate: "subscription_update"
};
var OrderBillingReason$inboundSchema = _enum2(OrderBillingReason);
var OrderBillingReason$outboundSchema = OrderBillingReason$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/ordercustomer.js
var OrderCustomerTaxId$inboundSchema = smartUnion([string2(), TaxIDFormat$inboundSchema]);
var OrderCustomerTaxId$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var OrderCustomer$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_id: nullable(string2()),
  email: string2(),
  email_verified: boolean2(),
  type: optional(nullable(CustomerType$inboundSchema)),
  name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  organization_id: string2(),
  deleted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  avatar_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "external_id": "externalId",
    "email_verified": "emailVerified",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "organization_id": "organizationId",
    "deleted_at": "deletedAt",
    "avatar_url": "avatarUrl"
  });
}));
var OrderCustomer$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  externalId: nullable(string2()),
  email: string2(),
  emailVerified: boolean2(),
  type: optional(nullable(CustomerType$outboundSchema)),
  name: nullable(string2()),
  billingAddress: nullable(Address$outboundSchema),
  taxId: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema])))),
  organizationId: string2(),
  deletedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  avatarUrl: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    externalId: "external_id",
    emailVerified: "email_verified",
    billingAddress: "billing_address",
    taxId: "tax_id",
    organizationId: "organization_id",
    deletedAt: "deleted_at",
    avatarUrl: "avatar_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderitemschema.js
var OrderItemSchema$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  label: string2(),
  amount: int(),
  tax_amount: int(),
  proration: boolean2(),
  product_price_id: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "tax_amount": "taxAmount",
    "product_price_id": "productPriceId"
  });
}));
var OrderItemSchema$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  label: string2(),
  amount: int(),
  taxAmount: int(),
  proration: boolean2(),
  productPriceId: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    taxAmount: "tax_amount",
    productPriceId: "product_price_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderproduct.js
var OrderProduct$inboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));
var OrderProduct$outboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialInterval: nullable(TrialInterval$outboundSchema),
  trialIntervalCount: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  recurringIntervalCount: nullable(int()),
  isRecurring: boolean2(),
  isArchived: boolean2(),
  organizationId: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count",
    isRecurring: "is_recurring",
    isArchived: "is_archived",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderstatus.js
var OrderStatus = {
  Pending: "pending",
  Paid: "paid",
  Refunded: "refunded",
  PartiallyRefunded: "partially_refunded"
};
var OrderStatus$inboundSchema = _enum2(OrderStatus);
var OrderStatus$outboundSchema = OrderStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercancellationreason.js
var CustomerCancellationReason = {
  CustomerService: "customer_service",
  LowQuality: "low_quality",
  MissingFeatures: "missing_features",
  SwitchedService: "switched_service",
  TooComplex: "too_complex",
  TooExpensive: "too_expensive",
  Unused: "unused",
  Other: "other"
};
var CustomerCancellationReason$inboundSchema = _enum2(CustomerCancellationReason);
var CustomerCancellationReason$outboundSchema = CustomerCancellationReason$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionstatus.js
var SubscriptionStatus = {
  Incomplete: "incomplete",
  IncompleteExpired: "incomplete_expired",
  Trialing: "trialing",
  Active: "active",
  PastDue: "past_due",
  Canceled: "canceled",
  Unpaid: "unpaid"
};
var SubscriptionStatus$inboundSchema = _enum2(SubscriptionStatus);
var SubscriptionStatus$outboundSchema = SubscriptionStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/ordersubscription.js
var OrderSubscription$inboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  amount: int(),
  currency: string2(),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  recurring_interval_count: int(),
  status: SubscriptionStatus$inboundSchema,
  current_period_start: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  current_period_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_start: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  cancel_at_period_end: boolean2(),
  canceled_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  started_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ended_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  product_id: string2(),
  discount_id: nullable(string2()),
  checkout_id: nullable(string2()),
  seats: optional(nullable(int())),
  customer_cancellation_reason: nullable(CustomerCancellationReason$inboundSchema),
  customer_cancellation_comment: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "current_period_start": "currentPeriodStart",
    "current_period_end": "currentPeriodEnd",
    "trial_start": "trialStart",
    "trial_end": "trialEnd",
    "cancel_at_period_end": "cancelAtPeriodEnd",
    "canceled_at": "canceledAt",
    "started_at": "startedAt",
    "ends_at": "endsAt",
    "ended_at": "endedAt",
    "customer_id": "customerId",
    "product_id": "productId",
    "discount_id": "discountId",
    "checkout_id": "checkoutId",
    "customer_cancellation_reason": "customerCancellationReason",
    "customer_cancellation_comment": "customerCancellationComment"
  });
}));
var OrderSubscription$outboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  amount: int(),
  currency: string2(),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  recurringIntervalCount: int(),
  status: SubscriptionStatus$outboundSchema,
  currentPeriodStart: pipe(date2(), transform((v2) => v2.toISOString())),
  currentPeriodEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialStart: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  cancelAtPeriodEnd: boolean2(),
  canceledAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  startedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  customerId: string2(),
  productId: string2(),
  discountId: nullable(string2()),
  checkoutId: nullable(string2()),
  seats: optional(nullable(int())),
  customerCancellationReason: nullable(CustomerCancellationReason$outboundSchema),
  customerCancellationComment: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count",
    currentPeriodStart: "current_period_start",
    currentPeriodEnd: "current_period_end",
    trialStart: "trial_start",
    trialEnd: "trial_end",
    cancelAtPeriodEnd: "cancel_at_period_end",
    canceledAt: "canceled_at",
    startedAt: "started_at",
    endsAt: "ends_at",
    endedAt: "ended_at",
    customerId: "customer_id",
    productId: "product_id",
    discountId: "discount_id",
    checkoutId: "checkout_id",
    customerCancellationReason: "customer_cancellation_reason",
    customerCancellationComment: "customer_cancellation_comment"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/order.js
var OrderCustomFieldData$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
]);
var OrderCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var OrderDiscount$inboundSchema = smartUnion([
  DiscountFixedRepeatDurationBase$inboundSchema,
  DiscountFixedOnceForeverDurationBase$inboundSchema,
  DiscountPercentageRepeatDurationBase$inboundSchema,
  DiscountPercentageOnceForeverDurationBase$inboundSchema
]);
var OrderDiscount$outboundSchema = smartUnion([
  DiscountFixedRepeatDurationBase$outboundSchema,
  DiscountFixedOnceForeverDurationBase$outboundSchema,
  DiscountPercentageRepeatDurationBase$outboundSchema,
  DiscountPercentageOnceForeverDurationBase$outboundSchema
]);
var Order$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  status: OrderStatus$inboundSchema,
  paid: boolean2(),
  subtotal_amount: int(),
  discount_amount: int(),
  net_amount: int(),
  tax_amount: int(),
  total_amount: int(),
  applied_balance_amount: int(),
  due_amount: int(),
  refunded_amount: int(),
  refunded_tax_amount: int(),
  currency: string2(),
  billing_reason: OrderBillingReason$inboundSchema,
  billing_name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  invoice_number: string2(),
  is_invoice_generated: boolean2(),
  seats: optional(nullable(int())),
  customer_id: string2(),
  product_id: nullable(string2()),
  discount_id: nullable(string2()),
  subscription_id: nullable(string2()),
  checkout_id: nullable(string2()),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  custom_field_data: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
  ])))),
  platform_fee_amount: int(),
  platform_fee_currency: nullable(string2()),
  customer: OrderCustomer$inboundSchema,
  user_id: string2(),
  product: nullable(OrderProduct$inboundSchema),
  discount: nullable(smartUnion([
    DiscountFixedRepeatDurationBase$inboundSchema,
    DiscountFixedOnceForeverDurationBase$inboundSchema,
    DiscountPercentageRepeatDurationBase$inboundSchema,
    DiscountPercentageOnceForeverDurationBase$inboundSchema
  ])),
  subscription: nullable(OrderSubscription$inboundSchema),
  items: array(OrderItemSchema$inboundSchema),
  description: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "subtotal_amount": "subtotalAmount",
    "discount_amount": "discountAmount",
    "net_amount": "netAmount",
    "tax_amount": "taxAmount",
    "total_amount": "totalAmount",
    "applied_balance_amount": "appliedBalanceAmount",
    "due_amount": "dueAmount",
    "refunded_amount": "refundedAmount",
    "refunded_tax_amount": "refundedTaxAmount",
    "billing_reason": "billingReason",
    "billing_name": "billingName",
    "billing_address": "billingAddress",
    "invoice_number": "invoiceNumber",
    "is_invoice_generated": "isInvoiceGenerated",
    "customer_id": "customerId",
    "product_id": "productId",
    "discount_id": "discountId",
    "subscription_id": "subscriptionId",
    "checkout_id": "checkoutId",
    "custom_field_data": "customFieldData",
    "platform_fee_amount": "platformFeeAmount",
    "platform_fee_currency": "platformFeeCurrency",
    "user_id": "userId"
  });
}));
var Order$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  status: OrderStatus$outboundSchema,
  paid: boolean2(),
  subtotalAmount: int(),
  discountAmount: int(),
  netAmount: int(),
  taxAmount: int(),
  totalAmount: int(),
  appliedBalanceAmount: int(),
  dueAmount: int(),
  refundedAmount: int(),
  refundedTaxAmount: int(),
  currency: string2(),
  billingReason: OrderBillingReason$outboundSchema,
  billingName: nullable(string2()),
  billingAddress: nullable(Address$outboundSchema),
  invoiceNumber: string2(),
  isInvoiceGenerated: boolean2(),
  seats: optional(nullable(int())),
  customerId: string2(),
  productId: nullable(string2()),
  discountId: nullable(string2()),
  subscriptionId: nullable(string2()),
  checkoutId: nullable(string2()),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  platformFeeAmount: int(),
  platformFeeCurrency: nullable(string2()),
  customer: OrderCustomer$outboundSchema,
  userId: string2(),
  product: nullable(OrderProduct$outboundSchema),
  discount: nullable(smartUnion([
    DiscountFixedRepeatDurationBase$outboundSchema,
    DiscountFixedOnceForeverDurationBase$outboundSchema,
    DiscountPercentageRepeatDurationBase$outboundSchema,
    DiscountPercentageOnceForeverDurationBase$outboundSchema
  ])),
  subscription: nullable(OrderSubscription$outboundSchema),
  items: array(OrderItemSchema$outboundSchema),
  description: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    subtotalAmount: "subtotal_amount",
    discountAmount: "discount_amount",
    netAmount: "net_amount",
    taxAmount: "tax_amount",
    totalAmount: "total_amount",
    appliedBalanceAmount: "applied_balance_amount",
    dueAmount: "due_amount",
    refundedAmount: "refunded_amount",
    refundedTaxAmount: "refunded_tax_amount",
    billingReason: "billing_reason",
    billingName: "billing_name",
    billingAddress: "billing_address",
    invoiceNumber: "invoice_number",
    isInvoiceGenerated: "is_invoice_generated",
    customerId: "customer_id",
    productId: "product_id",
    discountId: "discount_id",
    subscriptionId: "subscription_id",
    checkoutId: "checkout_id",
    customFieldData: "custom_field_data",
    platformFeeAmount: "platform_fee_amount",
    platformFeeCurrency: "platform_fee_currency",
    userId: "user_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookordercreatedpayload.js
var WebhookOrderCreatedPayload$inboundSchema = object({
  type: literal("order.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Order$inboundSchema
});
var WebhookOrderCreatedPayload$outboundSchema = object({
  type: literal("order.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Order$outboundSchema
});
function webhookOrderCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookOrderCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookOrderCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookorderpaidpayload.js
var WebhookOrderPaidPayload$inboundSchema = object({
  type: literal("order.paid"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Order$inboundSchema
});
var WebhookOrderPaidPayload$outboundSchema = object({
  type: literal("order.paid"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Order$outboundSchema
});
function webhookOrderPaidPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookOrderPaidPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookOrderPaidPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookorderrefundedpayload.js
var WebhookOrderRefundedPayload$inboundSchema = object({
  type: literal("order.refunded"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Order$inboundSchema
});
var WebhookOrderRefundedPayload$outboundSchema = object({
  type: literal("order.refunded"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Order$outboundSchema
});
function webhookOrderRefundedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookOrderRefundedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookOrderRefundedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookorderupdatedpayload.js
var WebhookOrderUpdatedPayload$inboundSchema = object({
  type: literal("order.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Order$inboundSchema
});
var WebhookOrderUpdatedPayload$outboundSchema = object({
  type: literal("order.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Order$outboundSchema
});
function webhookOrderUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookOrderUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookOrderUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationcustomeremailsettings.js
var OrganizationCustomerEmailSettings$inboundSchema = pipe(object({
  order_confirmation: boolean2(),
  subscription_cancellation: boolean2(),
  subscription_confirmation: boolean2(),
  subscription_cycled: boolean2(),
  subscription_past_due: boolean2(),
  subscription_revoked: boolean2(),
  subscription_uncanceled: boolean2(),
  subscription_updated: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "order_confirmation": "orderConfirmation",
    "subscription_cancellation": "subscriptionCancellation",
    "subscription_confirmation": "subscriptionConfirmation",
    "subscription_cycled": "subscriptionCycled",
    "subscription_past_due": "subscriptionPastDue",
    "subscription_revoked": "subscriptionRevoked",
    "subscription_uncanceled": "subscriptionUncanceled",
    "subscription_updated": "subscriptionUpdated"
  });
}));
var OrganizationCustomerEmailSettings$outboundSchema = pipe(object({
  orderConfirmation: boolean2(),
  subscriptionCancellation: boolean2(),
  subscriptionConfirmation: boolean2(),
  subscriptionCycled: boolean2(),
  subscriptionPastDue: boolean2(),
  subscriptionRevoked: boolean2(),
  subscriptionUncanceled: boolean2(),
  subscriptionUpdated: boolean2()
}), transform((v2) => {
  return remap(v2, {
    orderConfirmation: "order_confirmation",
    subscriptionCancellation: "subscription_cancellation",
    subscriptionConfirmation: "subscription_confirmation",
    subscriptionCycled: "subscription_cycled",
    subscriptionPastDue: "subscription_past_due",
    subscriptionRevoked: "subscription_revoked",
    subscriptionUncanceled: "subscription_uncanceled",
    subscriptionUpdated: "subscription_updated"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerportalsubscriptionsettings.js
var CustomerPortalSubscriptionSettings$inboundSchema = pipe(object({
  update_seats: boolean2(),
  update_plan: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "update_seats": "updateSeats",
    "update_plan": "updatePlan"
  });
}));
var CustomerPortalSubscriptionSettings$outboundSchema = pipe(object({
  updateSeats: boolean2(),
  updatePlan: boolean2()
}), transform((v2) => {
  return remap(v2, {
    updateSeats: "update_seats",
    updatePlan: "update_plan"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerportalusagesettings.js
var CustomerPortalUsageSettings$inboundSchema = object({
  show: boolean2()
});
var CustomerPortalUsageSettings$outboundSchema = object({
  show: boolean2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationcustomerportalsettings.js
var OrganizationCustomerPortalSettings$inboundSchema = object({
  usage: CustomerPortalUsageSettings$inboundSchema,
  subscription: CustomerPortalSubscriptionSettings$inboundSchema
});
var OrganizationCustomerPortalSettings$outboundSchema = object({
  usage: CustomerPortalUsageSettings$outboundSchema,
  subscription: CustomerPortalSubscriptionSettings$outboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationfeaturesettings.js
var OrganizationFeatureSettings$inboundSchema = pipe(object({
  issue_funding_enabled: _default2(boolean2(), false),
  seat_based_pricing_enabled: _default2(boolean2(), false),
  revops_enabled: _default2(boolean2(), false),
  wallets_enabled: _default2(boolean2(), false),
  member_model_enabled: _default2(boolean2(), false)
}), transform((v2) => {
  return remap(v2, {
    "issue_funding_enabled": "issueFundingEnabled",
    "seat_based_pricing_enabled": "seatBasedPricingEnabled",
    "revops_enabled": "revopsEnabled",
    "wallets_enabled": "walletsEnabled",
    "member_model_enabled": "memberModelEnabled"
  });
}));
var OrganizationFeatureSettings$outboundSchema = pipe(object({
  issueFundingEnabled: _default2(boolean2(), false),
  seatBasedPricingEnabled: _default2(boolean2(), false),
  revopsEnabled: _default2(boolean2(), false),
  walletsEnabled: _default2(boolean2(), false),
  memberModelEnabled: _default2(boolean2(), false)
}), transform((v2) => {
  return remap(v2, {
    issueFundingEnabled: "issue_funding_enabled",
    seatBasedPricingEnabled: "seat_based_pricing_enabled",
    revopsEnabled: "revops_enabled",
    walletsEnabled: "wallets_enabled",
    memberModelEnabled: "member_model_enabled"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationnotificationsettings.js
var OrganizationNotificationSettings$inboundSchema = pipe(object({
  new_order: boolean2(),
  new_subscription: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "new_order": "newOrder",
    "new_subscription": "newSubscription"
  });
}));
var OrganizationNotificationSettings$outboundSchema = pipe(object({
  newOrder: boolean2(),
  newSubscription: boolean2()
}), transform((v2) => {
  return remap(v2, {
    newOrder: "new_order",
    newSubscription: "new_subscription"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationsocialplatforms.js
var OrganizationSocialPlatforms = {
  X: "x",
  Github: "github",
  Facebook: "facebook",
  Instagram: "instagram",
  Youtube: "youtube",
  Tiktok: "tiktok",
  Linkedin: "linkedin",
  Other: "other"
};
var OrganizationSocialPlatforms$inboundSchema = _enum2(OrganizationSocialPlatforms);
var OrganizationSocialPlatforms$outboundSchema = OrganizationSocialPlatforms$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationsociallink.js
var OrganizationSocialLink$inboundSchema = object({
  platform: OrganizationSocialPlatforms$inboundSchema,
  url: string2()
});
var OrganizationSocialLink$outboundSchema = object({
  platform: OrganizationSocialPlatforms$outboundSchema,
  url: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationstatus.js
var OrganizationStatus = {
  Created: "created",
  OnboardingStarted: "onboarding_started",
  InitialReview: "initial_review",
  OngoingReview: "ongoing_review",
  Denied: "denied",
  Active: "active"
};
var OrganizationStatus$inboundSchema = _enum2(OrganizationStatus);
var OrganizationStatus$outboundSchema = OrganizationStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionprorationbehavior.js
var SubscriptionProrationBehavior = {
  Invoice: "invoice",
  Prorate: "prorate"
};
var SubscriptionProrationBehavior$inboundSchema = _enum2(SubscriptionProrationBehavior);
var SubscriptionProrationBehavior$outboundSchema = SubscriptionProrationBehavior$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationsubscriptionsettings.js
var OrganizationSubscriptionSettings$inboundSchema = pipe(object({
  allow_multiple_subscriptions: boolean2(),
  allow_customer_updates: boolean2(),
  proration_behavior: SubscriptionProrationBehavior$inboundSchema,
  benefit_revocation_grace_period: int(),
  prevent_trial_abuse: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "allow_multiple_subscriptions": "allowMultipleSubscriptions",
    "allow_customer_updates": "allowCustomerUpdates",
    "proration_behavior": "prorationBehavior",
    "benefit_revocation_grace_period": "benefitRevocationGracePeriod",
    "prevent_trial_abuse": "preventTrialAbuse"
  });
}));
var OrganizationSubscriptionSettings$outboundSchema = pipe(object({
  allowMultipleSubscriptions: boolean2(),
  allowCustomerUpdates: boolean2(),
  prorationBehavior: SubscriptionProrationBehavior$outboundSchema,
  benefitRevocationGracePeriod: int(),
  preventTrialAbuse: boolean2()
}), transform((v2) => {
  return remap(v2, {
    allowMultipleSubscriptions: "allow_multiple_subscriptions",
    allowCustomerUpdates: "allow_customer_updates",
    prorationBehavior: "proration_behavior",
    benefitRevocationGracePeriod: "benefit_revocation_grace_period",
    preventTrialAbuse: "prevent_trial_abuse"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organization.js
var Organization$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  slug: string2(),
  avatar_url: nullable(string2()),
  proration_behavior: SubscriptionProrationBehavior$inboundSchema,
  allow_customer_updates: boolean2(),
  email: nullable(string2()),
  website: nullable(string2()),
  socials: array(OrganizationSocialLink$inboundSchema),
  status: OrganizationStatus$inboundSchema,
  details_submitted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  feature_settings: nullable(OrganizationFeatureSettings$inboundSchema),
  subscription_settings: OrganizationSubscriptionSettings$inboundSchema,
  notification_settings: OrganizationNotificationSettings$inboundSchema,
  customer_email_settings: OrganizationCustomerEmailSettings$inboundSchema,
  customer_portal_settings: OrganizationCustomerPortalSettings$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "avatar_url": "avatarUrl",
    "proration_behavior": "prorationBehavior",
    "allow_customer_updates": "allowCustomerUpdates",
    "details_submitted_at": "detailsSubmittedAt",
    "feature_settings": "featureSettings",
    "subscription_settings": "subscriptionSettings",
    "notification_settings": "notificationSettings",
    "customer_email_settings": "customerEmailSettings",
    "customer_portal_settings": "customerPortalSettings"
  });
}));
var Organization$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  name: string2(),
  slug: string2(),
  avatarUrl: nullable(string2()),
  prorationBehavior: SubscriptionProrationBehavior$outboundSchema,
  allowCustomerUpdates: boolean2(),
  email: nullable(string2()),
  website: nullable(string2()),
  socials: array(OrganizationSocialLink$outboundSchema),
  status: OrganizationStatus$outboundSchema,
  detailsSubmittedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  featureSettings: nullable(OrganizationFeatureSettings$outboundSchema),
  subscriptionSettings: OrganizationSubscriptionSettings$outboundSchema,
  notificationSettings: OrganizationNotificationSettings$outboundSchema,
  customerEmailSettings: OrganizationCustomerEmailSettings$outboundSchema,
  customerPortalSettings: OrganizationCustomerPortalSettings$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    avatarUrl: "avatar_url",
    prorationBehavior: "proration_behavior",
    allowCustomerUpdates: "allow_customer_updates",
    detailsSubmittedAt: "details_submitted_at",
    featureSettings: "feature_settings",
    subscriptionSettings: "subscription_settings",
    notificationSettings: "notification_settings",
    customerEmailSettings: "customer_email_settings",
    customerPortalSettings: "customer_portal_settings"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookorganizationupdatedpayload.js
var WebhookOrganizationUpdatedPayload$inboundSchema = object({
  type: literal("organization.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Organization$inboundSchema
});
var WebhookOrganizationUpdatedPayload$outboundSchema = object({
  type: literal("organization.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Organization$outboundSchema
});
function webhookOrganizationUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookOrganizationUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookOrganizationUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/product.js
var Prices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var Prices$outboundSchema = smartUnion([
  LegacyRecurringProductPrice$outboundSchema,
  ProductPrice$outboundSchema
]);
var Product$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  benefits: array(Benefit$inboundSchema),
  medias: array(ProductMediaFileRead$inboundSchema),
  attached_custom_fields: array(AttachedCustomField$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId",
    "attached_custom_fields": "attachedCustomFields"
  });
}));
var Product$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialInterval: nullable(TrialInterval$outboundSchema),
  trialIntervalCount: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurringInterval: nullable(SubscriptionRecurringInterval$outboundSchema),
  recurringIntervalCount: nullable(int()),
  isRecurring: boolean2(),
  isArchived: boolean2(),
  organizationId: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$outboundSchema,
    ProductPrice$outboundSchema
  ])),
  benefits: array(Benefit$outboundSchema),
  medias: array(ProductMediaFileRead$outboundSchema),
  attachedCustomFields: array(AttachedCustomField$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count",
    isRecurring: "is_recurring",
    isArchived: "is_archived",
    organizationId: "organization_id",
    attachedCustomFields: "attached_custom_fields"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookproductcreatedpayload.js
var WebhookProductCreatedPayload$inboundSchema = object({
  type: literal("product.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Product$inboundSchema
});
var WebhookProductCreatedPayload$outboundSchema = object({
  type: literal("product.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Product$outboundSchema
});
function webhookProductCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookProductCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookProductCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookproductupdatedpayload.js
var WebhookProductUpdatedPayload$inboundSchema = object({
  type: literal("product.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Product$inboundSchema
});
var WebhookProductUpdatedPayload$outboundSchema = object({
  type: literal("product.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Product$outboundSchema
});
function webhookProductUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookProductUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookProductUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/disputestatus.js
var DisputeStatus = {
  Prevented: "prevented",
  EarlyWarning: "early_warning",
  NeedsResponse: "needs_response",
  UnderReview: "under_review",
  Lost: "lost",
  Won: "won"
};
var DisputeStatus$inboundSchema = _enum2(DisputeStatus);
var DisputeStatus$outboundSchema = DisputeStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refunddispute.js
var RefundDispute$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  status: DisputeStatus$inboundSchema,
  resolved: boolean2(),
  closed: boolean2(),
  amount: int(),
  tax_amount: int(),
  currency: string2(),
  order_id: string2(),
  payment_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "tax_amount": "taxAmount",
    "order_id": "orderId",
    "payment_id": "paymentId"
  });
}));
var RefundDispute$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  status: DisputeStatus$outboundSchema,
  resolved: boolean2(),
  closed: boolean2(),
  amount: int(),
  taxAmount: int(),
  currency: string2(),
  orderId: string2(),
  paymentId: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    taxAmount: "tax_amount",
    orderId: "order_id",
    paymentId: "payment_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refundreason.js
var RefundReason = {
  Duplicate: "duplicate",
  Fraudulent: "fraudulent",
  CustomerRequest: "customer_request",
  ServiceDisruption: "service_disruption",
  SatisfactionGuarantee: "satisfaction_guarantee",
  DisputePrevention: "dispute_prevention",
  Other: "other"
};
var RefundReason$inboundSchema = _enum2(RefundReason);
var RefundReason$outboundSchema = RefundReason$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refundstatus.js
var RefundStatus = {
  Pending: "pending",
  Succeeded: "succeeded",
  Failed: "failed",
  Canceled: "canceled"
};
var RefundStatus$inboundSchema = _enum2(RefundStatus);
var RefundStatus$outboundSchema = RefundStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refund.js
var Refund$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  status: RefundStatus$inboundSchema,
  reason: RefundReason$inboundSchema,
  amount: int(),
  tax_amount: int(),
  currency: string2(),
  organization_id: string2(),
  order_id: string2(),
  subscription_id: nullable(string2()),
  customer_id: string2(),
  revoke_benefits: boolean2(),
  dispute: nullable(RefundDispute$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "tax_amount": "taxAmount",
    "organization_id": "organizationId",
    "order_id": "orderId",
    "subscription_id": "subscriptionId",
    "customer_id": "customerId",
    "revoke_benefits": "revokeBenefits"
  });
}));
var Refund$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  status: RefundStatus$outboundSchema,
  reason: RefundReason$outboundSchema,
  amount: int(),
  taxAmount: int(),
  currency: string2(),
  organizationId: string2(),
  orderId: string2(),
  subscriptionId: nullable(string2()),
  customerId: string2(),
  revokeBenefits: boolean2(),
  dispute: nullable(RefundDispute$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    taxAmount: "tax_amount",
    organizationId: "organization_id",
    orderId: "order_id",
    subscriptionId: "subscription_id",
    customerId: "customer_id",
    revokeBenefits: "revoke_benefits"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookrefundcreatedpayload.js
var WebhookRefundCreatedPayload$inboundSchema = object({
  type: literal("refund.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Refund$inboundSchema
});
var WebhookRefundCreatedPayload$outboundSchema = object({
  type: literal("refund.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Refund$outboundSchema
});
function webhookRefundCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookRefundCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookRefundCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookrefundupdatedpayload.js
var WebhookRefundUpdatedPayload$inboundSchema = object({
  type: literal("refund.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Refund$inboundSchema
});
var WebhookRefundUpdatedPayload$outboundSchema = object({
  type: literal("refund.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Refund$outboundSchema
});
function webhookRefundUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookRefundUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookRefundUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncustomer.js
var TaxId$inboundSchema = smartUnion([
  string2(),
  TaxIDFormat$inboundSchema
]);
var TaxId$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var SubscriptionCustomer$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_id: nullable(string2()),
  email: string2(),
  email_verified: boolean2(),
  type: optional(nullable(CustomerType$inboundSchema)),
  name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  organization_id: string2(),
  deleted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  avatar_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "external_id": "externalId",
    "email_verified": "emailVerified",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "organization_id": "organizationId",
    "deleted_at": "deletedAt",
    "avatar_url": "avatarUrl"
  });
}));
var SubscriptionCustomer$outboundSchema = pipe(object({
  id: string2(),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  externalId: nullable(string2()),
  email: string2(),
  emailVerified: boolean2(),
  type: optional(nullable(CustomerType$outboundSchema)),
  name: nullable(string2()),
  billingAddress: nullable(Address$outboundSchema),
  taxId: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema])))),
  organizationId: string2(),
  deletedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  avatarUrl: string2()
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    externalId: "external_id",
    emailVerified: "email_verified",
    billingAddress: "billing_address",
    taxId: "tax_id",
    organizationId: "organization_id",
    deletedAt: "deleted_at",
    avatarUrl: "avatar_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/countaggregation.js
var CountAggregation$inboundSchema = object({
  func: literal("count")
});
var CountAggregation$outboundSchema = object({
  func: literal("count")
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filteroperator.js
var FilterOperator = {
  Eq: "eq",
  Ne: "ne",
  Gt: "gt",
  Gte: "gte",
  Lt: "lt",
  Lte: "lte",
  Like: "like",
  NotLike: "not_like"
};
var FilterOperator$inboundSchema = _enum2(FilterOperator);
var FilterOperator$outboundSchema = FilterOperator$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filterclause.js
var Value$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2()
]);
var Value$outboundSchema = smartUnion([string2(), int(), boolean2()]);
var FilterClause$inboundSchema = object({
  property: string2(),
  operator: FilterOperator$inboundSchema,
  value: smartUnion([string2(), int(), boolean2()])
});
var FilterClause$outboundSchema = object({
  property: string2(),
  operator: FilterOperator$outboundSchema,
  value: smartUnion([string2(), int(), boolean2()])
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filterconjunction.js
var FilterConjunction = {
  And: "and",
  Or: "or"
};
var FilterConjunction$inboundSchema = _enum2(FilterConjunction);
var FilterConjunction$outboundSchema = FilterConjunction$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filter.js
var Filter$inboundSchema = object({
  conjunction: FilterConjunction$inboundSchema,
  clauses: array(smartUnion([
    FilterClause$inboundSchema,
    _lazy2(() => Filter$inboundSchema)
  ]))
});
var Filter$outboundSchema = object({
  conjunction: FilterConjunction$outboundSchema,
  clauses: array(smartUnion([
    FilterClause$outboundSchema,
    _lazy2(() => Filter$outboundSchema)
  ]))
});
var Clauses$inboundSchema = smartUnion([FilterClause$inboundSchema, _lazy2(() => Filter$inboundSchema)]);
var Clauses$outboundSchema = smartUnion([
  FilterClause$outboundSchema,
  _lazy2(() => Filter$outboundSchema)
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/propertyaggregation.js
var Func = {
  Sum: "sum",
  Max: "max",
  Min: "min",
  Avg: "avg"
};
var Func$inboundSchema = _enum2(Func);
var Func$outboundSchema = Func$inboundSchema;
var PropertyAggregation$inboundSchema = object({
  func: Func$inboundSchema,
  property: string2()
});
var PropertyAggregation$outboundSchema = object({
  func: Func$outboundSchema,
  property: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/uniqueaggregation.js
var UniqueAggregation$inboundSchema = object({
  func: literal("unique"),
  property: string2()
});
var UniqueAggregation$outboundSchema = object({
  func: literal("unique"),
  property: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/meter.js
var MeterAggregation$inboundSchema = union([
  intersection(PropertyAggregation$inboundSchema, object({ func: literal("avg") })),
  CountAggregation$inboundSchema,
  intersection(PropertyAggregation$inboundSchema, object({ func: literal("max") })),
  intersection(PropertyAggregation$inboundSchema, object({ func: literal("min") })),
  intersection(PropertyAggregation$inboundSchema, object({ func: literal("sum") })),
  UniqueAggregation$inboundSchema
]);
var MeterAggregation$outboundSchema = union([
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("avg") })),
  CountAggregation$outboundSchema,
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("max") })),
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("min") })),
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("sum") })),
  UniqueAggregation$outboundSchema
]);
var Meter$inboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  filter: Filter$inboundSchema,
  aggregation: union([
    intersection(PropertyAggregation$inboundSchema, object({ func: literal("avg") })),
    CountAggregation$inboundSchema,
    intersection(PropertyAggregation$inboundSchema, object({ func: literal("max") })),
    intersection(PropertyAggregation$inboundSchema, object({ func: literal("min") })),
    intersection(PropertyAggregation$inboundSchema, object({ func: literal("sum") })),
    UniqueAggregation$inboundSchema
  ]),
  organization_id: string2(),
  archived_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId",
    "archived_at": "archivedAt"
  });
}));
var Meter$outboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  name: string2(),
  filter: Filter$outboundSchema,
  aggregation: union([
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("avg") })),
    CountAggregation$outboundSchema,
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("max") })),
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("min") })),
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("sum") })),
    UniqueAggregation$outboundSchema
  ]),
  organizationId: string2(),
  archivedAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString()))))
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    organizationId: "organization_id",
    archivedAt: "archived_at"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionmeter.js
var SubscriptionMeter$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  consumed_units: number2(),
  credited_units: int(),
  amount: int(),
  meter_id: string2(),
  meter: Meter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "consumed_units": "consumedUnits",
    "credited_units": "creditedUnits",
    "meter_id": "meterId"
  });
}));
var SubscriptionMeter$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  consumedUnits: number2(),
  creditedUnits: int(),
  amount: int(),
  meterId: string2(),
  meter: Meter$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    consumedUnits: "consumed_units",
    creditedUnits: "credited_units",
    meterId: "meter_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscription.js
var CustomFieldData$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
]);
var CustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var SubscriptionDiscount$inboundSchema = smartUnion([
  DiscountFixedRepeatDurationBase$inboundSchema,
  DiscountFixedOnceForeverDurationBase$inboundSchema,
  DiscountPercentageRepeatDurationBase$inboundSchema,
  DiscountPercentageOnceForeverDurationBase$inboundSchema
]);
var SubscriptionDiscount$outboundSchema = smartUnion([
  DiscountFixedRepeatDurationBase$outboundSchema,
  DiscountFixedOnceForeverDurationBase$outboundSchema,
  DiscountPercentageRepeatDurationBase$outboundSchema,
  DiscountPercentageOnceForeverDurationBase$outboundSchema
]);
var SubscriptionPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var SubscriptionPrices$outboundSchema = smartUnion([
  LegacyRecurringProductPrice$outboundSchema,
  ProductPrice$outboundSchema
]);
var Subscription$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  amount: int(),
  currency: string2(),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  recurring_interval_count: int(),
  status: SubscriptionStatus$inboundSchema,
  current_period_start: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  current_period_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_start: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  cancel_at_period_end: boolean2(),
  canceled_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  started_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ended_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  product_id: string2(),
  discount_id: nullable(string2()),
  checkout_id: nullable(string2()),
  seats: optional(nullable(int())),
  customer_cancellation_reason: nullable(CustomerCancellationReason$inboundSchema),
  customer_cancellation_comment: nullable(string2()),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  custom_field_data: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
  ])))),
  customer: SubscriptionCustomer$inboundSchema,
  product: Product$inboundSchema,
  discount: nullable(smartUnion([
    DiscountFixedRepeatDurationBase$inboundSchema,
    DiscountFixedOnceForeverDurationBase$inboundSchema,
    DiscountPercentageRepeatDurationBase$inboundSchema,
    DiscountPercentageOnceForeverDurationBase$inboundSchema
  ])),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  meters: array(SubscriptionMeter$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "current_period_start": "currentPeriodStart",
    "current_period_end": "currentPeriodEnd",
    "trial_start": "trialStart",
    "trial_end": "trialEnd",
    "cancel_at_period_end": "cancelAtPeriodEnd",
    "canceled_at": "canceledAt",
    "started_at": "startedAt",
    "ends_at": "endsAt",
    "ended_at": "endedAt",
    "customer_id": "customerId",
    "product_id": "productId",
    "discount_id": "discountId",
    "checkout_id": "checkoutId",
    "customer_cancellation_reason": "customerCancellationReason",
    "customer_cancellation_comment": "customerCancellationComment",
    "custom_field_data": "customFieldData"
  });
}));
var Subscription$outboundSchema = pipe(object({
  createdAt: pipe(date2(), transform((v2) => v2.toISOString())),
  modifiedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  id: string2(),
  amount: int(),
  currency: string2(),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  recurringIntervalCount: int(),
  status: SubscriptionStatus$outboundSchema,
  currentPeriodStart: pipe(date2(), transform((v2) => v2.toISOString())),
  currentPeriodEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialStart: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  trialEnd: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  cancelAtPeriodEnd: boolean2(),
  canceledAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  startedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endsAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  endedAt: nullable(pipe(date2(), transform((v2) => v2.toISOString()))),
  customerId: string2(),
  productId: string2(),
  discountId: nullable(string2()),
  checkoutId: nullable(string2()),
  seats: optional(nullable(int())),
  customerCancellationReason: nullable(CustomerCancellationReason$outboundSchema),
  customerCancellationComment: nullable(string2()),
  metadata: record(string2(), MetadataOutputType$outboundSchema),
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  customer: SubscriptionCustomer$outboundSchema,
  product: Product$outboundSchema,
  discount: nullable(smartUnion([
    DiscountFixedRepeatDurationBase$outboundSchema,
    DiscountFixedOnceForeverDurationBase$outboundSchema,
    DiscountPercentageRepeatDurationBase$outboundSchema,
    DiscountPercentageOnceForeverDurationBase$outboundSchema
  ])),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$outboundSchema,
    ProductPrice$outboundSchema
  ])),
  meters: array(SubscriptionMeter$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    createdAt: "created_at",
    modifiedAt: "modified_at",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count",
    currentPeriodStart: "current_period_start",
    currentPeriodEnd: "current_period_end",
    trialStart: "trial_start",
    trialEnd: "trial_end",
    cancelAtPeriodEnd: "cancel_at_period_end",
    canceledAt: "canceled_at",
    startedAt: "started_at",
    endsAt: "ends_at",
    endedAt: "ended_at",
    customerId: "customer_id",
    productId: "product_id",
    discountId: "discount_id",
    checkoutId: "checkout_id",
    customerCancellationReason: "customer_cancellation_reason",
    customerCancellationComment: "customer_cancellation_comment",
    customFieldData: "custom_field_data"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptionactivepayload.js
var WebhookSubscriptionActivePayload$inboundSchema = object({
  type: literal("subscription.active"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionActivePayload$outboundSchema = object({
  type: literal("subscription.active"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionActivePayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionActivePayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionActivePayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptioncanceledpayload.js
var WebhookSubscriptionCanceledPayload$inboundSchema = object({
  type: literal("subscription.canceled"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionCanceledPayload$outboundSchema = object({
  type: literal("subscription.canceled"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionCanceledPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionCanceledPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionCanceledPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptioncreatedpayload.js
var WebhookSubscriptionCreatedPayload$inboundSchema = object({
  type: literal("subscription.created"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionCreatedPayload$outboundSchema = object({
  type: literal("subscription.created"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionCreatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionCreatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionCreatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptionpastduepayload.js
var WebhookSubscriptionPastDuePayload$inboundSchema = object({
  type: literal("subscription.past_due"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionPastDuePayload$outboundSchema = object({
  type: literal("subscription.past_due"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionPastDuePayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionPastDuePayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionPastDuePayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptionrevokedpayload.js
var WebhookSubscriptionRevokedPayload$inboundSchema = object({
  type: literal("subscription.revoked"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionRevokedPayload$outboundSchema = object({
  type: literal("subscription.revoked"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionRevokedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionRevokedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionRevokedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptionuncanceledpayload.js
var WebhookSubscriptionUncanceledPayload$inboundSchema = object({
  type: literal("subscription.uncanceled"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionUncanceledPayload$outboundSchema = object({
  type: literal("subscription.uncanceled"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionUncanceledPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionUncanceledPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionUncanceledPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhooksubscriptionupdatedpayload.js
var WebhookSubscriptionUpdatedPayload$inboundSchema = object({
  type: literal("subscription.updated"),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  data: Subscription$inboundSchema
});
var WebhookSubscriptionUpdatedPayload$outboundSchema = object({
  type: literal("subscription.updated"),
  timestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  data: Subscription$outboundSchema
});
function webhookSubscriptionUpdatedPayloadFromJSON(jsonString) {
  return safeParse2(jsonString, (x2) => WebhookSubscriptionUpdatedPayload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebhookSubscriptionUpdatedPayload' from JSON`);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/validateWebhook.js
async function validateWebhook(_client, { request: rawRequest }) {
  const request = normalizeRequest(rawRequest);
  const knownSchemas = [
    webhookCheckoutCreatedPayloadFromJSON,
    webhookCheckoutUpdatedPayloadFromJSON,
    webhookCustomerCreatedPayloadFromJSON,
    webhookCustomerUpdatedPayloadFromJSON,
    webhookCustomerDeletedPayloadFromJSON,
    webhookCustomerStateChangedPayloadFromJSON,
    webhookCustomerSeatAssignedPayloadFromJSON,
    webhookCustomerSeatClaimedPayloadFromJSON,
    webhookCustomerSeatRevokedPayloadFromJSON,
    webhookOrderCreatedPayloadFromJSON,
    webhookOrderUpdatedPayloadFromJSON,
    webhookOrderPaidPayloadFromJSON,
    webhookOrderRefundedPayloadFromJSON,
    webhookSubscriptionCreatedPayloadFromJSON,
    webhookSubscriptionUpdatedPayloadFromJSON,
    webhookSubscriptionActivePayloadFromJSON,
    webhookSubscriptionCanceledPayloadFromJSON,
    webhookSubscriptionUncanceledPayloadFromJSON,
    webhookSubscriptionRevokedPayloadFromJSON,
    webhookSubscriptionPastDuePayloadFromJSON,
    webhookRefundCreatedPayloadFromJSON,
    webhookRefundUpdatedPayloadFromJSON,
    webhookProductCreatedPayloadFromJSON,
    webhookProductUpdatedPayloadFromJSON,
    webhookOrganizationUpdatedPayloadFromJSON,
    webhookBenefitCreatedPayloadFromJSON,
    webhookBenefitUpdatedPayloadFromJSON,
    webhookBenefitGrantCreatedPayloadFromJSON,
    webhookBenefitGrantUpdatedPayloadFromJSON,
    webhookBenefitGrantCycledPayloadFromJSON,
    webhookBenefitGrantRevokedPayloadFromJSON
  ];
  const jsonString = await request.text();
  for (const schema of knownSchemas) {
    const ret = schema(jsonString);
    if (ret.ok) {
      return ret;
    }
  }
  return ERR(new SDKValidationError("No matching schema found for the given webhook payload", jsonString, jsonString));
}
function normalizeRequest(request) {
  if (request instanceof Request) {
    return request;
  }
  return new Request(request.url, request);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/hooks/registration.js
function initHooks(hooks) {
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/hooks/hooks.js
var SDKHooks = class {
  constructor() {
    this.sdkInitHooks = [];
    this.beforeCreateRequestHooks = [];
    this.beforeRequestHooks = [];
    this.afterSuccessHooks = [];
    this.afterErrorHooks = [];
    const presetHooks = [];
    for (const hook of presetHooks) {
      if ("sdkInit" in hook) {
        this.registerSDKInitHook(hook);
      }
      if ("beforeCreateRequest" in hook) {
        this.registerBeforeCreateRequestHook(hook);
      }
      if ("beforeRequest" in hook) {
        this.registerBeforeRequestHook(hook);
      }
      if ("afterSuccess" in hook) {
        this.registerAfterSuccessHook(hook);
      }
      if ("afterError" in hook) {
        this.registerAfterErrorHook(hook);
      }
    }
    initHooks(this);
  }
  registerSDKInitHook(hook) {
    this.sdkInitHooks.push(hook);
  }
  registerBeforeCreateRequestHook(hook) {
    this.beforeCreateRequestHooks.push(hook);
  }
  registerBeforeRequestHook(hook) {
    this.beforeRequestHooks.push(hook);
  }
  registerAfterSuccessHook(hook) {
    this.afterSuccessHooks.push(hook);
  }
  registerAfterErrorHook(hook) {
    this.afterErrorHooks.push(hook);
  }
  sdkInit(opts) {
    return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
  }
  beforeCreateRequest(hookCtx, input) {
    let inp = input;
    for (const hook of this.beforeCreateRequestHooks) {
      inp = hook.beforeCreateRequest(hookCtx, inp);
    }
    return inp;
  }
  async beforeRequest(hookCtx, request) {
    let req = request;
    for (const hook of this.beforeRequestHooks) {
      req = await hook.beforeRequest(hookCtx, req);
    }
    return req;
  }
  async afterSuccess(hookCtx, response) {
    let res = response;
    for (const hook of this.afterSuccessHooks) {
      res = await hook.afterSuccess(hookCtx, res);
    }
    return res;
  }
  async afterError(hookCtx, response, error48) {
    let res = response;
    let err = error48;
    for (const hook of this.afterErrorHooks) {
      const result = await hook.afterError(hookCtx, res, err);
      res = result.response;
      err = result.error;
    }
    return { response: res, error: err };
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/httpclienterrors.js
var HTTPClientError = class extends Error {
  constructor(message, opts) {
    let msg = message;
    if (opts?.cause) {
      msg += `: ${opts.cause}`;
    }
    super(msg, opts);
    this.name = "HTTPClientError";
    if (typeof this.cause === "undefined") {
      this.cause = opts?.cause;
    }
  }
};
var UnexpectedClientError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "UnexpectedClientError";
  }
};
var InvalidRequestError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "InvalidRequestError";
  }
};
var RequestAbortedError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "RequestAbortedError";
  }
};
var RequestTimeoutError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "RequestTimeoutError";
  }
};
var ConnectionError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "ConnectionError";
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/base64.js
function bytesToBase64(u8arr) {
  return btoa(String.fromCodePoint(...u8arr));
}
function bytesFromBase64(encoded) {
  return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
}
function stringToBytes(str) {
  return new TextEncoder().encode(str);
}
function stringToBase64(str) {
  return bytesToBase64(stringToBytes(str));
}
var zodOutbound = union([
  custom((x2) => x2 instanceof Uint8Array),
  pipe(string2(), transform(stringToBytes))
]);
var zodInbound = union([
  custom((x2) => x2 instanceof Uint8Array),
  pipe(string2(), transform(bytesFromBase64))
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/is-plain-object.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/encodings.js
var EncodingError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EncodingError";
  }
};
function formEncoder(sep) {
  return (key, value, options) => {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [[key, value]];
    if (pairs.every(([_, v2]) => v2 == null)) {
      return;
    }
    const encodeString = (v2) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
    };
    const encodeValue = (v2) => encodeString(serializeValue(v2));
    const encodedSep = encodeString(sep);
    pairs.forEach(([pk, pv]) => {
      let tmp = "";
      let encValue = null;
      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        encValue = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(encodedSep);
      } else if (isPlainObject2(pv)) {
        encValue = mapDefinedEntries(Object.entries(pv), ([k, v2]) => {
          return `${encodeString(k)}${encodedSep}${encodeValue(v2)}`;
        })?.join(encodedSep);
      } else {
        encValue = `${encodeValue(pv)}`;
      }
      if (encValue == null) {
        return;
      }
      tmp = `${encodeString(pk)}=${encValue}`;
      if (!tmp || tmp === "=") {
        return;
      }
      out += `&${tmp}`;
    });
    return out.slice(1);
  };
}
var encodeForm = formEncoder(",");
var encodeSpaceDelimited = formEncoder(" ");
var encodePipeDelimited = formEncoder("|");
function encodeBodyForm(key, value, options) {
  let out = "";
  const pairs = options?.explode ? explode(key, value) : [[key, value]];
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  const encodeValue = (v2) => encodeString(serializeValue(v2));
  pairs.forEach(([pk, pv]) => {
    let tmp = "";
    let encValue = "";
    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      encValue = JSON.stringify(pv, jsonReplacer);
    } else if (isPlainObject2(pv)) {
      encValue = JSON.stringify(pv, jsonReplacer);
    } else {
      encValue = `${encodeValue(pv)}`;
    }
    tmp = `${encodeString(pk)}=${encValue}`;
    if (!tmp || tmp === "=") {
      return;
    }
    out += `&${tmp}`;
  });
  return out.slice(1);
}
function encodeDeepObject(key, value, options) {
  if (value == null) {
    return;
  }
  if (!isPlainObject2(value)) {
    throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
  }
  return encodeDeepObjectObject(key, value, options);
}
function encodeDeepObjectObject(key, value, options) {
  if (value == null) {
    return;
  }
  let out = "";
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  if (!isPlainObject2(value)) {
    throw new EncodingError(`Expected parameter '${key}' to be an object.`);
  }
  Object.entries(value).forEach(([ck, cv]) => {
    if (cv == null) {
      return;
    }
    const pk = `${key}[${ck}]`;
    if (isPlainObject2(cv)) {
      const objOut = encodeDeepObjectObject(pk, cv, options);
      out += objOut == null ? "" : `&${objOut}`;
      return;
    }
    const pairs = Array.isArray(cv) ? cv : [cv];
    const encoded = mapDefined(pairs, (v2) => {
      return `${encodeString(pk)}=${encodeString(serializeValue(v2))}`;
    })?.join("&");
    out += encoded == null ? "" : `&${encoded}`;
  });
  return out.slice(1);
}
function encodeJSON(key, value, options) {
  if (typeof value === "undefined") {
    return;
  }
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  const encVal = encodeString(JSON.stringify(value, jsonReplacer));
  return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
}
var encodeSimple = (key, value, options) => {
  let out = "";
  const pairs = options?.explode ? explode(key, value) : [[key, value]];
  if (pairs.every(([_, v2]) => v2 == null)) {
    return;
  }
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  const encodeValue = (v2) => encodeString(serializeValue(v2));
  pairs.forEach(([pk, pv]) => {
    let tmp = "";
    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      tmp = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(",");
    } else if (isPlainObject2(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k, v2]) => {
        return `,${encodeString(k)},${encodeValue(v2)}`;
      });
      tmp = mapped?.join("").slice(1);
    } else {
      const k = options?.explode && isPlainObject2(value) ? `${pk}=` : "";
      tmp = `${k}${encodeValue(pv)}`;
    }
    out += tmp ? `,${tmp}` : "";
  });
  return out.slice(1);
};
function explode(key, value) {
  if (Array.isArray(value)) {
    return value.map((v2) => [key, v2]);
  } else if (isPlainObject2(value)) {
    const o = value ?? {};
    return Object.entries(o).map(([k, v2]) => [k, v2]);
  } else {
    return [[key, value]];
  }
}
function serializeValue(value) {
  if (value == null) {
    return "";
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (typeof value === "object") {
    return JSON.stringify(value, jsonReplacer);
  }
  return `${value}`;
}
function jsonReplacer(_, value) {
  if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else {
    return value;
  }
}
function mapDefined(inp, mapper) {
  const res = inp.reduce((acc, v2) => {
    if (v2 == null) {
      return acc;
    }
    const m2 = mapper(v2);
    if (m2 == null) {
      return acc;
    }
    acc.push(m2);
    return acc;
  }, []);
  return res.length ? res : null;
}
function mapDefinedEntries(inp, mapper) {
  const acc = [];
  for (const [k, v2] of inp) {
    if (v2 == null) {
      continue;
    }
    const m2 = mapper([k, v2]);
    if (m2 == null) {
      continue;
    }
    acc.push(m2);
  }
  return acc.length ? acc : null;
}
function queryJoin(...args) {
  return args.filter(Boolean).join("&");
}
function queryEncoder(f) {
  const bulkEncode = function(values, options) {
    const opts = {
      ...options,
      explode: options?.explode ?? true,
      charEncoding: options?.charEncoding ?? "percent"
    };
    const allowEmptySet = new Set(options?.allowEmptyValue ?? []);
    const encoded = Object.entries(values).map(([key, value]) => {
      if (allowEmptySet.has(key)) {
        if (value === void 0 || value === null || value === "" || Array.isArray(value) && value.length === 0) {
          return `${encodeURIComponent(key)}=`;
        }
      }
      return f(key, value, opts);
    });
    return queryJoin(...encoded);
  };
  return bulkEncode;
}
var encodeJSONQuery = queryEncoder(encodeJSON);
var encodeFormQuery = queryEncoder(encodeForm);
var encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
var encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
var encodeDeepObjectQuery = queryEncoder(encodeDeepObject);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/dlv.js
function dlv(obj, key, def, p2, undef) {
  key = Array.isArray(key) ? key : key.split(".");
  for (p2 = 0; p2 < key.length; p2++) {
    const k = key[p2];
    obj = k != null && obj ? obj[k] : undef;
  }
  return obj === undef ? def : obj;
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/env.js
var envSchema = object({
  POLAR_ACCESS_TOKEN: optional(string2()),
  POLAR_DEBUG: optional(coerce_exports.boolean())
});
function isDeno() {
  if ("Deno" in globalThis) {
    return true;
  }
  return false;
}
var envMemo = void 0;
function env() {
  if (envMemo) {
    return envMemo;
  }
  let envObject = {};
  if (isDeno()) {
    envObject = globalThis.Deno?.env?.toObject?.() ?? {};
  } else {
    envObject = dlv(globalThis, "process.env") ?? {};
  }
  envMemo = envSchema.parse(envObject);
  return envMemo;
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/retries.js
var defaultBackoff = {
  initialInterval: 500,
  maxInterval: 6e4,
  exponent: 1.5,
  maxElapsedTime: 36e5
};
var PermanentError = class _PermanentError extends Error {
  constructor(message, options) {
    let msg = message;
    if (options?.cause) {
      msg += `: ${options.cause}`;
    }
    super(msg, options);
    this.name = "PermanentError";
    if (typeof this.cause === "undefined") {
      this.cause = options?.cause;
    }
    Object.setPrototypeOf(this, _PermanentError.prototype);
  }
};
var TemporaryError = class _TemporaryError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "TemporaryError";
    Object.setPrototypeOf(this, _TemporaryError.prototype);
  }
};
async function retry(fetchFn, options) {
  switch (options.config.strategy) {
    case "backoff":
      return retryBackoff(wrapFetcher(fetchFn, {
        statusCodes: options.statusCodes,
        retryConnectionErrors: !!options.config.retryConnectionErrors
      }), options.config.backoff ?? defaultBackoff);
    default:
      return await fetchFn();
  }
}
function wrapFetcher(fn, options) {
  return async () => {
    try {
      const res = await fn();
      if (isRetryableResponse(res, options.statusCodes)) {
        throw new TemporaryError("Response failed with retryable status code", res);
      }
      return res;
    } catch (err) {
      if (err instanceof TemporaryError) {
        throw err;
      }
      if (options.retryConnectionErrors && (isTimeoutError(err) || isConnectionError(err))) {
        throw err;
      }
      throw new PermanentError("Permanent error", { cause: err });
    }
  };
}
var codeRangeRE2 = new RegExp("^[0-9]xx$", "i");
function isRetryableResponse(res, statusCodes) {
  const actual = `${res.status}`;
  return statusCodes.some((code) => {
    if (!codeRangeRE2.test(code)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
async function retryBackoff(fn, strategy) {
  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
  const start = Date.now();
  let x2 = 0;
  while (true) {
    try {
      const res = await fn();
      return res;
    } catch (err) {
      if (err instanceof PermanentError) {
        throw err.cause;
      }
      const elapsed = Date.now() - start;
      if (elapsed > maxElapsedTime) {
        if (err instanceof TemporaryError) {
          return err.response;
        }
        throw err;
      }
      let retryInterval = 0;
      if (err instanceof TemporaryError) {
        retryInterval = retryIntervalFromResponse(err.response);
      }
      if (retryInterval <= 0) {
        retryInterval = initialInterval * Math.pow(x2, exponent) + Math.random() * 1e3;
      }
      const d2 = Math.min(retryInterval, maxInterval);
      await delay(d2);
      x2++;
    }
  }
}
function retryIntervalFromResponse(res) {
  const retryVal = res.headers.get("retry-after") || "";
  if (!retryVal) {
    return 0;
  }
  const parsedNumber = Number(retryVal);
  if (Number.isInteger(parsedNumber)) {
    return parsedNumber * 1e3;
  }
  const parsedDate = Date.parse(retryVal);
  if (Number.isInteger(parsedDate)) {
    const deltaMS = parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }
  return 0;
}
async function delay(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/sdks.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClientSDK_httpClient;
var _ClientSDK_hooks;
var _ClientSDK_logger;
var gt = typeof globalThis === "undefined" ? null : globalThis;
var webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
var isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
var ClientSDK = class {
  constructor(options = {}) {
    _ClientSDK_httpClient.set(this, void 0);
    _ClientSDK_hooks.set(this, void 0);
    _ClientSDK_logger.set(this, void 0);
    const opt = options;
    if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof SDKHooks) {
      __classPrivateFieldSet(this, _ClientSDK_hooks, opt.hooks, "f");
    } else {
      __classPrivateFieldSet(this, _ClientSDK_hooks, new SDKHooks(), "f");
    }
    const url2 = serverURLFromOptions(options);
    if (url2) {
      url2.pathname = url2.pathname.replace(/\/+$/, "") + "/";
    }
    const { baseURL, client } = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").sdkInit({
      baseURL: url2,
      client: options.httpClient || new HTTPClient()
    });
    this._baseURL = baseURL;
    __classPrivateFieldSet(this, _ClientSDK_httpClient, client, "f");
    this._options = { ...options, hooks: __classPrivateFieldGet(this, _ClientSDK_hooks, "f") };
    __classPrivateFieldSet(this, _ClientSDK_logger, this._options.debugLogger, "f");
    if (!__classPrivateFieldGet(this, _ClientSDK_logger, "f") && env().POLAR_DEBUG) {
      __classPrivateFieldSet(this, _ClientSDK_logger, console, "f");
    }
  }
  _createRequest(context, conf, options) {
    const { method, path, query, headers: opHeaders, security } = conf;
    const base = conf.baseURL ?? this._baseURL;
    if (!base) {
      return ERR(new InvalidRequestError("No base URL provided for operation"));
    }
    const reqURL = new URL(base);
    const inputURL = new URL(path, reqURL);
    if (path) {
      reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
      reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
    }
    let finalQuery = query || "";
    const secQuery = [];
    for (const [k, v2] of Object.entries(security?.queryParams || {})) {
      const q = encodeForm(k, v2, { charEncoding: "percent" });
      if (typeof q !== "undefined") {
        secQuery.push(q);
      }
    }
    if (secQuery.length) {
      finalQuery += `&${secQuery.join("&")}`;
    }
    if (finalQuery) {
      const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
      reqURL.search = `?${q}`;
    }
    const headers = new Headers(opHeaders);
    const username = security?.basic.username;
    const password = security?.basic.password;
    if (username != null || password != null) {
      const encoded = stringToBase64([username || "", password || ""].join(":"));
      headers.set("Authorization", `Basic ${encoded}`);
    }
    const securityHeaders = new Headers(security?.headers || {});
    for (const [k, v2] of securityHeaders) {
      headers.set(k, v2);
    }
    let cookie = headers.get("cookie") || "";
    for (const [k, v2] of Object.entries(security?.cookies || {})) {
      cookie += `; ${k}=${v2}`;
    }
    cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
    headers.set("cookie", cookie);
    const userHeaders = new Headers(options?.headers ?? options?.fetchOptions?.headers);
    for (const [k, v2] of userHeaders) {
      headers.set(k, v2);
    }
    if (!isBrowserLike) {
      headers.set(conf.uaHeader ?? "user-agent", conf.userAgent ?? SDK_METADATA.userAgent);
    }
    const fetchOptions = {
      ...options?.fetchOptions,
      ...options
    };
    if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
      const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
      fetchOptions.signal = timeoutSignal;
    }
    if (conf.body instanceof ReadableStream) {
      Object.assign(fetchOptions, { duplex: "half" });
    }
    let input;
    try {
      input = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
        url: reqURL,
        options: {
          ...fetchOptions,
          body: conf.body ?? null,
          headers,
          method
        }
      });
    } catch (err) {
      return ERR(new UnexpectedClientError("Create request hook failed to execute", {
        cause: err
      }));
    }
    return OK(new Request(input.url, input.options));
  }
  async _do(request, options) {
    const { context, errorCodes } = options;
    return retry(async () => {
      const req = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
      await logRequest(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), req).catch((e) => __classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log request:", e));
      let response = await __classPrivateFieldGet(this, _ClientSDK_httpClient, "f").request(req);
      try {
        if (matchStatusCode(response, errorCodes)) {
          const result = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterError(context, response, null);
          if (result.error) {
            throw result.error;
          }
          response = result.response || response;
        } else {
          response = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
        }
      } finally {
        await logResponse(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), response, req).catch((e) => __classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log response:", e));
      }
      return response;
    }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r) => OK(r), (err) => {
      switch (true) {
        case isAbortError(err):
          return ERR(new RequestAbortedError("Request aborted by client", {
            cause: err
          }));
        case isTimeoutError(err):
          return ERR(new RequestTimeoutError("Request timed out", { cause: err }));
        case isConnectionError(err):
          return ERR(new ConnectionError("Unable to make request", { cause: err }));
        default:
          return ERR(new UnexpectedClientError("Unexpected HTTP client error", {
            cause: err
          }));
      }
    });
  }
};
_ClientSDK_httpClient = /* @__PURE__ */ new WeakMap(), _ClientSDK_hooks = /* @__PURE__ */ new WeakMap(), _ClientSDK_logger = /* @__PURE__ */ new WeakMap();
var jsonLikeContentTypeRE = /^(application|text)\/([^+]+\+)*json.*/;
var jsonlLikeContentTypeRE = /^(application|text)\/([^+]+\+)*(jsonl|x-ndjson)\b.*/;
async function logRequest(logger, req) {
  if (!logger) {
    return;
  }
  const contentType = req.headers.get("content-type");
  const ct2 = contentType?.split(";")[0] || "";
  logger.group(`> Request: ${req.method} ${req.url}`);
  logger.group("Headers:");
  for (const [k, v2] of req.headers.entries()) {
    logger.log(`${k}: ${v2}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case jsonLikeContentTypeRE.test(ct2):
      logger.log(await req.clone().json());
      break;
    case ct2.startsWith("text/"):
      logger.log(await req.clone().text());
      break;
    case ct2 === "multipart/form-data": {
      const body = await req.clone().formData();
      for (const [k, v2] of body) {
        const vlabel = v2 instanceof Blob ? "<Blob>" : v2;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}
async function logResponse(logger, res, req) {
  if (!logger) {
    return;
  }
  const contentType = res.headers.get("content-type");
  const ct2 = contentType?.split(";")[0] || "";
  logger.group(`< Response: ${req.method} ${req.url}`);
  logger.log("Status Code:", res.status, res.statusText);
  logger.group("Headers:");
  for (const [k, v2] of res.headers.entries()) {
    logger.log(`${k}: ${v2}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case (matchContentType(res, "application/json") || jsonLikeContentTypeRE.test(ct2) && !jsonlLikeContentTypeRE.test(ct2)):
      logger.log(await res.clone().json());
      break;
    case (matchContentType(res, "application/jsonl") || jsonlLikeContentTypeRE.test(ct2)):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "text/event-stream"):
      logger.log(`<${contentType}>`);
      break;
    case matchContentType(res, "text/*"):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "multipart/form-data"): {
      const body = await res.clone().formData();
      for (const [k, v2] of body) {
        const vlabel = v2 instanceof Blob ? "<Blob>" : v2;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/polarerror.js
var PolarError = class extends Error {
  constructor(message, httpMeta) {
    super(message);
    this.statusCode = httpMeta.response.status;
    this.body = httpMeta.body;
    this.headers = httpMeta.response.headers;
    this.contentType = httpMeta.response.headers.get("content-type") || "";
    this.rawResponse = httpMeta.response;
    this.name = "PolarError";
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/responsevalidationerror.js
var ResponseValidationError = class extends PolarError {
  constructor(message, extra) {
    super(message, extra);
    this.name = "ResponseValidationError";
    this.cause = extra.cause;
    this.rawValue = extra.rawValue;
    this.rawMessage = extra.rawMessage;
  }
  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  pretty() {
    if (this.cause instanceof $ZodError) {
      return `${this.rawMessage}
${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/sdkerror.js
var SDKError = class extends PolarError {
  constructor(message, httpMeta) {
    if (message) {
      message += `: `;
    }
    message += `Status ${httpMeta.response.status}`;
    const contentType = httpMeta.response.headers.get("content-type") || `""`;
    if (contentType !== "application/json") {
      message += ` Content-Type ${contentType.includes(" ") ? `"${contentType}"` : contentType}`;
    }
    const body = httpMeta.body || `""`;
    message += body.length > 100 ? "\n" : ". ";
    let bodyDisplay = body;
    if (body.length > 1e4) {
      const truncated = body.substring(0, 1e4);
      const remaining = body.length - 1e4;
      bodyDisplay = `${truncated}...and ${remaining} more chars`;
    }
    message += `Body: ${bodyDisplay}`;
    message = message.trim();
    super(message, httpMeta);
    this.name = "SDKError";
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/matchers.js
var DEFAULT_CONTENT_TYPES = {
  jsonl: "application/jsonl",
  json: "application/json",
  text: "text/plain",
  bytes: "application/octet-stream",
  stream: "application/octet-stream",
  sse: "text/event-stream",
  nil: "*",
  fail: "*"
};
function jsonErr(codes, schema, options) {
  return { ...options, err: true, enc: "json", codes, schema };
}
function json(codes, schema, options) {
  return { ...options, enc: "json", codes, schema };
}
function nil(codes, schema, options) {
  return { ...options, enc: "nil", codes, schema };
}
function fail(codes) {
  return { enc: "fail", codes };
}
function match(...matchers) {
  return async function matchFunc(response, request, options) {
    let raw;
    let matcher;
    for (const match2 of matchers) {
      const { codes } = match2;
      const ctpattern = "ctype" in match2 ? match2.ctype : DEFAULT_CONTENT_TYPES[match2.enc];
      if (ctpattern && matchResponse(response, codes, ctpattern)) {
        matcher = match2;
        break;
      } else if (!ctpattern && matchStatusCode(response, codes)) {
        matcher = match2;
        break;
      }
    }
    if (!matcher) {
      return [{
        ok: false,
        error: new SDKError("Unexpected Status or Content-Type", {
          response,
          request,
          body: await response.text().catch(() => "")
        })
      }, raw];
    }
    const encoding = matcher.enc;
    let body = "";
    switch (encoding) {
      case "json":
        body = await response.text();
        raw = JSON.parse(body);
        break;
      case "jsonl":
        raw = response.body;
        break;
      case "bytes":
        raw = new Uint8Array(await response.arrayBuffer());
        break;
      case "stream":
        raw = response.body;
        break;
      case "text":
        body = await response.text();
        raw = body;
        break;
      case "sse":
        raw = response.body;
        break;
      case "nil":
        body = await response.text();
        raw = void 0;
        break;
      case "fail":
        body = await response.text();
        raw = body;
        break;
      default:
        encoding;
        throw new Error(`Unsupported response type: ${encoding}`);
    }
    if (matcher.enc === "fail") {
      return [{
        ok: false,
        error: new SDKError("API error occurred", { request, response, body })
      }, raw];
    }
    const resultKey = matcher.key || options?.resultKey;
    let data;
    if ("err" in matcher) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject2(raw) ? raw : null,
        request$: request,
        response$: response,
        body$: body
      };
    } else if (resultKey) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        [resultKey]: raw
      };
    } else if (matcher.hdrs) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject2(raw) ? raw : null
      };
    } else {
      data = raw;
    }
    if ("err" in matcher) {
      const result = safeParseResponse(data, (v2) => matcher.schema.parse(v2), "Response validation failed", { request, response, body });
      return [result.ok ? { ok: false, error: result.value } : result, raw];
    } else {
      return [
        safeParseResponse(data, (v2) => matcher.schema.parse(v2), "Response validation failed", { request, response, body }),
        raw
      ];
    }
  };
}
var headerValRE = /, */;
function unpackHeaders(headers) {
  const out = {};
  for (const [k, v2] of headers.entries()) {
    out[k] = v2.split(headerValRE);
  }
  return out;
}
function safeParseResponse(rawValue, fn, errorMessage, httpMeta) {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new ResponseValidationError(errorMessage, {
      cause: err,
      rawValue,
      rawMessage: errorMessage,
      ...httpMeta
    }));
  }
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/lib/security.js
var SecurityErrorCode;
(function(SecurityErrorCode2) {
  SecurityErrorCode2["Incomplete"] = "incomplete";
  SecurityErrorCode2["UnrecognisedSecurityType"] = "unrecognized_security_type";
})(SecurityErrorCode || (SecurityErrorCode = {}));
var SecurityError = class _SecurityError extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "SecurityError";
  }
  static incomplete() {
    return new _SecurityError(SecurityErrorCode.Incomplete, "Security requirements not met in order to perform the operation");
  }
  static unrecognizedType(type) {
    return new _SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);
  }
};
function resolveSecurity(...options) {
  const state = {
    basic: {},
    headers: {},
    queryParams: {},
    cookies: {},
    oauth2: { type: "none" }
  };
  const option = options.find((opts) => {
    return opts.every((o) => {
      if (o.value == null) {
        return false;
      } else if (o.type === "http:basic") {
        return o.value.username != null || o.value.password != null;
      } else if (o.type === "http:custom") {
        return null;
      } else if (o.type === "oauth2:password") {
        return typeof o.value === "string" && !!o.value;
      } else if (o.type === "oauth2:client_credentials") {
        if (typeof o.value == "string") {
          return !!o.value;
        }
        return o.value.clientID != null || o.value.clientSecret != null;
      } else if (typeof o.value === "string") {
        return !!o.value;
      } else {
        throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);
      }
    });
  });
  if (option == null) {
    return null;
  }
  option.forEach((spec) => {
    if (spec.value == null) {
      return;
    }
    const { type } = spec;
    switch (type) {
      case "apiKey:header":
        state.headers[spec.fieldName] = spec.value;
        break;
      case "apiKey:query":
        state.queryParams[spec.fieldName] = spec.value;
        break;
      case "apiKey:cookie":
        state.cookies[spec.fieldName] = spec.value;
        break;
      case "http:basic":
        applyBasic(state, spec);
        break;
      case "http:custom":
        break;
      case "http:bearer":
        applyBearer(state, spec);
        break;
      case "oauth2":
        applyBearer(state, spec);
        break;
      case "oauth2:password":
        applyBearer(state, spec);
        break;
      case "oauth2:client_credentials":
        break;
      case "openIdConnect":
        applyBearer(state, spec);
        break;
      default:
        spec;
        throw SecurityError.unrecognizedType(type);
    }
  });
  return state;
}
function applyBasic(state, spec) {
  if (spec.value == null) {
    return;
  }
  state.basic = spec.value;
}
function applyBearer(state, spec) {
  if (typeof spec.value !== "string" || !spec.value) {
    return;
  }
  let value = spec.value;
  if (value.slice(0, 7).toLowerCase() !== "bearer ") {
    value = `Bearer ${value}`;
  }
  if (spec.fieldName !== void 0) {
    state.headers[spec.fieldName] = value;
  }
}
function resolveGlobalSecurity(security) {
  return resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.accessToken ?? env().POLAR_ACCESS_TOKEN
    }
  ]);
}
async function extractSecurity(sec) {
  if (sec == null) {
    return;
  }
  return typeof sec === "function" ? sec() : sec;
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/validationerror.js
var Loc$inboundSchema = smartUnion([
  string2(),
  int()
]);
var Loc$outboundSchema = smartUnion([
  string2(),
  int()
]);
var ValidationError$inboundSchema = object({
  loc: array(smartUnion([string2(), int()])),
  msg: string2(),
  type: string2()
});
var ValidationError$outboundSchema = object({
  loc: array(smartUnion([string2(), int()])),
  msg: string2(),
  type: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/httpvalidationerror.js
var HTTPValidationError = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    if (err.detail != null)
      this.detail = err.detail;
    this.name = "HTTPValidationError";
  }
};
var HTTPValidationError$inboundSchema = pipe(object({
  detail: optional(array(ValidationError$inboundSchema)),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new HTTPValidationError(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));
var HTTPValidationError$outboundSchema = pipe(pipe(custom((x2) => x2 instanceof HTTPValidationError), transform((v2) => v2.data$)), object({
  detail: optional(array(ValidationError$outboundSchema))
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantsortproperty.js
var BenefitGrantSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  GrantedAt: "granted_at",
  MinusGrantedAt: "-granted_at",
  RevokedAt: "revoked_at",
  MinusRevokedAt: "-revoked_at"
};
var BenefitGrantSortProperty$outboundSchema = _enum2(BenefitGrantSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrant.js
var Properties$inboundSchema = smartUnion([
  BenefitGrantDiscordProperties$inboundSchema,
  BenefitGrantGitHubRepositoryProperties$inboundSchema,
  BenefitGrantDownloadablesProperties$inboundSchema,
  BenefitGrantLicenseKeysProperties$inboundSchema,
  BenefitGrantCustomProperties$inboundSchema
]);
var BenefitGrant$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_granted: boolean2(),
  revoked_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))),
  is_revoked: boolean2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  error: optional(nullable(BenefitGrantError$inboundSchema)),
  customer: Customer$inboundSchema,
  benefit: Benefit$inboundSchema,
  properties: smartUnion([
    BenefitGrantDiscordProperties$inboundSchema,
    BenefitGrantGitHubRepositoryProperties$inboundSchema,
    BenefitGrantDownloadablesProperties$inboundSchema,
    BenefitGrantLicenseKeysProperties$inboundSchema,
    BenefitGrantCustomProperties$inboundSchema
  ])
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "is_granted": "isGranted",
    "revoked_at": "revokedAt",
    "is_revoked": "isRevoked",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/pagination.js
var Pagination$inboundSchema = pipe(object({
  total_count: int(),
  max_page: int()
}), transform((v2) => {
  return remap(v2, {
    "total_count": "totalCount",
    "max_page": "maxPage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcebenefitgrant.js
var ListResourceBenefitGrant$inboundSchema = object({
  items: array(BenefitGrant$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/benefitgrantslist.js
var BenefitGrantsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var BenefitGrantsListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var BenefitGrantsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  isGranted: optional(nullable(boolean2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(BenefitGrantSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    isGranted: "is_granted"
  });
}));
var BenefitGrantsListResponse$inboundSchema = pipe(object({
  Result: ListResourceBenefitGrant$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/types/async.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _APIPromise_promise;
var _APIPromise_unwrapped;
var _a2;
var APIPromise = class {
  constructor(p2) {
    _APIPromise_promise.set(this, void 0);
    _APIPromise_unwrapped.set(this, void 0);
    this[_a2] = "APIPromise";
    __classPrivateFieldSet2(this, _APIPromise_promise, p2 instanceof Promise ? p2 : Promise.resolve(p2), "f");
    __classPrivateFieldSet2(this, _APIPromise_unwrapped, p2 instanceof Promise ? __classPrivateFieldGet2(this, _APIPromise_promise, "f").then(([value]) => value) : Promise.resolve(p2[0]), "f");
  }
  then(onfulfilled, onrejected) {
    return __classPrivateFieldGet2(this, _APIPromise_promise, "f").then(onfulfilled ? ([value]) => onfulfilled(value) : void 0, onrejected);
  }
  catch(onrejected) {
    return __classPrivateFieldGet2(this, _APIPromise_unwrapped, "f").catch(onrejected);
  }
  finally(onfinally) {
    return __classPrivateFieldGet2(this, _APIPromise_unwrapped, "f").finally(onfinally);
  }
  $inspect() {
    return __classPrivateFieldGet2(this, _APIPromise_promise, "f");
  }
};
_APIPromise_promise = /* @__PURE__ */ new WeakMap(), _APIPromise_unwrapped = /* @__PURE__ */ new WeakMap(), _a2 = Symbol.toStringTag;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/types/operations.js
function createPageIterator(page, halt) {
  return {
    [Symbol.asyncIterator]: async function* paginator() {
      yield page;
      if (halt(page)) {
        return;
      }
      let p2 = page;
      for (p2 = await p2.next(); p2 != null; p2 = await p2.next()) {
        yield p2;
        if (halt(p2)) {
          return;
        }
      }
    }
  };
}
function haltIterator(v2) {
  return {
    ...v2,
    next: () => null,
    [Symbol.asyncIterator]: async function* paginator() {
      yield v2;
    }
  };
}
async function unwrapResultIterator(iteratorPromise) {
  const resultIter = await iteratorPromise;
  if (!resultIter.ok) {
    throw resultIter.error;
  }
  return {
    ...resultIter.value,
    next: unwrapPaginator(resultIter.next),
    "~next": resultIter["~next"],
    [Symbol.asyncIterator]: async function* paginator() {
      for await (const page of resultIter) {
        if (!page.ok) {
          throw page.error;
        }
        yield page.value;
      }
    }
  };
}
function unwrapPaginator(paginator) {
  return () => {
    const nextResult = paginator();
    if (nextResult == null) {
      return null;
    }
    return nextResult.then((res) => {
      if (!res.ok) {
        throw res.error;
      }
      const out = {
        ...res.value,
        next: unwrapPaginator(res.next)
      };
      return out;
    });
  };
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitGrantsList.js
function benefitGrantsList(client, request, options) {
  return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitGrantsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/benefit-grants/")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "is_granted": payload.is_granted,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefit-grants:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, BenefitGrantsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => benefitGrantsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/benefitgrants.js
var BenefitGrants = class extends ClientSDK {
  /**
   * List Benefit Grants
   *
   * @remarks
   * List benefit grants across all benefits for the authenticated organization.
   *
   * **Scopes**: `benefits:read` `benefits:write`
   */
  async list(request, options) {
    return unwrapResultIterator(benefitGrantsList(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustomcreateproperties.js
var BenefitCustomCreateProperties$outboundSchema = object({
  note: optional(nullable(string2()))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustomcreate.js
var BenefitCustomCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitCustomCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("custom"),
  description: string2(),
  organizationId: optional(nullable(string2())),
  properties: BenefitCustomCreateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscordcreateproperties.js
var BenefitDiscordCreateProperties$outboundSchema = pipe(object({
  guildToken: string2(),
  roleId: string2(),
  kickMember: boolean2()
}), transform((v2) => {
  return remap(v2, {
    guildToken: "guild_token",
    roleId: "role_id",
    kickMember: "kick_member"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscordcreate.js
var BenefitDiscordCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitDiscordCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("discord"),
  description: string2(),
  organizationId: optional(nullable(string2())),
  properties: BenefitDiscordCreateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadablescreateproperties.js
var BenefitDownloadablesCreateProperties$outboundSchema = object({
  archived: optional(record(string2(), boolean2())),
  files: array(string2())
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadablescreate.js
var BenefitDownloadablesCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitDownloadablesCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("downloadables"),
  description: string2(),
  organizationId: optional(nullable(string2())),
  properties: BenefitDownloadablesCreateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepositorycreateproperties.js
var BenefitGitHubRepositoryCreatePropertiesPermission = {
  Pull: "pull",
  Triage: "triage",
  Push: "push",
  Maintain: "maintain",
  Admin: "admin"
};
var BenefitGitHubRepositoryCreatePropertiesPermission$outboundSchema = _enum2(BenefitGitHubRepositoryCreatePropertiesPermission);
var BenefitGitHubRepositoryCreateProperties$outboundSchema = pipe(object({
  repositoryOwner: string2(),
  repositoryName: string2(),
  permission: BenefitGitHubRepositoryCreatePropertiesPermission$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    repositoryOwner: "repository_owner",
    repositoryName: "repository_name"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepositorycreate.js
var BenefitGitHubRepositoryCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitGitHubRepositoryCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("github_repository"),
  description: string2(),
  organizationId: optional(nullable(string2())),
  properties: BenefitGitHubRepositoryCreateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyactivationcreateproperties.js
var BenefitLicenseKeyActivationCreateProperties$outboundSchema = pipe(object({
  limit: int(),
  enableCustomerAdmin: boolean2()
}), transform((v2) => {
  return remap(v2, {
    enableCustomerAdmin: "enable_customer_admin"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyscreateproperties.js
var BenefitLicenseKeysCreateProperties$outboundSchema = pipe(object({
  prefix: optional(nullable(string2())),
  expires: optional(nullable(BenefitLicenseKeyExpirationProperties$outboundSchema)),
  activations: optional(nullable(BenefitLicenseKeyActivationCreateProperties$outboundSchema)),
  limitUsage: optional(nullable(int()))
}), transform((v2) => {
  return remap(v2, {
    limitUsage: "limit_usage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyscreate.js
var BenefitLicenseKeysCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitLicenseKeysCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("license_keys"),
  description: string2(),
  organizationId: optional(nullable(string2())),
  properties: BenefitLicenseKeysCreateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercreditcreateproperties.js
var BenefitMeterCreditCreateProperties$outboundSchema = pipe(object({
  units: int(),
  rollover: boolean2(),
  meterId: string2()
}), transform((v2) => {
  return remap(v2, {
    meterId: "meter_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercreditcreate.js
var BenefitMeterCreditCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitMeterCreditCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("meter_credit"),
  description: string2(),
  organizationId: optional(nullable(string2())),
  properties: BenefitMeterCreditCreateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcreate.js
var BenefitCreate$outboundSchema = union([
  BenefitCustomCreate$outboundSchema,
  BenefitDiscordCreate$outboundSchema,
  BenefitDownloadablesCreate$outboundSchema,
  BenefitGitHubRepositoryCreate$outboundSchema,
  BenefitLicenseKeysCreate$outboundSchema,
  BenefitMeterCreditCreate$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitsCreate.js
function benefitsCreate(client, request, options) {
  return new APIPromise($do2(client, request, options));
}
async function $do2(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/benefits/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefits:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Benefit$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/notpermitted.js
var NotPermitted = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "NotPermitted";
  }
};
var NotPermitted$inboundSchema = pipe(object({
  error: literal("NotPermitted"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new NotPermitted(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/resourcenotfound.js
var ResourceNotFound = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "ResourceNotFound";
  }
};
var ResourceNotFound$inboundSchema = pipe(object({
  error: literal("ResourceNotFound"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new ResourceNotFound(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/benefitsdelete.js
var BenefitsDeleteRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitsDelete.js
function benefitsDelete(client, request, options) {
  return new APIPromise($do3(client, request, options));
}
async function $do3(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitsDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/benefits/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefits:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/benefitsget.js
var BenefitsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitsGet.js
function benefitsGet(client, request, options) {
  return new APIPromise($do4(client, request, options));
}
async function $do4(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/benefits/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefits:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Benefit$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/benefitsgrants.js
var QueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var MemberIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var BenefitsGrantsRequest$outboundSchema = pipe(object({
  id: string2(),
  isGranted: optional(nullable(boolean2())),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  memberId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    isGranted: "is_granted",
    customerId: "customer_id",
    memberId: "member_id"
  });
}));
var BenefitsGrantsResponse$inboundSchema = pipe(object({
  Result: ListResourceBenefitGrant$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitsGrants.js
function benefitsGrants(client, request, options) {
  return new APIPromise($do5(client, request, options));
}
async function $do5(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitsGrantsRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/benefits/{id}/grants")(pathParams);
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "is_granted": payload.is_granted,
    "limit": payload.limit,
    "member_id": payload.member_id,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefits:grants",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, BenefitsGrantsResponse$inboundSchema, { key: "Result" }), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => benefitsGrants(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitsortproperty.js
var BenefitSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Description: "description",
  MinusDescription: "-description",
  Type: "type",
  MinusType: "-type",
  UserOrder: "user_order",
  MinusUserOrder: "-user_order"
};
var BenefitSortProperty$outboundSchema = _enum2(BenefitSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcebenefit.js
var ListResourceBenefit$inboundSchema = object({
  items: array(Benefit$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionslist.js
var MetadataQuery$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  array(string2()),
  array(int()),
  array(boolean2())
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/benefitslist.js
var QueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var BenefitTypeFilter$outboundSchema = smartUnion([
  BenefitType$outboundSchema,
  array(BenefitType$outboundSchema)
]);
var FilterIDs$outboundSchema = smartUnion([string2(), array(string2())]);
var ExcludeIDs$outboundSchema = smartUnion([string2(), array(string2())]);
var BenefitsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  typeFilter: optional(nullable(smartUnion([
    BenefitType$outboundSchema,
    array(BenefitType$outboundSchema)
  ]))),
  id: optional(nullable(smartUnion([string2(), array(string2())]))),
  excludeId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(BenefitSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    typeFilter: "type_filter",
    excludeId: "exclude_id"
  });
}));
var BenefitsListResponse$inboundSchema = pipe(object({
  Result: ListResourceBenefit$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitsList.js
function benefitsList(client, request, options) {
  return new APIPromise($do6(client, request, options));
}
async function $do6(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/benefits/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "exclude_id": payload.exclude_id,
    "id": payload.id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting,
    "type": payload.type_filter
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefits:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, BenefitsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => benefitsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustomupdate.js
var BenefitCustomUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitCustomUpdate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  description: optional(nullable(string2())),
  type: literal("custom"),
  properties: optional(nullable(BenefitCustomProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscordupdate.js
var BenefitDiscordUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitDiscordUpdate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  description: optional(nullable(string2())),
  type: literal("discord"),
  properties: optional(nullable(BenefitDiscordCreateProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadablesupdate.js
var BenefitDownloadablesUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitDownloadablesUpdate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  description: optional(nullable(string2())),
  type: literal("downloadables"),
  properties: optional(nullable(BenefitDownloadablesCreateProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepositoryupdate.js
var BenefitGitHubRepositoryUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitGitHubRepositoryUpdate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  description: optional(nullable(string2())),
  type: literal("github_repository"),
  properties: optional(nullable(BenefitGitHubRepositoryCreateProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeysupdate.js
var BenefitLicenseKeysUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitLicenseKeysUpdate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  description: optional(nullable(string2())),
  type: literal("license_keys"),
  properties: optional(nullable(BenefitLicenseKeysCreateProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercreditupdate.js
var BenefitMeterCreditUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var BenefitMeterCreditUpdate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  description: optional(nullable(string2())),
  type: literal("meter_credit"),
  properties: optional(nullable(BenefitMeterCreditCreateProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/benefitsupdate.js
var BenefitsUpdateBenefitUpdate$outboundSchema = union([
  BenefitCustomUpdate$outboundSchema,
  BenefitDiscordUpdate$outboundSchema,
  BenefitGitHubRepositoryUpdate$outboundSchema,
  BenefitDownloadablesUpdate$outboundSchema,
  BenefitLicenseKeysUpdate$outboundSchema,
  BenefitMeterCreditUpdate$outboundSchema
]);
var BenefitsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  requestBody: union([
    BenefitCustomUpdate$outboundSchema,
    BenefitDiscordUpdate$outboundSchema,
    BenefitGitHubRepositoryUpdate$outboundSchema,
    BenefitDownloadablesUpdate$outboundSchema,
    BenefitLicenseKeysUpdate$outboundSchema,
    BenefitMeterCreditUpdate$outboundSchema
  ])
}), transform((v2) => {
  return remap(v2, {
    requestBody: "RequestBody"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/benefitsUpdate.js
function benefitsUpdate(client, request, options) {
  return new APIPromise($do7(client, request, options));
}
async function $do7(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(BenefitsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/benefits/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "benefits:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Benefit$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/benefits.js
var Benefits = class extends ClientSDK {
  /**
   * List Benefits
   *
   * @remarks
   * List benefits.
   *
   * **Scopes**: `benefits:read` `benefits:write`
   */
  async list(request, options) {
    return unwrapResultIterator(benefitsList(this, request, options));
  }
  /**
   * Create Benefit
   *
   * @remarks
   * Create a benefit.
   *
   * **Scopes**: `benefits:write`
   */
  async create(request, options) {
    return unwrapAsync(benefitsCreate(this, request, options));
  }
  /**
   * Get Benefit
   *
   * @remarks
   * Get a benefit by ID.
   *
   * **Scopes**: `benefits:read` `benefits:write`
   */
  async get(request, options) {
    return unwrapAsync(benefitsGet(this, request, options));
  }
  /**
   * Update Benefit
   *
   * @remarks
   * Update a benefit.
   *
   * **Scopes**: `benefits:write`
   */
  async update(request, options) {
    return unwrapAsync(benefitsUpdate(this, request, options));
  }
  /**
   * Delete Benefit
   *
   * @remarks
   * Delete a benefit.
   *
   * > [!WARNING]
   * > Every grants associated with the benefit will be revoked.
   * > Users will lose access to the benefit.
   *
   * **Scopes**: `benefits:write`
   */
  async delete(request, options) {
    return unwrapAsync(benefitsDelete(this, request, options));
  }
  /**
   * List Benefit Grants
   *
   * @remarks
   * List the individual grants for a benefit.
   *
   * It's especially useful to check if a user has been granted a benefit.
   *
   * **Scopes**: `benefits:read` `benefits:write`
   */
  async grants(request, options) {
    return unwrapResultIterator(benefitsGrants(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinkproduct.js
var CheckoutLinkProductPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutLinkProduct$inboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2(),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  benefits: array(BenefitPublic$inboundSchema),
  medias: array(ProductMediaFileRead$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlink.js
var CheckoutLinkDiscount$inboundSchema = smartUnion([
  DiscountFixedRepeatDurationBase$inboundSchema,
  DiscountFixedOnceForeverDurationBase$inboundSchema,
  DiscountPercentageRepeatDurationBase$inboundSchema,
  DiscountPercentageOnceForeverDurationBase$inboundSchema
]);
var CheckoutLink$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  payment_processor: PaymentProcessor$inboundSchema,
  client_secret: string2(),
  success_url: nullable(string2()),
  label: nullable(string2()),
  allow_discount_codes: boolean2(),
  require_billing_address: boolean2(),
  discount_id: nullable(string2()),
  organization_id: string2(),
  products: array(CheckoutLinkProduct$inboundSchema),
  discount: nullable(smartUnion([
    DiscountFixedRepeatDurationBase$inboundSchema,
    DiscountFixedOnceForeverDurationBase$inboundSchema,
    DiscountPercentageRepeatDurationBase$inboundSchema,
    DiscountPercentageOnceForeverDurationBase$inboundSchema
  ])),
  url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "payment_processor": "paymentProcessor",
    "client_secret": "clientSecret",
    "success_url": "successUrl",
    "allow_discount_codes": "allowDiscountCodes",
    "require_billing_address": "requireBillingAddress",
    "discount_id": "discountId",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinkcreateproduct.js
var CheckoutLinkCreateProductMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutLinkCreateProduct$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  paymentProcessor: literal("stripe"),
  label: optional(nullable(string2())),
  allowDiscountCodes: _default2(boolean2(), true),
  requireBillingAddress: _default2(boolean2(), false),
  discountId: optional(nullable(string2())),
  successUrl: optional(nullable(string2())),
  productId: string2()
}), transform((v2) => {
  return remap(v2, {
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    paymentProcessor: "payment_processor",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    discountId: "discount_id",
    successUrl: "success_url",
    productId: "product_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinkcreateproductprice.js
var CheckoutLinkCreateProductPriceMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutLinkCreateProductPrice$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  paymentProcessor: literal("stripe"),
  label: optional(nullable(string2())),
  allowDiscountCodes: _default2(boolean2(), true),
  requireBillingAddress: _default2(boolean2(), false),
  discountId: optional(nullable(string2())),
  successUrl: optional(nullable(string2())),
  productPriceId: string2()
}), transform((v2) => {
  return remap(v2, {
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    paymentProcessor: "payment_processor",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    discountId: "discount_id",
    successUrl: "success_url",
    productPriceId: "product_price_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinkcreateproducts.js
var CheckoutLinkCreateProductsMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutLinkCreateProducts$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  paymentProcessor: literal("stripe"),
  label: optional(nullable(string2())),
  allowDiscountCodes: _default2(boolean2(), true),
  requireBillingAddress: _default2(boolean2(), false),
  discountId: optional(nullable(string2())),
  successUrl: optional(nullable(string2())),
  products: array(string2())
}), transform((v2) => {
  return remap(v2, {
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    paymentProcessor: "payment_processor",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    discountId: "discount_id",
    successUrl: "success_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinkcreate.js
var CheckoutLinkCreate$outboundSchema = smartUnion([
  CheckoutLinkCreateProductPrice$outboundSchema,
  CheckoutLinkCreateProduct$outboundSchema,
  CheckoutLinkCreateProducts$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutLinksCreate.js
function checkoutLinksCreate(client, request, options) {
  return new APIPromise($do8(client, request, options));
}
async function $do8(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutLinkCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/checkout-links/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkout-links:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, CheckoutLink$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutlinksdelete.js
var CheckoutLinksDeleteRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutLinksDelete.js
function checkoutLinksDelete(client, request, options) {
  return new APIPromise($do9(client, request, options));
}
async function $do9(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutLinksDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkout-links/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkout-links:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutlinksget.js
var CheckoutLinksGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutLinksGet.js
function checkoutLinksGet(client, request, options) {
  return new APIPromise($do10(client, request, options));
}
async function $do10(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutLinksGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkout-links/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkout-links:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CheckoutLink$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinksortproperty.js
var CheckoutLinkSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Label: "label",
  MinusLabel: "-label",
  SuccessUrl: "success_url",
  MinusSuccessUrl: "-success_url",
  AllowDiscountCodes: "allow_discount_codes",
  MinusAllowDiscountCodes: "-allow_discount_codes"
};
var CheckoutLinkSortProperty$outboundSchema = _enum2(CheckoutLinkSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecheckoutlink.js
var ListResourceCheckoutLink$inboundSchema = object({
  items: array(CheckoutLink$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutlinkslist.js
var CheckoutLinksListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CheckoutLinksListQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CheckoutLinksListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CheckoutLinkSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    productId: "product_id"
  });
}));
var CheckoutLinksListResponse$inboundSchema = pipe(object({
  Result: ListResourceCheckoutLink$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutLinksList.js
function checkoutLinksList(client, request, options) {
  return new APIPromise($do11(client, request, options));
}
async function $do11(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutLinksListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/checkout-links/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "product_id": payload.product_id,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkout-links:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CheckoutLinksListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => checkoutLinksList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutlinkupdate.js
var CheckoutLinkUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutLinkUpdate$outboundSchema = pipe(object({
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  products: optional(nullable(array(string2()))),
  label: optional(nullable(string2())),
  allowDiscountCodes: optional(nullable(boolean2())),
  requireBillingAddress: optional(nullable(boolean2())),
  discountId: optional(nullable(string2())),
  successUrl: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    discountId: "discount_id",
    successUrl: "success_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutlinksupdate.js
var CheckoutLinksUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  checkoutLinkUpdate: CheckoutLinkUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    checkoutLinkUpdate: "CheckoutLinkUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutLinksUpdate.js
function checkoutLinksUpdate(client, request, options) {
  return new APIPromise($do12(client, request, options));
}
async function $do12(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutLinksUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CheckoutLinkUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkout-links/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkout-links:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CheckoutLink$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/checkoutlinks.js
var CheckoutLinks = class extends ClientSDK {
  /**
   * List Checkout Links
   *
   * @remarks
   * List checkout links.
   *
   * **Scopes**: `checkout_links:read` `checkout_links:write`
   */
  async list(request, options) {
    return unwrapResultIterator(checkoutLinksList(this, request, options));
  }
  /**
   * Create Checkout Link
   *
   * @remarks
   * Create a checkout link.
   *
   * **Scopes**: `checkout_links:write`
   */
  async create(request, options) {
    return unwrapAsync(checkoutLinksCreate(this, request, options));
  }
  /**
   * Get Checkout Link
   *
   * @remarks
   * Get a checkout link by ID.
   *
   * **Scopes**: `checkout_links:read` `checkout_links:write`
   */
  async get(request, options) {
    return unwrapAsync(checkoutLinksGet(this, request, options));
  }
  /**
   * Update Checkout Link
   *
   * @remarks
   * Update a checkout link.
   *
   * **Scopes**: `checkout_links:write`
   */
  async update(request, options) {
    return unwrapAsync(checkoutLinksUpdate(this, request, options));
  }
  /**
   * Delete Checkout Link
   *
   * @remarks
   * Delete a checkout link.
   *
   * **Scopes**: `checkout_links:write`
   */
  async delete(request, options) {
    return unwrapAsync(checkoutLinksDelete(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutorganization.js
var CheckoutOrganization$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  slug: string2(),
  avatar_url: nullable(string2()),
  proration_behavior: SubscriptionProrationBehavior$inboundSchema,
  allow_customer_updates: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "avatar_url": "avatarUrl",
    "proration_behavior": "prorationBehavior",
    "allow_customer_updates": "allowCustomerUpdates"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutpublicconfirmed.js
var CheckoutPublicConfirmedCustomFieldData$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
]);
var CheckoutPublicConfirmedProductPrice$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutPublicConfirmedPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutPublicConfirmedDiscount$inboundSchema = smartUnion([
  CheckoutDiscountFixedRepeatDuration$inboundSchema,
  CheckoutDiscountFixedOnceForeverDuration$inboundSchema,
  CheckoutDiscountPercentageRepeatDuration$inboundSchema,
  CheckoutDiscountPercentageOnceForeverDuration$inboundSchema
]);
var CheckoutPublicConfirmed$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  custom_field_data: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
  ])))),
  payment_processor: PaymentProcessor$inboundSchema,
  status: literal("confirmed"),
  client_secret: string2(),
  url: string2(),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  success_url: string2(),
  return_url: nullable(string2()),
  embed_origin: nullable(string2()),
  amount: int(),
  seats: optional(nullable(int())),
  price_per_seat: optional(nullable(int())),
  discount_amount: int(),
  net_amount: int(),
  tax_amount: nullable(int()),
  total_amount: int(),
  currency: string2(),
  allow_trial: nullable(boolean2()),
  active_trial_interval: nullable(TrialInterval$inboundSchema),
  active_trial_interval_count: nullable(int()),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2(),
  product_id: nullable(string2()),
  product_price_id: nullable(string2()),
  discount_id: nullable(string2()),
  allow_discount_codes: boolean2(),
  require_billing_address: boolean2(),
  is_discount_applicable: boolean2(),
  is_free_product_price: boolean2(),
  is_payment_required: boolean2(),
  is_payment_setup_required: boolean2(),
  is_payment_form_required: boolean2(),
  customer_id: nullable(string2()),
  is_business_customer: boolean2(),
  customer_name: nullable(string2()),
  customer_email: nullable(string2()),
  customer_ip_address: nullable(string2()),
  customer_billing_name: nullable(string2()),
  customer_billing_address: nullable(Address$inboundSchema),
  customer_tax_id: nullable(string2()),
  payment_processor_metadata: record(string2(), string2()),
  billing_address_fields: CheckoutBillingAddressFields$inboundSchema,
  products: array(CheckoutProduct$inboundSchema),
  product: nullable(CheckoutProduct$inboundSchema),
  product_price: nullable(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  prices: nullable(record(string2(), array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])))),
  discount: nullable(smartUnion([
    CheckoutDiscountFixedRepeatDuration$inboundSchema,
    CheckoutDiscountFixedOnceForeverDuration$inboundSchema,
    CheckoutDiscountPercentageRepeatDuration$inboundSchema,
    CheckoutDiscountPercentageOnceForeverDuration$inboundSchema
  ])),
  organization: CheckoutOrganization$inboundSchema,
  attached_custom_fields: nullable(array(AttachedCustomField$inboundSchema)),
  customer_session_token: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "custom_field_data": "customFieldData",
    "payment_processor": "paymentProcessor",
    "client_secret": "clientSecret",
    "expires_at": "expiresAt",
    "success_url": "successUrl",
    "return_url": "returnUrl",
    "embed_origin": "embedOrigin",
    "price_per_seat": "pricePerSeat",
    "discount_amount": "discountAmount",
    "net_amount": "netAmount",
    "tax_amount": "taxAmount",
    "total_amount": "totalAmount",
    "allow_trial": "allowTrial",
    "active_trial_interval": "activeTrialInterval",
    "active_trial_interval_count": "activeTrialIntervalCount",
    "trial_end": "trialEnd",
    "organization_id": "organizationId",
    "product_id": "productId",
    "product_price_id": "productPriceId",
    "discount_id": "discountId",
    "allow_discount_codes": "allowDiscountCodes",
    "require_billing_address": "requireBillingAddress",
    "is_discount_applicable": "isDiscountApplicable",
    "is_free_product_price": "isFreeProductPrice",
    "is_payment_required": "isPaymentRequired",
    "is_payment_setup_required": "isPaymentSetupRequired",
    "is_payment_form_required": "isPaymentFormRequired",
    "customer_id": "customerId",
    "is_business_customer": "isBusinessCustomer",
    "customer_name": "customerName",
    "customer_email": "customerEmail",
    "customer_ip_address": "customerIpAddress",
    "customer_billing_name": "customerBillingName",
    "customer_billing_address": "customerBillingAddress",
    "customer_tax_id": "customerTaxId",
    "payment_processor_metadata": "paymentProcessorMetadata",
    "billing_address_fields": "billingAddressFields",
    "product_price": "productPrice",
    "attached_custom_fields": "attachedCustomFields",
    "customer_session_token": "customerSessionToken"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/alreadyactivesubscriptionerror.js
var AlreadyActiveSubscriptionError = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "AlreadyActiveSubscriptionError";
  }
};
var AlreadyActiveSubscriptionError$inboundSchema = pipe(object({
  error: literal("AlreadyActiveSubscriptionError"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new AlreadyActiveSubscriptionError(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/notopencheckout.js
var NotOpenCheckout = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "NotOpenCheckout";
  }
};
var NotOpenCheckout$inboundSchema = pipe(object({
  error: literal("NotOpenCheckout"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new NotOpenCheckout(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/paymentnotready.js
var PaymentNotReady = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "PaymentNotReady";
  }
};
var PaymentNotReady$inboundSchema = pipe(object({
  error: literal("PaymentNotReady"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new PaymentNotReady(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/trialalreadyredeemed.js
var TrialAlreadyRedeemed = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "TrialAlreadyRedeemed";
  }
};
var TrialAlreadyRedeemed$inboundSchema = pipe(object({
  error: literal("TrialAlreadyRedeemed"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new TrialAlreadyRedeemed(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/checkoutforbiddenerror.js
var CheckoutForbiddenError$inboundSchema = union([
  AlreadyActiveSubscriptionError$inboundSchema,
  NotOpenCheckout$inboundSchema,
  PaymentNotReady$inboundSchema,
  TrialAlreadyRedeemed$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/expiredcheckouterror.js
var ExpiredCheckoutError = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "ExpiredCheckoutError";
  }
};
var ExpiredCheckoutError$inboundSchema = pipe(object({
  error: literal("ExpiredCheckoutError"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new ExpiredCheckoutError(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/paymenterror.js
var PaymentError = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "PaymentError";
  }
};
var PaymentError$inboundSchema = pipe(object({
  error: literal("PaymentError"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new PaymentError(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/addressinput.js
var CountryAlpha2Input = {
  Ad: "AD",
  Ae: "AE",
  Af: "AF",
  Ag: "AG",
  Ai: "AI",
  Al: "AL",
  Am: "AM",
  Ao: "AO",
  Aq: "AQ",
  Ar: "AR",
  As: "AS",
  At: "AT",
  Au: "AU",
  Aw: "AW",
  Ax: "AX",
  Az: "AZ",
  Ba: "BA",
  Bb: "BB",
  Bd: "BD",
  Be: "BE",
  Bf: "BF",
  Bg: "BG",
  Bh: "BH",
  Bi: "BI",
  Bj: "BJ",
  Bl: "BL",
  Bm: "BM",
  Bn: "BN",
  Bo: "BO",
  Bq: "BQ",
  Br: "BR",
  Bs: "BS",
  Bt: "BT",
  Bv: "BV",
  Bw: "BW",
  By: "BY",
  Bz: "BZ",
  Ca: "CA",
  Cc: "CC",
  Cd: "CD",
  Cf: "CF",
  Cg: "CG",
  Ch: "CH",
  Ci: "CI",
  Ck: "CK",
  Cl: "CL",
  Cm: "CM",
  Cn: "CN",
  Co: "CO",
  Cr: "CR",
  Cv: "CV",
  Cw: "CW",
  Cx: "CX",
  Cy: "CY",
  Cz: "CZ",
  De: "DE",
  Dj: "DJ",
  Dk: "DK",
  Dm: "DM",
  Do: "DO",
  Dz: "DZ",
  Ec: "EC",
  Ee: "EE",
  Eg: "EG",
  Eh: "EH",
  Er: "ER",
  Es: "ES",
  Et: "ET",
  Fi: "FI",
  Fj: "FJ",
  Fk: "FK",
  Fm: "FM",
  Fo: "FO",
  Fr: "FR",
  Ga: "GA",
  Gb: "GB",
  Gd: "GD",
  Ge: "GE",
  Gf: "GF",
  Gg: "GG",
  Gh: "GH",
  Gi: "GI",
  Gl: "GL",
  Gm: "GM",
  Gn: "GN",
  Gp: "GP",
  Gq: "GQ",
  Gr: "GR",
  Gs: "GS",
  Gt: "GT",
  Gu: "GU",
  Gw: "GW",
  Gy: "GY",
  Hk: "HK",
  Hm: "HM",
  Hn: "HN",
  Hr: "HR",
  Ht: "HT",
  Hu: "HU",
  Id: "ID",
  Ie: "IE",
  Il: "IL",
  Im: "IM",
  In: "IN",
  Io: "IO",
  Iq: "IQ",
  Is: "IS",
  It: "IT",
  Je: "JE",
  Jm: "JM",
  Jo: "JO",
  Jp: "JP",
  Ke: "KE",
  Kg: "KG",
  Kh: "KH",
  Ki: "KI",
  Km: "KM",
  Kn: "KN",
  Kr: "KR",
  Kw: "KW",
  Ky: "KY",
  Kz: "KZ",
  La: "LA",
  Lb: "LB",
  Lc: "LC",
  Li: "LI",
  Lk: "LK",
  Lr: "LR",
  Ls: "LS",
  Lt: "LT",
  Lu: "LU",
  Lv: "LV",
  Ly: "LY",
  Ma: "MA",
  Mc: "MC",
  Md: "MD",
  Me: "ME",
  Mf: "MF",
  Mg: "MG",
  Mh: "MH",
  Mk: "MK",
  Ml: "ML",
  Mm: "MM",
  Mn: "MN",
  Mo: "MO",
  Mp: "MP",
  Mq: "MQ",
  Mr: "MR",
  Ms: "MS",
  Mt: "MT",
  Mu: "MU",
  Mv: "MV",
  Mw: "MW",
  Mx: "MX",
  My: "MY",
  Mz: "MZ",
  Na: "NA",
  Nc: "NC",
  Ne: "NE",
  Nf: "NF",
  Ng: "NG",
  Ni: "NI",
  Nl: "NL",
  No: "NO",
  Np: "NP",
  Nr: "NR",
  Nu: "NU",
  Nz: "NZ",
  Om: "OM",
  Pa: "PA",
  Pe: "PE",
  Pf: "PF",
  Pg: "PG",
  Ph: "PH",
  Pk: "PK",
  Pl: "PL",
  Pm: "PM",
  Pn: "PN",
  Pr: "PR",
  Ps: "PS",
  Pt: "PT",
  Pw: "PW",
  Py: "PY",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Rs: "RS",
  Rw: "RW",
  Sa: "SA",
  Sb: "SB",
  Sc: "SC",
  Sd: "SD",
  Se: "SE",
  Sg: "SG",
  Sh: "SH",
  Si: "SI",
  Sj: "SJ",
  Sk: "SK",
  Sl: "SL",
  Sm: "SM",
  Sn: "SN",
  So: "SO",
  Sr: "SR",
  Ss: "SS",
  St: "ST",
  Sv: "SV",
  Sx: "SX",
  Sz: "SZ",
  Tc: "TC",
  Td: "TD",
  Tf: "TF",
  Tg: "TG",
  Th: "TH",
  Tj: "TJ",
  Tk: "TK",
  Tl: "TL",
  Tm: "TM",
  Tn: "TN",
  To: "TO",
  Tr: "TR",
  Tt: "TT",
  Tv: "TV",
  Tw: "TW",
  Tz: "TZ",
  Ua: "UA",
  Ug: "UG",
  Um: "UM",
  Us: "US",
  Uy: "UY",
  Uz: "UZ",
  Va: "VA",
  Vc: "VC",
  Ve: "VE",
  Vg: "VG",
  Vi: "VI",
  Vn: "VN",
  Vu: "VU",
  Wf: "WF",
  Ws: "WS",
  Ye: "YE",
  Yt: "YT",
  Za: "ZA",
  Zm: "ZM",
  Zw: "ZW"
};
var CountryAlpha2Input$outboundSchema = _enum2(CountryAlpha2Input);
var AddressInput$outboundSchema = pipe(object({
  line1: optional(nullable(string2())),
  line2: optional(nullable(string2())),
  postalCode: optional(nullable(string2())),
  city: optional(nullable(string2())),
  state: optional(nullable(string2())),
  country: CountryAlpha2Input$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    postalCode: "postal_code"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutconfirmstripe.js
var CheckoutConfirmStripeCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var CheckoutConfirmStripe$outboundSchema = pipe(object({
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  productId: optional(nullable(string2())),
  productPriceId: optional(nullable(string2())),
  amount: optional(nullable(int())),
  seats: optional(nullable(int())),
  isBusinessCustomer: optional(nullable(boolean2())),
  customerName: optional(nullable(string2())),
  customerEmail: optional(nullable(string2())),
  customerBillingName: optional(nullable(string2())),
  customerBillingAddress: optional(nullable(AddressInput$outboundSchema)),
  customerTaxId: optional(nullable(string2())),
  discountCode: optional(nullable(string2())),
  allowTrial: optional(nullable(literal(false))),
  confirmationTokenId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    customFieldData: "custom_field_data",
    productId: "product_id",
    productPriceId: "product_price_id",
    isBusinessCustomer: "is_business_customer",
    customerName: "customer_name",
    customerEmail: "customer_email",
    customerBillingName: "customer_billing_name",
    customerBillingAddress: "customer_billing_address",
    customerTaxId: "customer_tax_id",
    discountCode: "discount_code",
    allowTrial: "allow_trial",
    confirmationTokenId: "confirmation_token_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutsclientconfirm.js
var CheckoutsClientConfirmRequest$outboundSchema = pipe(object({
  clientSecret: string2(),
  checkoutConfirmStripe: CheckoutConfirmStripe$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    clientSecret: "client_secret",
    checkoutConfirmStripe: "CheckoutConfirmStripe"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsClientConfirm.js
function checkoutsClientConfirm(client, request, options) {
  return new APIPromise($do13(client, request, options));
}
async function $do13(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutsClientConfirmRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CheckoutConfirmStripe, {
    explode: true
  });
  const pathParams = {
    client_secret: encodeSimple("client_secret", payload.client_secret, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkouts/client/{client_secret}/confirm")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:client_confirm",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "403", "404", "410", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CheckoutPublicConfirmed$inboundSchema), jsonErr(400, PaymentError$inboundSchema), jsonErr(403, CheckoutForbiddenError$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(410, ExpiredCheckoutError$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutpublic.js
var CheckoutPublicCustomFieldData$inboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
]);
var CheckoutPublicProductPrice$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutPublicPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CheckoutPublicDiscount$inboundSchema = smartUnion([
  CheckoutDiscountFixedRepeatDuration$inboundSchema,
  CheckoutDiscountFixedOnceForeverDuration$inboundSchema,
  CheckoutDiscountPercentageRepeatDuration$inboundSchema,
  CheckoutDiscountPercentageOnceForeverDuration$inboundSchema
]);
var CheckoutPublic$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  custom_field_data: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
  ])))),
  payment_processor: PaymentProcessor$inboundSchema,
  status: CheckoutStatus$inboundSchema,
  client_secret: string2(),
  url: string2(),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  success_url: string2(),
  return_url: nullable(string2()),
  embed_origin: nullable(string2()),
  amount: int(),
  seats: optional(nullable(int())),
  price_per_seat: optional(nullable(int())),
  discount_amount: int(),
  net_amount: int(),
  tax_amount: nullable(int()),
  total_amount: int(),
  currency: string2(),
  allow_trial: nullable(boolean2()),
  active_trial_interval: nullable(TrialInterval$inboundSchema),
  active_trial_interval_count: nullable(int()),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2(),
  product_id: nullable(string2()),
  product_price_id: nullable(string2()),
  discount_id: nullable(string2()),
  allow_discount_codes: boolean2(),
  require_billing_address: boolean2(),
  is_discount_applicable: boolean2(),
  is_free_product_price: boolean2(),
  is_payment_required: boolean2(),
  is_payment_setup_required: boolean2(),
  is_payment_form_required: boolean2(),
  customer_id: nullable(string2()),
  is_business_customer: boolean2(),
  customer_name: nullable(string2()),
  customer_email: nullable(string2()),
  customer_ip_address: nullable(string2()),
  customer_billing_name: nullable(string2()),
  customer_billing_address: nullable(Address$inboundSchema),
  customer_tax_id: nullable(string2()),
  payment_processor_metadata: record(string2(), string2()),
  billing_address_fields: CheckoutBillingAddressFields$inboundSchema,
  products: array(CheckoutProduct$inboundSchema),
  product: nullable(CheckoutProduct$inboundSchema),
  product_price: nullable(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  prices: nullable(record(string2(), array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])))),
  discount: nullable(smartUnion([
    CheckoutDiscountFixedRepeatDuration$inboundSchema,
    CheckoutDiscountFixedOnceForeverDuration$inboundSchema,
    CheckoutDiscountPercentageRepeatDuration$inboundSchema,
    CheckoutDiscountPercentageOnceForeverDuration$inboundSchema
  ])),
  organization: CheckoutOrganization$inboundSchema,
  attached_custom_fields: nullable(array(AttachedCustomField$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "custom_field_data": "customFieldData",
    "payment_processor": "paymentProcessor",
    "client_secret": "clientSecret",
    "expires_at": "expiresAt",
    "success_url": "successUrl",
    "return_url": "returnUrl",
    "embed_origin": "embedOrigin",
    "price_per_seat": "pricePerSeat",
    "discount_amount": "discountAmount",
    "net_amount": "netAmount",
    "tax_amount": "taxAmount",
    "total_amount": "totalAmount",
    "allow_trial": "allowTrial",
    "active_trial_interval": "activeTrialInterval",
    "active_trial_interval_count": "activeTrialIntervalCount",
    "trial_end": "trialEnd",
    "organization_id": "organizationId",
    "product_id": "productId",
    "product_price_id": "productPriceId",
    "discount_id": "discountId",
    "allow_discount_codes": "allowDiscountCodes",
    "require_billing_address": "requireBillingAddress",
    "is_discount_applicable": "isDiscountApplicable",
    "is_free_product_price": "isFreeProductPrice",
    "is_payment_required": "isPaymentRequired",
    "is_payment_setup_required": "isPaymentSetupRequired",
    "is_payment_form_required": "isPaymentFormRequired",
    "customer_id": "customerId",
    "is_business_customer": "isBusinessCustomer",
    "customer_name": "customerName",
    "customer_email": "customerEmail",
    "customer_ip_address": "customerIpAddress",
    "customer_billing_name": "customerBillingName",
    "customer_billing_address": "customerBillingAddress",
    "customer_tax_id": "customerTaxId",
    "payment_processor_metadata": "paymentProcessorMetadata",
    "billing_address_fields": "billingAddressFields",
    "product_price": "productPrice",
    "attached_custom_fields": "attachedCustomFields"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutsclientget.js
var CheckoutsClientGetRequest$outboundSchema = pipe(object({
  clientSecret: string2()
}), transform((v2) => {
  return remap(v2, {
    clientSecret: "client_secret"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsClientGet.js
function checkoutsClientGet(client, request, options) {
  return new APIPromise($do14(client, request, options));
}
async function $do14(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutsClientGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    client_secret: encodeSimple("client_secret", payload.client_secret, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkouts/client/{client_secret}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:client_get",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "410", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CheckoutPublic$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(410, ExpiredCheckoutError$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutupdatepublic.js
var CheckoutUpdatePublicCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var CheckoutUpdatePublic$outboundSchema = pipe(object({
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  productId: optional(nullable(string2())),
  productPriceId: optional(nullable(string2())),
  amount: optional(nullable(int())),
  seats: optional(nullable(int())),
  isBusinessCustomer: optional(nullable(boolean2())),
  customerName: optional(nullable(string2())),
  customerEmail: optional(nullable(string2())),
  customerBillingName: optional(nullable(string2())),
  customerBillingAddress: optional(nullable(AddressInput$outboundSchema)),
  customerTaxId: optional(nullable(string2())),
  discountCode: optional(nullable(string2())),
  allowTrial: optional(nullable(literal(false)))
}), transform((v2) => {
  return remap(v2, {
    customFieldData: "custom_field_data",
    productId: "product_id",
    productPriceId: "product_price_id",
    isBusinessCustomer: "is_business_customer",
    customerName: "customer_name",
    customerEmail: "customer_email",
    customerBillingName: "customer_billing_name",
    customerBillingAddress: "customer_billing_address",
    customerTaxId: "customer_tax_id",
    discountCode: "discount_code",
    allowTrial: "allow_trial"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutsclientupdate.js
var CheckoutsClientUpdateRequest$outboundSchema = pipe(object({
  clientSecret: string2(),
  checkoutUpdatePublic: CheckoutUpdatePublic$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    clientSecret: "client_secret",
    checkoutUpdatePublic: "CheckoutUpdatePublic"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsClientUpdate.js
function checkoutsClientUpdate(client, request, options) {
  return new APIPromise($do15(client, request, options));
}
async function $do15(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutsClientUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CheckoutUpdatePublic, {
    explode: true
  });
  const pathParams = {
    client_secret: encodeSimple("client_secret", payload.client_secret, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkouts/client/{client_secret}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:client_update",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "410", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CheckoutPublic$inboundSchema), jsonErr(403, CheckoutForbiddenError$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(410, ExpiredCheckoutError$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/presentmentcurrency.js
var PresentmentCurrency = {
  Usd: "usd",
  Eur: "eur",
  Gbp: "gbp",
  Cad: "cad",
  Aud: "aud",
  Jpy: "jpy",
  Chf: "chf",
  Sek: "sek"
};
var PresentmentCurrency$outboundSchema = _enum2(PresentmentCurrency);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricecustomcreate.js
var ProductPriceCustomCreate$outboundSchema = pipe(object({
  amountType: literal("custom"),
  priceCurrency: _default2(string2(), "usd"),
  minimumAmount: _default2(int(), 50),
  maximumAmount: optional(nullable(int())),
  presetAmount: optional(nullable(int()))
}), transform((v2) => {
  return remap(v2, {
    amountType: "amount_type",
    priceCurrency: "price_currency",
    minimumAmount: "minimum_amount",
    maximumAmount: "maximum_amount",
    presetAmount: "preset_amount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricefixedcreate.js
var ProductPriceFixedCreate$outboundSchema = pipe(object({
  amountType: literal("fixed"),
  priceAmount: int(),
  priceCurrency: _default2(string2(), "usd")
}), transform((v2) => {
  return remap(v2, {
    amountType: "amount_type",
    priceAmount: "price_amount",
    priceCurrency: "price_currency"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricefreecreate.js
var ProductPriceFreeCreate$outboundSchema = pipe(object({
  amountType: literal("free")
}), transform((v2) => {
  return remap(v2, {
    amountType: "amount_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpricemeteredunitcreate.js
var UnitAmount$outboundSchema = smartUnion([number2(), string2()]);
var ProductPriceMeteredUnitCreate$outboundSchema = pipe(object({
  amountType: literal("metered_unit"),
  meterId: string2(),
  priceCurrency: _default2(string2(), "usd"),
  unitAmount: smartUnion([number2(), string2()]),
  capAmount: optional(nullable(int()))
}), transform((v2) => {
  return remap(v2, {
    amountType: "amount_type",
    meterId: "meter_id",
    priceCurrency: "price_currency",
    unitAmount: "unit_amount",
    capAmount: "cap_amount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpriceseattiersinput.js
var ProductPriceSeatTiersInput$outboundSchema = object({
  tiers: array(ProductPriceSeatTier$outboundSchema)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productpriceseatbasedcreate.js
var ProductPriceSeatBasedCreate$outboundSchema = pipe(object({
  amountType: literal("seat_based"),
  priceCurrency: _default2(string2(), "usd"),
  seatTiers: ProductPriceSeatTiersInput$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    amountType: "amount_type",
    priceCurrency: "price_currency",
    seatTiers: "seat_tiers"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutcreate.js
var CheckoutCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutCreateCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var CheckoutCreateCustomerMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutCreatePrices$outboundSchema = union([
  ProductPriceCustomCreate$outboundSchema,
  ProductPriceFixedCreate$outboundSchema,
  ProductPriceFreeCreate$outboundSchema,
  ProductPriceMeteredUnitCreate$outboundSchema,
  ProductPriceSeatBasedCreate$outboundSchema
]);
var CheckoutCreate$outboundSchema = pipe(object({
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  discountId: optional(nullable(string2())),
  allowDiscountCodes: _default2(boolean2(), true),
  requireBillingAddress: _default2(boolean2(), false),
  amount: optional(nullable(int())),
  seats: optional(nullable(int())),
  allowTrial: _default2(boolean2(), true),
  customerId: optional(nullable(string2())),
  isBusinessCustomer: _default2(boolean2(), false),
  externalCustomerId: optional(nullable(string2())),
  customerName: optional(nullable(string2())),
  customerEmail: optional(nullable(string2())),
  customerIpAddress: optional(nullable(string2())),
  customerBillingName: optional(nullable(string2())),
  customerBillingAddress: optional(nullable(AddressInput$outboundSchema)),
  customerTaxId: optional(nullable(string2())),
  customerMetadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  subscriptionId: optional(nullable(string2())),
  successUrl: optional(nullable(string2())),
  returnUrl: optional(nullable(string2())),
  embedOrigin: optional(nullable(string2())),
  currency: optional(nullable(PresentmentCurrency$outboundSchema)),
  products: array(string2()),
  prices: optional(nullable(record(string2(), array(union([
    ProductPriceCustomCreate$outboundSchema,
    ProductPriceFixedCreate$outboundSchema,
    ProductPriceFreeCreate$outboundSchema,
    ProductPriceMeteredUnitCreate$outboundSchema,
    ProductPriceSeatBasedCreate$outboundSchema
  ])))))
}), transform((v2) => {
  return remap(v2, {
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    customFieldData: "custom_field_data",
    discountId: "discount_id",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    allowTrial: "allow_trial",
    customerId: "customer_id",
    isBusinessCustomer: "is_business_customer",
    externalCustomerId: "external_customer_id",
    customerName: "customer_name",
    customerEmail: "customer_email",
    customerIpAddress: "customer_ip_address",
    customerBillingName: "customer_billing_name",
    customerBillingAddress: "customer_billing_address",
    customerTaxId: "customer_tax_id",
    customerMetadata: "customer_metadata",
    subscriptionId: "subscription_id",
    successUrl: "success_url",
    returnUrl: "return_url",
    embedOrigin: "embed_origin"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsCreate.js
function checkoutsCreate(client, request, options) {
  return new APIPromise($do16(client, request, options));
}
async function $do16(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/checkouts/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Checkout$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutsget.js
var CheckoutsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsGet.js
function checkoutsGet(client, request, options) {
  return new APIPromise($do17(client, request, options));
}
async function $do17(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkouts/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Checkout$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutsortproperty.js
var CheckoutSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  ExpiresAt: "expires_at",
  MinusExpiresAt: "-expires_at",
  Status: "status",
  MinusStatus: "-status"
};
var CheckoutSortProperty$outboundSchema = _enum2(CheckoutSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecheckout.js
var ListResourceCheckout$inboundSchema = object({
  items: array(Checkout$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutslist.js
var CheckoutsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CheckoutsListQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CheckoutsListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CheckoutsListQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamStatusFilter$outboundSchema = smartUnion([
  CheckoutStatus$outboundSchema,
  array(CheckoutStatus$outboundSchema)
]);
var CheckoutsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  status: optional(nullable(smartUnion([
    CheckoutStatus$outboundSchema,
    array(CheckoutStatus$outboundSchema)
  ]))),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CheckoutSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    productId: "product_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id"
  });
}));
var CheckoutsListResponse$inboundSchema = pipe(object({
  Result: ListResourceCheckout$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsList.js
function checkoutsList(client, request, options) {
  return new APIPromise($do18(client, request, options));
}
async function $do18(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/checkouts/")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "product_id": payload.product_id,
    "query": payload.query,
    "sorting": payload.sorting,
    "status": payload.status
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CheckoutsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => checkoutsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutupdate.js
var CheckoutUpdateCustomFieldData$outboundSchema = smartUnion([
  string2(),
  int(),
  boolean2(),
  pipe(date2(), transform((v2) => v2.toISOString()))
]);
var CheckoutUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutUpdateCustomerMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CheckoutUpdate$outboundSchema = pipe(object({
  customFieldData: optional(record(string2(), nullable(smartUnion([
    string2(),
    int(),
    boolean2(),
    pipe(date2(), transform((v2) => v2.toISOString()))
  ])))),
  productId: optional(nullable(string2())),
  productPriceId: optional(nullable(string2())),
  amount: optional(nullable(int())),
  seats: optional(nullable(int())),
  isBusinessCustomer: optional(nullable(boolean2())),
  customerName: optional(nullable(string2())),
  customerEmail: optional(nullable(string2())),
  customerBillingName: optional(nullable(string2())),
  customerBillingAddress: optional(nullable(AddressInput$outboundSchema)),
  customerTaxId: optional(nullable(string2())),
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  currency: optional(nullable(PresentmentCurrency$outboundSchema)),
  discountId: optional(nullable(string2())),
  allowDiscountCodes: optional(nullable(boolean2())),
  requireBillingAddress: optional(nullable(boolean2())),
  allowTrial: optional(nullable(boolean2())),
  customerIpAddress: optional(nullable(string2())),
  customerMetadata: optional(nullable(record(string2(), smartUnion([string2(), int(), number2(), boolean2()])))),
  successUrl: optional(nullable(string2())),
  returnUrl: optional(nullable(string2())),
  embedOrigin: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    customFieldData: "custom_field_data",
    productId: "product_id",
    productPriceId: "product_price_id",
    isBusinessCustomer: "is_business_customer",
    customerName: "customer_name",
    customerEmail: "customer_email",
    customerBillingName: "customer_billing_name",
    customerBillingAddress: "customer_billing_address",
    customerTaxId: "customer_tax_id",
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    discountId: "discount_id",
    allowDiscountCodes: "allow_discount_codes",
    requireBillingAddress: "require_billing_address",
    allowTrial: "allow_trial",
    customerIpAddress: "customer_ip_address",
    customerMetadata: "customer_metadata",
    successUrl: "success_url",
    returnUrl: "return_url",
    embedOrigin: "embed_origin"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/checkoutsupdate.js
var CheckoutsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  checkoutUpdate: CheckoutUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    checkoutUpdate: "CheckoutUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/checkoutsUpdate.js
function checkoutsUpdate(client, request, options) {
  return new APIPromise($do19(client, request, options));
}
async function $do19(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CheckoutsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CheckoutUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/checkouts/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "checkouts:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Checkout$inboundSchema), jsonErr(403, CheckoutForbiddenError$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/checkouts.js
var Checkouts = class extends ClientSDK {
  /**
   * List Checkout Sessions
   *
   * @remarks
   * List checkout sessions.
   *
   * **Scopes**: `checkouts:read` `checkouts:write`
   */
  async list(request, options) {
    return unwrapResultIterator(checkoutsList(this, request, options));
  }
  /**
   * Create Checkout Session
   *
   * @remarks
   * Create a checkout session.
   *
   * **Scopes**: `checkouts:write`
   */
  async create(request, options) {
    return unwrapAsync(checkoutsCreate(this, request, options));
  }
  /**
   * Get Checkout Session
   *
   * @remarks
   * Get a checkout session by ID.
   *
   * **Scopes**: `checkouts:read` `checkouts:write`
   */
  async get(request, options) {
    return unwrapAsync(checkoutsGet(this, request, options));
  }
  /**
   * Update Checkout Session
   *
   * @remarks
   * Update a checkout session.
   *
   * **Scopes**: `checkouts:write`
   */
  async update(request, options) {
    return unwrapAsync(checkoutsUpdate(this, request, options));
  }
  /**
   * Get Checkout Session from Client
   *
   * @remarks
   * Get a checkout session by client secret.
   */
  async clientGet(request, options) {
    return unwrapAsync(checkoutsClientGet(this, request, options));
  }
  /**
   * Update Checkout Session from Client
   *
   * @remarks
   * Update a checkout session by client secret.
   */
  async clientUpdate(request, options) {
    return unwrapAsync(checkoutsClientUpdate(this, request, options));
  }
  /**
   * Confirm Checkout Session from Client
   *
   * @remarks
   * Confirm a checkout session by client secret.
   *
   * Orders and subscriptions will be processed.
   */
  async clientConfirm(request, options) {
    return unwrapAsync(checkoutsClientConfirm(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customermeter.js
var CustomerMeter$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  meter_id: string2(),
  consumed_units: number2(),
  credited_units: int(),
  balance: number2(),
  customer: Customer$inboundSchema,
  meter: Meter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "customer_id": "customerId",
    "meter_id": "meterId",
    "consumed_units": "consumedUnits",
    "credited_units": "creditedUnits"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customermetersget.js
var CustomerMetersGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerMetersGet.js
function customerMetersGet(client, request, options) {
  return new APIPromise($do20(client, request, options));
}
async function $do20(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerMetersGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-meters/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_meters:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerMeter$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customermetersortproperty.js
var CustomerMeterSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  ModifiedAt: "modified_at",
  MinusModifiedAt: "-modified_at",
  CustomerId: "customer_id",
  MinusCustomerId: "-customer_id",
  CustomerName: "customer_name",
  MinusCustomerName: "-customer_name",
  MeterId: "meter_id",
  MinusMeterId: "-meter_id",
  MeterName: "meter_name",
  MinusMeterName: "-meter_name",
  ConsumedUnits: "consumed_units",
  MinusConsumedUnits: "-consumed_units",
  CreditedUnits: "credited_units",
  MinusCreditedUnits: "-credited_units",
  Balance: "balance",
  MinusBalance: "-balance"
};
var CustomerMeterSortProperty$outboundSchema = _enum2(CustomerMeterSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomermeter.js
var ListResourceCustomerMeter$inboundSchema = object({
  items: array(CustomerMeter$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customermeterslist.js
var CustomerMetersListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerMetersListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerMetersListQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamMeterIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerMetersListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  meterId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerMeterSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    meterId: "meter_id"
  });
}));
var CustomerMetersListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerMeter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerMetersList.js
function customerMetersList(client, request, options) {
  return new APIPromise($do21(client, request, options));
}
async function $do21(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerMetersListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-meters/")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "meter_id": payload.meter_id,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_meters:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerMetersListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerMetersList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customermeters.js
var CustomerMeters = class extends ClientSDK {
  /**
   * List Customer Meters
   *
   * @remarks
   * List customer meters.
   *
   * **Scopes**: `customer_meters:read`
   */
  async list(request, options) {
    return unwrapResultIterator(customerMetersList(this, request, options));
  }
  /**
   * Get Customer Meter
   *
   * @remarks
   * Get a customer meter by ID.
   *
   * **Scopes**: `customer_meters:read`
   */
  async get(request, options) {
    return unwrapAsync(customerMetersGet(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/portalauthenticateduser.js
var PortalAuthenticatedUser$inboundSchema = pipe(object({
  type: string2(),
  name: nullable(string2()),
  email: string2(),
  customer_id: string2(),
  role: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    "customer_id": "customerId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomerSessionGetAuthenticatedUser.js
function customerPortalCustomerSessionGetAuthenticatedUser(client, security, options) {
  return new APIPromise($do22(client, security, options));
}
async function $do22(client, security, options) {
  const path = pathToFunc("/v1/customer-portal/customer-session/user")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customer-session:get_authenticated_user",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, PortalAuthenticatedUser$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercustomersession.js
var CustomerCustomerSession$inboundSchema = pipe(object({
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  return_url: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "expires_at": "expiresAt",
    "return_url": "returnUrl"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomerSessionIntrospect.js
function customerPortalCustomerSessionIntrospect(client, security, options) {
  return new APIPromise($do23(client, security, options));
}
async function $do23(client, security, options) {
  const path = pathToFunc("/v1/customer-portal/customer-session/introspect")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customer-session:introspect",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CustomerCustomerSession$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customersession.js
var CustomerSession = class extends ClientSDK {
  /**
   * Introspect Customer Session
   *
   * @remarks
   * Introspect the current session and return its information.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async introspect(security, options) {
    return unwrapAsync(customerPortalCustomerSessionIntrospect(this, security, options));
  }
  /**
   * Get Authenticated Portal User
   *
   * @remarks
   * Get information about the currently authenticated portal user.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async getAuthenticatedUser(security, options) {
    return unwrapAsync(customerPortalCustomerSessionGetAuthenticatedUser(this, security, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/fileservicetypes.js
var FileServiceTypes = {
  Downloadable: "downloadable",
  ProductMedia: "product_media",
  OrganizationAvatar: "organization_avatar"
};
var FileServiceTypes$inboundSchema = _enum2(FileServiceTypes);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/s3downloadurl.js
var S3DownloadURL$inboundSchema = pipe(object({
  url: string2(),
  headers: optional(record(string2(), string2())),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
}), transform((v2) => {
  return remap(v2, {
    "expires_at": "expiresAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filedownload.js
var FileDownload$inboundSchema = pipe(object({
  id: string2(),
  organization_id: string2(),
  name: string2(),
  path: string2(),
  mime_type: string2(),
  size: int(),
  storage_version: nullable(string2()),
  checksum_etag: nullable(string2()),
  checksum_sha256_base64: nullable(string2()),
  checksum_sha256_hex: nullable(string2()),
  last_modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  download: S3DownloadURL$inboundSchema,
  version: nullable(string2()),
  is_uploaded: boolean2(),
  service: FileServiceTypes$inboundSchema,
  size_readable: string2()
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "mime_type": "mimeType",
    "storage_version": "storageVersion",
    "checksum_etag": "checksumEtag",
    "checksum_sha256_base64": "checksumSha256Base64",
    "checksum_sha256_hex": "checksumSha256Hex",
    "last_modified_at": "lastModifiedAt",
    "is_uploaded": "isUploaded",
    "size_readable": "sizeReadable"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/downloadableread.js
var DownloadableRead$inboundSchema = pipe(object({
  id: string2(),
  benefit_id: string2(),
  file: FileDownload$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "benefit_id": "benefitId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcedownloadableread.js
var ListResourceDownloadableRead$inboundSchema = object({
  items: array(DownloadableRead$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportaldownloadableslist.js
var CustomerPortalDownloadablesListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalDownloadablesListQueryParamBenefitIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalDownloadablesListRequest$outboundSchema = pipe(object({
  benefitId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    benefitId: "benefit_id"
  });
}));
var CustomerPortalDownloadablesListResponse$inboundSchema = pipe(object({
  Result: ListResourceDownloadableRead$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalDownloadablesList.js
function customerPortalDownloadablesList(client, security, request, options) {
  return new APIPromise($do24(client, security, request, options));
}
async function $do24(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalDownloadablesListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/downloadables/")();
  const query = encodeFormQuery({
    "benefit_id": payload.benefit_id,
    "limit": payload.limit,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:downloadables:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalDownloadablesListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalDownloadablesList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/downloadables.js
var Downloadables = class extends ClientSDK {
  /**
   * List Downloadables
   *
   * @remarks
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalDownloadablesList(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustomsubscriberproperties.js
var BenefitCustomSubscriberProperties$inboundSchema = object({
  note: nullable(string2())
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitsubscriberorganization.js
var BenefitSubscriberOrganization$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  slug: string2(),
  avatar_url: nullable(string2()),
  proration_behavior: SubscriptionProrationBehavior$inboundSchema,
  allow_customer_updates: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "avatar_url": "avatarUrl",
    "proration_behavior": "prorationBehavior",
    "allow_customer_updates": "allowCustomerUpdates"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcustomsubscriber.js
var BenefitCustomSubscriber$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("custom"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  organization: BenefitSubscriberOrganization$inboundSchema,
  properties: BenefitCustomSubscriberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerportaloauthaccount.js
var CustomerPortalOAuthAccount$inboundSchema = pipe(object({
  account_id: string2(),
  account_username: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "account_id": "accountId",
    "account_username": "accountUsername"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerportalcustomer.js
var CustomerPortalCustomerTaxId$inboundSchema = smartUnion([string2(), TaxIDFormat$inboundSchema]);
var CustomerPortalCustomer$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  email: string2(),
  email_verified: boolean2(),
  name: nullable(string2()),
  billing_name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  oauth_accounts: record(string2(), CustomerPortalOAuthAccount$inboundSchema),
  default_payment_method_id: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "email_verified": "emailVerified",
    "billing_name": "billingName",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "oauth_accounts": "oauthAccounts",
    "default_payment_method_id": "defaultPaymentMethodId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantcustom.js
var CustomerBenefitGrantCustom$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  revoked_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  is_granted: boolean2(),
  is_revoked: boolean2(),
  customer: CustomerPortalCustomer$inboundSchema,
  benefit: BenefitCustomSubscriber$inboundSchema,
  properties: BenefitGrantCustomProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "revoked_at": "revokedAt",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "is_granted": "isGranted",
    "is_revoked": "isRevoked"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscordsubscriberproperties.js
var BenefitDiscordSubscriberProperties$inboundSchema = pipe(object({
  guild_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "guild_id": "guildId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdiscordsubscriber.js
var BenefitDiscordSubscriber$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("discord"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  organization: BenefitSubscriberOrganization$inboundSchema,
  properties: BenefitDiscordSubscriberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantdiscord.js
var CustomerBenefitGrantDiscord$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  revoked_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  is_granted: boolean2(),
  is_revoked: boolean2(),
  customer: CustomerPortalCustomer$inboundSchema,
  benefit: BenefitDiscordSubscriber$inboundSchema,
  properties: BenefitGrantDiscordProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "revoked_at": "revokedAt",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "is_granted": "isGranted",
    "is_revoked": "isRevoked"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadablessubscriberproperties.js
var BenefitDownloadablesSubscriberProperties$inboundSchema = pipe(object({
  active_files: array(string2())
}), transform((v2) => {
  return remap(v2, {
    "active_files": "activeFiles"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitdownloadablessubscriber.js
var BenefitDownloadablesSubscriber$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("downloadables"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  organization: BenefitSubscriberOrganization$inboundSchema,
  properties: BenefitDownloadablesSubscriberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantdownloadables.js
var CustomerBenefitGrantDownloadables$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  revoked_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  is_granted: boolean2(),
  is_revoked: boolean2(),
  customer: CustomerPortalCustomer$inboundSchema,
  benefit: BenefitDownloadablesSubscriber$inboundSchema,
  properties: BenefitGrantDownloadablesProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "revoked_at": "revokedAt",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "is_granted": "isGranted",
    "is_revoked": "isRevoked"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepositorysubscriberproperties.js
var BenefitGitHubRepositorySubscriberProperties$inboundSchema = pipe(object({
  repository_owner: string2(),
  repository_name: string2()
}), transform((v2) => {
  return remap(v2, {
    "repository_owner": "repositoryOwner",
    "repository_name": "repositoryName"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgithubrepositorysubscriber.js
var BenefitGitHubRepositorySubscriber$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("github_repository"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  organization: BenefitSubscriberOrganization$inboundSchema,
  properties: BenefitGitHubRepositorySubscriberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantgithubrepository.js
var CustomerBenefitGrantGitHubRepository$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  revoked_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  is_granted: boolean2(),
  is_revoked: boolean2(),
  customer: CustomerPortalCustomer$inboundSchema,
  benefit: BenefitGitHubRepositorySubscriber$inboundSchema,
  properties: BenefitGrantGitHubRepositoryProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "revoked_at": "revokedAt",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "is_granted": "isGranted",
    "is_revoked": "isRevoked"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyssubscriberproperties.js
var BenefitLicenseKeysSubscriberProperties$inboundSchema = pipe(object({
  prefix: nullable(string2()),
  expires: nullable(BenefitLicenseKeyExpirationProperties$inboundSchema),
  activations: nullable(BenefitLicenseKeyActivationProperties$inboundSchema),
  limit_usage: nullable(int())
}), transform((v2) => {
  return remap(v2, {
    "limit_usage": "limitUsage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitlicensekeyssubscriber.js
var BenefitLicenseKeysSubscriber$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("license_keys"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  organization: BenefitSubscriberOrganization$inboundSchema,
  properties: BenefitLicenseKeysSubscriberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantlicensekeys.js
var CustomerBenefitGrantLicenseKeys$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  revoked_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  is_granted: boolean2(),
  is_revoked: boolean2(),
  customer: CustomerPortalCustomer$inboundSchema,
  benefit: BenefitLicenseKeysSubscriber$inboundSchema,
  properties: BenefitGrantLicenseKeysProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "revoked_at": "revokedAt",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "is_granted": "isGranted",
    "is_revoked": "isRevoked"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercreditsubscriberproperties.js
var BenefitMeterCreditSubscriberProperties$inboundSchema = pipe(object({
  units: int(),
  rollover: boolean2(),
  meter_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "meter_id": "meterId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitmetercreditsubscriber.js
var BenefitMeterCreditSubscriber$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  type: literal("meter_credit"),
  description: string2(),
  selectable: boolean2(),
  deletable: boolean2(),
  organization_id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  organization: BenefitSubscriberOrganization$inboundSchema,
  properties: BenefitMeterCreditSubscriberProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantmetercredit.js
var CustomerBenefitGrantMeterCredit$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  granted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  revoked_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  member_id: optional(nullable(string2())),
  benefit_id: string2(),
  subscription_id: nullable(string2()),
  order_id: nullable(string2()),
  is_granted: boolean2(),
  is_revoked: boolean2(),
  customer: CustomerPortalCustomer$inboundSchema,
  benefit: BenefitMeterCreditSubscriber$inboundSchema,
  properties: BenefitGrantMeterCreditProperties$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "granted_at": "grantedAt",
    "revoked_at": "revokedAt",
    "customer_id": "customerId",
    "member_id": "memberId",
    "benefit_id": "benefitId",
    "subscription_id": "subscriptionId",
    "order_id": "orderId",
    "is_granted": "isGranted",
    "is_revoked": "isRevoked"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrant.js
var CustomerBenefitGrant$inboundSchema = smartUnion([
  CustomerBenefitGrantDiscord$inboundSchema,
  CustomerBenefitGrantGitHubRepository$inboundSchema,
  CustomerBenefitGrantDownloadables$inboundSchema,
  CustomerBenefitGrantLicenseKeys$inboundSchema,
  CustomerBenefitGrantCustom$inboundSchema,
  CustomerBenefitGrantMeterCredit$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalbenefitgrantsget.js
var CustomerPortalBenefitGrantsGetSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalBenefitGrantsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalBenefitGrantsGet.js
function customerPortalBenefitGrantsGet(client, security, request, options) {
  return new APIPromise($do25(client, security, request, options));
}
async function $do25(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalBenefitGrantsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/benefit-grants/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:benefit-grants:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerBenefitGrant$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantsortproperty.js
var CustomerBenefitGrantSortProperty = {
  GrantedAt: "granted_at",
  MinusGrantedAt: "-granted_at",
  Type: "type",
  MinusType: "-type",
  Organization: "organization",
  MinusOrganization: "-organization",
  ProductBenefit: "product_benefit",
  MinusProductBenefit: "-product_benefit"
};
var CustomerBenefitGrantSortProperty$outboundSchema = _enum2(CustomerBenefitGrantSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomerbenefitgrant.js
var ListResourceCustomerBenefitGrant$inboundSchema = object({
  items: array(CustomerBenefitGrant$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalbenefitgrantslist.js
var CustomerPortalBenefitGrantsListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var QueryParamBenefitTypeFilter$outboundSchema = smartUnion([
  BenefitType$outboundSchema,
  array(BenefitType$outboundSchema)
]);
var CustomerPortalBenefitGrantsListQueryParamBenefitIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamCheckoutIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalBenefitGrantsListQueryParamOrderIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamSubscriptionIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamMemberIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalBenefitGrantsListRequest$outboundSchema = pipe(object({
  typeFilter: optional(nullable(smartUnion([
    BenefitType$outboundSchema,
    array(BenefitType$outboundSchema)
  ]))),
  benefitId: optional(nullable(smartUnion([string2(), array(string2())]))),
  checkoutId: optional(nullable(smartUnion([string2(), array(string2())]))),
  orderId: optional(nullable(smartUnion([string2(), array(string2())]))),
  subscriptionId: optional(nullable(smartUnion([string2(), array(string2())]))),
  memberId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerBenefitGrantSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    typeFilter: "type_filter",
    benefitId: "benefit_id",
    checkoutId: "checkout_id",
    orderId: "order_id",
    subscriptionId: "subscription_id",
    memberId: "member_id"
  });
}));
var CustomerPortalBenefitGrantsListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerBenefitGrant$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalBenefitGrantsList.js
function customerPortalBenefitGrantsList(client, security, request, options) {
  return new APIPromise($do26(client, security, request, options));
}
async function $do26(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalBenefitGrantsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/benefit-grants/")();
  const query = encodeFormQuery({
    "benefit_id": payload.benefit_id,
    "checkout_id": payload.checkout_id,
    "limit": payload.limit,
    "member_id": payload.member_id,
    "order_id": payload.order_id,
    "page": payload.page,
    "sorting": payload.sorting,
    "subscription_id": payload.subscription_id,
    "type": payload.type_filter
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:benefit-grants:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalBenefitGrantsListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalBenefitGrantsList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantcustomupdate.js
var CustomerBenefitGrantCustomUpdate$outboundSchema = pipe(object({
  benefitType: literal("custom")
}), transform((v2) => {
  return remap(v2, {
    benefitType: "benefit_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantdiscordpropertiesupdate.js
var CustomerBenefitGrantDiscordPropertiesUpdate$outboundSchema = pipe(object({
  accountId: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    accountId: "account_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantdiscordupdate.js
var CustomerBenefitGrantDiscordUpdate$outboundSchema = pipe(object({
  benefitType: literal("discord"),
  properties: CustomerBenefitGrantDiscordPropertiesUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    benefitType: "benefit_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantdownloadablesupdate.js
var CustomerBenefitGrantDownloadablesUpdate$outboundSchema = pipe(object({
  benefitType: literal("downloadables")
}), transform((v2) => {
  return remap(v2, {
    benefitType: "benefit_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantgithubrepositorypropertiesupdate.js
var CustomerBenefitGrantGitHubRepositoryPropertiesUpdate$outboundSchema = pipe(object({
  accountId: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    accountId: "account_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantgithubrepositoryupdate.js
var CustomerBenefitGrantGitHubRepositoryUpdate$outboundSchema = pipe(object({
  benefitType: literal("github_repository"),
  properties: CustomerBenefitGrantGitHubRepositoryPropertiesUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    benefitType: "benefit_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantlicensekeysupdate.js
var CustomerBenefitGrantLicenseKeysUpdate$outboundSchema = pipe(object({
  benefitType: literal("license_keys")
}), transform((v2) => {
  return remap(v2, {
    benefitType: "benefit_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantmetercreditupdate.js
var CustomerBenefitGrantMeterCreditUpdate$outboundSchema = pipe(object({
  benefitType: literal("meter_credit")
}), transform((v2) => {
  return remap(v2, {
    benefitType: "benefit_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerbenefitgrantupdate.js
var CustomerBenefitGrantUpdate$outboundSchema = union([
  CustomerBenefitGrantCustomUpdate$outboundSchema,
  CustomerBenefitGrantDiscordUpdate$outboundSchema,
  CustomerBenefitGrantDownloadablesUpdate$outboundSchema,
  CustomerBenefitGrantGitHubRepositoryUpdate$outboundSchema,
  CustomerBenefitGrantLicenseKeysUpdate$outboundSchema,
  CustomerBenefitGrantMeterCreditUpdate$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalbenefitgrantsupdate.js
var CustomerPortalBenefitGrantsUpdateSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalBenefitGrantsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  customerBenefitGrantUpdate: CustomerBenefitGrantUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    customerBenefitGrantUpdate: "CustomerBenefitGrantUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalBenefitGrantsUpdate.js
function customerPortalBenefitGrantsUpdate(client, security, request, options) {
  return new APIPromise($do27(client, security, request, options));
}
async function $do27(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalBenefitGrantsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomerBenefitGrantUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/benefit-grants/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:benefit-grants:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerBenefitGrant$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarbenefitgrants.js
var PolarBenefitGrants = class extends ClientSDK {
  /**
   * List Benefit Grants
   *
   * @remarks
   * List benefits grants of the authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalBenefitGrantsList(this, security, request, options));
  }
  /**
   * Get Benefit Grant
   *
   * @remarks
   * Get a benefit grant by ID for the authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async get(security, request, options) {
    return unwrapAsync(customerPortalBenefitGrantsGet(this, security, request, options));
  }
  /**
   * Update Benefit Grant
   *
   * @remarks
   * Update a benefit grant for the authenticated customer.
   *
   * **Scopes**: `customer_portal:write`
   */
  async update(security, request, options) {
    return unwrapAsync(customerPortalBenefitGrantsUpdate(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercustomermetermeter.js
var CustomerCustomerMeterMeter$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercustomermeter.js
var CustomerCustomerMeter$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  meter_id: string2(),
  consumed_units: number2(),
  credited_units: int(),
  balance: number2(),
  meter: CustomerCustomerMeterMeter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "customer_id": "customerId",
    "meter_id": "meterId",
    "consumed_units": "consumedUnits",
    "credited_units": "creditedUnits"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalcustomermetersget.js
var CustomerPortalCustomerMetersGetSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalCustomerMetersGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomerMetersGet.js
function customerPortalCustomerMetersGet(client, security, request, options) {
  return new APIPromise($do28(client, security, request, options));
}
async function $do28(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalCustomerMetersGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/meters/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customer_meters:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerCustomerMeter$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercustomermetersortproperty.js
var CustomerCustomerMeterSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  ModifiedAt: "modified_at",
  MinusModifiedAt: "-modified_at",
  MeterId: "meter_id",
  MinusMeterId: "-meter_id",
  MeterName: "meter_name",
  MinusMeterName: "-meter_name",
  ConsumedUnits: "consumed_units",
  MinusConsumedUnits: "-consumed_units",
  CreditedUnits: "credited_units",
  MinusCreditedUnits: "-credited_units",
  Balance: "balance",
  MinusBalance: "-balance"
};
var CustomerCustomerMeterSortProperty$outboundSchema = _enum2(CustomerCustomerMeterSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomercustomermeter.js
var ListResourceCustomerCustomerMeter$inboundSchema = object({
  items: array(CustomerCustomerMeter$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalcustomermeterslist.js
var CustomerPortalCustomerMetersListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var MeterIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalCustomerMetersListRequest$outboundSchema = pipe(object({
  meterId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerCustomerMeterSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    meterId: "meter_id"
  });
}));
var CustomerPortalCustomerMetersListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerCustomerMeter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomerMetersList.js
function customerPortalCustomerMetersList(client, security, request, options) {
  return new APIPromise($do29(client, security, request, options));
}
async function $do29(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalCustomerMetersListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/meters/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "meter_id": payload.meter_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customer_meters:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalCustomerMetersListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalCustomerMetersList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarcustomermeters.js
var PolarCustomerMeters = class extends ClientSDK {
  /**
   * List Meters
   *
   * @remarks
   * List meters of the authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalCustomerMetersList(this, security, request, options));
  }
  /**
   * Get Customer Meter
   *
   * @remarks
   * Get a meter by ID for the authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async get(security, request, options) {
    return unwrapAsync(customerPortalCustomerMetersGet(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerpaymentmethodcreate.js
var CustomerPaymentMethodCreate$outboundSchema = pipe(object({
  confirmationTokenId: string2(),
  setDefault: boolean2(),
  returnUrl: string2()
}), transform((v2) => {
  return remap(v2, {
    confirmationTokenId: "confirmation_token_id",
    setDefault: "set_default",
    returnUrl: "return_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerpaymentmethodcreaterequiresactionresponse.js
var CustomerPaymentMethodCreateRequiresActionResponse$inboundSchema = pipe(object({
  status: literal("requires_action"),
  client_secret: string2()
}), transform((v2) => {
  return remap(v2, {
    "client_secret": "clientSecret"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/paymentmethodcardmetadata.js
var PaymentMethodCardMetadata$inboundSchema = pipe(object({
  brand: string2(),
  last4: string2(),
  exp_month: int(),
  exp_year: int(),
  wallet: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    "exp_month": "expMonth",
    "exp_year": "expYear"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/paymentmethodcard.js
var PaymentMethodCard$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  processor: PaymentProcessor$inboundSchema,
  customer_id: string2(),
  type: literal("card"),
  method_metadata: PaymentMethodCardMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "customer_id": "customerId",
    "method_metadata": "methodMetadata"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/paymentmethodgeneric.js
var PaymentMethodGeneric$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  processor: PaymentProcessor$inboundSchema,
  customer_id: string2(),
  type: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "customer_id": "customerId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerpaymentmethod.js
var CustomerPaymentMethod$inboundSchema = smartUnion([
  PaymentMethodCard$inboundSchema,
  PaymentMethodGeneric$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerpaymentmethodcreatesucceededresponse.js
var CustomerPaymentMethodCreateSucceededResponse$inboundSchema = pipe(object({
  status: literal("succeeded"),
  payment_method: CustomerPaymentMethod$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "payment_method": "paymentMethod"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerpaymentmethodcreateresponse.js
var CustomerPaymentMethodCreateResponse$inboundSchema = union([
  CustomerPaymentMethodCreateRequiresActionResponse$inboundSchema,
  CustomerPaymentMethodCreateSucceededResponse$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomersAddPaymentMethod.js
function customerPortalCustomersAddPaymentMethod(client, security, request, options) {
  return new APIPromise($do30(client, security, request, options));
}
async function $do30(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPaymentMethodCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/customers/me/payment-methods")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customers:add_payment_method",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, CustomerPaymentMethodCreateResponse$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerpaymentmethodconfirm.js
var CustomerPaymentMethodConfirm$outboundSchema = pipe(object({
  setupIntentId: string2(),
  setDefault: boolean2()
}), transform((v2) => {
  return remap(v2, {
    setupIntentId: "setup_intent_id",
    setDefault: "set_default"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/customernotready.js
var CustomerNotReady = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "CustomerNotReady";
  }
};
var CustomerNotReady$inboundSchema = pipe(object({
  error: literal("CustomerNotReady"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new CustomerNotReady(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomersConfirmPaymentMethod.js
function customerPortalCustomersConfirmPaymentMethod(client, security, request, options) {
  return new APIPromise($do31(client, security, request, options));
}
async function $do31(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPaymentMethodConfirm$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/customers/me/payment-methods/confirm")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customers:confirm_payment_method",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, CustomerPaymentMethodCreateResponse$inboundSchema), jsonErr(400, CustomerNotReady$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/paymentmethodinusebyactivesubscription.js
var PaymentMethodInUseByActiveSubscription = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "PaymentMethodInUseByActiveSubscription";
  }
};
var PaymentMethodInUseByActiveSubscription$inboundSchema = pipe(object({
  error: literal("PaymentMethodInUseByActiveSubscription"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new PaymentMethodInUseByActiveSubscription(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalcustomersdeletepaymentmethod.js
var CustomerPortalCustomersDeletePaymentMethodSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalCustomersDeletePaymentMethodRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomersDeletePaymentMethod.js
function customerPortalCustomersDeletePaymentMethod(client, security, request, options) {
  return new APIPromise($do32(client, security, request, options));
}
async function $do32(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalCustomersDeletePaymentMethodRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/customers/me/payment-methods/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customers:delete_payment_method",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(400, PaymentMethodInUseByActiveSubscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomersGet.js
function customerPortalCustomersGet(client, security, options) {
  return new APIPromise($do33(client, security, options));
}
async function $do33(client, security, options) {
  const path = pathToFunc("/v1/customer-portal/customers/me")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customers:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CustomerPortalCustomer$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomerpaymentmethod.js
var ListResourceCustomerPaymentMethod$inboundSchema = object({
  items: array(CustomerPaymentMethod$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalcustomerslistpaymentmethods.js
var CustomerPortalCustomersListPaymentMethodsSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalCustomersListPaymentMethodsRequest$outboundSchema = object({
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
});
var CustomerPortalCustomersListPaymentMethodsResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerPaymentMethod$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomersListPaymentMethods.js
function customerPortalCustomersListPaymentMethods(client, security, request, options) {
  return new APIPromise($do34(client, security, request, options));
}
async function $do34(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalCustomersListPaymentMethodsRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/customers/me/payment-methods")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customers:list_payment_methods",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalCustomersListPaymentMethodsResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalCustomersListPaymentMethods(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerportalcustomerupdate.js
var CustomerPortalCustomerUpdate$outboundSchema = pipe(object({
  billingName: optional(nullable(string2())),
  billingAddress: optional(nullable(AddressInput$outboundSchema)),
  taxId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    billingName: "billing_name",
    billingAddress: "billing_address",
    taxId: "tax_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalCustomersUpdate.js
function customerPortalCustomersUpdate(client, security, request, options) {
  return new APIPromise($do35(client, security, request, options));
}
async function $do35(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalCustomerUpdate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/customers/me")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:customers:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerPortalCustomer$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarcustomers.js
var PolarCustomers = class extends ClientSDK {
  /**
   * Get Customer
   *
   * @remarks
   * Get authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async get(security, options) {
    return unwrapAsync(customerPortalCustomersGet(this, security, options));
  }
  /**
   * Update Customer
   *
   * @remarks
   * Update authenticated customer.
   */
  async update(security, request, options) {
    return unwrapAsync(customerPortalCustomersUpdate(this, security, request, options));
  }
  /**
   * List Customer Payment Methods
   *
   * @remarks
   * Get saved payment methods of the authenticated customer.
   */
  async listPaymentMethods(security, request, options) {
    return unwrapResultIterator(customerPortalCustomersListPaymentMethods(this, security, request, options));
  }
  /**
   * Add Customer Payment Method
   *
   * @remarks
   * Add a payment method to the authenticated customer.
   */
  async addPaymentMethod(security, request, options) {
    return unwrapAsync(customerPortalCustomersAddPaymentMethod(this, security, request, options));
  }
  /**
   * Confirm Customer Payment Method
   *
   * @remarks
   * Confirm a payment method for the authenticated customer.
   */
  async confirmPaymentMethod(security, request, options) {
    return unwrapAsync(customerPortalCustomersConfirmPaymentMethod(this, security, request, options));
  }
  /**
   * Delete Customer Payment Method
   *
   * @remarks
   * Delete a payment method from the authenticated customer.
   */
  async deletePaymentMethod(security, request, options) {
    return unwrapAsync(customerPortalCustomersDeletePaymentMethod(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeyactivate.js
var LicenseKeyActivateConditions$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var LicenseKeyActivateMeta$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var LicenseKeyActivate$outboundSchema = pipe(object({
  key: string2(),
  organizationId: string2(),
  label: string2(),
  conditions: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  meta: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()])))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeycustomer.js
var LicenseKeyCustomerTaxId$inboundSchema = smartUnion([string2(), TaxIDFormat$inboundSchema]);
var LicenseKeyCustomer$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_id: nullable(string2()),
  email: string2(),
  email_verified: boolean2(),
  type: optional(nullable(CustomerType$inboundSchema)),
  name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  organization_id: string2(),
  deleted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  avatar_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "external_id": "externalId",
    "email_verified": "emailVerified",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "organization_id": "organizationId",
    "deleted_at": "deletedAt",
    "avatar_url": "avatarUrl"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeystatus.js
var LicenseKeyStatus = {
  Granted: "granted",
  Revoked: "revoked",
  Disabled: "disabled"
};
var LicenseKeyStatus$inboundSchema = _enum2(LicenseKeyStatus);
var LicenseKeyStatus$outboundSchema = LicenseKeyStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeyread.js
var LicenseKeyRead$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2(),
  customer_id: string2(),
  customer: LicenseKeyCustomer$inboundSchema,
  benefit_id: string2(),
  key: string2(),
  display_key: string2(),
  status: LicenseKeyStatus$inboundSchema,
  limit_activations: nullable(int()),
  usage: int(),
  limit_usage: nullable(int()),
  validations: int(),
  last_validated_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  expires_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "benefit_id": "benefitId",
    "display_key": "displayKey",
    "limit_activations": "limitActivations",
    "limit_usage": "limitUsage",
    "last_validated_at": "lastValidatedAt",
    "expires_at": "expiresAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeyactivationread.js
var LicenseKeyActivationReadMeta$inboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var LicenseKeyActivationRead$inboundSchema = pipe(object({
  id: string2(),
  license_key_id: string2(),
  label: string2(),
  meta: record(string2(), smartUnion([string2(), int(), number2(), boolean2()])),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  license_key: LicenseKeyRead$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "license_key_id": "licenseKeyId",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "license_key": "licenseKey"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalLicenseKeysActivate.js
function customerPortalLicenseKeysActivate(client, request, options) {
  return new APIPromise($do36(client, request, options));
}
async function $do36(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeyActivate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/license-keys/activate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:license_keys:activate",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, LicenseKeyActivationRead$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeydeactivate.js
var LicenseKeyDeactivate$outboundSchema = pipe(object({
  key: string2(),
  organizationId: string2(),
  activationId: string2()
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    activationId: "activation_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalLicenseKeysDeactivate.js
function customerPortalLicenseKeysDeactivate(client, request, options) {
  return new APIPromise($do37(client, request, options));
}
async function $do37(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeyDeactivate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/license-keys/deactivate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:license_keys:deactivate",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeyactivationbase.js
var Meta$inboundSchema = smartUnion([
  string2(),
  int(),
  number2(),
  boolean2()
]);
var LicenseKeyActivationBase$inboundSchema = pipe(object({
  id: string2(),
  license_key_id: string2(),
  label: string2(),
  meta: record(string2(), smartUnion([string2(), int(), number2(), boolean2()])),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))))
}), transform((v2) => {
  return remap(v2, {
    "license_key_id": "licenseKeyId",
    "created_at": "createdAt",
    "modified_at": "modifiedAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeywithactivations.js
var LicenseKeyWithActivations$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2(),
  customer_id: string2(),
  customer: LicenseKeyCustomer$inboundSchema,
  benefit_id: string2(),
  key: string2(),
  display_key: string2(),
  status: LicenseKeyStatus$inboundSchema,
  limit_activations: nullable(int()),
  usage: int(),
  limit_usage: nullable(int()),
  validations: int(),
  last_validated_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  expires_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  activations: array(LicenseKeyActivationBase$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "benefit_id": "benefitId",
    "display_key": "displayKey",
    "limit_activations": "limitActivations",
    "limit_usage": "limitUsage",
    "last_validated_at": "lastValidatedAt",
    "expires_at": "expiresAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportallicensekeysget.js
var CustomerPortalLicenseKeysGetSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalLicenseKeysGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalLicenseKeysGet.js
function customerPortalLicenseKeysGet(client, security, request, options) {
  return new APIPromise($do38(client, security, request, options));
}
async function $do38(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalLicenseKeysGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/license-keys/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:license_keys:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, LicenseKeyWithActivations$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/unauthorized.js
var Unauthorized = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "Unauthorized";
  }
};
var Unauthorized$inboundSchema = pipe(object({
  error: literal("Unauthorized"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new Unauthorized(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcelicensekeyread.js
var ListResourceLicenseKeyRead$inboundSchema = object({
  items: array(LicenseKeyRead$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportallicensekeyslist.js
var CustomerPortalLicenseKeysListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalLicenseKeysListRequest$outboundSchema = pipe(object({
  benefitId: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    benefitId: "benefit_id"
  });
}));
var CustomerPortalLicenseKeysListResponse$inboundSchema = pipe(object({
  Result: ListResourceLicenseKeyRead$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalLicenseKeysList.js
function customerPortalLicenseKeysList(client, security, request, options) {
  return new APIPromise($do39(client, security, request, options));
}
async function $do39(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalLicenseKeysListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/license-keys/")();
  const query = encodeFormQuery({
    "benefit_id": payload.benefit_id,
    "limit": payload.limit,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:license_keys:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalLicenseKeysListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(401, Unauthorized$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalLicenseKeysList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeyvalidate.js
var Conditions$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var LicenseKeyValidate$outboundSchema = pipe(object({
  key: string2(),
  organizationId: string2(),
  activationId: optional(nullable(string2())),
  benefitId: optional(nullable(string2())),
  customerId: optional(nullable(string2())),
  incrementUsage: optional(nullable(int())),
  conditions: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()])))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    activationId: "activation_id",
    benefitId: "benefit_id",
    customerId: "customer_id",
    incrementUsage: "increment_usage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/validatedlicensekey.js
var ValidatedLicenseKey$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2(),
  customer_id: string2(),
  customer: LicenseKeyCustomer$inboundSchema,
  benefit_id: string2(),
  key: string2(),
  display_key: string2(),
  status: LicenseKeyStatus$inboundSchema,
  limit_activations: nullable(int()),
  usage: int(),
  limit_usage: nullable(int()),
  validations: int(),
  last_validated_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  expires_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  activation: optional(nullable(LicenseKeyActivationBase$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "benefit_id": "benefitId",
    "display_key": "displayKey",
    "limit_activations": "limitActivations",
    "limit_usage": "limitUsage",
    "last_validated_at": "lastValidatedAt",
    "expires_at": "expiresAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalLicenseKeysValidate.js
function customerPortalLicenseKeysValidate(client, request, options) {
  return new APIPromise($do40(client, request, options));
}
async function $do40(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeyValidate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/license-keys/validate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:license_keys:validate",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, ValidatedLicenseKey$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarlicensekeys.js
var PolarLicenseKeys = class extends ClientSDK {
  /**
   * List License Keys
   *
   * @remarks
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalLicenseKeysList(this, security, request, options));
  }
  /**
   * Get License Key
   *
   * @remarks
   * Get a license key.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async get(security, request, options) {
    return unwrapAsync(customerPortalLicenseKeysGet(this, security, request, options));
  }
  /**
   * Validate License Key
   *
   * @remarks
   * Validate a license key.
   *
   * > This endpoint doesn't require authentication and can be safely used on a public
   * > client, like a desktop application or a mobile app.
   * > If you plan to validate a license key on a server, use the `/v1/license-keys/validate`
   * > endpoint instead.
   */
  async validate(request, options) {
    return unwrapAsync(customerPortalLicenseKeysValidate(this, request, options));
  }
  /**
   * Activate License Key
   *
   * @remarks
   * Activate a license key instance.
   *
   * > This endpoint doesn't require authentication and can be safely used on a public
   * > client, like a desktop application or a mobile app.
   * > If you plan to validate a license key on a server, use the `/v1/license-keys/activate`
   * > endpoint instead.
   */
  async activate(request, options) {
    return unwrapAsync(customerPortalLicenseKeysActivate(this, request, options));
  }
  /**
   * Deactivate License Key
   *
   * @remarks
   * Deactivate a license key instance.
   *
   * > This endpoint doesn't require authentication and can be safely used on a public
   * > client, like a desktop application or a mobile app.
   * > If you plan to validate a license key on a server, use the `/v1/license-keys/deactivate`
   * > endpoint instead.
   */
  async deactivate(request, options) {
    return unwrapAsync(customerPortalLicenseKeysDeactivate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorderpaymentconfirmation.js
var CustomerOrderPaymentConfirmation$inboundSchema = pipe(object({
  status: string2(),
  client_secret: optional(nullable(string2())),
  error: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    "client_secret": "clientSecret"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/ordernoteligibleforretry.js
var OrderNotEligibleForRetry = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "OrderNotEligibleForRetry";
  }
};
var OrderNotEligibleForRetry$inboundSchema = pipe(object({
  error: literal("OrderNotEligibleForRetry"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new OrderNotEligibleForRetry(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/paymentalreadyinprogress.js
var PaymentAlreadyInProgress = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "PaymentAlreadyInProgress";
  }
};
var PaymentAlreadyInProgress$inboundSchema = pipe(object({
  error: literal("PaymentAlreadyInProgress"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new PaymentAlreadyInProgress(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorderconfirmpayment.js
var CustomerOrderConfirmPayment$outboundSchema = pipe(object({
  confirmationTokenId: optional(nullable(string2())),
  paymentMethodId: optional(nullable(string2())),
  paymentProcessor: optional(PaymentProcessor$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    confirmationTokenId: "confirmation_token_id",
    paymentMethodId: "payment_method_id",
    paymentProcessor: "payment_processor"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalordersconfirmretrypayment.js
var CustomerPortalOrdersConfirmRetryPaymentSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersConfirmRetryPaymentRequest$outboundSchema = pipe(object({
  id: string2(),
  customerOrderConfirmPayment: CustomerOrderConfirmPayment$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    customerOrderConfirmPayment: "CustomerOrderConfirmPayment"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersConfirmRetryPayment.js
function customerPortalOrdersConfirmRetryPayment(client, security, request, options) {
  return new APIPromise($do41(client, security, request, options));
}
async function $do41(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersConfirmRetryPaymentRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomerOrderConfirmPayment, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/orders/{id}/confirm-payment")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:confirm_retry_payment",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "409", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerOrderPaymentConfirmation$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(409, PaymentAlreadyInProgress$inboundSchema), jsonErr(422, OrderNotEligibleForRetry$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/missinginvoicebillingdetails.js
var MissingInvoiceBillingDetails = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "MissingInvoiceBillingDetails";
  }
};
var MissingInvoiceBillingDetails$inboundSchema = pipe(object({
  error: literal("MissingInvoiceBillingDetails"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new MissingInvoiceBillingDetails(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/notpaidorder.js
var NotPaidOrder = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "NotPaidOrder";
  }
};
var NotPaidOrder$inboundSchema = pipe(object({
  error: literal("NotPaidOrder"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new NotPaidOrder(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/customerportalordersgenerateinvoice.js
var CustomerPortalOrdersGenerateInvoiceResponse422CustomerPortalOrdersGenerateInvoice$inboundSchema = union([
  MissingInvoiceBillingDetails$inboundSchema,
  NotPaidOrder$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalordersgenerateinvoice.js
var CustomerPortalOrdersGenerateInvoiceSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersGenerateInvoiceRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersGenerateInvoice.js
function customerPortalOrdersGenerateInvoice(client, security, request, options) {
  return new APIPromise($do42(client, security, request, options));
}
async function $do42(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersGenerateInvoiceRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/orders/{id}/invoice")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:generate_invoice",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(202, any()), jsonErr(422, CustomerPortalOrdersGenerateInvoiceResponse422CustomerPortalOrdersGenerateInvoice$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorganization.js
var CustomerOrganization$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  slug: string2(),
  avatar_url: nullable(string2()),
  proration_behavior: SubscriptionProrationBehavior$inboundSchema,
  allow_customer_updates: boolean2(),
  customer_portal_settings: OrganizationCustomerPortalSettings$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "avatar_url": "avatarUrl",
    "proration_behavior": "prorationBehavior",
    "allow_customer_updates": "allowCustomerUpdates",
    "customer_portal_settings": "customerPortalSettings"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorderproduct.js
var CustomerOrderProductPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CustomerOrderProduct$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2(),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  benefits: array(BenefitPublic$inboundSchema),
  medias: array(ProductMediaFileRead$inboundSchema),
  organization: CustomerOrganization$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerordersubscription.js
var CustomerOrderSubscription$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  amount: int(),
  currency: string2(),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  recurring_interval_count: int(),
  status: SubscriptionStatus$inboundSchema,
  current_period_start: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  current_period_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_start: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  cancel_at_period_end: boolean2(),
  canceled_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  started_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ended_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  product_id: string2(),
  discount_id: nullable(string2()),
  checkout_id: nullable(string2()),
  seats: optional(nullable(int())),
  customer_cancellation_reason: nullable(CustomerCancellationReason$inboundSchema),
  customer_cancellation_comment: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "current_period_start": "currentPeriodStart",
    "current_period_end": "currentPeriodEnd",
    "trial_start": "trialStart",
    "trial_end": "trialEnd",
    "cancel_at_period_end": "cancelAtPeriodEnd",
    "canceled_at": "canceledAt",
    "started_at": "startedAt",
    "ends_at": "endsAt",
    "ended_at": "endedAt",
    "customer_id": "customerId",
    "product_id": "productId",
    "discount_id": "discountId",
    "checkout_id": "checkoutId",
    "customer_cancellation_reason": "customerCancellationReason",
    "customer_cancellation_comment": "customerCancellationComment"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorder.js
var CustomerOrder$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  status: OrderStatus$inboundSchema,
  paid: boolean2(),
  subtotal_amount: int(),
  discount_amount: int(),
  net_amount: int(),
  tax_amount: int(),
  total_amount: int(),
  applied_balance_amount: int(),
  due_amount: int(),
  refunded_amount: int(),
  refunded_tax_amount: int(),
  currency: string2(),
  billing_reason: OrderBillingReason$inboundSchema,
  billing_name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  invoice_number: string2(),
  is_invoice_generated: boolean2(),
  seats: optional(nullable(int())),
  customer_id: string2(),
  product_id: nullable(string2()),
  discount_id: nullable(string2()),
  subscription_id: nullable(string2()),
  checkout_id: nullable(string2()),
  user_id: string2(),
  product: nullable(CustomerOrderProduct$inboundSchema),
  subscription: nullable(CustomerOrderSubscription$inboundSchema),
  items: array(OrderItemSchema$inboundSchema),
  description: string2(),
  next_payment_attempt_at: optional(nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "subtotal_amount": "subtotalAmount",
    "discount_amount": "discountAmount",
    "net_amount": "netAmount",
    "tax_amount": "taxAmount",
    "total_amount": "totalAmount",
    "applied_balance_amount": "appliedBalanceAmount",
    "due_amount": "dueAmount",
    "refunded_amount": "refundedAmount",
    "refunded_tax_amount": "refundedTaxAmount",
    "billing_reason": "billingReason",
    "billing_name": "billingName",
    "billing_address": "billingAddress",
    "invoice_number": "invoiceNumber",
    "is_invoice_generated": "isInvoiceGenerated",
    "customer_id": "customerId",
    "product_id": "productId",
    "discount_id": "discountId",
    "subscription_id": "subscriptionId",
    "checkout_id": "checkoutId",
    "user_id": "userId",
    "next_payment_attempt_at": "nextPaymentAttemptAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalordersget.js
var CustomerPortalOrdersGetSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersGet.js
function customerPortalOrdersGet(client, security, request, options) {
  return new APIPromise($do43(client, security, request, options));
}
async function $do43(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/orders/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerOrder$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorderpaymentstatus.js
var CustomerOrderPaymentStatus$inboundSchema = object({
  status: string2(),
  error: optional(nullable(string2()))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalordersgetpaymentstatus.js
var CustomerPortalOrdersGetPaymentStatusSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersGetPaymentStatusRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersGetPaymentStatus.js
function customerPortalOrdersGetPaymentStatus(client, security, request, options) {
  return new APIPromise($do44(client, security, request, options));
}
async function $do44(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersGetPaymentStatusRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/orders/{id}/payment-status")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:get_payment_status",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerOrderPaymentStatus$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorderinvoice.js
var CustomerOrderInvoice$inboundSchema = object({
  url: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalordersinvoice.js
var CustomerPortalOrdersInvoiceSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersInvoiceRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersInvoice.js
function customerPortalOrdersInvoice(client, security, request, options) {
  return new APIPromise($do45(client, security, request, options));
}
async function $do45(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersInvoiceRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/orders/{id}/invoice")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:invoice",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerOrderInvoice$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerordersortproperty.js
var CustomerOrderSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Amount: "amount",
  MinusAmount: "-amount",
  NetAmount: "net_amount",
  MinusNetAmount: "-net_amount",
  Product: "product",
  MinusProduct: "-product",
  Subscription: "subscription",
  MinusSubscription: "-subscription"
};
var CustomerOrderSortProperty$outboundSchema = _enum2(CustomerOrderSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomerorder.js
var ListResourceCustomerOrder$inboundSchema = object({
  items: array(CustomerOrder$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productbillingtype.js
var ProductBillingType = {
  OneTime: "one_time",
  Recurring: "recurring"
};
var ProductBillingType$outboundSchema = _enum2(ProductBillingType);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalorderslist.js
var CustomerPortalOrdersListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersListQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalOrdersListQueryParamProductBillingTypeFilter$outboundSchema = smartUnion([
  ProductBillingType$outboundSchema,
  array(ProductBillingType$outboundSchema)
]);
var CustomerPortalOrdersListQueryParamSubscriptionIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalOrdersListRequest$outboundSchema = pipe(object({
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productBillingType: optional(nullable(smartUnion([
    ProductBillingType$outboundSchema,
    array(ProductBillingType$outboundSchema)
  ]))),
  subscriptionId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerOrderSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    productId: "product_id",
    productBillingType: "product_billing_type",
    subscriptionId: "subscription_id"
  });
}));
var CustomerPortalOrdersListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerOrder$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersList.js
function customerPortalOrdersList(client, security, request, options) {
  return new APIPromise($do46(client, security, request, options));
}
async function $do46(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/orders/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "page": payload.page,
    "product_billing_type": payload.product_billing_type,
    "product_id": payload.product_id,
    "query": payload.query,
    "sorting": payload.sorting,
    "subscription_id": payload.subscription_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalOrdersListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalOrdersList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorderupdate.js
var CustomerOrderUpdate$outboundSchema = pipe(object({
  billingName: optional(nullable(string2())),
  billingAddress: optional(nullable(AddressInput$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    billingName: "billing_name",
    billingAddress: "billing_address"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalordersupdate.js
var CustomerPortalOrdersUpdateSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalOrdersUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  customerOrderUpdate: CustomerOrderUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    customerOrderUpdate: "CustomerOrderUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrdersUpdate.js
function customerPortalOrdersUpdate(client, security, request, options) {
  return new APIPromise($do47(client, security, request, options));
}
async function $do47(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrdersUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomerOrderUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/orders/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:orders:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerOrder$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarorders.js
var PolarOrders = class extends ClientSDK {
  /**
   * List Orders
   *
   * @remarks
   * List orders of the authenticated customer.
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalOrdersList(this, security, request, options));
  }
  /**
   * Get Order
   *
   * @remarks
   * Get an order by ID for the authenticated customer.
   */
  async get(security, request, options) {
    return unwrapAsync(customerPortalOrdersGet(this, security, request, options));
  }
  /**
   * Update Order
   *
   * @remarks
   * Update an order for the authenticated customer.
   */
  async update(security, request, options) {
    return unwrapAsync(customerPortalOrdersUpdate(this, security, request, options));
  }
  /**
   * Generate Order Invoice
   *
   * @remarks
   * Trigger generation of an order's invoice.
   */
  async generateInvoice(security, request, options) {
    return unwrapAsync(customerPortalOrdersGenerateInvoice(this, security, request, options));
  }
  /**
   * Get Order Invoice
   *
   * @remarks
   * Get an order's invoice data.
   */
  async invoice(security, request, options) {
    return unwrapAsync(customerPortalOrdersInvoice(this, security, request, options));
  }
  /**
   * Get Order Payment Status
   *
   * @remarks
   * Get the current payment status for an order.
   */
  async getPaymentStatus(security, request, options) {
    return unwrapAsync(customerPortalOrdersGetPaymentStatus(this, security, request, options));
  }
  /**
   * Confirm Retry Payment
   *
   * @remarks
   * Confirm a retry payment using a Stripe confirmation token.
   */
  async confirmRetryPayment(security, request, options) {
    return unwrapAsync(customerPortalOrdersConfirmRetryPayment(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerproduct.js
var CustomerProductPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CustomerProduct$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2(),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  benefits: array(BenefitPublic$inboundSchema),
  medias: array(ProductMediaFileRead$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerorganizationdata.js
var CustomerOrganizationData$inboundSchema = object({
  organization: CustomerOrganization$inboundSchema,
  products: array(CustomerProduct$inboundSchema)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalorganizationsget.js
var CustomerPortalOrganizationsGetRequest$outboundSchema = object({
  slug: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalOrganizationsGet.js
function customerPortalOrganizationsGet(client, request, options) {
  return new APIPromise($do48(client, request, options));
}
async function $do48(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalOrganizationsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    slug: encodeSimple("slug", payload.slug, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/organizations/{slug}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:organizations:get",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerOrganizationData$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarorganizations.js
var PolarOrganizations = class extends ClientSDK {
  /**
   * Get Organization
   *
   * @remarks
   * Get a customer portal's organization by slug.
   */
  async get(request, options) {
    return unwrapAsync(customerPortalOrganizationsGet(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionmetermeter.js
var CustomerSubscriptionMeterMeter$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionmeter.js
var CustomerSubscriptionMeter$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  consumed_units: number2(),
  credited_units: int(),
  amount: int(),
  meter_id: string2(),
  meter: CustomerSubscriptionMeterMeter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "consumed_units": "consumedUnits",
    "credited_units": "creditedUnits",
    "meter_id": "meterId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionproduct.js
var CustomerSubscriptionProductPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CustomerSubscriptionProduct$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2(),
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  benefits: array(BenefitPublic$inboundSchema),
  medias: array(ProductMediaFileRead$inboundSchema),
  organization: CustomerOrganization$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscription.js
var CustomerSubscriptionPrices$inboundSchema = smartUnion([
  LegacyRecurringProductPrice$inboundSchema,
  ProductPrice$inboundSchema
]);
var CustomerSubscription$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  amount: int(),
  currency: string2(),
  recurring_interval: SubscriptionRecurringInterval$inboundSchema,
  recurring_interval_count: int(),
  status: SubscriptionStatus$inboundSchema,
  current_period_start: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  current_period_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_start: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_end: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  cancel_at_period_end: boolean2(),
  canceled_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  started_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ended_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  product_id: string2(),
  discount_id: nullable(string2()),
  checkout_id: nullable(string2()),
  seats: optional(nullable(int())),
  customer_cancellation_reason: nullable(CustomerCancellationReason$inboundSchema),
  customer_cancellation_comment: nullable(string2()),
  product: CustomerSubscriptionProduct$inboundSchema,
  prices: array(smartUnion([
    LegacyRecurringProductPrice$inboundSchema,
    ProductPrice$inboundSchema
  ])),
  meters: array(CustomerSubscriptionMeter$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "current_period_start": "currentPeriodStart",
    "current_period_end": "currentPeriodEnd",
    "trial_start": "trialStart",
    "trial_end": "trialEnd",
    "cancel_at_period_end": "cancelAtPeriodEnd",
    "canceled_at": "canceledAt",
    "started_at": "startedAt",
    "ends_at": "endsAt",
    "ended_at": "endedAt",
    "customer_id": "customerId",
    "product_id": "productId",
    "discount_id": "discountId",
    "checkout_id": "checkoutId",
    "customer_cancellation_reason": "customerCancellationReason",
    "customer_cancellation_comment": "customerCancellationComment"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/alreadycanceledsubscription.js
var AlreadyCanceledSubscription = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "AlreadyCanceledSubscription";
  }
};
var AlreadyCanceledSubscription$inboundSchema = pipe(object({
  error: literal("AlreadyCanceledSubscription"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new AlreadyCanceledSubscription(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalsubscriptionscancel.js
var CustomerPortalSubscriptionsCancelSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSubscriptionsCancelRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSubscriptionsCancel.js
function customerPortalSubscriptionsCancel(client, security, request, options) {
  return new APIPromise($do49(client, security, request, options));
}
async function $do49(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSubscriptionsCancelRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:subscriptions:cancel",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSubscription$inboundSchema), jsonErr(403, AlreadyCanceledSubscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalsubscriptionsget.js
var CustomerPortalSubscriptionsGetSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSubscriptionsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSubscriptionsGet.js
function customerPortalSubscriptionsGet(client, security, request, options) {
  return new APIPromise($do50(client, security, request, options));
}
async function $do50(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSubscriptionsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:subscriptions:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSubscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionsortproperty.js
var CustomerSubscriptionSortProperty = {
  StartedAt: "started_at",
  MinusStartedAt: "-started_at",
  Amount: "amount",
  MinusAmount: "-amount",
  Status: "status",
  MinusStatus: "-status",
  Organization: "organization",
  MinusOrganization: "-organization",
  Product: "product",
  MinusProduct: "-product"
};
var CustomerSubscriptionSortProperty$outboundSchema = _enum2(CustomerSubscriptionSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomersubscription.js
var ListResourceCustomerSubscription$inboundSchema = object({
  items: array(CustomerSubscription$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalsubscriptionslist.js
var CustomerPortalSubscriptionsListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSubscriptionsListQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerPortalSubscriptionsListRequest$outboundSchema = pipe(object({
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  active: optional(nullable(boolean2())),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerSubscriptionSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    productId: "product_id"
  });
}));
var CustomerPortalSubscriptionsListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerSubscription$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSubscriptionsList.js
function customerPortalSubscriptionsList(client, security, request, options) {
  return new APIPromise($do51(client, security, request, options));
}
async function $do51(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSubscriptionsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/subscriptions/")();
  const query = encodeFormQuery({
    "active": payload.active,
    "limit": payload.limit,
    "page": payload.page,
    "product_id": payload.product_id,
    "query": payload.query,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:subscriptions:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalSubscriptionsListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalSubscriptionsList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptioncancel.js
var CustomerSubscriptionCancel$outboundSchema = pipe(object({
  cancelAtPeriodEnd: optional(nullable(boolean2())),
  cancellationReason: optional(nullable(CustomerCancellationReason$outboundSchema)),
  cancellationComment: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    cancelAtPeriodEnd: "cancel_at_period_end",
    cancellationReason: "cancellation_reason",
    cancellationComment: "cancellation_comment"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionupdateproduct.js
var CustomerSubscriptionUpdateProduct$outboundSchema = pipe(object({
  productId: string2()
}), transform((v2) => {
  return remap(v2, {
    productId: "product_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionupdateseats.js
var CustomerSubscriptionUpdateSeats$outboundSchema = pipe(object({
  seats: int(),
  prorationBehavior: optional(nullable(SubscriptionProrationBehavior$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    prorationBehavior: "proration_behavior"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersubscriptionupdate.js
var CustomerSubscriptionUpdate$outboundSchema = smartUnion([
  CustomerSubscriptionUpdateProduct$outboundSchema,
  CustomerSubscriptionUpdateSeats$outboundSchema,
  CustomerSubscriptionCancel$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalsubscriptionsupdate.js
var CustomerPortalSubscriptionsUpdateSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSubscriptionsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  customerSubscriptionUpdate: CustomerSubscriptionUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    customerSubscriptionUpdate: "CustomerSubscriptionUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSubscriptionsUpdate.js
function customerPortalSubscriptionsUpdate(client, security, request, options) {
  return new APIPromise($do52(client, security, request, options));
}
async function $do52(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSubscriptionsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomerSubscriptionUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:subscriptions:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSubscription$inboundSchema), jsonErr(403, AlreadyCanceledSubscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/polarsubscriptions.js
var PolarSubscriptions = class extends ClientSDK {
  /**
   * List Subscriptions
   *
   * @remarks
   * List subscriptions of the authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalSubscriptionsList(this, security, request, options));
  }
  /**
   * Get Subscription
   *
   * @remarks
   * Get a subscription for the authenticated customer.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async get(security, request, options) {
    return unwrapAsync(customerPortalSubscriptionsGet(this, security, request, options));
  }
  /**
   * Update Subscription
   *
   * @remarks
   * Update a subscription of the authenticated customer.
   */
  async update(security, request, options) {
    return unwrapAsync(customerPortalSubscriptionsUpdate(this, security, request, options));
  }
  /**
   * Cancel Subscription
   *
   * @remarks
   * Cancel a subscription of the authenticated customer.
   */
  async cancel(security, request, options) {
    return unwrapAsync(customerPortalSubscriptionsCancel(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/seatassign.js
var SeatAssign$outboundSchema = pipe(object({
  subscriptionId: optional(nullable(string2())),
  checkoutId: optional(nullable(string2())),
  orderId: optional(nullable(string2())),
  email: optional(nullable(string2())),
  externalCustomerId: optional(nullable(string2())),
  customerId: optional(nullable(string2())),
  metadata: optional(nullable(record(string2(), any()))),
  immediateClaim: _default2(boolean2(), false)
}), transform((v2) => {
  return remap(v2, {
    subscriptionId: "subscription_id",
    checkoutId: "checkout_id",
    orderId: "order_id",
    externalCustomerId: "external_customer_id",
    customerId: "customer_id",
    immediateClaim: "immediate_claim"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSeatsAssignSeat.js
function customerPortalSeatsAssignSeat(client, security, request, options) {
  return new APIPromise($do53(client, security, request, options));
}
async function $do53(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(SeatAssign$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-portal/seats")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:seats:assign_seat",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeat$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([400, 401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSeatsListClaimedSubscriptions.js
function customerPortalSeatsListClaimedSubscriptions(client, security, options) {
  return new APIPromise($do54(client, security, options));
}
async function $do54(client, security, options) {
  const path = pathToFunc("/v1/customer-portal/seats/subscriptions")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:seats:list_claimed_subscriptions",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, array(CustomerSubscription$inboundSchema)), fail([401, "4XX"]), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/seatslist.js
var SeatsList$inboundSchema = pipe(object({
  seats: array(CustomerSeat$inboundSchema),
  available_seats: int(),
  total_seats: int()
}), transform((v2) => {
  return remap(v2, {
    "available_seats": "availableSeats",
    "total_seats": "totalSeats"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalseatslistseats.js
var CustomerPortalSeatsListSeatsSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSeatsListSeatsRequest$outboundSchema = pipe(object({
  subscriptionId: optional(nullable(string2())),
  orderId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    subscriptionId: "subscription_id",
    orderId: "order_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSeatsListSeats.js
function customerPortalSeatsListSeats(client, security, request, options) {
  return new APIPromise($do55(client, security, request, options));
}
async function $do55(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSeatsListSeatsRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/seats")();
  const query = encodeFormQuery({
    "order_id": payload.order_id,
    "subscription_id": payload.subscription_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:seats:list_seats",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, SeatsList$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalseatsresendinvitation.js
var CustomerPortalSeatsResendInvitationSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSeatsResendInvitationRequest$outboundSchema = pipe(object({
  seatId: string2()
}), transform((v2) => {
  return remap(v2, {
    seatId: "seat_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSeatsResendInvitation.js
function customerPortalSeatsResendInvitation(client, security, request, options) {
  return new APIPromise($do56(client, security, request, options));
}
async function $do56(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSeatsResendInvitationRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    seat_id: encodeSimple("seat_id", payload.seat_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/seats/{seat_id}/resend")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:seats:resend_invitation",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeat$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([400, 401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalseatsrevokeseat.js
var CustomerPortalSeatsRevokeSeatSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalSeatsRevokeSeatRequest$outboundSchema = pipe(object({
  seatId: string2()
}), transform((v2) => {
  return remap(v2, {
    seatId: "seat_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalSeatsRevokeSeat.js
function customerPortalSeatsRevokeSeat(client, security, request, options) {
  return new APIPromise($do57(client, security, request, options));
}
async function $do57(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalSeatsRevokeSeatRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    seat_id: encodeSimple("seat_id", payload.seat_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/seats/{seat_id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:seats:revoke_seat",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeat$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/seats.js
var Seats = class extends ClientSDK {
  /**
   * List Seats
   *
   * @remarks
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async listSeats(security, request, options) {
    return unwrapAsync(customerPortalSeatsListSeats(this, security, request, options));
  }
  /**
   * Assign Seat
   */
  async assignSeat(security, request, options) {
    return unwrapAsync(customerPortalSeatsAssignSeat(this, security, request, options));
  }
  /**
   * Revoke Seat
   */
  async revokeSeat(security, request, options) {
    return unwrapAsync(customerPortalSeatsRevokeSeat(this, security, request, options));
  }
  /**
   * Resend Invitation
   */
  async resendInvitation(security, request, options) {
    return unwrapAsync(customerPortalSeatsResendInvitation(this, security, request, options));
  }
  /**
   * List Claimed Subscriptions
   *
   * @remarks
   * List all subscriptions where the authenticated customer has claimed a seat.
   *
   * **Scopes**: `customer_portal:read` `customer_portal:write`
   */
  async listClaimedSubscriptions(security, options) {
    return unwrapAsync(customerPortalSeatsListClaimedSubscriptions(this, security, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerwallet.js
var CustomerWallet$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  customer_id: string2(),
  balance: int(),
  currency: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "customer_id": "customerId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalwalletsget.js
var CustomerPortalWalletsGetSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalWalletsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalWalletsGet.js
function customerPortalWalletsGet(client, security, request, options) {
  return new APIPromise($do58(client, security, request, options));
}
async function $do58(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalWalletsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-portal/wallets/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:wallets:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerWallet$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerwalletsortproperty.js
var CustomerWalletSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Balance: "balance",
  MinusBalance: "-balance"
};
var CustomerWalletSortProperty$outboundSchema = _enum2(CustomerWalletSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomerwallet.js
var ListResourceCustomerWallet$inboundSchema = object({
  items: array(CustomerWallet$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerportalwalletslist.js
var CustomerPortalWalletsListSecurity$outboundSchema = pipe(object({
  customerSession: optional(string2()),
  memberSession: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    customerSession: "customer_session",
    memberSession: "member_session"
  });
}));
var CustomerPortalWalletsListRequest$outboundSchema = object({
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerWalletSortProperty$outboundSchema)))
});
var CustomerPortalWalletsListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerWallet$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerPortalWalletsList.js
function customerPortalWalletsList(client, security, request, options) {
  return new APIPromise($do59(client, security, request, options));
}
async function $do59(client, security, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerPortalWalletsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-portal/wallets/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "page": payload.page,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.customerSession
    }
  ], [
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.memberSession
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer_portal:wallets:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomerPortalWalletsListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customerPortalWalletsList(client, security, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/wallets.js
var Wallets = class extends ClientSDK {
  /**
   * List Wallets
   *
   * @remarks
   * List wallets of the authenticated customer.
   */
  async list(security, request, options) {
    return unwrapResultIterator(customerPortalWalletsList(this, security, request, options));
  }
  /**
   * Get Wallet
   *
   * @remarks
   * Get a wallet by ID for the authenticated customer.
   */
  async get(security, request, options) {
    return unwrapAsync(customerPortalWalletsGet(this, security, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customerportal.js
var CustomerPortal = class extends ClientSDK {
  get benefitGrants() {
    return this._benefitGrants ?? (this._benefitGrants = new PolarBenefitGrants(this._options));
  }
  get customers() {
    return this._customers ?? (this._customers = new PolarCustomers(this._options));
  }
  get customerMeters() {
    return this._customerMeters ?? (this._customerMeters = new PolarCustomerMeters(this._options));
  }
  get seats() {
    return this._seats ?? (this._seats = new Seats(this._options));
  }
  get customerSession() {
    return this._customerSession ?? (this._customerSession = new CustomerSession(this._options));
  }
  get downloadables() {
    return this._downloadables ?? (this._downloadables = new Downloadables(this._options));
  }
  get licenseKeys() {
    return this._licenseKeys ?? (this._licenseKeys = new PolarLicenseKeys(this._options));
  }
  get orders() {
    return this._orders ?? (this._orders = new PolarOrders(this._options));
  }
  get organizations() {
    return this._organizations ?? (this._organizations = new PolarOrganizations(this._options));
  }
  get subscriptions() {
    return this._subscriptions ?? (this._subscriptions = new PolarSubscriptions(this._options));
  }
  get wallets() {
    return this._wallets ?? (this._wallets = new Wallets(this._options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/ownercreate.js
var OwnerCreate$outboundSchema = pipe(object({
  email: optional(nullable(string2())),
  name: optional(nullable(string2())),
  externalId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercreate.js
var CustomerCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomerCreateTaxId$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var CustomerCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  externalId: optional(nullable(string2())),
  email: string2(),
  name: optional(nullable(string2())),
  billingAddress: optional(nullable(AddressInput$outboundSchema)),
  taxId: optional(nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema]))))),
  type: optional(nullable(CustomerType$outboundSchema)),
  organizationId: optional(nullable(string2())),
  owner: optional(nullable(OwnerCreate$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    externalId: "external_id",
    billingAddress: "billing_address",
    taxId: "tax_id",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerwithmembers.js
var CustomerWithMembersTaxId$inboundSchema = smartUnion([string2(), TaxIDFormat$inboundSchema]);
var CustomerWithMembers$inboundSchema = pipe(object({
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  external_id: nullable(string2()),
  email: string2(),
  email_verified: boolean2(),
  type: optional(nullable(CustomerType$inboundSchema)),
  name: nullable(string2()),
  billing_address: nullable(Address$inboundSchema),
  tax_id: nullable(array(nullable(smartUnion([string2(), TaxIDFormat$inboundSchema])))),
  organization_id: string2(),
  deleted_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  members: optional(array(Member$inboundSchema)),
  avatar_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "external_id": "externalId",
    "email_verified": "emailVerified",
    "billing_address": "billingAddress",
    "tax_id": "taxId",
    "organization_id": "organizationId",
    "deleted_at": "deletedAt",
    "avatar_url": "avatarUrl"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersCreate.js
function customersCreate(client, request, options) {
  return new APIPromise($do60(client, request, options));
}
async function $do60(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customers/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, CustomerWithMembers$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersdelete.js
var CustomersDeleteRequest$outboundSchema = object({
  id: string2(),
  anonymize: _default2(boolean2(), false)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersDelete.js
function customersDelete(client, request, options) {
  return new APIPromise($do61(client, request, options));
}
async function $do61(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/{id}")(pathParams);
  const query = encodeFormQuery({
    "anonymize": payload.anonymize
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersdeleteexternal.js
var CustomersDeleteExternalRequest$outboundSchema = pipe(object({
  externalId: string2(),
  anonymize: _default2(boolean2(), false)
}), transform((v2) => {
  return remap(v2, {
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersDeleteExternal.js
function customersDeleteExternal(client, request, options) {
  return new APIPromise($do62(client, request, options));
}
async function $do62(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersDeleteExternalRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    external_id: encodeSimple("external_id", payload.external_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/external/{external_id}")(pathParams);
  const query = encodeFormQuery({
    "anonymize": payload.anonymize
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:delete_external",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersexport.js
var CustomersExportQueryParamOrganizationId$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomersExportRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())])))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersExport.js
function customersExport(client, request, options) {
  return new APIPromise($do63(client, request, options));
}
async function $do63(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersExportRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customers/export")();
  const query = encodeFormQuery({
    "organization_id": payload.organization_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:export",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersget.js
var CustomersGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersGet.js
function customersGet(client, request, options) {
  return new APIPromise($do64(client, request, options));
}
async function $do64(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerWithMembers$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersgetexternal.js
var CustomersGetExternalRequest$outboundSchema = pipe(object({
  externalId: string2()
}), transform((v2) => {
  return remap(v2, {
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersGetExternal.js
function customersGetExternal(client, request, options) {
  return new APIPromise($do65(client, request, options));
}
async function $do65(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersGetExternalRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    external_id: encodeSimple("external_id", payload.external_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/external/{external_id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:get_external",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerWithMembers$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersgetstate.js
var CustomersGetStateRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersGetState.js
function customersGetState(client, request, options) {
  return new APIPromise($do66(client, request, options));
}
async function $do66(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersGetStateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/{id}/state")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:get_state",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerState$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersgetstateexternal.js
var CustomersGetStateExternalRequest$outboundSchema = pipe(object({
  externalId: string2()
}), transform((v2) => {
  return remap(v2, {
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersGetStateExternal.js
function customersGetStateExternal(client, request, options) {
  return new APIPromise($do67(client, request, options));
}
async function $do67(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersGetStateExternalRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    external_id: encodeSimple("external_id", payload.external_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/external/{external_id}/state")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:get_state_external",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerState$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersortproperty.js
var CustomerSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Email: "email",
  MinusEmail: "-email",
  Name: "name",
  MinusName: "-name"
};
var CustomerSortProperty$outboundSchema = _enum2(CustomerSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomerwithmembers.js
var ListResourceCustomerWithMembers$inboundSchema = object({
  items: array(CustomerWithMembers$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerslist.js
var CustomersListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomersListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  email: optional(nullable(string2())),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomerSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));
var CustomersListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomerWithMembers$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersList.js
function customersList(client, request, options) {
  return new APIPromise($do68(client, request, options));
}
async function $do68(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customers/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "email": payload.email,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomersListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customersList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerupdate.js
var CustomerUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomerUpdateTaxId$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var CustomerUpdate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  email: optional(nullable(string2())),
  name: optional(nullable(string2())),
  billingAddress: optional(nullable(AddressInput$outboundSchema)),
  taxId: optional(nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema]))))),
  externalId: optional(nullable(string2())),
  type: optional(nullable(CustomerType$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    billingAddress: "billing_address",
    taxId: "tax_id",
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersupdate.js
var CustomersUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  customerUpdate: CustomerUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    customerUpdate: "CustomerUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersUpdate.js
function customersUpdate(client, request, options) {
  return new APIPromise($do69(client, request, options));
}
async function $do69(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomerUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerWithMembers$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerupdateexternalid.js
var CustomerUpdateExternalIDMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomerUpdateExternalIDTaxID$outboundSchema = smartUnion([string2(), TaxIDFormat$outboundSchema]);
var CustomerUpdateExternalID$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  email: optional(nullable(string2())),
  name: optional(nullable(string2())),
  billingAddress: optional(nullable(AddressInput$outboundSchema)),
  taxId: optional(nullable(array(nullable(smartUnion([string2(), TaxIDFormat$outboundSchema])))))
}), transform((v2) => {
  return remap(v2, {
    billingAddress: "billing_address",
    taxId: "tax_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersupdateexternal.js
var CustomersUpdateExternalRequest$outboundSchema = pipe(object({
  externalId: string2(),
  customerUpdateExternalID: CustomerUpdateExternalID$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    externalId: "external_id",
    customerUpdateExternalID: "CustomerUpdateExternalID"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customersUpdateExternal.js
function customersUpdateExternal(client, request, options) {
  return new APIPromise($do70(client, request, options));
}
async function $do70(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomersUpdateExternalRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomerUpdateExternalID, {
    explode: true
  });
  const pathParams = {
    external_id: encodeSimple("external_id", payload.external_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customers/external/{external_id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customers:update_external",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerWithMembers$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customers.js
var Customers = class extends ClientSDK {
  /**
   * List Customers
   *
   * @remarks
   * List customers.
   *
   * **Scopes**: `customers:read` `customers:write`
   */
  async list(request, options) {
    return unwrapResultIterator(customersList(this, request, options));
  }
  /**
   * Create Customer
   *
   * @remarks
   * Create a customer.
   *
   * **Scopes**: `customers:write`
   */
  async create(request, options) {
    return unwrapAsync(customersCreate(this, request, options));
  }
  /**
   * Export Customers
   *
   * @remarks
   * Export customers as a CSV file.
   *
   * **Scopes**: `customers:read` `customers:write`
   */
  async export(request, options) {
    return unwrapAsync(customersExport(this, request, options));
  }
  /**
   * Get Customer
   *
   * @remarks
   * Get a customer by ID.
   *
   * **Scopes**: `customers:read` `customers:write`
   */
  async get(request, options) {
    return unwrapAsync(customersGet(this, request, options));
  }
  /**
   * Update Customer
   *
   * @remarks
   * Update a customer.
   *
   * **Scopes**: `customers:write`
   */
  async update(request, options) {
    return unwrapAsync(customersUpdate(this, request, options));
  }
  /**
   * Delete Customer
   *
   * @remarks
   * Delete a customer.
   *
   * This action cannot be undone and will immediately:
   * - Cancel any active subscriptions for the customer
   * - Revoke all their benefits
   * - Clear any `external_id`
   *
   * Use it only in the context of deleting a user within your
   * own service. Otherwise, use more granular API endpoints to cancel
   * a specific subscription or revoke certain benefits.
   *
   * Note: The customers information will nonetheless be retained for historic
   * orders and subscriptions.
   *
   * Set `anonymize=true` to also anonymize PII for GDPR compliance.
   *
   * **Scopes**: `customers:write`
   */
  async delete(request, options) {
    return unwrapAsync(customersDelete(this, request, options));
  }
  /**
   * Get Customer by External ID
   *
   * @remarks
   * Get a customer by external ID.
   *
   * **Scopes**: `customers:read` `customers:write`
   */
  async getExternal(request, options) {
    return unwrapAsync(customersGetExternal(this, request, options));
  }
  /**
   * Update Customer by External ID
   *
   * @remarks
   * Update a customer by external ID.
   *
   * **Scopes**: `customers:write`
   */
  async updateExternal(request, options) {
    return unwrapAsync(customersUpdateExternal(this, request, options));
  }
  /**
   * Delete Customer by External ID
   *
   * @remarks
   * Delete a customer by external ID.
   *
   * Immediately cancels any active subscriptions and revokes any active benefits.
   *
   * Set `anonymize=true` to also anonymize PII for GDPR compliance.
   *
   * **Scopes**: `customers:write`
   */
  async deleteExternal(request, options) {
    return unwrapAsync(customersDeleteExternal(this, request, options));
  }
  /**
   * Get Customer State
   *
   * @remarks
   * Get a customer state by ID.
   *
   * The customer state includes information about
   * the customer's active subscriptions and benefits.
   *
   * It's the ideal endpoint to use when you need to get a full overview
   * of a customer's status.
   *
   * **Scopes**: `customers:read` `customers:write`
   */
  async getState(request, options) {
    return unwrapAsync(customersGetState(this, request, options));
  }
  /**
   * Get Customer State by External ID
   *
   * @remarks
   * Get a customer state by external ID.
   *
   * The customer state includes information about
   * the customer's active subscriptions and benefits.
   *
   * It's the ideal endpoint to use when you need to get a full overview
   * of a customer's status.
   *
   * **Scopes**: `customers:read` `customers:write`
   */
  async getStateExternal(request, options) {
    return unwrapAsync(customersGetStateExternal(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSeatsAssignSeat.js
function customerSeatsAssignSeat(client, request, options) {
  return new APIPromise($do71(client, request, options));
}
async function $do71(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SeatAssign$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-seats")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-seats:assign_seat",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeat$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([400, 401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerseatclaimresponse.js
var CustomerSeatClaimResponse$inboundSchema = pipe(object({
  seat: CustomerSeat$inboundSchema,
  customer_session_token: string2()
}), transform((v2) => {
  return remap(v2, {
    "customer_session_token": "customerSessionToken"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/seatclaim.js
var SeatClaim$outboundSchema = pipe(object({
  invitationToken: string2()
}), transform((v2) => {
  return remap(v2, {
    invitationToken: "invitation_token"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSeatsClaimSeat.js
function customerSeatsClaimSeat(client, request, options) {
  return new APIPromise($do72(client, request, options));
}
async function $do72(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SeatClaim$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-seats/claim")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-seats:claim_seat",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "403", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeatClaimResponse$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([400, 403, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/seatclaiminfo.js
var SeatClaimInfo$inboundSchema = pipe(object({
  product_name: string2(),
  product_id: string2(),
  organization_name: string2(),
  organization_slug: string2(),
  customer_email: string2(),
  can_claim: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "product_name": "productName",
    "product_id": "productId",
    "organization_name": "organizationName",
    "organization_slug": "organizationSlug",
    "customer_email": "customerEmail",
    "can_claim": "canClaim"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerseatsgetclaiminfo.js
var CustomerSeatsGetClaimInfoRequest$outboundSchema = pipe(object({
  invitationToken: string2()
}), transform((v2) => {
  return remap(v2, {
    invitationToken: "invitation_token"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSeatsGetClaimInfo.js
function customerSeatsGetClaimInfo(client, request, options) {
  return new APIPromise($do73(client, request, options));
}
async function $do73(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerSeatsGetClaimInfoRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    invitation_token: encodeSimple("invitation_token", payload.invitation_token, { explode: false, charEncoding: "percent" })
  };
  const path = pathToFunc("/v1/customer-seats/claim/{invitation_token}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-seats:get_claim_info",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, SeatClaimInfo$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([400, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerseatslistseats.js
var CustomerSeatsListSeatsRequest$outboundSchema = pipe(object({
  subscriptionId: optional(nullable(string2())),
  orderId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    subscriptionId: "subscription_id",
    orderId: "order_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSeatsListSeats.js
function customerSeatsListSeats(client, request, options) {
  return new APIPromise($do74(client, request, options));
}
async function $do74(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerSeatsListSeatsRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customer-seats")();
  const query = encodeFormQuery({
    "order_id": payload.order_id,
    "subscription_id": payload.subscription_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-seats:list_seats",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, SeatsList$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerseatsresendinvitation.js
var CustomerSeatsResendInvitationRequest$outboundSchema = pipe(object({
  seatId: string2()
}), transform((v2) => {
  return remap(v2, {
    seatId: "seat_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSeatsResendInvitation.js
function customerSeatsResendInvitation(client, request, options) {
  return new APIPromise($do75(client, request, options));
}
async function $do75(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerSeatsResendInvitationRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    seat_id: encodeSimple("seat_id", payload.seat_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-seats/{seat_id}/resend")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-seats:resend_invitation",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeat$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([400, 401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customerseatsrevokeseat.js
var CustomerSeatsRevokeSeatRequest$outboundSchema = pipe(object({
  seatId: string2()
}), transform((v2) => {
  return remap(v2, {
    seatId: "seat_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSeatsRevokeSeat.js
function customerSeatsRevokeSeat(client, request, options) {
  return new APIPromise($do76(client, request, options));
}
async function $do76(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerSeatsRevokeSeatRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    seat_id: encodeSimple("seat_id", payload.seat_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/customer-seats/{seat_id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-seats:revoke_seat",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomerSeat$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([401, 403, 404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customerseats.js
var CustomerSeats = class extends ClientSDK {
  /**
   * Assign Seat
   *
   * @remarks
   * **Scopes**: `customer_seats:write`
   */
  async assignSeat(request, options) {
    return unwrapAsync(customerSeatsAssignSeat(this, request, options));
  }
  /**
   * List Seats
   *
   * @remarks
   * **Scopes**: `customer_seats:write`
   */
  async listSeats(request, options) {
    return unwrapAsync(customerSeatsListSeats(this, request, options));
  }
  /**
   * Revoke Seat
   *
   * @remarks
   * **Scopes**: `customer_seats:write`
   */
  async revokeSeat(request, options) {
    return unwrapAsync(customerSeatsRevokeSeat(this, request, options));
  }
  /**
   * Resend Invitation
   *
   * @remarks
   * **Scopes**: `customer_seats:write`
   */
  async resendInvitation(request, options) {
    return unwrapAsync(customerSeatsResendInvitation(this, request, options));
  }
  /**
   * Get Claim Info
   */
  async getClaimInfo(request, options) {
    return unwrapAsync(customerSeatsGetClaimInfo(this, request, options));
  }
  /**
   * Claim Seat
   */
  async claimSeat(request, options) {
    return unwrapAsync(customerSeatsClaimSeat(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersession.js
var CustomerSession$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  token: string2(),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  return_url: nullable(string2()),
  customer_portal_url: string2(),
  customer_id: string2(),
  customer: Customer$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "expires_at": "expiresAt",
    "return_url": "returnUrl",
    "customer_portal_url": "customerPortalUrl",
    "customer_id": "customerId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersessioncustomerexternalidcreate.js
var CustomerSessionCustomerExternalIDCreate$outboundSchema = pipe(object({
  returnUrl: optional(nullable(string2())),
  externalCustomerId: string2()
}), transform((v2) => {
  return remap(v2, {
    returnUrl: "return_url",
    externalCustomerId: "external_customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customersessioncustomeridcreate.js
var CustomerSessionCustomerIDCreate$outboundSchema = pipe(object({
  returnUrl: optional(nullable(string2())),
  customerId: string2()
}), transform((v2) => {
  return remap(v2, {
    returnUrl: "return_url",
    customerId: "customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customersessionscreate.js
var CustomerSessionsCreateCustomerSessionCreate$outboundSchema = smartUnion([
  CustomerSessionCustomerIDCreate$outboundSchema,
  CustomerSessionCustomerExternalIDCreate$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customerSessionsCreate.js
function customerSessionsCreate(client, request, options) {
  return new APIPromise($do77(client, request, options));
}
async function $do77(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomerSessionsCreateCustomerSessionCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/customer-sessions/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "customer-sessions:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, CustomerSession$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customersessions.js
var CustomerSessions = class extends ClientSDK {
  /**
   * Create Customer Session
   *
   * @remarks
   * Create a customer session.
   *
   * For organizations with `member_model_enabled`, this will automatically
   * create a member session for the owner member of the customer.
   *
   * **Scopes**: `customer_sessions:write`
   */
  async create(request, options) {
    return unwrapAsync(customerSessionsCreate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcreatecheckbox.js
var CustomFieldCreateCheckboxMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldCreateCheckbox$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("checkbox"),
  slug: string2(),
  name: string2(),
  organizationId: optional(nullable(string2())),
  properties: CustomFieldCheckboxProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcreatedate.js
var CustomFieldCreateDateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldCreateDate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("date"),
  slug: string2(),
  name: string2(),
  organizationId: optional(nullable(string2())),
  properties: CustomFieldDateProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcreatenumber.js
var CustomFieldCreateNumberMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldCreateNumber$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("number"),
  slug: string2(),
  name: string2(),
  organizationId: optional(nullable(string2())),
  properties: CustomFieldNumberProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcreateselect.js
var CustomFieldCreateSelectMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldCreateSelect$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("select"),
  slug: string2(),
  name: string2(),
  organizationId: optional(nullable(string2())),
  properties: CustomFieldSelectProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcreatetext.js
var CustomFieldCreateTextMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldCreateText$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  type: literal("text"),
  slug: string2(),
  name: string2(),
  organizationId: optional(nullable(string2())),
  properties: CustomFieldTextProperties$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldcreate.js
var CustomFieldCreate$outboundSchema = union([
  CustomFieldCreateCheckbox$outboundSchema,
  CustomFieldCreateDate$outboundSchema,
  CustomFieldCreateNumber$outboundSchema,
  CustomFieldCreateSelect$outboundSchema,
  CustomFieldCreateText$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customFieldsCreate.js
function customFieldsCreate(client, request, options) {
  return new APIPromise($do78(client, request, options));
}
async function $do78(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomFieldCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/custom-fields/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "custom-fields:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, CustomField$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customfieldsdelete.js
var CustomFieldsDeleteRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customFieldsDelete.js
function customFieldsDelete(client, request, options) {
  return new APIPromise($do79(client, request, options));
}
async function $do79(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomFieldsDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/custom-fields/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "custom-fields:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customfieldsget.js
var CustomFieldsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customFieldsGet.js
function customFieldsGet(client, request, options) {
  return new APIPromise($do80(client, request, options));
}
async function $do80(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomFieldsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/custom-fields/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "custom-fields:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomField$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldsortproperty.js
var CustomFieldSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Slug: "slug",
  MinusSlug: "-slug",
  Name: "name",
  MinusName: "-name",
  Type: "type",
  MinusType: "-type"
};
var CustomFieldSortProperty$outboundSchema = _enum2(CustomFieldSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldtype.js
var CustomFieldType = {
  Text: "text",
  Number: "number",
  Date: "date",
  Checkbox: "checkbox",
  Select: "select"
};
var CustomFieldType$outboundSchema = _enum2(CustomFieldType);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcecustomfield.js
var ListResourceCustomField$inboundSchema = object({
  items: array(CustomField$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customfieldslist.js
var CustomFieldsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomFieldTypeFilter$outboundSchema = smartUnion([
  CustomFieldType$outboundSchema,
  array(CustomFieldType$outboundSchema)
]);
var CustomFieldsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  typeFilter: optional(nullable(smartUnion([
    CustomFieldType$outboundSchema,
    array(CustomFieldType$outboundSchema)
  ]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(CustomFieldSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    typeFilter: "type_filter"
  });
}));
var CustomFieldsListResponse$inboundSchema = pipe(object({
  Result: ListResourceCustomField$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customFieldsList.js
function customFieldsList(client, request, options) {
  return new APIPromise($do81(client, request, options));
}
async function $do81(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomFieldsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/custom-fields/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting,
    "type": payload.type_filter
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "custom-fields:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, CustomFieldsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => customFieldsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldupdatecheckbox.js
var CustomFieldUpdateCheckboxMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldUpdateCheckbox$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  slug: optional(nullable(string2())),
  type: literal("checkbox"),
  properties: optional(nullable(CustomFieldCheckboxProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldupdatedate.js
var CustomFieldUpdateDateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldUpdateDate$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  slug: optional(nullable(string2())),
  type: literal("date"),
  properties: optional(nullable(CustomFieldDateProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldupdatenumber.js
var CustomFieldUpdateNumberMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldUpdateNumber$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  slug: optional(nullable(string2())),
  type: literal("number"),
  properties: optional(nullable(CustomFieldNumberProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldupdateselect.js
var CustomFieldUpdateSelectMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldUpdateSelect$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  slug: optional(nullable(string2())),
  type: literal("select"),
  properties: optional(nullable(CustomFieldSelectProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldupdatetext.js
var CustomFieldUpdateTextMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var CustomFieldUpdateText$outboundSchema = object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  slug: optional(nullable(string2())),
  type: literal("text"),
  properties: optional(nullable(CustomFieldTextProperties$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customfieldupdate.js
var CustomFieldUpdate$outboundSchema = union([
  CustomFieldUpdateCheckbox$outboundSchema,
  CustomFieldUpdateDate$outboundSchema,
  CustomFieldUpdateNumber$outboundSchema,
  CustomFieldUpdateSelect$outboundSchema,
  CustomFieldUpdateText$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/customfieldsupdate.js
var CustomFieldsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  customFieldUpdate: CustomFieldUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    customFieldUpdate: "CustomFieldUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/customFieldsUpdate.js
function customFieldsUpdate(client, request, options) {
  return new APIPromise($do82(client, request, options));
}
async function $do82(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(CustomFieldsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CustomFieldUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/custom-fields/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "custom-fields:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, CustomField$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/customfields.js
var CustomFields = class extends ClientSDK {
  /**
   * List Custom Fields
   *
   * @remarks
   * List custom fields.
   *
   * **Scopes**: `custom_fields:read` `custom_fields:write`
   */
  async list(request, options) {
    return unwrapResultIterator(customFieldsList(this, request, options));
  }
  /**
   * Create Custom Field
   *
   * @remarks
   * Create a custom field.
   *
   * **Scopes**: `custom_fields:write`
   */
  async create(request, options) {
    return unwrapAsync(customFieldsCreate(this, request, options));
  }
  /**
   * Get Custom Field
   *
   * @remarks
   * Get a custom field by ID.
   *
   * **Scopes**: `custom_fields:read` `custom_fields:write`
   */
  async get(request, options) {
    return unwrapAsync(customFieldsGet(this, request, options));
  }
  /**
   * Update Custom Field
   *
   * @remarks
   * Update a custom field.
   *
   * **Scopes**: `custom_fields:write`
   */
  async update(request, options) {
    return unwrapAsync(customFieldsUpdate(this, request, options));
  }
  /**
   * Delete Custom Field
   *
   * @remarks
   * Delete a custom field.
   *
   * **Scopes**: `custom_fields:write`
   */
  async delete(request, options) {
    return unwrapAsync(customFieldsDelete(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountproduct.js
var DiscountProduct$inboundSchema = pipe(object({
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  id: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  trial_interval: nullable(TrialInterval$inboundSchema),
  trial_interval_count: nullable(int()),
  name: string2(),
  description: nullable(string2()),
  recurring_interval: nullable(SubscriptionRecurringInterval$inboundSchema),
  recurring_interval_count: nullable(int()),
  is_recurring: boolean2(),
  is_archived: boolean2(),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "trial_interval": "trialInterval",
    "trial_interval_count": "trialIntervalCount",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "is_recurring": "isRecurring",
    "is_archived": "isArchived",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountfixedonceforeverduration.js
var DiscountFixedOnceForeverDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  type: DiscountType$inboundSchema,
  amount: int(),
  currency: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2(),
  products: array(DiscountProduct$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountfixedrepeatduration.js
var DiscountFixedRepeatDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  duration_in_months: int(),
  type: DiscountType$inboundSchema,
  amount: int(),
  currency: string2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2(),
  products: array(DiscountProduct$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "duration_in_months": "durationInMonths",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountpercentageonceforeverduration.js
var DiscountPercentageOnceForeverDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  type: DiscountType$inboundSchema,
  basis_points: int(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2(),
  products: array(DiscountProduct$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "basis_points": "basisPoints",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountpercentagerepeatduration.js
var DiscountPercentageRepeatDuration$inboundSchema = pipe(object({
  duration: DiscountDuration$inboundSchema,
  duration_in_months: int(),
  type: DiscountType$inboundSchema,
  basis_points: int(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  metadata: record(string2(), MetadataOutputType$inboundSchema),
  name: string2(),
  code: nullable(string2()),
  starts_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  ends_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  max_redemptions: nullable(int()),
  redemptions_count: int(),
  organization_id: string2(),
  products: array(DiscountProduct$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "duration_in_months": "durationInMonths",
    "basis_points": "basisPoints",
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "starts_at": "startsAt",
    "ends_at": "endsAt",
    "max_redemptions": "maxRedemptions",
    "redemptions_count": "redemptionsCount",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discount.js
var Discount$inboundSchema = smartUnion([
  DiscountFixedRepeatDuration$inboundSchema,
  DiscountFixedOnceForeverDuration$inboundSchema,
  DiscountPercentageRepeatDuration$inboundSchema,
  DiscountPercentageOnceForeverDuration$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountfixedonceforeverdurationcreate.js
var DiscountFixedOnceForeverDurationCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var DiscountFixedOnceForeverDurationCreate$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  type: DiscountType$outboundSchema,
  amount: int(),
  currency: _default2(string2(), "usd"),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  code: optional(nullable(string2())),
  startsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  maxRedemptions: optional(nullable(int())),
  products: optional(nullable(array(string2()))),
  organizationId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountfixedrepeatdurationcreate.js
var DiscountFixedRepeatDurationCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var DiscountFixedRepeatDurationCreate$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  durationInMonths: int(),
  type: DiscountType$outboundSchema,
  amount: int(),
  currency: _default2(string2(), "usd"),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  code: optional(nullable(string2())),
  startsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  maxRedemptions: optional(nullable(int())),
  products: optional(nullable(array(string2()))),
  organizationId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    durationInMonths: "duration_in_months",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountpercentageonceforeverdurationcreate.js
var DiscountPercentageOnceForeverDurationCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var DiscountPercentageOnceForeverDurationCreate$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  type: DiscountType$outboundSchema,
  basisPoints: int(),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  code: optional(nullable(string2())),
  startsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  maxRedemptions: optional(nullable(int())),
  products: optional(nullable(array(string2()))),
  organizationId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    basisPoints: "basis_points",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountpercentagerepeatdurationcreate.js
var DiscountPercentageRepeatDurationCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var DiscountPercentageRepeatDurationCreate$outboundSchema = pipe(object({
  duration: DiscountDuration$outboundSchema,
  durationInMonths: int(),
  type: DiscountType$outboundSchema,
  basisPoints: int(),
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  code: optional(nullable(string2())),
  startsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  maxRedemptions: optional(nullable(int())),
  products: optional(nullable(array(string2()))),
  organizationId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    durationInMonths: "duration_in_months",
    basisPoints: "basis_points",
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountcreate.js
var DiscountCreate$outboundSchema = smartUnion([
  DiscountFixedRepeatDurationCreate$outboundSchema,
  DiscountPercentageRepeatDurationCreate$outboundSchema,
  DiscountFixedOnceForeverDurationCreate$outboundSchema,
  DiscountPercentageOnceForeverDurationCreate$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/discountsCreate.js
function discountsCreate(client, request, options) {
  return new APIPromise($do83(client, request, options));
}
async function $do83(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DiscountCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/discounts/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "discounts:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Discount$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/discountsdelete.js
var DiscountsDeleteRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/discountsDelete.js
function discountsDelete(client, request, options) {
  return new APIPromise($do84(client, request, options));
}
async function $do84(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DiscountsDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/discounts/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "discounts:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/discountsget.js
var DiscountsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/discountsGet.js
function discountsGet(client, request, options) {
  return new APIPromise($do85(client, request, options));
}
async function $do85(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DiscountsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/discounts/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "discounts:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Discount$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountsortproperty.js
var DiscountSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Name: "name",
  MinusName: "-name",
  Code: "code",
  MinusCode: "-code",
  RedemptionsCount: "redemptions_count",
  MinusRedemptionsCount: "-redemptions_count"
};
var DiscountSortProperty$outboundSchema = _enum2(DiscountSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcediscount.js
var ListResourceDiscount$inboundSchema = object({
  items: array(Discount$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/discountslist.js
var DiscountsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var DiscountsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(DiscountSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));
var DiscountsListResponse$inboundSchema = pipe(object({
  Result: ListResourceDiscount$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/discountsList.js
function discountsList(client, request, options) {
  return new APIPromise($do86(client, request, options));
}
async function $do86(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DiscountsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/discounts/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "discounts:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, DiscountsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => discountsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/discountupdate.js
var DiscountUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var DiscountUpdate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  code: optional(nullable(string2())),
  startsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endsAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  maxRedemptions: optional(nullable(int())),
  duration: optional(nullable(DiscountDuration$outboundSchema)),
  durationInMonths: optional(nullable(int())),
  type: optional(nullable(DiscountType$outboundSchema)),
  amount: optional(nullable(int())),
  currency: optional(nullable(string2())),
  basisPoints: optional(nullable(int())),
  products: optional(nullable(array(string2())))
}), transform((v2) => {
  return remap(v2, {
    startsAt: "starts_at",
    endsAt: "ends_at",
    maxRedemptions: "max_redemptions",
    durationInMonths: "duration_in_months",
    basisPoints: "basis_points"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/discountsupdate.js
var DiscountsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  discountUpdate: DiscountUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    discountUpdate: "DiscountUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/discountsUpdate.js
function discountsUpdate(client, request, options) {
  return new APIPromise($do87(client, request, options));
}
async function $do87(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DiscountsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.DiscountUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/discounts/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "discounts:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Discount$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/discounts.js
var Discounts = class extends ClientSDK {
  /**
   * List Discounts
   *
   * @remarks
   * List discounts.
   *
   * **Scopes**: `discounts:read` `discounts:write`
   */
  async list(request, options) {
    return unwrapResultIterator(discountsList(this, request, options));
  }
  /**
   * Create Discount
   *
   * @remarks
   * Create a discount.
   *
   * **Scopes**: `discounts:write`
   */
  async create(request, options) {
    return unwrapAsync(discountsCreate(this, request, options));
  }
  /**
   * Get Discount
   *
   * @remarks
   * Get a discount by ID.
   *
   * **Scopes**: `discounts:read` `discounts:write`
   */
  async get(request, options) {
    return unwrapAsync(discountsGet(this, request, options));
  }
  /**
   * Update Discount
   *
   * @remarks
   * Update a discount.
   *
   * **Scopes**: `discounts:write`
   */
  async update(request, options) {
    return unwrapAsync(discountsUpdate(this, request, options));
  }
  /**
   * Delete Discount
   *
   * @remarks
   * Delete a discount.
   *
   * **Scopes**: `discounts:write`
   */
  async delete(request, options) {
    return unwrapAsync(discountsDelete(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/dispute.js
var Dispute$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  status: DisputeStatus$inboundSchema,
  resolved: boolean2(),
  closed: boolean2(),
  amount: int(),
  tax_amount: int(),
  currency: string2(),
  order_id: string2(),
  payment_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "tax_amount": "taxAmount",
    "order_id": "orderId",
    "payment_id": "paymentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/disputesget.js
var DisputesGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/disputesGet.js
function disputesGet(client, request, options) {
  return new APIPromise($do88(client, request, options));
}
async function $do88(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DisputesGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/disputes/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "disputes:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Dispute$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/disputesortproperty.js
var DisputeSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Amount: "amount",
  MinusAmount: "-amount"
};
var DisputeSortProperty$outboundSchema = _enum2(DisputeSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcedispute.js
var ListResourceDispute$inboundSchema = object({
  items: array(Dispute$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/disputeslist.js
var DisputesListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamOrderIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var StatusFilter$outboundSchema = smartUnion([
  DisputeStatus$outboundSchema,
  array(DisputeStatus$outboundSchema)
]);
var DisputesListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  orderId: optional(nullable(smartUnion([string2(), array(string2())]))),
  status: optional(nullable(smartUnion([
    DisputeStatus$outboundSchema,
    array(DisputeStatus$outboundSchema)
  ]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(DisputeSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    orderId: "order_id"
  });
}));
var DisputesListResponse$inboundSchema = pipe(object({
  Result: ListResourceDispute$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/disputesList.js
function disputesList(client, request, options) {
  return new APIPromise($do89(client, request, options));
}
async function $do89(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(DisputesListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/disputes/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "order_id": payload.order_id,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "sorting": payload.sorting,
    "status": payload.status
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "disputes:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, DisputesListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => disputesList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/disputes.js
var Disputes = class extends ClientSDK {
  /**
   * List Disputes
   *
   * @remarks
   * List disputes.
   *
   * **Scopes**: `disputes:read`
   */
  async list(request, options) {
    return unwrapResultIterator(disputesList(this, request, options));
  }
  /**
   * Get Dispute
   *
   * @remarks
   * Get a dispute by ID.
   *
   * **Scopes**: `disputes:read`
   */
  async get(request, options) {
    return unwrapAsync(disputesGet(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancecreditordermetadata.js
var BalanceCreditOrderMetadata$inboundSchema = pipe(object({
  order_id: string2(),
  product_id: optional(string2()),
  subscription_id: optional(string2()),
  amount: int(),
  currency: string2(),
  tax_amount: int(),
  tax_state: optional(nullable(string2())),
  tax_country: optional(nullable(string2())),
  fee: int()
}), transform((v2) => {
  return remap(v2, {
    "order_id": "orderId",
    "product_id": "productId",
    "subscription_id": "subscriptionId",
    "tax_amount": "taxAmount",
    "tax_state": "taxState",
    "tax_country": "taxCountry"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancecreditorderevent.js
var BalanceCreditOrderEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("balance.credit_order"),
  metadata: BalanceCreditOrderMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancedisputemetadata.js
var BalanceDisputeMetadata$inboundSchema = pipe(object({
  transaction_id: string2(),
  dispute_id: string2(),
  order_id: optional(string2()),
  order_created_at: optional(string2()),
  product_id: optional(string2()),
  subscription_id: optional(string2()),
  amount: int(),
  currency: string2(),
  presentment_amount: int(),
  presentment_currency: string2(),
  tax_amount: int(),
  tax_state: optional(nullable(string2())),
  tax_country: optional(nullable(string2())),
  fee: int()
}), transform((v2) => {
  return remap(v2, {
    "transaction_id": "transactionId",
    "dispute_id": "disputeId",
    "order_id": "orderId",
    "order_created_at": "orderCreatedAt",
    "product_id": "productId",
    "subscription_id": "subscriptionId",
    "presentment_amount": "presentmentAmount",
    "presentment_currency": "presentmentCurrency",
    "tax_amount": "taxAmount",
    "tax_state": "taxState",
    "tax_country": "taxCountry"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancedisputeevent.js
var BalanceDisputeEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("balance.dispute"),
  metadata: BalanceDisputeMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancedisputereversalevent.js
var BalanceDisputeReversalEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("balance.dispute_reversal"),
  metadata: BalanceDisputeMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balanceordermetadata.js
var BalanceOrderMetadata$inboundSchema = pipe(object({
  transaction_id: string2(),
  order_id: string2(),
  product_id: optional(string2()),
  subscription_id: optional(string2()),
  amount: int(),
  currency: string2(),
  presentment_amount: int(),
  presentment_currency: string2(),
  tax_amount: int(),
  tax_state: optional(nullable(string2())),
  tax_country: optional(nullable(string2())),
  fee: int()
}), transform((v2) => {
  return remap(v2, {
    "transaction_id": "transactionId",
    "order_id": "orderId",
    "product_id": "productId",
    "subscription_id": "subscriptionId",
    "presentment_amount": "presentmentAmount",
    "presentment_currency": "presentmentCurrency",
    "tax_amount": "taxAmount",
    "tax_state": "taxState",
    "tax_country": "taxCountry"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balanceorderevent.js
var BalanceOrderEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("balance.order"),
  metadata: BalanceOrderMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancerefundmetadata.js
var BalanceRefundMetadata$inboundSchema = pipe(object({
  transaction_id: string2(),
  refund_id: string2(),
  order_id: optional(string2()),
  order_created_at: optional(string2()),
  product_id: optional(string2()),
  subscription_id: optional(string2()),
  amount: int(),
  currency: string2(),
  presentment_amount: int(),
  presentment_currency: string2(),
  refundable_amount: optional(int()),
  tax_amount: int(),
  tax_state: optional(nullable(string2())),
  tax_country: optional(nullable(string2())),
  fee: int()
}), transform((v2) => {
  return remap(v2, {
    "transaction_id": "transactionId",
    "refund_id": "refundId",
    "order_id": "orderId",
    "order_created_at": "orderCreatedAt",
    "product_id": "productId",
    "subscription_id": "subscriptionId",
    "presentment_amount": "presentmentAmount",
    "presentment_currency": "presentmentCurrency",
    "refundable_amount": "refundableAmount",
    "tax_amount": "taxAmount",
    "tax_state": "taxState",
    "tax_country": "taxCountry"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancerefundevent.js
var BalanceRefundEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("balance.refund"),
  metadata: BalanceRefundMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/balancerefundreversalevent.js
var BalanceRefundReversalEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("balance.refund_reversal"),
  metadata: BalanceRefundMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantmetadata.js
var BenefitGrantMetadata$inboundSchema = pipe(object({
  benefit_id: string2(),
  benefit_grant_id: string2(),
  benefit_type: BenefitType$inboundSchema,
  member_id: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "benefit_id": "benefitId",
    "benefit_grant_id": "benefitGrantId",
    "benefit_type": "benefitType",
    "member_id": "memberId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitcycledevent.js
var BenefitCycledEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("benefit.cycled"),
  metadata: BenefitGrantMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitgrantedevent.js
var BenefitGrantedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("benefit.granted"),
  metadata: BenefitGrantMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitrevokedevent.js
var BenefitRevokedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("benefit.revoked"),
  metadata: BenefitGrantMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/benefitupdatedevent.js
var BenefitUpdatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("benefit.updated"),
  metadata: BenefitGrantMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutcreatedmetadata.js
var CheckoutCreatedMetadata$inboundSchema = pipe(object({
  checkout_id: string2(),
  checkout_status: string2(),
  product_id: optional(string2())
}), transform((v2) => {
  return remap(v2, {
    "checkout_id": "checkoutId",
    "checkout_status": "checkoutStatus",
    "product_id": "productId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/checkoutcreatedevent.js
var CheckoutCreatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("checkout.created"),
  metadata: CheckoutCreatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercreatedmetadata.js
var CustomerCreatedMetadata$inboundSchema = pipe(object({
  customer_id: string2(),
  customer_email: string2(),
  customer_name: nullable(string2()),
  customer_external_id: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "customer_id": "customerId",
    "customer_email": "customerEmail",
    "customer_name": "customerName",
    "customer_external_id": "customerExternalId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customercreatedevent.js
var CustomerCreatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("customer.created"),
  metadata: CustomerCreatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerdeletedmetadata.js
var CustomerDeletedMetadata$inboundSchema = pipe(object({
  customer_id: string2(),
  customer_email: string2(),
  customer_name: nullable(string2()),
  customer_external_id: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "customer_id": "customerId",
    "customer_email": "customerEmail",
    "customer_name": "customerName",
    "customer_external_id": "customerExternalId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerdeletedevent.js
var CustomerDeletedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("customer.deleted"),
  metadata: CustomerDeletedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/addressdict.js
var AddressDict$inboundSchema = pipe(object({
  line1: optional(string2()),
  line2: optional(string2()),
  postal_code: optional(string2()),
  city: optional(string2()),
  state: optional(string2()),
  country: string2()
}), transform((v2) => {
  return remap(v2, {
    "postal_code": "postalCode"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerupdatedfields.js
var CustomerUpdatedFieldsMetadata$inboundSchema = smartUnion([string2(), int(), boolean2()]);
var CustomerUpdatedFields$inboundSchema = pipe(object({
  name: optional(nullable(string2())),
  email: optional(nullable(string2())),
  billing_address: optional(nullable(AddressDict$inboundSchema)),
  tax_id: optional(nullable(string2())),
  metadata: optional(nullable(record(string2(), smartUnion([string2(), int(), boolean2()]))))
}), transform((v2) => {
  return remap(v2, {
    "billing_address": "billingAddress",
    "tax_id": "taxId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerupdatedmetadata.js
var CustomerUpdatedMetadata$inboundSchema = pipe(object({
  customer_id: string2(),
  customer_email: string2(),
  customer_name: nullable(string2()),
  customer_external_id: nullable(string2()),
  updated_fields: CustomerUpdatedFields$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "customer_id": "customerId",
    "customer_email": "customerEmail",
    "customer_name": "customerName",
    "customer_external_id": "customerExternalId",
    "updated_fields": "updatedFields"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/customerupdatedevent.js
var CustomerUpdatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("customer.updated"),
  metadata: CustomerUpdatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metercreditedmetadata.js
var MeterCreditedMetadata$inboundSchema = pipe(object({
  meter_id: string2(),
  units: int(),
  rollover: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "meter_id": "meterId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metercreditevent.js
var MeterCreditEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("meter.credited"),
  metadata: MeterCreditedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/meterresetmetadata.js
var MeterResetMetadata$inboundSchema = pipe(object({
  meter_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "meter_id": "meterId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/meterresetevent.js
var MeterResetEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("meter.reset"),
  metadata: MeterResetMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderpaidmetadata.js
var OrderPaidMetadata$inboundSchema = pipe(object({
  order_id: string2(),
  product_id: optional(string2()),
  billing_type: optional(string2()),
  amount: int(),
  currency: optional(string2()),
  net_amount: optional(int()),
  tax_amount: optional(int()),
  applied_balance_amount: optional(int()),
  discount_amount: optional(int()),
  discount_id: optional(string2()),
  platform_fee: optional(int()),
  subscription_id: optional(string2()),
  recurring_interval: optional(string2()),
  recurring_interval_count: optional(int())
}), transform((v2) => {
  return remap(v2, {
    "order_id": "orderId",
    "product_id": "productId",
    "billing_type": "billingType",
    "net_amount": "netAmount",
    "tax_amount": "taxAmount",
    "applied_balance_amount": "appliedBalanceAmount",
    "discount_amount": "discountAmount",
    "discount_id": "discountId",
    "platform_fee": "platformFee",
    "subscription_id": "subscriptionId",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderpaidevent.js
var OrderPaidEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("order.paid"),
  metadata: OrderPaidMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderrefundedmetadata.js
var OrderRefundedMetadata$inboundSchema = pipe(object({
  order_id: string2(),
  refunded_amount: int(),
  currency: string2()
}), transform((v2) => {
  return remap(v2, {
    "order_id": "orderId",
    "refunded_amount": "refundedAmount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderrefundedevent.js
var OrderRefundedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("order.refunded"),
  metadata: OrderRefundedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionbillingperiodupdatedmetadata.js
var SubscriptionBillingPeriodUpdatedMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  old_period_end: string2(),
  new_period_end: string2()
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "old_period_end": "oldPeriodEnd",
    "new_period_end": "newPeriodEnd"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionbillingperiodupdatedevent.js
var SubscriptionBillingPeriodUpdatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.billing_period_updated"),
  metadata: SubscriptionBillingPeriodUpdatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncanceledmetadata.js
var SubscriptionCanceledMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  product_id: optional(string2()),
  amount: int(),
  currency: string2(),
  recurring_interval: string2(),
  recurring_interval_count: int(),
  customer_cancellation_reason: optional(string2()),
  customer_cancellation_comment: optional(string2()),
  canceled_at: string2(),
  ends_at: optional(string2()),
  cancel_at_period_end: optional(boolean2())
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "customer_cancellation_reason": "customerCancellationReason",
    "customer_cancellation_comment": "customerCancellationComment",
    "canceled_at": "canceledAt",
    "ends_at": "endsAt",
    "cancel_at_period_end": "cancelAtPeriodEnd"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncanceledevent.js
var SubscriptionCanceledEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.canceled"),
  metadata: SubscriptionCanceledMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncreatedmetadata.js
var SubscriptionCreatedMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  product_id: string2(),
  amount: int(),
  currency: string2(),
  recurring_interval: string2(),
  recurring_interval_count: int(),
  started_at: string2()
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount",
    "started_at": "startedAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncreatedevent.js
var SubscriptionCreatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.created"),
  metadata: SubscriptionCreatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncycledmetadata.js
var SubscriptionCycledMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  product_id: optional(string2()),
  amount: optional(int()),
  currency: optional(string2()),
  recurring_interval: optional(string2()),
  recurring_interval_count: optional(int())
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncycledevent.js
var SubscriptionCycledEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.cycled"),
  metadata: SubscriptionCycledMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionproductupdatedmetadata.js
var SubscriptionProductUpdatedMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  old_product_id: string2(),
  new_product_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "old_product_id": "oldProductId",
    "new_product_id": "newProductId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionproductupdatedevent.js
var SubscriptionProductUpdatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.product_updated"),
  metadata: SubscriptionProductUpdatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionrevokedmetadata.js
var SubscriptionRevokedMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  product_id: optional(string2()),
  amount: optional(int()),
  currency: optional(string2()),
  recurring_interval: optional(string2()),
  recurring_interval_count: optional(int())
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionrevokedevent.js
var SubscriptionRevokedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.revoked"),
  metadata: SubscriptionRevokedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionseatsupdatedmetadata.js
var SubscriptionSeatsUpdatedMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  old_seats: int(),
  new_seats: int(),
  proration_behavior: string2()
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "old_seats": "oldSeats",
    "new_seats": "newSeats",
    "proration_behavior": "prorationBehavior"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionseatsupdatedevent.js
var SubscriptionSeatsUpdatedEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.seats_updated"),
  metadata: SubscriptionSeatsUpdatedMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionuncanceledmetadata.js
var SubscriptionUncanceledMetadata$inboundSchema = pipe(object({
  subscription_id: string2(),
  product_id: string2(),
  amount: int(),
  currency: string2(),
  recurring_interval: string2(),
  recurring_interval_count: int()
}), transform((v2) => {
  return remap(v2, {
    "subscription_id": "subscriptionId",
    "product_id": "productId",
    "recurring_interval": "recurringInterval",
    "recurring_interval_count": "recurringIntervalCount"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionuncanceledevent.js
var SubscriptionUncanceledEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  source: literal("system"),
  name: literal("subscription.uncanceled"),
  metadata: SubscriptionUncanceledMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/systemevent.js
var SystemEvent$inboundSchema = union([
  BalanceCreditOrderEvent$inboundSchema,
  BalanceDisputeEvent$inboundSchema,
  BalanceDisputeReversalEvent$inboundSchema,
  BalanceOrderEvent$inboundSchema,
  BalanceRefundEvent$inboundSchema,
  BalanceRefundReversalEvent$inboundSchema,
  BenefitCycledEvent$inboundSchema,
  BenefitGrantedEvent$inboundSchema,
  BenefitRevokedEvent$inboundSchema,
  BenefitUpdatedEvent$inboundSchema,
  CheckoutCreatedEvent$inboundSchema,
  CustomerCreatedEvent$inboundSchema,
  CustomerDeletedEvent$inboundSchema,
  CustomerUpdatedEvent$inboundSchema,
  MeterCreditEvent$inboundSchema,
  MeterResetEvent$inboundSchema,
  OrderPaidEvent$inboundSchema,
  OrderRefundedEvent$inboundSchema,
  SubscriptionBillingPeriodUpdatedEvent$inboundSchema,
  SubscriptionCanceledEvent$inboundSchema,
  SubscriptionCreatedEvent$inboundSchema,
  SubscriptionCycledEvent$inboundSchema,
  SubscriptionProductUpdatedEvent$inboundSchema,
  SubscriptionRevokedEvent$inboundSchema,
  SubscriptionSeatsUpdatedEvent$inboundSchema,
  SubscriptionUncanceledEvent$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/costmetadataoutput.js
var CostMetadataOutput$inboundSchema = object({
  amount: string2(),
  currency: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/llmmetadata.js
var LLMMetadata$inboundSchema = pipe(object({
  vendor: string2(),
  model: string2(),
  prompt: optional(nullable(string2())),
  response: optional(nullable(string2())),
  input_tokens: int(),
  cached_input_tokens: optional(int()),
  output_tokens: int(),
  total_tokens: int()
}), transform((v2) => {
  return remap(v2, {
    "input_tokens": "inputTokens",
    "cached_input_tokens": "cachedInputTokens",
    "output_tokens": "outputTokens",
    "total_tokens": "totalTokens"
  });
}));
var LLMMetadata$outboundSchema = pipe(object({
  vendor: string2(),
  model: string2(),
  prompt: optional(nullable(string2())),
  response: optional(nullable(string2())),
  inputTokens: int(),
  cachedInputTokens: optional(int()),
  outputTokens: int(),
  totalTokens: int()
}), transform((v2) => {
  return remap(v2, {
    inputTokens: "input_tokens",
    cachedInputTokens: "cached_input_tokens",
    outputTokens: "output_tokens",
    totalTokens: "total_tokens"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventmetadataoutput.js
var EventMetadataOutput$inboundSchema = smartUnion([
  LLMMetadata$inboundSchema,
  CostMetadataOutput$inboundSchema,
  string2(),
  int(),
  number2(),
  boolean2()
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/userevent.js
var UserEvent$inboundSchema = pipe(object({
  id: string2(),
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  organization_id: string2(),
  customer_id: nullable(string2()),
  customer: nullable(Customer$inboundSchema),
  external_customer_id: nullable(string2()),
  child_count: _default2(int(), 0),
  parent_id: optional(nullable(string2())),
  label: string2(),
  name: string2(),
  source: literal("user"),
  metadata: record(string2(), EventMetadataOutput$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "customer_id": "customerId",
    "external_customer_id": "externalCustomerId",
    "child_count": "childCount",
    "parent_id": "parentId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/event.js
var Event$inboundSchema = smartUnion([
  UserEvent$inboundSchema,
  SystemEvent$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/eventsget.js
var EventsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/eventsGet.js
function eventsGet(client, request, options) {
  return new APIPromise($do90(client, request, options));
}
async function $do90(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(EventsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/events/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "events:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Event$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/costmetadatainput.js
var Amount$outboundSchema = smartUnion([number2(), string2()]);
var CostMetadataInput$outboundSchema = object({
  amount: smartUnion([number2(), string2()]),
  currency: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventmetadatainput.js
var EventMetadataInput$outboundSchema = smartUnion([
  LLMMetadata$outboundSchema,
  CostMetadataInput$outboundSchema,
  string2(),
  int(),
  number2(),
  boolean2()
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventcreatecustomer.js
var EventCreateCustomer$outboundSchema = pipe(object({
  timestamp: optional(pipe(date2(), transform((v2) => v2.toISOString()))),
  name: string2(),
  organizationId: optional(nullable(string2())),
  externalId: optional(nullable(string2())),
  parentId: optional(nullable(string2())),
  metadata: optional(record(string2(), EventMetadataInput$outboundSchema)),
  customerId: string2()
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    externalId: "external_id",
    parentId: "parent_id",
    customerId: "customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventcreateexternalcustomer.js
var EventCreateExternalCustomer$outboundSchema = pipe(object({
  timestamp: optional(pipe(date2(), transform((v2) => v2.toISOString()))),
  name: string2(),
  organizationId: optional(nullable(string2())),
  externalId: optional(nullable(string2())),
  parentId: optional(nullable(string2())),
  metadata: optional(record(string2(), EventMetadataInput$outboundSchema)),
  externalCustomerId: string2()
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    externalId: "external_id",
    parentId: "parent_id",
    externalCustomerId: "external_customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventsingest.js
var Events$outboundSchema = smartUnion([
  EventCreateCustomer$outboundSchema,
  EventCreateExternalCustomer$outboundSchema
]);
var EventsIngest$outboundSchema = object({
  events: array(smartUnion([
    EventCreateCustomer$outboundSchema,
    EventCreateExternalCustomer$outboundSchema
  ]))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventsingestresponse.js
var EventsIngestResponse$inboundSchema = object({
  inserted: int(),
  duplicates: _default2(int(), 0)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/eventsIngest.js
function eventsIngest(client, request, options) {
  return new APIPromise($do91(client, request, options));
}
async function $do91(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(EventsIngest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/events/ingest")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "events:ingest",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, EventsIngestResponse$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventsortproperty.js
var EventSortProperty = {
  Timestamp: "timestamp",
  MinusTimestamp: "-timestamp"
};
var EventSortProperty$outboundSchema = _enum2(EventSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventsource.js
var EventSource = {
  System: "system",
  User: "user"
};
var EventSource$inboundSchema = _enum2(EventSource);
var EventSource$outboundSchema = EventSource$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceevent.js
var ListResourceEvent$inboundSchema = object({
  items: array(Event$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/cursorpagination.js
var CursorPagination$inboundSchema = pipe(object({
  has_next_page: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "has_next_page": "hasNextPage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcewithcursorpaginationevent.js
var ListResourceWithCursorPaginationEvent$inboundSchema = object({
  items: array(Event$inboundSchema),
  pagination: CursorPagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/eventslist.js
var EventsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventsListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventsListQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var NameFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var SourceFilter$outboundSchema = smartUnion([
  EventSource$outboundSchema,
  array(EventSource$outboundSchema)
]);
var EventsListRequest$outboundSchema = pipe(object({
  filter: optional(nullable(string2())),
  startTimestamp: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endTimestamp: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  meterId: optional(nullable(string2())),
  name: optional(nullable(smartUnion([string2(), array(string2())]))),
  source: optional(nullable(smartUnion([
    EventSource$outboundSchema,
    array(EventSource$outboundSchema)
  ]))),
  query: optional(nullable(string2())),
  parentId: optional(nullable(string2())),
  depth: optional(nullable(int())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(EventSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    startTimestamp: "start_timestamp",
    endTimestamp: "end_timestamp",
    organizationId: "organization_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    meterId: "meter_id",
    parentId: "parent_id"
  });
}));
var EventsListResponseEventsList$inboundSchema = smartUnion([
  ListResourceEvent$inboundSchema,
  ListResourceWithCursorPaginationEvent$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/eventsList.js
function eventsList(client, request, options) {
  return new APIPromise($do92(client, request, options));
}
async function $do92(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(EventsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/events/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "customer_id": payload.customer_id,
    "depth": payload.depth,
    "end_timestamp": payload.end_timestamp,
    "external_customer_id": payload.external_customer_id,
    "filter": payload.filter,
    "limit": payload.limit,
    "meter_id": payload.meter_id,
    "name": payload.name,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "parent_id": payload.parent_id,
    "query": payload.query,
    "sorting": payload.sorting,
    "source": payload.source,
    "start_timestamp": payload.start_timestamp
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "events:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, EventsListResponseEventsList$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventnamessortproperty.js
var EventNamesSortProperty = {
  Name: "name",
  MinusName: "-name",
  Occurrences: "occurrences",
  MinusOccurrences: "-occurrences",
  FirstSeen: "first_seen",
  MinusFirstSeen: "-first_seen",
  LastSeen: "last_seen",
  MinusLastSeen: "-last_seen"
};
var EventNamesSortProperty$outboundSchema = _enum2(EventNamesSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventname.js
var EventName$inboundSchema = pipe(object({
  name: string2(),
  source: EventSource$inboundSchema,
  occurrences: int(),
  first_seen: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  last_seen: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
}), transform((v2) => {
  return remap(v2, {
    "first_seen": "firstSeen",
    "last_seen": "lastSeen"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceeventname.js
var ListResourceEventName$inboundSchema = object({
  items: array(EventName$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/eventslistnames.js
var EventsListNamesQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventsListNamesQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventsListNamesQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamSourceFilter$outboundSchema = smartUnion([
  EventSource$outboundSchema,
  array(EventSource$outboundSchema)
]);
var EventsListNamesRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  source: optional(nullable(smartUnion([
    EventSource$outboundSchema,
    array(EventSource$outboundSchema)
  ]))),
  query: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(EventNamesSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id"
  });
}));
var EventsListNamesResponse$inboundSchema = pipe(object({
  Result: ListResourceEventName$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/eventsListNames.js
function eventsListNames(client, request, options) {
  return new APIPromise($do93(client, request, options));
}
async function $do93(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(EventsListNamesRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/events/names")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting,
    "source": payload.source
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "events:list_names",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, EventsListNamesResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => eventsListNames(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/events.js
var Events = class extends ClientSDK {
  /**
   * List Events
   *
   * @remarks
   * List events.
   *
   * **Scopes**: `events:read` `events:write`
   */
  async list(request, options) {
    return unwrapAsync(eventsList(this, request, options));
  }
  /**
   * List Event Names
   *
   * @remarks
   * List event names.
   *
   * **Scopes**: `events:read` `events:write`
   */
  async listNames(request, options) {
    return unwrapResultIterator(eventsListNames(this, request, options));
  }
  /**
   * Get Event
   *
   * @remarks
   * Get an event by ID.
   *
   * **Scopes**: `events:read` `events:write`
   */
  async get(request, options) {
    return unwrapAsync(eventsGet(this, request, options));
  }
  /**
   * Ingest Events
   *
   * @remarks
   * Ingest batch of events.
   *
   * **Scopes**: `events:write`
   */
  async ingest(request, options) {
    return unwrapAsync(eventsIngest(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventtypessortproperty.js
var EventTypesSortProperty = {
  Name: "name",
  MinusName: "-name",
  Label: "label",
  MinusLabel: "-label",
  Occurrences: "occurrences",
  MinusOccurrences: "-occurrences",
  FirstSeen: "first_seen",
  MinusFirstSeen: "-first_seen",
  LastSeen: "last_seen",
  MinusLastSeen: "-last_seen"
};
var EventTypesSortProperty$outboundSchema = _enum2(EventTypesSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventtypewithstats.js
var EventTypeWithStats$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  label: string2(),
  label_property_selector: optional(nullable(string2())),
  organization_id: string2(),
  source: EventSource$inboundSchema,
  occurrences: int(),
  first_seen: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  last_seen: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "label_property_selector": "labelPropertySelector",
    "organization_id": "organizationId",
    "first_seen": "firstSeen",
    "last_seen": "lastSeen"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceeventtypewithstats.js
var ListResourceEventTypeWithStats$inboundSchema = object({
  items: array(EventTypeWithStats$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/eventtypeslist.js
var EventTypesListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventTypesListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventTypesListQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var EventTypesListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  rootEvents: _default2(boolean2(), false),
  parentId: optional(nullable(string2())),
  source: optional(nullable(EventSource$outboundSchema)),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(EventTypesSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    rootEvents: "root_events",
    parentId: "parent_id"
  });
}));
var EventTypesListResponse$inboundSchema = pipe(object({
  Result: ListResourceEventTypeWithStats$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/eventTypesList.js
function eventTypesList(client, request, options) {
  return new APIPromise($do94(client, request, options));
}
async function $do94(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(EventTypesListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/event-types/")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "parent_id": payload.parent_id,
    "query": payload.query,
    "root_events": payload.root_events,
    "sorting": payload.sorting,
    "source": payload.source
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "event-types:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, EventTypesListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => eventTypesList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventtype.js
var EventType$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  name: string2(),
  label: string2(),
  label_property_selector: optional(nullable(string2())),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "label_property_selector": "labelPropertySelector",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/eventtypeupdate.js
var EventTypeUpdate$outboundSchema = pipe(object({
  label: string2(),
  labelPropertySelector: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    labelPropertySelector: "label_property_selector"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/eventtypesupdate.js
var EventTypesUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  eventTypeUpdate: EventTypeUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    eventTypeUpdate: "EventTypeUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/eventTypesUpdate.js
function eventTypesUpdate(client, request, options) {
  return new APIPromise($do95(client, request, options));
}
async function $do95(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(EventTypesUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.EventTypeUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/event-types/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "event-types:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, EventType$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([404, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/eventtypes.js
var EventTypes = class extends ClientSDK {
  /**
   * List Event Types
   *
   * @remarks
   * List event types with aggregated statistics.
   *
   * **Scopes**: `events:read` `events:write`
   */
  async list(request, options) {
    return unwrapResultIterator(eventTypesList(this, request, options));
  }
  /**
   * Update Event Type
   *
   * @remarks
   * Update an event type's label.
   */
  async update(request, options) {
    return unwrapAsync(eventTypesUpdate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/s3filecreatepart.js
var S3FileCreatePart$outboundSchema = pipe(object({
  number: int(),
  chunkStart: int(),
  chunkEnd: int(),
  checksumSha256Base64: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    chunkStart: "chunk_start",
    chunkEnd: "chunk_end",
    checksumSha256Base64: "checksum_sha256_base64"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/s3filecreatemultipart.js
var S3FileCreateMultipart$outboundSchema = object({
  parts: array(S3FileCreatePart$outboundSchema)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/downloadablefilecreate.js
var DownloadableFileCreate$outboundSchema = pipe(object({
  organizationId: optional(nullable(string2())),
  name: string2(),
  mimeType: string2(),
  size: int(),
  checksumSha256Base64: optional(nullable(string2())),
  upload: S3FileCreateMultipart$outboundSchema,
  service: literal("downloadable"),
  version: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    mimeType: "mime_type",
    checksumSha256Base64: "checksum_sha256_base64"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationavatarfilecreate.js
var OrganizationAvatarFileCreate$outboundSchema = pipe(object({
  organizationId: optional(nullable(string2())),
  name: string2(),
  mimeType: string2(),
  size: int(),
  checksumSha256Base64: optional(nullable(string2())),
  upload: S3FileCreateMultipart$outboundSchema,
  service: literal("organization_avatar"),
  version: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    mimeType: "mime_type",
    checksumSha256Base64: "checksum_sha256_base64"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productmediafilecreate.js
var ProductMediaFileCreate$outboundSchema = pipe(object({
  organizationId: optional(nullable(string2())),
  name: string2(),
  mimeType: string2(),
  size: int(),
  checksumSha256Base64: optional(nullable(string2())),
  upload: S3FileCreateMultipart$outboundSchema,
  service: literal("product_media"),
  version: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    mimeType: "mime_type",
    checksumSha256Base64: "checksum_sha256_base64"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filecreate.js
var FileCreate$outboundSchema = union([
  DownloadableFileCreate$outboundSchema,
  OrganizationAvatarFileCreate$outboundSchema,
  ProductMediaFileCreate$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/s3fileuploadpart.js
var S3FileUploadPart$inboundSchema = pipe(object({
  number: int(),
  chunk_start: int(),
  chunk_end: int(),
  checksum_sha256_base64: optional(nullable(string2())),
  url: string2(),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  headers: optional(record(string2(), string2()))
}), transform((v2) => {
  return remap(v2, {
    "chunk_start": "chunkStart",
    "chunk_end": "chunkEnd",
    "checksum_sha256_base64": "checksumSha256Base64",
    "expires_at": "expiresAt"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/s3fileuploadmultipart.js
var S3FileUploadMultipart$inboundSchema = object({
  id: string2(),
  path: string2(),
  parts: array(S3FileUploadPart$inboundSchema)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/fileupload.js
var FileUpload$inboundSchema = pipe(object({
  id: string2(),
  organization_id: string2(),
  name: string2(),
  path: string2(),
  mime_type: string2(),
  size: int(),
  storage_version: nullable(string2()),
  checksum_etag: nullable(string2()),
  checksum_sha256_base64: nullable(string2()),
  checksum_sha256_hex: nullable(string2()),
  last_modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  upload: S3FileUploadMultipart$inboundSchema,
  version: nullable(string2()),
  is_uploaded: _default2(boolean2(), false),
  service: FileServiceTypes$inboundSchema,
  size_readable: string2()
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "mime_type": "mimeType",
    "storage_version": "storageVersion",
    "checksum_etag": "checksumEtag",
    "checksum_sha256_base64": "checksumSha256Base64",
    "checksum_sha256_hex": "checksumSha256Hex",
    "last_modified_at": "lastModifiedAt",
    "is_uploaded": "isUploaded",
    "size_readable": "sizeReadable"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/filesCreate.js
function filesCreate(client, request, options) {
  return new APIPromise($do96(client, request, options));
}
async function $do96(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(FileCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/files/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "files:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, FileUpload$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/filesdelete.js
var FilesDeleteRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/filesDelete.js
function filesDelete(client, request, options) {
  return new APIPromise($do97(client, request, options));
}
async function $do97(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(FilesDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/files/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "files:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/downloadablefileread.js
var DownloadableFileRead$inboundSchema = pipe(object({
  id: string2(),
  organization_id: string2(),
  name: string2(),
  path: string2(),
  mime_type: string2(),
  size: int(),
  storage_version: nullable(string2()),
  checksum_etag: nullable(string2()),
  checksum_sha256_base64: nullable(string2()),
  checksum_sha256_hex: nullable(string2()),
  last_modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  version: nullable(string2()),
  service: literal("downloadable"),
  is_uploaded: boolean2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  size_readable: string2()
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "mime_type": "mimeType",
    "storage_version": "storageVersion",
    "checksum_etag": "checksumEtag",
    "checksum_sha256_base64": "checksumSha256Base64",
    "checksum_sha256_hex": "checksumSha256Hex",
    "last_modified_at": "lastModifiedAt",
    "is_uploaded": "isUploaded",
    "created_at": "createdAt",
    "size_readable": "sizeReadable"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationavatarfileread.js
var OrganizationAvatarFileRead$inboundSchema = pipe(object({
  id: string2(),
  organization_id: string2(),
  name: string2(),
  path: string2(),
  mime_type: string2(),
  size: int(),
  storage_version: nullable(string2()),
  checksum_etag: nullable(string2()),
  checksum_sha256_base64: nullable(string2()),
  checksum_sha256_hex: nullable(string2()),
  last_modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  version: nullable(string2()),
  service: literal("organization_avatar"),
  is_uploaded: boolean2(),
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  size_readable: string2(),
  public_url: string2()
}), transform((v2) => {
  return remap(v2, {
    "organization_id": "organizationId",
    "mime_type": "mimeType",
    "storage_version": "storageVersion",
    "checksum_etag": "checksumEtag",
    "checksum_sha256_base64": "checksumSha256Base64",
    "checksum_sha256_hex": "checksumSha256Hex",
    "last_modified_at": "lastModifiedAt",
    "is_uploaded": "isUploaded",
    "created_at": "createdAt",
    "size_readable": "sizeReadable",
    "public_url": "publicUrl"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcefileread.js
var FileRead$inboundSchema = union([
  DownloadableFileRead$inboundSchema,
  OrganizationAvatarFileRead$inboundSchema,
  ProductMediaFileRead$inboundSchema
]);
var ListResourceFileRead$inboundSchema = object({
  items: array(union([
    DownloadableFileRead$inboundSchema,
    OrganizationAvatarFileRead$inboundSchema,
    ProductMediaFileRead$inboundSchema
  ])),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/fileslist.js
var FilesListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var FileIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var FilesListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  ids: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));
var FilesListResponse$inboundSchema = pipe(object({
  Result: ListResourceFileRead$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/filesList.js
function filesList(client, request, options) {
  return new APIPromise($do98(client, request, options));
}
async function $do98(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(FilesListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/files/")();
  const query = encodeFormQuery({
    "ids": payload.ids,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "files:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, FilesListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => filesList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/filepatch.js
var FilePatch$outboundSchema = object({
  name: optional(nullable(string2())),
  version: optional(nullable(string2()))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/filesupdate.js
var FilesUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  filePatch: FilePatch$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    filePatch: "FilePatch"
  });
}));
var FilesUpdateResponseFilesUpdate$inboundSchema = union([
  DownloadableFileRead$inboundSchema,
  ProductMediaFileRead$inboundSchema,
  OrganizationAvatarFileRead$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/filesUpdate.js
function filesUpdate(client, request, options) {
  return new APIPromise($do99(client, request, options));
}
async function $do99(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(FilesUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.FilePatch, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/files/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "files:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, FilesUpdateResponseFilesUpdate$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/s3fileuploadcompletedpart.js
var S3FileUploadCompletedPart$outboundSchema = pipe(object({
  number: int(),
  checksumEtag: string2(),
  checksumSha256Base64: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    checksumEtag: "checksum_etag",
    checksumSha256Base64: "checksum_sha256_base64"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/fileuploadcompleted.js
var FileUploadCompleted$outboundSchema = object({
  id: string2(),
  path: string2(),
  parts: array(S3FileUploadCompletedPart$outboundSchema)
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/filesuploaded.js
var FilesUploadedRequest$outboundSchema = pipe(object({
  id: string2(),
  fileUploadCompleted: FileUploadCompleted$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    fileUploadCompleted: "FileUploadCompleted"
  });
}));
var FilesUploadedResponseFilesUploaded$inboundSchema = union([
  DownloadableFileRead$inboundSchema,
  ProductMediaFileRead$inboundSchema,
  OrganizationAvatarFileRead$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/filesUploaded.js
function filesUploaded(client, request, options) {
  return new APIPromise($do100(client, request, options));
}
async function $do100(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(FilesUploadedRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.FileUploadCompleted, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/files/{id}/uploaded")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "files:uploaded",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, FilesUploadedResponseFilesUploaded$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/files.js
var Files = class extends ClientSDK {
  /**
   * List Files
   *
   * @remarks
   * List files.
   *
   * **Scopes**: `files:read` `files:write`
   */
  async list(request, options) {
    return unwrapResultIterator(filesList(this, request, options));
  }
  /**
   * Create File
   *
   * @remarks
   * Create a file.
   *
   * **Scopes**: `files:write`
   */
  async create(request, options) {
    return unwrapAsync(filesCreate(this, request, options));
  }
  /**
   * Complete File Upload
   *
   * @remarks
   * Complete a file upload.
   *
   * **Scopes**: `files:write`
   */
  async uploaded(request, options) {
    return unwrapAsync(filesUploaded(this, request, options));
  }
  /**
   * Update File
   *
   * @remarks
   * Update a file.
   *
   * **Scopes**: `files:write`
   */
  async update(request, options) {
    return unwrapAsync(filesUpdate(this, request, options));
  }
  /**
   * Delete File
   *
   * @remarks
   * Delete a file.
   *
   * **Scopes**: `files:write`
   */
  async delete(request, options) {
    return unwrapAsync(filesDelete(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysActivate.js
function licenseKeysActivate(client, request, options) {
  return new APIPromise($do101(client, request, options));
}
async function $do101(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeyActivate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/license-keys/activate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:activate",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, LicenseKeyActivationRead$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysDeactivate.js
function licenseKeysDeactivate(client, request, options) {
  return new APIPromise($do102(client, request, options));
}
async function $do102(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeyDeactivate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/license-keys/deactivate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:deactivate",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/licensekeysget.js
var LicenseKeysGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysGet.js
function licenseKeysGet(client, request, options) {
  return new APIPromise($do103(client, request, options));
}
async function $do103(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeysGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/license-keys/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, LicenseKeyWithActivations$inboundSchema), jsonErr(401, Unauthorized$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/licensekeysgetactivation.js
var LicenseKeysGetActivationRequest$outboundSchema = pipe(object({
  id: string2(),
  activationId: string2()
}), transform((v2) => {
  return remap(v2, {
    activationId: "activation_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysGetActivation.js
function licenseKeysGetActivation(client, request, options) {
  return new APIPromise($do104(client, request, options));
}
async function $do104(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeysGetActivationRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    activation_id: encodeSimple("activation_id", payload.activation_id, {
      explode: false,
      charEncoding: "percent"
    }),
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/license-keys/{id}/activations/{activation_id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:get_activation",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, LicenseKeyActivationRead$inboundSchema), jsonErr(401, Unauthorized$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/licensekeyslist.js
var LicenseKeysListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamBenefitIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var LicenseKeysListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  benefitId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    benefitId: "benefit_id"
  });
}));
var LicenseKeysListResponse$inboundSchema = pipe(object({
  Result: ListResourceLicenseKeyRead$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysList.js
function licenseKeysList(client, request, options) {
  return new APIPromise($do105(client, request, options));
}
async function $do105(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeysListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/license-keys/")();
  const query = encodeFormQuery({
    "benefit_id": payload.benefit_id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, LicenseKeysListResponse$inboundSchema, { key: "Result" }), jsonErr(401, Unauthorized$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => licenseKeysList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/licensekeyupdate.js
var LicenseKeyUpdate$outboundSchema = pipe(object({
  status: optional(nullable(LicenseKeyStatus$outboundSchema)),
  usage: _default2(int(), 0),
  limitActivations: optional(nullable(int())),
  limitUsage: optional(nullable(int())),
  expiresAt: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString()))))
}), transform((v2) => {
  return remap(v2, {
    limitActivations: "limit_activations",
    limitUsage: "limit_usage",
    expiresAt: "expires_at"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/licensekeysupdate.js
var LicenseKeysUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  licenseKeyUpdate: LicenseKeyUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    licenseKeyUpdate: "LicenseKeyUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysUpdate.js
function licenseKeysUpdate(client, request, options) {
  return new APIPromise($do106(client, request, options));
}
async function $do106(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeysUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.LicenseKeyUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/license-keys/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, LicenseKeyRead$inboundSchema), jsonErr(401, Unauthorized$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/licenseKeysValidate.js
function licenseKeysValidate(client, request, options) {
  return new APIPromise($do107(client, request, options));
}
async function $do107(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(LicenseKeyValidate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/license-keys/validate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "license_keys:validate",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, ValidatedLicenseKey$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/licensekeys.js
var LicenseKeys = class extends ClientSDK {
  /**
   * List License Keys
   *
   * @remarks
   * Get license keys connected to the given organization & filters.
   *
   * **Scopes**: `license_keys:read` `license_keys:write`
   */
  async list(request, options) {
    return unwrapResultIterator(licenseKeysList(this, request, options));
  }
  /**
   * Get License Key
   *
   * @remarks
   * Get a license key.
   *
   * **Scopes**: `license_keys:read` `license_keys:write`
   */
  async get(request, options) {
    return unwrapAsync(licenseKeysGet(this, request, options));
  }
  /**
   * Update License Key
   *
   * @remarks
   * Update a license key.
   *
   * **Scopes**: `license_keys:write`
   */
  async update(request, options) {
    return unwrapAsync(licenseKeysUpdate(this, request, options));
  }
  /**
   * Get Activation
   *
   * @remarks
   * Get a license key activation.
   *
   * **Scopes**: `license_keys:read` `license_keys:write`
   */
  async getActivation(request, options) {
    return unwrapAsync(licenseKeysGetActivation(this, request, options));
  }
  /**
   * Validate License Key
   *
   * @remarks
   * Validate a license key.
   *
   * **Scopes**: `license_keys:write`
   */
  async validate(request, options) {
    return unwrapAsync(licenseKeysValidate(this, request, options));
  }
  /**
   * Activate License Key
   *
   * @remarks
   * Activate a license key instance.
   *
   * **Scopes**: `license_keys:write`
   */
  async activate(request, options) {
    return unwrapAsync(licenseKeysActivate(this, request, options));
  }
  /**
   * Deactivate License Key
   *
   * @remarks
   * Deactivate a license key instance.
   *
   * **Scopes**: `license_keys:write`
   */
  async deactivate(request, options) {
    return unwrapAsync(licenseKeysDeactivate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/membercreate.js
var MemberCreate$outboundSchema = pipe(object({
  customerId: string2(),
  email: string2(),
  name: optional(nullable(string2())),
  externalId: optional(nullable(string2())),
  role: optional(MemberRole$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    customerId: "customer_id",
    externalId: "external_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/membersCreateMember.js
function membersCreateMember(client, request, options) {
  return new APIPromise($do108(client, request, options));
}
async function $do108(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MemberCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/members/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "members:create_member",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Member$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail([403, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/membersdeletemember.js
var MembersDeleteMemberRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/membersDeleteMember.js
function membersDeleteMember(client, request, options) {
  return new APIPromise($do109(client, request, options));
}
async function $do109(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MembersDeleteMemberRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/members/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "members:delete_member",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/membersgetmember.js
var MembersGetMemberRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/membersGetMember.js
function membersGetMember(client, request, options) {
  return new APIPromise($do110(client, request, options));
}
async function $do110(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MembersGetMemberRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/members/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "members:get_member",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Member$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcemember.js
var ListResourceMember$inboundSchema = object({
  items: array(Member$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/membersortproperty.js
var MemberSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at"
};
var MemberSortProperty$outboundSchema = _enum2(MemberSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/memberslistmembers.js
var MembersListMembersRequest$outboundSchema = pipe(object({
  customerId: optional(nullable(string2())),
  externalCustomerId: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(MemberSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    customerId: "customer_id",
    externalCustomerId: "external_customer_id"
  });
}));
var MembersListMembersResponse$inboundSchema = pipe(object({
  Result: ListResourceMember$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/membersListMembers.js
function membersListMembers(client, request, options) {
  return new APIPromise($do111(client, request, options));
}
async function $do111(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MembersListMembersRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/members/")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "page": payload.page,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "members:list_members",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, MembersListMembersResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => membersListMembers(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/memberupdate.js
var MemberUpdate$outboundSchema = object({
  name: optional(nullable(string2())),
  role: optional(nullable(MemberRole$outboundSchema))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/membersupdatemember.js
var MembersUpdateMemberRequest$outboundSchema = pipe(object({
  id: string2(),
  memberUpdate: MemberUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    memberUpdate: "MemberUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/membersUpdateMember.js
function membersUpdateMember(client, request, options) {
  return new APIPromise($do112(client, request, options));
}
async function $do112(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MembersUpdateMemberRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.MemberUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/members/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "members:update_member",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Member$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/members.js
var Members = class extends ClientSDK {
  /**
   * List Members
   *
   * @remarks
   * List members with optional customer ID filter.
   *
   * **Scopes**: `members:read` `members:write`
   */
  async listMembers(request, options) {
    return unwrapResultIterator(membersListMembers(this, request, options));
  }
  /**
   * Create Member
   *
   * @remarks
   * Create a new member for a customer.
   *
   * Only B2B customers with the member management feature enabled can add members.
   * The authenticated user or organization must have access to the customer's organization.
   *
   * **Scopes**: `members:write`
   */
  async createMember(request, options) {
    return unwrapAsync(membersCreateMember(this, request, options));
  }
  /**
   * Get Member
   *
   * @remarks
   * Get a member by ID.
   *
   * The authenticated user or organization must have access to the member's organization.
   *
   * **Scopes**: `members:read` `members:write`
   */
  async getMember(request, options) {
    return unwrapAsync(membersGetMember(this, request, options));
  }
  /**
   * Update Member
   *
   * @remarks
   * Update a member.
   *
   * Only name and role can be updated.
   * The authenticated user or organization must have access to the member's organization.
   *
   * **Scopes**: `members:write`
   */
  async updateMember(request, options) {
    return unwrapAsync(membersUpdateMember(this, request, options));
  }
  /**
   * Delete Member
   *
   * @remarks
   * Delete a member.
   *
   * The authenticated user or organization must have access to the member's organization.
   *
   * **Scopes**: `members:write`
   */
  async deleteMember(request, options) {
    return unwrapAsync(membersDeleteMember(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/membersession.js
var MemberSession$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  token: string2(),
  expires_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  return_url: nullable(string2()),
  member_portal_url: string2(),
  member_id: string2(),
  member: Member$inboundSchema,
  customer_id: string2(),
  customer: Customer$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "expires_at": "expiresAt",
    "return_url": "returnUrl",
    "member_portal_url": "memberPortalUrl",
    "member_id": "memberId",
    "customer_id": "customerId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/membersessioncreate.js
var MemberSessionCreate$outboundSchema = pipe(object({
  memberId: string2(),
  returnUrl: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    memberId: "member_id",
    returnUrl: "return_url"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/memberSessionsCreate.js
function memberSessionsCreate(client, request, options) {
  return new APIPromise($do113(client, request, options));
}
async function $do113(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MemberSessionCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/member-sessions/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "member-sessions:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, MemberSession$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/membersessions.js
var MemberSessions = class extends ClientSDK {
  /**
   * Create Member Session
   *
   * @remarks
   * Create a member session.
   *
   * This endpoint is only available for organizations with `member_model_enabled`
   * and `seat_based_pricing_enabled` feature flags enabled.
   *
   * **Scopes**: `member_sessions:write`
   */
  async create(request, options) {
    return unwrapAsync(memberSessionsCreate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metercreate.js
var MeterCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var MeterCreateAggregation$outboundSchema = union([
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("avg") })),
  CountAggregation$outboundSchema,
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("max") })),
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("min") })),
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("sum") })),
  UniqueAggregation$outboundSchema
]);
var MeterCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  filter: Filter$outboundSchema,
  aggregation: union([
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("avg") })),
    CountAggregation$outboundSchema,
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("max") })),
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("min") })),
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("sum") })),
    UniqueAggregation$outboundSchema
  ]),
  organizationId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metersCreate.js
function metersCreate(client, request, options) {
  return new APIPromise($do114(client, request, options));
}
async function $do114(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MeterCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/meters/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "meters:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Meter$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/metersget.js
var MetersGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metersGet.js
function metersGet(client, request, options) {
  return new APIPromise($do115(client, request, options));
}
async function $do115(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MetersGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/meters/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "meters:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Meter$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcemeter.js
var ListResourceMeter$inboundSchema = object({
  items: array(Meter$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metersortproperty.js
var MeterSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Name: "name",
  MinusName: "-name"
};
var MeterSortProperty$outboundSchema = _enum2(MeterSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/meterslist.js
var MetersListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var MetersListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  isArchived: optional(nullable(boolean2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(MeterSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    isArchived: "is_archived"
  });
}));
var MetersListResponse$inboundSchema = pipe(object({
  Result: ListResourceMeter$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metersList.js
function metersList(client, request, options) {
  return new APIPromise($do116(client, request, options));
}
async function $do116(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MetersListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/meters/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "is_archived": payload.is_archived,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "meters:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, MetersListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => metersList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/meterquantity.js
var MeterQuantity$inboundSchema = object({
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  quantity: number2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/meterquantities.js
var MeterQuantities$inboundSchema = object({
  quantities: array(MeterQuantity$inboundSchema),
  total: number2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/aggregationfunction.js
var AggregationFunction = {
  Count: "count",
  Sum: "sum",
  Max: "max",
  Min: "min",
  Avg: "avg",
  Unique: "unique"
};
var AggregationFunction$outboundSchema = _enum2(AggregationFunction);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/timeinterval.js
var TimeInterval = {
  Year: "year",
  Month: "month",
  Week: "week",
  Day: "day",
  Hour: "hour"
};
var TimeInterval$outboundSchema = _enum2(TimeInterval);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/metersquantities.js
var MetersQuantitiesQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var MetersQuantitiesQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var MetersQuantitiesRequest$outboundSchema = pipe(object({
  id: string2(),
  startTimestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  endTimestamp: pipe(date2(), transform((v2) => v2.toISOString())),
  interval: TimeInterval$outboundSchema,
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerAggregationFunction: optional(nullable(AggregationFunction$outboundSchema)),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    startTimestamp: "start_timestamp",
    endTimestamp: "end_timestamp",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    customerAggregationFunction: "customer_aggregation_function"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metersQuantities.js
function metersQuantities(client, request, options) {
  return new APIPromise($do117(client, request, options));
}
async function $do117(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MetersQuantitiesRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/meters/{id}/quantities")(pathParams);
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "customer_aggregation_function": payload.customer_aggregation_function,
    "customer_id": payload.customer_id,
    "end_timestamp": payload.end_timestamp,
    "external_customer_id": payload.external_customer_id,
    "interval": payload.interval,
    "start_timestamp": payload.start_timestamp
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "meters:quantities",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, MeterQuantities$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/meterupdate.js
var MeterUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var Aggregation$outboundSchema = union([
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("avg") })),
  CountAggregation$outboundSchema,
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("max") })),
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("min") })),
  intersection(PropertyAggregation$outboundSchema, object({ func: literal("sum") })),
  UniqueAggregation$outboundSchema
]);
var MeterUpdate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: optional(nullable(string2())),
  filter: optional(nullable(Filter$outboundSchema)),
  aggregation: optional(nullable(union([
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("avg") })),
    CountAggregation$outboundSchema,
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("max") })),
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("min") })),
    intersection(PropertyAggregation$outboundSchema, object({ func: literal("sum") })),
    UniqueAggregation$outboundSchema
  ]))),
  isArchived: optional(nullable(boolean2()))
}), transform((v2) => {
  return remap(v2, {
    isArchived: "is_archived"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/metersupdate.js
var MetersUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  meterUpdate: MeterUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    meterUpdate: "MeterUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metersUpdate.js
function metersUpdate(client, request, options) {
  return new APIPromise($do118(client, request, options));
}
async function $do118(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MetersUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.MeterUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/meters/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "meters:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Meter$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/meters.js
var Meters = class extends ClientSDK {
  /**
   * List Meters
   *
   * @remarks
   * List meters.
   *
   * **Scopes**: `meters:read` `meters:write`
   */
  async list(request, options) {
    return unwrapResultIterator(metersList(this, request, options));
  }
  /**
   * Create Meter
   *
   * @remarks
   * Create a meter.
   *
   * **Scopes**: `meters:write`
   */
  async create(request, options) {
    return unwrapAsync(metersCreate(this, request, options));
  }
  /**
   * Get Meter
   *
   * @remarks
   * Get a meter by ID.
   *
   * **Scopes**: `meters:read` `meters:write`
   */
  async get(request, options) {
    return unwrapAsync(metersGet(this, request, options));
  }
  /**
   * Update Meter
   *
   * @remarks
   * Update a meter.
   *
   * **Scopes**: `meters:write`
   */
  async update(request, options) {
    return unwrapAsync(metersUpdate(this, request, options));
  }
  /**
   * Get Meter Quantities
   *
   * @remarks
   * Get quantities of a meter over a time period.
   *
   * **Scopes**: `meters:read` `meters:write`
   */
  async quantities(request, options) {
    return unwrapAsync(metersQuantities(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metricperiod.js
var Orders$inboundSchema = smartUnion([
  int(),
  number2()
]);
var Revenue$inboundSchema = smartUnion([int(), number2()]);
var NetRevenue$inboundSchema = smartUnion([int(), number2()]);
var CumulativeRevenue$inboundSchema = smartUnion([int(), number2()]);
var NetCumulativeRevenue$inboundSchema = smartUnion([int(), number2()]);
var Costs$inboundSchema = smartUnion([
  int(),
  number2()
]);
var CumulativeCosts$inboundSchema = smartUnion([int(), number2()]);
var AverageOrderValue$inboundSchema = smartUnion([int(), number2()]);
var NetAverageOrderValue$inboundSchema = smartUnion([int(), number2()]);
var AverageRevenuePerUser$inboundSchema = smartUnion([int(), number2()]);
var CostPerUser$inboundSchema = smartUnion([int(), number2()]);
var ActiveUserByEvent$inboundSchema = smartUnion([int(), number2()]);
var OneTimeProducts$inboundSchema = smartUnion([int(), number2()]);
var OneTimeProductsRevenue$inboundSchema = smartUnion([int(), number2()]);
var OneTimeProductsNetRevenue$inboundSchema = smartUnion([int(), number2()]);
var NewSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var NewSubscriptionsRevenue$inboundSchema = smartUnion([int(), number2()]);
var NewSubscriptionsNetRevenue$inboundSchema = smartUnion([int(), number2()]);
var RenewedSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var RenewedSubscriptionsRevenue$inboundSchema = smartUnion([int(), number2()]);
var RenewedSubscriptionsNetRevenue$inboundSchema = smartUnion([int(), number2()]);
var ActiveSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var CommittedSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MonthlyRecurringRevenue$inboundSchema = smartUnion([int(), number2()]);
var CommittedMonthlyRecurringRevenue$inboundSchema = smartUnion([int(), number2()]);
var Checkouts$inboundSchema = smartUnion([int(), number2()]);
var SucceededCheckouts$inboundSchema = smartUnion([int(), number2()]);
var CheckoutsConversion$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsCustomerService$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsLowQuality$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsMissingFeatures$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsSwitchedService$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsTooComplex$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsTooExpensive$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsUnused$inboundSchema = smartUnion([int(), number2()]);
var CanceledSubscriptionsOther$inboundSchema = smartUnion([int(), number2()]);
var ChurnedSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var ChurnRate$inboundSchema = smartUnion([int(), number2()]);
var Ltv$inboundSchema = smartUnion([
  int(),
  number2()
]);
var GrossMargin$inboundSchema = smartUnion([int(), number2()]);
var GrossMarginPercentage$inboundSchema = smartUnion([int(), number2()]);
var Cashflow$inboundSchema = smartUnion([int(), number2()]);
var MetricPeriod$inboundSchema = pipe(object({
  timestamp: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  orders: optional(nullable(smartUnion([int(), number2()]))),
  revenue: optional(nullable(smartUnion([int(), number2()]))),
  net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  cumulative_revenue: optional(nullable(smartUnion([int(), number2()]))),
  net_cumulative_revenue: optional(nullable(smartUnion([int(), number2()]))),
  costs: optional(nullable(smartUnion([int(), number2()]))),
  cumulative_costs: optional(nullable(smartUnion([int(), number2()]))),
  average_order_value: optional(nullable(smartUnion([int(), number2()]))),
  net_average_order_value: optional(nullable(smartUnion([int(), number2()]))),
  average_revenue_per_user: optional(nullable(smartUnion([int(), number2()]))),
  cost_per_user: optional(nullable(smartUnion([int(), number2()]))),
  active_user_by_event: optional(nullable(smartUnion([int(), number2()]))),
  one_time_products: optional(nullable(smartUnion([int(), number2()]))),
  one_time_products_revenue: optional(nullable(smartUnion([int(), number2()]))),
  one_time_products_net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  new_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  new_subscriptions_revenue: optional(nullable(smartUnion([int(), number2()]))),
  new_subscriptions_net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  renewed_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  renewed_subscriptions_revenue: optional(nullable(smartUnion([int(), number2()]))),
  renewed_subscriptions_net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  active_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  committed_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  monthly_recurring_revenue: optional(nullable(smartUnion([int(), number2()]))),
  committed_monthly_recurring_revenue: optional(nullable(smartUnion([int(), number2()]))),
  checkouts: optional(nullable(smartUnion([int(), number2()]))),
  succeeded_checkouts: optional(nullable(smartUnion([int(), number2()]))),
  checkouts_conversion: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_customer_service: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_low_quality: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_missing_features: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_switched_service: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_too_complex: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_too_expensive: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_unused: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_other: optional(nullable(smartUnion([int(), number2()]))),
  churned_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  churn_rate: optional(nullable(smartUnion([int(), number2()]))),
  ltv: optional(nullable(smartUnion([int(), number2()]))),
  gross_margin: optional(nullable(smartUnion([int(), number2()]))),
  gross_margin_percentage: optional(nullable(smartUnion([int(), number2()]))),
  cashflow: optional(nullable(smartUnion([int(), number2()])))
}), transform((v2) => {
  return remap(v2, {
    "net_revenue": "netRevenue",
    "cumulative_revenue": "cumulativeRevenue",
    "net_cumulative_revenue": "netCumulativeRevenue",
    "cumulative_costs": "cumulativeCosts",
    "average_order_value": "averageOrderValue",
    "net_average_order_value": "netAverageOrderValue",
    "average_revenue_per_user": "averageRevenuePerUser",
    "cost_per_user": "costPerUser",
    "active_user_by_event": "activeUserByEvent",
    "one_time_products": "oneTimeProducts",
    "one_time_products_revenue": "oneTimeProductsRevenue",
    "one_time_products_net_revenue": "oneTimeProductsNetRevenue",
    "new_subscriptions": "newSubscriptions",
    "new_subscriptions_revenue": "newSubscriptionsRevenue",
    "new_subscriptions_net_revenue": "newSubscriptionsNetRevenue",
    "renewed_subscriptions": "renewedSubscriptions",
    "renewed_subscriptions_revenue": "renewedSubscriptionsRevenue",
    "renewed_subscriptions_net_revenue": "renewedSubscriptionsNetRevenue",
    "active_subscriptions": "activeSubscriptions",
    "committed_subscriptions": "committedSubscriptions",
    "monthly_recurring_revenue": "monthlyRecurringRevenue",
    "committed_monthly_recurring_revenue": "committedMonthlyRecurringRevenue",
    "succeeded_checkouts": "succeededCheckouts",
    "checkouts_conversion": "checkoutsConversion",
    "canceled_subscriptions": "canceledSubscriptions",
    "canceled_subscriptions_customer_service": "canceledSubscriptionsCustomerService",
    "canceled_subscriptions_low_quality": "canceledSubscriptionsLowQuality",
    "canceled_subscriptions_missing_features": "canceledSubscriptionsMissingFeatures",
    "canceled_subscriptions_switched_service": "canceledSubscriptionsSwitchedService",
    "canceled_subscriptions_too_complex": "canceledSubscriptionsTooComplex",
    "canceled_subscriptions_too_expensive": "canceledSubscriptionsTooExpensive",
    "canceled_subscriptions_unused": "canceledSubscriptionsUnused",
    "canceled_subscriptions_other": "canceledSubscriptionsOther",
    "churned_subscriptions": "churnedSubscriptions",
    "churn_rate": "churnRate",
    "gross_margin": "grossMargin",
    "gross_margin_percentage": "grossMarginPercentage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metrictype.js
var MetricType = {
  Scalar: "scalar",
  Currency: "currency",
  CurrencySubCent: "currency_sub_cent",
  Percentage: "percentage"
};
var MetricType$inboundSchema = _enum2(MetricType);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metric.js
var Metric$inboundSchema = pipe(object({
  slug: string2(),
  display_name: string2(),
  type: MetricType$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "display_name": "displayName"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metrics.js
var Metrics$inboundSchema = pipe(object({
  orders: optional(nullable(Metric$inboundSchema)),
  revenue: optional(nullable(Metric$inboundSchema)),
  net_revenue: optional(nullable(Metric$inboundSchema)),
  cumulative_revenue: optional(nullable(Metric$inboundSchema)),
  net_cumulative_revenue: optional(nullable(Metric$inboundSchema)),
  costs: optional(nullable(Metric$inboundSchema)),
  cumulative_costs: optional(nullable(Metric$inboundSchema)),
  average_order_value: optional(nullable(Metric$inboundSchema)),
  net_average_order_value: optional(nullable(Metric$inboundSchema)),
  average_revenue_per_user: optional(nullable(Metric$inboundSchema)),
  cost_per_user: optional(nullable(Metric$inboundSchema)),
  active_user_by_event: optional(nullable(Metric$inboundSchema)),
  one_time_products: optional(nullable(Metric$inboundSchema)),
  one_time_products_revenue: optional(nullable(Metric$inboundSchema)),
  one_time_products_net_revenue: optional(nullable(Metric$inboundSchema)),
  new_subscriptions: optional(nullable(Metric$inboundSchema)),
  new_subscriptions_revenue: optional(nullable(Metric$inboundSchema)),
  new_subscriptions_net_revenue: optional(nullable(Metric$inboundSchema)),
  renewed_subscriptions: optional(nullable(Metric$inboundSchema)),
  renewed_subscriptions_revenue: optional(nullable(Metric$inboundSchema)),
  renewed_subscriptions_net_revenue: optional(nullable(Metric$inboundSchema)),
  active_subscriptions: optional(nullable(Metric$inboundSchema)),
  committed_subscriptions: optional(nullable(Metric$inboundSchema)),
  monthly_recurring_revenue: optional(nullable(Metric$inboundSchema)),
  committed_monthly_recurring_revenue: optional(nullable(Metric$inboundSchema)),
  checkouts: optional(nullable(Metric$inboundSchema)),
  succeeded_checkouts: optional(nullable(Metric$inboundSchema)),
  checkouts_conversion: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_customer_service: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_low_quality: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_missing_features: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_switched_service: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_too_complex: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_too_expensive: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_unused: optional(nullable(Metric$inboundSchema)),
  canceled_subscriptions_other: optional(nullable(Metric$inboundSchema)),
  churned_subscriptions: optional(nullable(Metric$inboundSchema)),
  churn_rate: optional(nullable(Metric$inboundSchema)),
  ltv: optional(nullable(Metric$inboundSchema)),
  gross_margin: optional(nullable(Metric$inboundSchema)),
  gross_margin_percentage: optional(nullable(Metric$inboundSchema)),
  cashflow: optional(nullable(Metric$inboundSchema))
}), transform((v2) => {
  return remap(v2, {
    "net_revenue": "netRevenue",
    "cumulative_revenue": "cumulativeRevenue",
    "net_cumulative_revenue": "netCumulativeRevenue",
    "cumulative_costs": "cumulativeCosts",
    "average_order_value": "averageOrderValue",
    "net_average_order_value": "netAverageOrderValue",
    "average_revenue_per_user": "averageRevenuePerUser",
    "cost_per_user": "costPerUser",
    "active_user_by_event": "activeUserByEvent",
    "one_time_products": "oneTimeProducts",
    "one_time_products_revenue": "oneTimeProductsRevenue",
    "one_time_products_net_revenue": "oneTimeProductsNetRevenue",
    "new_subscriptions": "newSubscriptions",
    "new_subscriptions_revenue": "newSubscriptionsRevenue",
    "new_subscriptions_net_revenue": "newSubscriptionsNetRevenue",
    "renewed_subscriptions": "renewedSubscriptions",
    "renewed_subscriptions_revenue": "renewedSubscriptionsRevenue",
    "renewed_subscriptions_net_revenue": "renewedSubscriptionsNetRevenue",
    "active_subscriptions": "activeSubscriptions",
    "committed_subscriptions": "committedSubscriptions",
    "monthly_recurring_revenue": "monthlyRecurringRevenue",
    "committed_monthly_recurring_revenue": "committedMonthlyRecurringRevenue",
    "succeeded_checkouts": "succeededCheckouts",
    "checkouts_conversion": "checkoutsConversion",
    "canceled_subscriptions": "canceledSubscriptions",
    "canceled_subscriptions_customer_service": "canceledSubscriptionsCustomerService",
    "canceled_subscriptions_low_quality": "canceledSubscriptionsLowQuality",
    "canceled_subscriptions_missing_features": "canceledSubscriptionsMissingFeatures",
    "canceled_subscriptions_switched_service": "canceledSubscriptionsSwitchedService",
    "canceled_subscriptions_too_complex": "canceledSubscriptionsTooComplex",
    "canceled_subscriptions_too_expensive": "canceledSubscriptionsTooExpensive",
    "canceled_subscriptions_unused": "canceledSubscriptionsUnused",
    "canceled_subscriptions_other": "canceledSubscriptionsOther",
    "churned_subscriptions": "churnedSubscriptions",
    "churn_rate": "churnRate",
    "gross_margin": "grossMargin",
    "gross_margin_percentage": "grossMarginPercentage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metricstotals.js
var MetricsTotalsOrders$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsNetRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCumulativeRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsNetCumulativeRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCosts$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCumulativeCosts$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsAverageOrderValue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsNetAverageOrderValue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsAverageRevenuePerUser$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCostPerUser$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsActiveUserByEvent$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsOneTimeProducts$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsOneTimeProductsRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsOneTimeProductsNetRevenue$inboundSchema = smartUnion([
  int(),
  number2()
]);
var MetricsTotalsNewSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsNewSubscriptionsRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsNewSubscriptionsNetRevenue$inboundSchema = smartUnion([
  int(),
  number2()
]);
var MetricsTotalsRenewedSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsRenewedSubscriptionsRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsRenewedSubscriptionsNetRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsActiveSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCommittedSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsMonthlyRecurringRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCommittedMonthlyRecurringRevenue$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCheckouts$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsSucceededCheckouts$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCheckoutsConversion$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsCustomerService$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsLowQuality$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsMissingFeatures$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsSwitchedService$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsTooComplex$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsTooExpensive$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsUnused$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCanceledSubscriptionsOther$inboundSchema = smartUnion([
  int(),
  number2()
]);
var MetricsTotalsChurnedSubscriptions$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsChurnRate$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsLtv$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsGrossMargin$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsGrossMarginPercentage$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotalsCashflow$inboundSchema = smartUnion([int(), number2()]);
var MetricsTotals$inboundSchema = pipe(object({
  orders: optional(nullable(smartUnion([int(), number2()]))),
  revenue: optional(nullable(smartUnion([int(), number2()]))),
  net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  cumulative_revenue: optional(nullable(smartUnion([int(), number2()]))),
  net_cumulative_revenue: optional(nullable(smartUnion([int(), number2()]))),
  costs: optional(nullable(smartUnion([int(), number2()]))),
  cumulative_costs: optional(nullable(smartUnion([int(), number2()]))),
  average_order_value: optional(nullable(smartUnion([int(), number2()]))),
  net_average_order_value: optional(nullable(smartUnion([int(), number2()]))),
  average_revenue_per_user: optional(nullable(smartUnion([int(), number2()]))),
  cost_per_user: optional(nullable(smartUnion([int(), number2()]))),
  active_user_by_event: optional(nullable(smartUnion([int(), number2()]))),
  one_time_products: optional(nullable(smartUnion([int(), number2()]))),
  one_time_products_revenue: optional(nullable(smartUnion([int(), number2()]))),
  one_time_products_net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  new_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  new_subscriptions_revenue: optional(nullable(smartUnion([int(), number2()]))),
  new_subscriptions_net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  renewed_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  renewed_subscriptions_revenue: optional(nullable(smartUnion([int(), number2()]))),
  renewed_subscriptions_net_revenue: optional(nullable(smartUnion([int(), number2()]))),
  active_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  committed_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  monthly_recurring_revenue: optional(nullable(smartUnion([int(), number2()]))),
  committed_monthly_recurring_revenue: optional(nullable(smartUnion([int(), number2()]))),
  checkouts: optional(nullable(smartUnion([int(), number2()]))),
  succeeded_checkouts: optional(nullable(smartUnion([int(), number2()]))),
  checkouts_conversion: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_customer_service: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_low_quality: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_missing_features: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_switched_service: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_too_complex: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_too_expensive: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_unused: optional(nullable(smartUnion([int(), number2()]))),
  canceled_subscriptions_other: optional(nullable(smartUnion([int(), number2()]))),
  churned_subscriptions: optional(nullable(smartUnion([int(), number2()]))),
  churn_rate: optional(nullable(smartUnion([int(), number2()]))),
  ltv: optional(nullable(smartUnion([int(), number2()]))),
  gross_margin: optional(nullable(smartUnion([int(), number2()]))),
  gross_margin_percentage: optional(nullable(smartUnion([int(), number2()]))),
  cashflow: optional(nullable(smartUnion([int(), number2()])))
}), transform((v2) => {
  return remap(v2, {
    "net_revenue": "netRevenue",
    "cumulative_revenue": "cumulativeRevenue",
    "net_cumulative_revenue": "netCumulativeRevenue",
    "cumulative_costs": "cumulativeCosts",
    "average_order_value": "averageOrderValue",
    "net_average_order_value": "netAverageOrderValue",
    "average_revenue_per_user": "averageRevenuePerUser",
    "cost_per_user": "costPerUser",
    "active_user_by_event": "activeUserByEvent",
    "one_time_products": "oneTimeProducts",
    "one_time_products_revenue": "oneTimeProductsRevenue",
    "one_time_products_net_revenue": "oneTimeProductsNetRevenue",
    "new_subscriptions": "newSubscriptions",
    "new_subscriptions_revenue": "newSubscriptionsRevenue",
    "new_subscriptions_net_revenue": "newSubscriptionsNetRevenue",
    "renewed_subscriptions": "renewedSubscriptions",
    "renewed_subscriptions_revenue": "renewedSubscriptionsRevenue",
    "renewed_subscriptions_net_revenue": "renewedSubscriptionsNetRevenue",
    "active_subscriptions": "activeSubscriptions",
    "committed_subscriptions": "committedSubscriptions",
    "monthly_recurring_revenue": "monthlyRecurringRevenue",
    "committed_monthly_recurring_revenue": "committedMonthlyRecurringRevenue",
    "succeeded_checkouts": "succeededCheckouts",
    "checkouts_conversion": "checkoutsConversion",
    "canceled_subscriptions": "canceledSubscriptions",
    "canceled_subscriptions_customer_service": "canceledSubscriptionsCustomerService",
    "canceled_subscriptions_low_quality": "canceledSubscriptionsLowQuality",
    "canceled_subscriptions_missing_features": "canceledSubscriptionsMissingFeatures",
    "canceled_subscriptions_switched_service": "canceledSubscriptionsSwitchedService",
    "canceled_subscriptions_too_complex": "canceledSubscriptionsTooComplex",
    "canceled_subscriptions_too_expensive": "canceledSubscriptionsTooExpensive",
    "canceled_subscriptions_unused": "canceledSubscriptionsUnused",
    "canceled_subscriptions_other": "canceledSubscriptionsOther",
    "churned_subscriptions": "churnedSubscriptions",
    "churn_rate": "churnRate",
    "gross_margin": "grossMargin",
    "gross_margin_percentage": "grossMarginPercentage"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metricsresponse.js
var MetricsResponse$inboundSchema = object({
  periods: array(MetricPeriod$inboundSchema),
  totals: MetricsTotals$inboundSchema,
  metrics: Metrics$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/metricsget.js
var MetricsGetQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var MetricsGetQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var QueryParamProductBillingTypeFilter$outboundSchema = smartUnion([
  ProductBillingType$outboundSchema,
  array(ProductBillingType$outboundSchema)
]);
var MetricsGetQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var MetricsGetRequest$outboundSchema = pipe(object({
  startDate: pipe(custom((x2) => x2 instanceof RFCDate), transform((v2) => v2.toString())),
  endDate: pipe(custom((x2) => x2 instanceof RFCDate), transform((v2) => v2.toString())),
  timezone: _default2(string2(), "UTC"),
  interval: TimeInterval$outboundSchema,
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  billingType: optional(nullable(smartUnion([
    ProductBillingType$outboundSchema,
    array(ProductBillingType$outboundSchema)
  ]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  metrics: optional(nullable(array(string2())))
}), transform((v2) => {
  return remap(v2, {
    startDate: "start_date",
    endDate: "end_date",
    organizationId: "organization_id",
    productId: "product_id",
    billingType: "billing_type",
    customerId: "customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metricsGet.js
function metricsGet(client, request, options) {
  return new APIPromise($do119(client, request, options));
}
async function $do119(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(MetricsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/metrics/")();
  const query = encodeFormQuery({
    "billing_type": payload.billing_type,
    "customer_id": payload.customer_id,
    "end_date": payload.end_date,
    "interval": payload.interval,
    "metrics": payload.metrics,
    "organization_id": payload.organization_id,
    "product_id": payload.product_id,
    "start_date": payload.start_date,
    "timezone": payload.timezone
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "metrics:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, MetricsResponse$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metricsintervallimit.js
var MetricsIntervalLimit$inboundSchema = pipe(object({
  min_days: int(),
  max_days: int()
}), transform((v2) => {
  return remap(v2, {
    "min_days": "minDays",
    "max_days": "maxDays"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metricsintervalslimits.js
var MetricsIntervalsLimits$inboundSchema = object({
  hour: MetricsIntervalLimit$inboundSchema,
  day: MetricsIntervalLimit$inboundSchema,
  week: MetricsIntervalLimit$inboundSchema,
  month: MetricsIntervalLimit$inboundSchema,
  year: MetricsIntervalLimit$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/metricslimits.js
var MetricsLimits$inboundSchema = pipe(object({
  min_date: pipe(string2(), transform((v2) => new RFCDate(v2))),
  intervals: MetricsIntervalsLimits$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "min_date": "minDate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/metricsLimits.js
function metricsLimits(client, options) {
  return new APIPromise($do120(client, options));
}
async function $do120(client, options) {
  const path = pathToFunc("/v1/metrics/limits")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "metrics:limits",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, MetricsLimits$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/metrics.js
var Metrics = class extends ClientSDK {
  /**
   * Get Metrics
   *
   * @remarks
   * Get metrics about your orders and subscriptions.
   *
   * Currency values are output in cents.
   *
   * **Scopes**: `metrics:read`
   */
  async get(request, options) {
    return unwrapAsync(metricsGet(this, request, options));
  }
  /**
   * Get Metrics Limits
   *
   * @remarks
   * Get the interval limits for the metrics endpoint.
   *
   * **Scopes**: `metrics:read`
   */
  async limits(options) {
    return unwrapAsync(metricsLimits(this, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/authorizeorganization.js
var AuthorizeOrganization$inboundSchema = pipe(object({
  id: string2(),
  slug: string2(),
  avatar_url: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "avatar_url": "avatarUrl"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/oauth2clientpublic.js
var OAuth2ClientPublic$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  client_id: string2(),
  client_name: nullable(string2()),
  client_uri: nullable(string2()),
  logo_uri: nullable(string2()),
  tos_uri: nullable(string2()),
  policy_uri: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "client_id": "clientId",
    "client_name": "clientName",
    "client_uri": "clientUri",
    "logo_uri": "logoUri",
    "tos_uri": "tosUri",
    "policy_uri": "policyUri"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/scope.js
var Scope = {
  Openid: "openid",
  Profile: "profile",
  Email: "email",
  UserRead: "user:read",
  UserWrite: "user:write",
  WebRead: "web:read",
  WebWrite: "web:write",
  OrganizationsRead: "organizations:read",
  OrganizationsWrite: "organizations:write",
  CustomFieldsRead: "custom_fields:read",
  CustomFieldsWrite: "custom_fields:write",
  DiscountsRead: "discounts:read",
  DiscountsWrite: "discounts:write",
  CheckoutLinksRead: "checkout_links:read",
  CheckoutLinksWrite: "checkout_links:write",
  CheckoutsRead: "checkouts:read",
  CheckoutsWrite: "checkouts:write",
  TransactionsRead: "transactions:read",
  TransactionsWrite: "transactions:write",
  PayoutsRead: "payouts:read",
  PayoutsWrite: "payouts:write",
  ProductsRead: "products:read",
  ProductsWrite: "products:write",
  BenefitsRead: "benefits:read",
  BenefitsWrite: "benefits:write",
  EventsRead: "events:read",
  EventsWrite: "events:write",
  MetersRead: "meters:read",
  MetersWrite: "meters:write",
  FilesRead: "files:read",
  FilesWrite: "files:write",
  SubscriptionsRead: "subscriptions:read",
  SubscriptionsWrite: "subscriptions:write",
  CustomersRead: "customers:read",
  CustomersWrite: "customers:write",
  MembersRead: "members:read",
  MembersWrite: "members:write",
  WalletsRead: "wallets:read",
  WalletsWrite: "wallets:write",
  DisputesRead: "disputes:read",
  CustomerMetersRead: "customer_meters:read",
  CustomerSessionsWrite: "customer_sessions:write",
  MemberSessionsWrite: "member_sessions:write",
  CustomerSeatsRead: "customer_seats:read",
  CustomerSeatsWrite: "customer_seats:write",
  OrdersRead: "orders:read",
  OrdersWrite: "orders:write",
  RefundsRead: "refunds:read",
  RefundsWrite: "refunds:write",
  PaymentsRead: "payments:read",
  MetricsRead: "metrics:read",
  WebhooksRead: "webhooks:read",
  WebhooksWrite: "webhooks:write",
  ExternalOrganizationsRead: "external_organizations:read",
  LicenseKeysRead: "license_keys:read",
  LicenseKeysWrite: "license_keys:write",
  RepositoriesRead: "repositories:read",
  RepositoriesWrite: "repositories:write",
  IssuesRead: "issues:read",
  IssuesWrite: "issues:write",
  CustomerPortalRead: "customer_portal:read",
  CustomerPortalWrite: "customer_portal:write",
  NotificationsRead: "notifications:read",
  NotificationsWrite: "notifications:write",
  NotificationRecipientsRead: "notification_recipients:read",
  NotificationRecipientsWrite: "notification_recipients:write",
  OrganizationAccessTokensRead: "organization_access_tokens:read",
  OrganizationAccessTokensWrite: "organization_access_tokens:write"
};
var Scope$inboundSchema = _enum2(Scope);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/authorizeresponseorganization.js
var AuthorizeResponseOrganization$inboundSchema = pipe(object({
  client: OAuth2ClientPublic$inboundSchema,
  sub_type: literal("organization"),
  sub: nullable(AuthorizeOrganization$inboundSchema),
  scopes: array(Scope$inboundSchema),
  scope_display_names: optional(record(string2(), string2())),
  organizations: array(AuthorizeOrganization$inboundSchema)
}), transform((v2) => {
  return remap(v2, {
    "sub_type": "subType",
    "scope_display_names": "scopeDisplayNames"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/authorizeuser.js
var AuthorizeUser$inboundSchema = pipe(object({
  id: string2(),
  email: string2(),
  avatar_url: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    "avatar_url": "avatarUrl"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/authorizeresponseuser.js
var AuthorizeResponseUser$inboundSchema = pipe(object({
  client: OAuth2ClientPublic$inboundSchema,
  sub_type: literal("user"),
  sub: nullable(AuthorizeUser$inboundSchema),
  scopes: array(Scope$inboundSchema),
  scope_display_names: optional(record(string2(), string2()))
}), transform((v2) => {
  return remap(v2, {
    "sub_type": "subType",
    "scope_display_names": "scopeDisplayNames"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/oauth2authorize.js
var Oauth2AuthorizeResponseOauth2Authorize$inboundSchema = union([
  AuthorizeResponseUser$inboundSchema,
  AuthorizeResponseOrganization$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2Authorize.js
function oauth2Authorize(client, options) {
  return new APIPromise($do121(client, options));
}
async function $do121(client, options) {
  const path = pathToFunc("/v1/oauth2/authorize")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:authorize",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, Oauth2AuthorizeResponseOauth2Authorize$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/introspecttokenrequest.js
var IntrospectTokenRequestTokenTypeHint = {
  AccessToken: "access_token",
  RefreshToken: "refresh_token"
};
var IntrospectTokenRequestTokenTypeHint$outboundSchema = _enum2(IntrospectTokenRequestTokenTypeHint);
var IntrospectTokenRequest$outboundSchema = pipe(object({
  token: string2(),
  tokenTypeHint: optional(nullable(IntrospectTokenRequestTokenTypeHint$outboundSchema)),
  clientId: string2(),
  clientSecret: string2()
}), transform((v2) => {
  return remap(v2, {
    tokenTypeHint: "token_type_hint",
    clientId: "client_id",
    clientSecret: "client_secret"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subtype.js
var SubType = {
  User: "user",
  Organization: "organization"
};
var SubType$inboundSchema = _enum2(SubType);
var SubType$outboundSchema = SubType$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/introspecttokenresponse.js
var TokenType = {
  AccessToken: "access_token",
  RefreshToken: "refresh_token"
};
var TokenType$inboundSchema = _enum2(TokenType);
var IntrospectTokenResponse$inboundSchema = pipe(object({
  active: boolean2(),
  client_id: string2(),
  token_type: TokenType$inboundSchema,
  scope: string2(),
  sub_type: SubType$inboundSchema,
  sub: string2(),
  aud: string2(),
  iss: string2(),
  exp: int(),
  iat: int()
}), transform((v2) => {
  return remap(v2, {
    "client_id": "clientId",
    "token_type": "tokenType",
    "sub_type": "subType"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2Introspect.js
function oauth2Introspect(client, request, options) {
  return new APIPromise($do122(client, request, options));
}
async function $do122(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(IntrospectTokenRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = Object.entries(payload || {}).map(([k, v2]) => {
    return encodeBodyForm(k, v2, { charEncoding: "percent" });
  }).join("&");
  const path = pathToFunc("/v1/oauth2/introspect")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:introspect_token",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, IntrospectTokenResponse$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/revoketokenrequest.js
var TokenTypeHint = {
  AccessToken: "access_token",
  RefreshToken: "refresh_token"
};
var TokenTypeHint$outboundSchema = _enum2(TokenTypeHint);
var RevokeTokenRequest$outboundSchema = pipe(object({
  token: string2(),
  tokenTypeHint: optional(nullable(TokenTypeHint$outboundSchema)),
  clientId: string2(),
  clientSecret: string2()
}), transform((v2) => {
  return remap(v2, {
    tokenTypeHint: "token_type_hint",
    clientId: "client_id",
    clientSecret: "client_secret"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/revoketokenresponse.js
var RevokeTokenResponse$inboundSchema = object({});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2Revoke.js
function oauth2Revoke(client, request, options) {
  return new APIPromise($do123(client, request, options));
}
async function $do123(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(RevokeTokenRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = Object.entries(payload || {}).map(([k, v2]) => {
    return encodeBodyForm(k, v2, { charEncoding: "percent" });
  }).join("&");
  const path = pathToFunc("/v1/oauth2/revoke")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:revoke_token",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, RevokeTokenResponse$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/tokenresponse.js
var TokenResponse$inboundSchema = pipe(object({
  access_token: string2(),
  token_type: literal("Bearer"),
  expires_in: int(),
  refresh_token: nullable(string2()),
  scope: string2(),
  id_token: string2()
}), transform((v2) => {
  return remap(v2, {
    "access_token": "accessToken",
    "token_type": "tokenType",
    "expires_in": "expiresIn",
    "refresh_token": "refreshToken",
    "id_token": "idToken"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/authorizationcodetokenrequest.js
var AuthorizationCodeTokenRequest$outboundSchema = pipe(object({
  grantType: literal("authorization_code"),
  clientId: string2(),
  clientSecret: string2(),
  code: string2(),
  redirectUri: string2()
}), transform((v2) => {
  return remap(v2, {
    grantType: "grant_type",
    clientId: "client_id",
    clientSecret: "client_secret",
    redirectUri: "redirect_uri"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refreshtokenrequest.js
var RefreshTokenRequest$outboundSchema = pipe(object({
  grantType: literal("refresh_token"),
  clientId: string2(),
  clientSecret: string2(),
  refreshToken: string2()
}), transform((v2) => {
  return remap(v2, {
    grantType: "grant_type",
    clientId: "client_id",
    clientSecret: "client_secret",
    refreshToken: "refresh_token"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webtokenrequest.js
var WebTokenRequestSubType = {
  User: "user",
  Organization: "organization"
};
var WebTokenRequestSubType$outboundSchema = _enum2(WebTokenRequestSubType);
var WebTokenRequest$outboundSchema = pipe(object({
  grantType: literal("web"),
  clientId: string2(),
  clientSecret: string2(),
  sessionToken: string2(),
  subType: _default2(WebTokenRequestSubType$outboundSchema, "user"),
  sub: optional(nullable(string2())),
  scope: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    grantType: "grant_type",
    clientId: "client_id",
    clientSecret: "client_secret",
    sessionToken: "session_token",
    subType: "sub_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/oauth2requesttoken.js
var Oauth2RequestTokenRequestBody$outboundSchema = union([
  AuthorizationCodeTokenRequest$outboundSchema,
  RefreshTokenRequest$outboundSchema,
  WebTokenRequest$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2Token.js
function oauth2Token(client, request, options) {
  return new APIPromise($do124(client, request, options));
}
async function $do124(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(Oauth2RequestTokenRequestBody$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = Object.entries(payload || {}).map(([k, v2]) => {
    return encodeBodyForm(k, v2, { charEncoding: "percent" });
  }).join("&");
  const path = pathToFunc("/v1/oauth2/token")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  }));
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:request_token",
    oAuth2Scopes: null,
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, TokenResponse$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/userinfoorganization.js
var UserInfoOrganization$inboundSchema = object({
  sub: string2(),
  name: optional(nullable(string2()))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/userinfouser.js
var UserInfoUser$inboundSchema = pipe(object({
  sub: string2(),
  name: optional(nullable(string2())),
  email: optional(nullable(string2())),
  email_verified: optional(nullable(boolean2()))
}), transform((v2) => {
  return remap(v2, {
    "email_verified": "emailVerified"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/oauth2userinfo.js
var Oauth2UserinfoResponseOauth2Userinfo$inboundSchema = smartUnion([
  UserInfoUser$inboundSchema,
  UserInfoOrganization$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2Userinfo.js
function oauth2Userinfo(client, options) {
  return new APIPromise($do125(client, options));
}
async function $do125(client, options) {
  const path = pathToFunc("/v1/oauth2/userinfo")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:userinfo",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, Oauth2UserinfoResponseOauth2Userinfo$inboundSchema), fail("4XX"), fail("5XX"))(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/oauth2clientconfiguration.js
var TokenEndpointAuthMethod = {
  ClientSecretBasic: "client_secret_basic",
  ClientSecretPost: "client_secret_post",
  None: "none"
};
var GrantTypes = {
  AuthorizationCode: "authorization_code",
  RefreshToken: "refresh_token"
};
var TokenEndpointAuthMethod$outboundSchema = _enum2(TokenEndpointAuthMethod);
var GrantTypes$outboundSchema = _enum2(GrantTypes);
var OAuth2ClientConfiguration$outboundSchema = pipe(object({
  redirectUris: array(string2()),
  tokenEndpointAuthMethod: _default2(TokenEndpointAuthMethod$outboundSchema, "client_secret_post"),
  grantTypes: optional(array(GrantTypes$outboundSchema)),
  responseTypes: optional(array(string2())),
  scope: _default2(string2(), "openid profile email user:read user:write organizations:read organizations:write custom_fields:read custom_fields:write discounts:read discounts:write checkout_links:read checkout_links:write checkouts:read checkouts:write transactions:read transactions:write payouts:read payouts:write products:read products:write benefits:read benefits:write events:read events:write meters:read meters:write files:read files:write subscriptions:read subscriptions:write customers:read customers:write members:read members:write wallets:read wallets:write disputes:read customer_meters:read customer_sessions:write member_sessions:write customer_seats:read customer_seats:write orders:read orders:write refunds:read refunds:write payments:read metrics:read webhooks:read webhooks:write external_organizations:read license_keys:read license_keys:write repositories:read repositories:write issues:read issues:write customer_portal:read customer_portal:write notifications:read notifications:write notification_recipients:read notification_recipients:write organization_access_tokens:read organization_access_tokens:write"),
  clientName: string2(),
  clientUri: optional(nullable(string2())),
  logoUri: optional(nullable(string2())),
  tosUri: optional(nullable(string2())),
  policyUri: optional(nullable(string2())),
  defaultSubType: optional(SubType$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    redirectUris: "redirect_uris",
    tokenEndpointAuthMethod: "token_endpoint_auth_method",
    grantTypes: "grant_types",
    responseTypes: "response_types",
    clientName: "client_name",
    clientUri: "client_uri",
    logoUri: "logo_uri",
    tosUri: "tos_uri",
    policyUri: "policy_uri",
    defaultSubType: "default_sub_type"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2ClientsCreate.js
function oauth2ClientsCreate(client, request, options) {
  return new APIPromise($do126(client, request, options));
}
async function $do126(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OAuth2ClientConfiguration$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/oauth2/register")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:clients:oauth2:create_client",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/oauth2clientsoauth2deleteclient.js
var Oauth2ClientsOauth2DeleteClientRequest$outboundSchema = pipe(object({
  clientId: string2()
}), transform((v2) => {
  return remap(v2, {
    clientId: "client_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2ClientsDelete.js
function oauth2ClientsDelete(client, request, options) {
  return new APIPromise($do127(client, request, options));
}
async function $do127(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(Oauth2ClientsOauth2DeleteClientRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    client_id: encodeSimple("client_id", payload.client_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/oauth2/register/{client_id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:clients:oauth2:delete_client",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/oauth2clientsoauth2getclient.js
var Oauth2ClientsOauth2GetClientRequest$outboundSchema = pipe(object({
  clientId: string2()
}), transform((v2) => {
  return remap(v2, {
    clientId: "client_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2ClientsGet.js
function oauth2ClientsGet(client, request, options) {
  return new APIPromise($do128(client, request, options));
}
async function $do128(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(Oauth2ClientsOauth2GetClientRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    client_id: encodeSimple("client_id", payload.client_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/oauth2/register/{client_id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:clients:oauth2:get_client",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/oauth2clientconfigurationupdate.js
var OAuth2ClientConfigurationUpdateTokenEndpointAuthMethod = {
  ClientSecretBasic: "client_secret_basic",
  ClientSecretPost: "client_secret_post",
  None: "none"
};
var OAuth2ClientConfigurationUpdateGrantTypes = {
  AuthorizationCode: "authorization_code",
  RefreshToken: "refresh_token"
};
var OAuth2ClientConfigurationUpdateTokenEndpointAuthMethod$outboundSchema = _enum2(OAuth2ClientConfigurationUpdateTokenEndpointAuthMethod);
var OAuth2ClientConfigurationUpdateGrantTypes$outboundSchema = _enum2(OAuth2ClientConfigurationUpdateGrantTypes);
var OAuth2ClientConfigurationUpdate$outboundSchema = pipe(object({
  redirectUris: array(string2()),
  tokenEndpointAuthMethod: _default2(OAuth2ClientConfigurationUpdateTokenEndpointAuthMethod$outboundSchema, "client_secret_post"),
  grantTypes: optional(array(OAuth2ClientConfigurationUpdateGrantTypes$outboundSchema)),
  responseTypes: optional(array(string2())),
  scope: _default2(string2(), "openid profile email user:read user:write organizations:read organizations:write custom_fields:read custom_fields:write discounts:read discounts:write checkout_links:read checkout_links:write checkouts:read checkouts:write transactions:read transactions:write payouts:read payouts:write products:read products:write benefits:read benefits:write events:read events:write meters:read meters:write files:read files:write subscriptions:read subscriptions:write customers:read customers:write members:read members:write wallets:read wallets:write disputes:read customer_meters:read customer_sessions:write member_sessions:write customer_seats:read customer_seats:write orders:read orders:write refunds:read refunds:write payments:read metrics:read webhooks:read webhooks:write external_organizations:read license_keys:read license_keys:write repositories:read repositories:write issues:read issues:write customer_portal:read customer_portal:write notifications:read notifications:write notification_recipients:read notification_recipients:write organization_access_tokens:read organization_access_tokens:write"),
  clientName: string2(),
  clientUri: optional(nullable(string2())),
  logoUri: optional(nullable(string2())),
  tosUri: optional(nullable(string2())),
  policyUri: optional(nullable(string2())),
  defaultSubType: optional(SubType$outboundSchema),
  clientId: string2()
}), transform((v2) => {
  return remap(v2, {
    redirectUris: "redirect_uris",
    tokenEndpointAuthMethod: "token_endpoint_auth_method",
    grantTypes: "grant_types",
    responseTypes: "response_types",
    clientName: "client_name",
    clientUri: "client_uri",
    logoUri: "logo_uri",
    tosUri: "tos_uri",
    policyUri: "policy_uri",
    defaultSubType: "default_sub_type",
    clientId: "client_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/oauth2clientsoauth2updateclient.js
var Oauth2ClientsOauth2UpdateClientRequest$outboundSchema = pipe(object({
  clientId: string2(),
  oAuth2ClientConfigurationUpdate: OAuth2ClientConfigurationUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    clientId: "client_id",
    oAuth2ClientConfigurationUpdate: "OAuth2ClientConfigurationUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/oauth2ClientsUpdate.js
function oauth2ClientsUpdate(client, request, options) {
  return new APIPromise($do129(client, request, options));
}
async function $do129(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(Oauth2ClientsOauth2UpdateClientRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.OAuth2ClientConfigurationUpdate, {
    explode: true
  });
  const pathParams = {
    client_id: encodeSimple("client_id", payload.client_id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/oauth2/register/{client_id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "oauth2:clients:oauth2:update_client",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/clients.js
var Clients = class extends ClientSDK {
  /**
   * Create Client
   *
   * @remarks
   * Create an OAuth2 client.
   */
  async create(request, options) {
    return unwrapAsync(oauth2ClientsCreate(this, request, options));
  }
  /**
   * Get Client
   *
   * @remarks
   * Get an OAuth2 client by Client ID.
   */
  async get(request, options) {
    return unwrapAsync(oauth2ClientsGet(this, request, options));
  }
  /**
   * Update Client
   *
   * @remarks
   * Update an OAuth2 client.
   */
  async update(request, options) {
    return unwrapAsync(oauth2ClientsUpdate(this, request, options));
  }
  /**
   * Delete Client
   *
   * @remarks
   * Delete an OAuth2 client.
   */
  async delete(request, options) {
    return unwrapAsync(oauth2ClientsDelete(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/oauth2.js
var Oauth2 = class extends ClientSDK {
  get clients() {
    return this._clients ?? (this._clients = new Clients(this._options));
  }
  /**
   * Authorize
   */
  async authorize(options) {
    return unwrapAsync(oauth2Authorize(this, options));
  }
  /**
   * Request Token
   *
   * @remarks
   * Request an access token using a valid grant.
   */
  async token(request, options) {
    return unwrapAsync(oauth2Token(this, request, options));
  }
  /**
   * Revoke Token
   *
   * @remarks
   * Revoke an access token or a refresh token.
   */
  async revoke(request, options) {
    return unwrapAsync(oauth2Revoke(this, request, options));
  }
  /**
   * Introspect Token
   *
   * @remarks
   * Get information about an access token.
   */
  async introspect(request, options) {
    return unwrapAsync(oauth2Introspect(this, request, options));
  }
  /**
   * Get User Info
   *
   * @remarks
   * Get information about the authenticated user.
   */
  async userinfo(options) {
    return unwrapAsync(oauth2Userinfo(this, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/ordersexport.js
var OrdersExportQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrdersExportQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrdersExportRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productId: optional(nullable(smartUnion([string2(), array(string2())])))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    productId: "product_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/ordersExport.js
function ordersExport(client, request, options) {
  return new APIPromise($do130(client, request, options));
}
async function $do130(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrdersExportRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/orders/export")();
  const query = encodeFormQuery({
    "organization_id": payload.organization_id,
    "product_id": payload.product_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "orders:export",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/ordersgenerateinvoice.js
var OrdersGenerateInvoiceResponse422OrdersGenerateInvoice$inboundSchema = union([
  MissingInvoiceBillingDetails$inboundSchema,
  NotPaidOrder$inboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/ordersgenerateinvoice.js
var OrdersGenerateInvoiceRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/ordersGenerateInvoice.js
function ordersGenerateInvoice(client, request, options) {
  return new APIPromise($do131(client, request, options));
}
async function $do131(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrdersGenerateInvoiceRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/orders/{id}/invoice")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "orders:generate_invoice",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(202, any()), jsonErr(422, OrdersGenerateInvoiceResponse422OrdersGenerateInvoice$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/ordersget.js
var OrdersGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/ordersGet.js
function ordersGet(client, request, options) {
  return new APIPromise($do132(client, request, options));
}
async function $do132(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrdersGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/orders/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "orders:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Order$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderinvoice.js
var OrderInvoice$inboundSchema = object({
  url: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/ordersinvoice.js
var OrdersInvoiceRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/ordersInvoice.js
function ordersInvoice(client, request, options) {
  return new APIPromise($do133(client, request, options));
}
async function $do133(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrdersInvoiceRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/orders/{id}/invoice")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "orders:invoice",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, OrderInvoice$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceorder.js
var ListResourceOrder$inboundSchema = object({
  items: array(Order$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/ordersortproperty.js
var OrderSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Status: "status",
  MinusStatus: "-status",
  InvoiceNumber: "invoice_number",
  MinusInvoiceNumber: "-invoice_number",
  Amount: "amount",
  MinusAmount: "-amount",
  NetAmount: "net_amount",
  MinusNetAmount: "-net_amount",
  Customer: "customer",
  MinusCustomer: "-customer",
  Product: "product",
  MinusProduct: "-product",
  Discount: "discount",
  MinusDiscount: "-discount",
  Subscription: "subscription",
  MinusSubscription: "-subscription"
};
var OrderSortProperty$outboundSchema = _enum2(OrderSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/orderslist.js
var OrdersListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrdersListQueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var ProductBillingTypeFilter$outboundSchema = smartUnion([
  ProductBillingType$outboundSchema,
  array(ProductBillingType$outboundSchema)
]);
var QueryParamDiscountIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrdersListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrdersListQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CheckoutIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrdersListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productBillingType: optional(nullable(smartUnion([
    ProductBillingType$outboundSchema,
    array(ProductBillingType$outboundSchema)
  ]))),
  discountId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  checkoutId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(OrderSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    productId: "product_id",
    productBillingType: "product_billing_type",
    discountId: "discount_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    checkoutId: "checkout_id"
  });
}));
var OrdersListResponse$inboundSchema = pipe(object({
  Result: ListResourceOrder$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/ordersList.js
function ordersList(client, request, options) {
  return new APIPromise($do134(client, request, options));
}
async function $do134(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrdersListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/orders/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "checkout_id": payload.checkout_id,
    "customer_id": payload.customer_id,
    "discount_id": payload.discount_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "product_billing_type": payload.product_billing_type,
    "product_id": payload.product_id,
    "sorting": payload.sorting
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "orders:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, OrdersListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => ordersList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/orderupdate.js
var OrderUpdate$outboundSchema = pipe(object({
  billingName: optional(nullable(string2())),
  billingAddress: optional(nullable(AddressInput$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    billingName: "billing_name",
    billingAddress: "billing_address"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/ordersupdate.js
var OrdersUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  orderUpdate: OrderUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    orderUpdate: "OrderUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/ordersUpdate.js
function ordersUpdate(client, request, options) {
  return new APIPromise($do135(client, request, options));
}
async function $do135(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrdersUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.OrderUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/orders/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "orders:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Order$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/orders.js
var Orders = class extends ClientSDK {
  /**
   * List Orders
   *
   * @remarks
   * List orders.
   *
   * **Scopes**: `orders:read`
   */
  async list(request, options) {
    return unwrapResultIterator(ordersList(this, request, options));
  }
  /**
   * Export Subscriptions
   *
   * @remarks
   * Export orders as a CSV file.
   *
   * **Scopes**: `orders:read`
   */
  async export(request, options) {
    return unwrapAsync(ordersExport(this, request, options));
  }
  /**
   * Get Order
   *
   * @remarks
   * Get an order by ID.
   *
   * **Scopes**: `orders:read`
   */
  async get(request, options) {
    return unwrapAsync(ordersGet(this, request, options));
  }
  /**
   * Update Order
   *
   * @remarks
   * Update an order.
   *
   * **Scopes**: `orders:write`
   */
  async update(request, options) {
    return unwrapAsync(ordersUpdate(this, request, options));
  }
  /**
   * Generate Order Invoice
   *
   * @remarks
   * Trigger generation of an order's invoice.
   *
   * **Scopes**: `orders:read`
   */
  async generateInvoice(request, options) {
    return unwrapAsync(ordersGenerateInvoice(this, request, options));
  }
  /**
   * Get Order Invoice
   *
   * @remarks
   * Get an order's invoice data.
   *
   * **Scopes**: `orders:read`
   */
  async invoice(request, options) {
    return unwrapAsync(ordersInvoice(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/availablescope.js
var AvailableScope = {
  Openid: "openid",
  Profile: "profile",
  Email: "email",
  UserRead: "user:read",
  UserWrite: "user:write",
  OrganizationsRead: "organizations:read",
  OrganizationsWrite: "organizations:write",
  CustomFieldsRead: "custom_fields:read",
  CustomFieldsWrite: "custom_fields:write",
  DiscountsRead: "discounts:read",
  DiscountsWrite: "discounts:write",
  CheckoutLinksRead: "checkout_links:read",
  CheckoutLinksWrite: "checkout_links:write",
  CheckoutsRead: "checkouts:read",
  CheckoutsWrite: "checkouts:write",
  TransactionsRead: "transactions:read",
  TransactionsWrite: "transactions:write",
  PayoutsRead: "payouts:read",
  PayoutsWrite: "payouts:write",
  ProductsRead: "products:read",
  ProductsWrite: "products:write",
  BenefitsRead: "benefits:read",
  BenefitsWrite: "benefits:write",
  EventsRead: "events:read",
  EventsWrite: "events:write",
  MetersRead: "meters:read",
  MetersWrite: "meters:write",
  FilesRead: "files:read",
  FilesWrite: "files:write",
  SubscriptionsRead: "subscriptions:read",
  SubscriptionsWrite: "subscriptions:write",
  CustomersRead: "customers:read",
  CustomersWrite: "customers:write",
  MembersRead: "members:read",
  MembersWrite: "members:write",
  WalletsRead: "wallets:read",
  WalletsWrite: "wallets:write",
  DisputesRead: "disputes:read",
  CustomerMetersRead: "customer_meters:read",
  CustomerSessionsWrite: "customer_sessions:write",
  MemberSessionsWrite: "member_sessions:write",
  CustomerSeatsRead: "customer_seats:read",
  CustomerSeatsWrite: "customer_seats:write",
  OrdersRead: "orders:read",
  OrdersWrite: "orders:write",
  RefundsRead: "refunds:read",
  RefundsWrite: "refunds:write",
  PaymentsRead: "payments:read",
  MetricsRead: "metrics:read",
  WebhooksRead: "webhooks:read",
  WebhooksWrite: "webhooks:write",
  ExternalOrganizationsRead: "external_organizations:read",
  LicenseKeysRead: "license_keys:read",
  LicenseKeysWrite: "license_keys:write",
  RepositoriesRead: "repositories:read",
  RepositoriesWrite: "repositories:write",
  IssuesRead: "issues:read",
  IssuesWrite: "issues:write",
  CustomerPortalRead: "customer_portal:read",
  CustomerPortalWrite: "customer_portal:write",
  NotificationsRead: "notifications:read",
  NotificationsWrite: "notifications:write",
  NotificationRecipientsRead: "notification_recipients:read",
  NotificationRecipientsWrite: "notification_recipients:write",
  OrganizationAccessTokensRead: "organization_access_tokens:read",
  OrganizationAccessTokensWrite: "organization_access_tokens:write"
};
var AvailableScope$outboundSchema = _enum2(AvailableScope);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationaccesstokencreate.js
var OrganizationAccessTokenCreate$outboundSchema = pipe(object({
  organizationId: optional(nullable(string2())),
  comment: string2(),
  expiresIn: optional(nullable(string2())),
  scopes: array(AvailableScope$outboundSchema)
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    expiresIn: "expires_in"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationaccesstoken.js
var OrganizationAccessToken$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  scopes: array(Scope$inboundSchema),
  expires_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  comment: string2(),
  last_used_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  organization_id: string2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "expires_at": "expiresAt",
    "last_used_at": "lastUsedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationaccesstokencreateresponse.js
var OrganizationAccessTokenCreateResponse$inboundSchema = pipe(object({
  organization_access_token: OrganizationAccessToken$inboundSchema,
  token: string2()
}), transform((v2) => {
  return remap(v2, {
    "organization_access_token": "organizationAccessToken"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationAccessTokensCreate.js
function organizationAccessTokensCreate(client, request, options) {
  return new APIPromise($do136(client, request, options));
}
async function $do136(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationAccessTokenCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/organization-access-tokens/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organization_access_tokens:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, OrganizationAccessTokenCreateResponse$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/organizationaccesstokensdelete.js
var OrganizationAccessTokensDeleteRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationAccessTokensDelete.js
function organizationAccessTokensDelete(client, request, options) {
  return new APIPromise($do137(client, request, options));
}
async function $do137(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationAccessTokensDeleteRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/organization-access-tokens/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organization_access_tokens:delete",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceorganizationaccesstoken.js
var ListResourceOrganizationAccessToken$inboundSchema = object({
  items: array(OrganizationAccessToken$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationaccesstokensortproperty.js
var OrganizationAccessTokenSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Comment: "comment",
  MinusComment: "-comment",
  LastUsedAt: "last_used_at",
  MinusLastUsedAt: "-last_used_at",
  OrganizationId: "organization_id",
  MinusOrganizationId: "-organization_id"
};
var OrganizationAccessTokenSortProperty$outboundSchema = _enum2(OrganizationAccessTokenSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/organizationaccesstokenslist.js
var OrganizationAccessTokensListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrganizationAccessTokensListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(OrganizationAccessTokenSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));
var OrganizationAccessTokensListResponse$inboundSchema = pipe(object({
  Result: ListResourceOrganizationAccessToken$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationAccessTokensList.js
function organizationAccessTokensList(client, request, options) {
  return new APIPromise($do138(client, request, options));
}
async function $do138(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationAccessTokensListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/organization-access-tokens/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organization_access_tokens:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, OrganizationAccessTokensListResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => organizationAccessTokensList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationaccesstokenupdate.js
var OrganizationAccessTokenUpdate$outboundSchema = object({
  comment: optional(nullable(string2())),
  scopes: optional(nullable(array(AvailableScope$outboundSchema)))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/organizationaccesstokensupdate.js
var OrganizationAccessTokensUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  organizationAccessTokenUpdate: OrganizationAccessTokenUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationAccessTokenUpdate: "OrganizationAccessTokenUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationAccessTokensUpdate.js
function organizationAccessTokensUpdate(client, request, options) {
  return new APIPromise($do139(client, request, options));
}
async function $do139(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationAccessTokensUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.OrganizationAccessTokenUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/organization-access-tokens/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organization_access_tokens:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, OrganizationAccessToken$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/organizationaccesstokens.js
var OrganizationAccessTokens = class extends ClientSDK {
  /**
   * List
   *
   * @remarks
   * List organization access tokens.
   *
   * **Scopes**: `organization_access_tokens:read` `organization_access_tokens:write`
   */
  async list(request, options) {
    return unwrapResultIterator(organizationAccessTokensList(this, request, options));
  }
  /**
   * Create
   *
   * @remarks
   * **Scopes**: `organization_access_tokens:write`
   */
  async create(request, options) {
    return unwrapAsync(organizationAccessTokensCreate(this, request, options));
  }
  /**
   * Update
   *
   * @remarks
   * **Scopes**: `organization_access_tokens:write`
   */
  async update(request, options) {
    return unwrapAsync(organizationAccessTokensUpdate(this, request, options));
  }
  /**
   * Delete
   *
   * @remarks
   * **Scopes**: `organization_access_tokens:write`
   */
  async delete(request, options) {
    return unwrapAsync(organizationAccessTokensDelete(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationdetails.js
var SwitchingFrom = {
  Paddle: "paddle",
  LemonSqueezy: "lemon_squeezy",
  Gumroad: "gumroad",
  Stripe: "stripe",
  Other: "other"
};
var SwitchingFrom$outboundSchema = _enum2(SwitchingFrom);
var OrganizationDetails$outboundSchema = pipe(object({
  about: string2(),
  productDescription: string2(),
  intendedUse: string2(),
  customerAcquisition: array(string2()),
  futureAnnualRevenue: int(),
  switching: _default2(boolean2(), true),
  switchingFrom: optional(nullable(SwitchingFrom$outboundSchema)),
  previousAnnualRevenue: _default2(int(), 0)
}), transform((v2) => {
  return remap(v2, {
    productDescription: "product_description",
    intendedUse: "intended_use",
    customerAcquisition: "customer_acquisition",
    futureAnnualRevenue: "future_annual_revenue",
    switchingFrom: "switching_from",
    previousAnnualRevenue: "previous_annual_revenue"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationcreate.js
var OrganizationCreate$outboundSchema = pipe(object({
  name: string2(),
  slug: string2(),
  avatarUrl: optional(nullable(string2())),
  email: optional(nullable(string2())),
  website: optional(nullable(string2())),
  socials: optional(nullable(array(OrganizationSocialLink$outboundSchema))),
  details: optional(nullable(OrganizationDetails$outboundSchema)),
  featureSettings: optional(nullable(OrganizationFeatureSettings$outboundSchema)),
  subscriptionSettings: optional(nullable(OrganizationSubscriptionSettings$outboundSchema)),
  notificationSettings: optional(nullable(OrganizationNotificationSettings$outboundSchema)),
  customerEmailSettings: optional(nullable(OrganizationCustomerEmailSettings$outboundSchema)),
  customerPortalSettings: optional(nullable(OrganizationCustomerPortalSettings$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    avatarUrl: "avatar_url",
    featureSettings: "feature_settings",
    subscriptionSettings: "subscription_settings",
    notificationSettings: "notification_settings",
    customerEmailSettings: "customer_email_settings",
    customerPortalSettings: "customer_portal_settings"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationsCreate.js
function organizationsCreate(client, request, options) {
  return new APIPromise($do140(client, request, options));
}
async function $do140(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/organizations/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organizations:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Organization$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/organizationsget.js
var OrganizationsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationsGet.js
function organizationsGet(client, request, options) {
  return new APIPromise($do141(client, request, options));
}
async function $do141(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/organizations/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organizations:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Organization$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceorganization.js
var ListResourceOrganization$inboundSchema = object({
  items: array(Organization$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationsortproperty.js
var OrganizationSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Slug: "slug",
  MinusSlug: "-slug",
  Name: "name",
  MinusName: "-name",
  NextReviewThreshold: "next_review_threshold",
  MinusNextReviewThreshold: "-next_review_threshold",
  DaysInStatus: "days_in_status",
  MinusDaysInStatus: "-days_in_status"
};
var OrganizationSortProperty$outboundSchema = _enum2(OrganizationSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/organizationslist.js
var OrganizationsListRequest$outboundSchema = object({
  slug: optional(nullable(string2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(OrganizationSortProperty$outboundSchema)))
});
var OrganizationsListResponse$inboundSchema = pipe(object({
  Result: ListResourceOrganization$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationsList.js
function organizationsList(client, request, options) {
  return new APIPromise($do142(client, request, options));
}
async function $do142(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/organizations/")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "page": payload.page,
    "slug": payload.slug,
    "sorting": payload.sorting
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organizations:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, OrganizationsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => organizationsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/organizationupdate.js
var OrganizationUpdate$outboundSchema = pipe(object({
  name: optional(nullable(string2())),
  avatarUrl: optional(nullable(string2())),
  email: optional(nullable(string2())),
  website: optional(nullable(string2())),
  socials: optional(nullable(array(OrganizationSocialLink$outboundSchema))),
  details: optional(nullable(OrganizationDetails$outboundSchema)),
  featureSettings: optional(nullable(OrganizationFeatureSettings$outboundSchema)),
  subscriptionSettings: optional(nullable(OrganizationSubscriptionSettings$outboundSchema)),
  notificationSettings: optional(nullable(OrganizationNotificationSettings$outboundSchema)),
  customerEmailSettings: optional(nullable(OrganizationCustomerEmailSettings$outboundSchema)),
  customerPortalSettings: optional(nullable(OrganizationCustomerPortalSettings$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    avatarUrl: "avatar_url",
    featureSettings: "feature_settings",
    subscriptionSettings: "subscription_settings",
    notificationSettings: "notification_settings",
    customerEmailSettings: "customer_email_settings",
    customerPortalSettings: "customer_portal_settings"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/organizationsupdate.js
var OrganizationsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  organizationUpdate: OrganizationUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    organizationUpdate: "OrganizationUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/organizationsUpdate.js
function organizationsUpdate(client, request, options) {
  return new APIPromise($do143(client, request, options));
}
async function $do143(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(OrganizationsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.OrganizationUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/organizations/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "organizations:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Organization$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/organizations.js
var Organizations = class extends ClientSDK {
  /**
   * List Organizations
   *
   * @remarks
   * List organizations.
   *
   * **Scopes**: `organizations:read` `organizations:write`
   */
  async list(request, options) {
    return unwrapResultIterator(organizationsList(this, request, options));
  }
  /**
   * Create Organization
   *
   * @remarks
   * Create an organization.
   *
   * **Scopes**: `organizations:write`
   */
  async create(request, options) {
    return unwrapAsync(organizationsCreate(this, request, options));
  }
  /**
   * Get Organization
   *
   * @remarks
   * Get an organization by ID.
   *
   * **Scopes**: `organizations:read` `organizations:write`
   */
  async get(request, options) {
    return unwrapAsync(organizationsGet(this, request, options));
  }
  /**
   * Update Organization
   *
   * @remarks
   * Update an organization.
   *
   * **Scopes**: `organizations:write`
   */
  async update(request, options) {
    return unwrapAsync(organizationsUpdate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/cardpaymentmetadata.js
var CardPaymentMetadata$inboundSchema = object({
  brand: string2(),
  last4: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/paymentstatus.js
var PaymentStatus = {
  Pending: "pending",
  Succeeded: "succeeded",
  Failed: "failed"
};
var PaymentStatus$inboundSchema = _enum2(PaymentStatus);
var PaymentStatus$outboundSchema = PaymentStatus$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/cardpayment.js
var CardPayment$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  processor: PaymentProcessor$inboundSchema,
  status: PaymentStatus$inboundSchema,
  amount: int(),
  currency: string2(),
  method: literal("card"),
  decline_reason: nullable(string2()),
  decline_message: nullable(string2()),
  organization_id: string2(),
  checkout_id: nullable(string2()),
  order_id: nullable(string2()),
  processor_metadata: optional(record(string2(), any())),
  method_metadata: CardPaymentMetadata$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "decline_reason": "declineReason",
    "decline_message": "declineMessage",
    "organization_id": "organizationId",
    "checkout_id": "checkoutId",
    "order_id": "orderId",
    "processor_metadata": "processorMetadata",
    "method_metadata": "methodMetadata"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/genericpayment.js
var GenericPayment$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  processor: PaymentProcessor$inboundSchema,
  status: PaymentStatus$inboundSchema,
  amount: int(),
  currency: string2(),
  method: string2(),
  decline_reason: nullable(string2()),
  decline_message: nullable(string2()),
  organization_id: string2(),
  checkout_id: nullable(string2()),
  order_id: nullable(string2()),
  processor_metadata: optional(record(string2(), any()))
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "decline_reason": "declineReason",
    "decline_message": "declineMessage",
    "organization_id": "organizationId",
    "checkout_id": "checkoutId",
    "order_id": "orderId",
    "processor_metadata": "processorMetadata"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/payment.js
var Payment$inboundSchema = smartUnion([CardPayment$inboundSchema, GenericPayment$inboundSchema]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/paymentsget.js
var PaymentsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/paymentsGet.js
function paymentsGet(client, request, options) {
  return new APIPromise($do144(client, request, options));
}
async function $do144(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(PaymentsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/payments/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "payments:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Payment$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresource.js
var ListResource$inboundSchema = object({
  items: array(Payment$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/paymentsortproperty.js
var PaymentSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Status: "status",
  MinusStatus: "-status",
  Amount: "amount",
  MinusAmount: "-amount",
  Method: "method",
  MinusMethod: "-method"
};
var PaymentSortProperty$outboundSchema = _enum2(PaymentSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/paymentslist.js
var PaymentsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var PaymentsListQueryParamCheckoutIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var PaymentsListQueryParamOrderIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var PaymentsListQueryParamStatusFilter$outboundSchema = smartUnion([
  PaymentStatus$outboundSchema,
  array(PaymentStatus$outboundSchema)
]);
var MethodFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerEmailFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var PaymentsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  checkoutId: optional(nullable(smartUnion([string2(), array(string2())]))),
  orderId: optional(nullable(smartUnion([string2(), array(string2())]))),
  status: optional(nullable(smartUnion([
    PaymentStatus$outboundSchema,
    array(PaymentStatus$outboundSchema)
  ]))),
  method: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerEmail: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(PaymentSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    checkoutId: "checkout_id",
    orderId: "order_id",
    customerEmail: "customer_email"
  });
}));
var PaymentsListResponse$inboundSchema = pipe(object({
  Result: ListResource$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/paymentsList.js
function paymentsList(client, request, options) {
  return new APIPromise($do145(client, request, options));
}
async function $do145(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(PaymentsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/payments/")();
  const query = encodeFormQuery({
    "checkout_id": payload.checkout_id,
    "customer_email": payload.customer_email,
    "limit": payload.limit,
    "method": payload.method,
    "order_id": payload.order_id,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "sorting": payload.sorting,
    "status": payload.status
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "payments:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, PaymentsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => paymentsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/payments.js
var Payments = class extends ClientSDK {
  /**
   * List Payments
   *
   * @remarks
   * List payments.
   *
   * **Scopes**: `payments:read`
   */
  async list(request, options) {
    return unwrapResultIterator(paymentsList(this, request, options));
  }
  /**
   * Get Payment
   *
   * @remarks
   * Get a payment by ID.
   *
   * **Scopes**: `payments:read`
   */
  async get(request, options) {
    return unwrapAsync(paymentsGet(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/attachedcustomfieldcreate.js
var AttachedCustomFieldCreate$outboundSchema = pipe(object({
  customFieldId: string2(),
  required: boolean2()
}), transform((v2) => {
  return remap(v2, {
    customFieldId: "custom_field_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productcreateonetime.js
var ProductCreateOneTimeMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var ProductCreateOneTimePrices$outboundSchema = union([
  ProductPriceCustomCreate$outboundSchema,
  ProductPriceFixedCreate$outboundSchema,
  ProductPriceFreeCreate$outboundSchema,
  ProductPriceMeteredUnitCreate$outboundSchema,
  ProductPriceSeatBasedCreate$outboundSchema
]);
var ProductCreateOneTime$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  description: optional(nullable(string2())),
  prices: array(union([
    ProductPriceCustomCreate$outboundSchema,
    ProductPriceFixedCreate$outboundSchema,
    ProductPriceFreeCreate$outboundSchema,
    ProductPriceMeteredUnitCreate$outboundSchema,
    ProductPriceSeatBasedCreate$outboundSchema
  ])),
  medias: optional(nullable(array(string2()))),
  attachedCustomFields: optional(array(AttachedCustomFieldCreate$outboundSchema)),
  organizationId: optional(nullable(string2())),
  recurringInterval: optional(nullable(any())),
  recurringIntervalCount: optional(nullable(any()))
}), transform((v2) => {
  return remap(v2, {
    attachedCustomFields: "attached_custom_fields",
    organizationId: "organization_id",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productcreaterecurring.js
var ProductCreateRecurringMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var ProductCreateRecurringPrices$outboundSchema = union([
  ProductPriceCustomCreate$outboundSchema,
  ProductPriceFixedCreate$outboundSchema,
  ProductPriceFreeCreate$outboundSchema,
  ProductPriceMeteredUnitCreate$outboundSchema,
  ProductPriceSeatBasedCreate$outboundSchema
]);
var ProductCreateRecurring$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  name: string2(),
  description: optional(nullable(string2())),
  prices: array(union([
    ProductPriceCustomCreate$outboundSchema,
    ProductPriceFixedCreate$outboundSchema,
    ProductPriceFreeCreate$outboundSchema,
    ProductPriceMeteredUnitCreate$outboundSchema,
    ProductPriceSeatBasedCreate$outboundSchema
  ])),
  medias: optional(nullable(array(string2()))),
  attachedCustomFields: optional(array(AttachedCustomFieldCreate$outboundSchema)),
  organizationId: optional(nullable(string2())),
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  recurringInterval: SubscriptionRecurringInterval$outboundSchema,
  recurringIntervalCount: _default2(int(), 1)
}), transform((v2) => {
  return remap(v2, {
    attachedCustomFields: "attached_custom_fields",
    organizationId: "organization_id",
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productcreate.js
var ProductCreate$outboundSchema = smartUnion([
  ProductCreateRecurring$outboundSchema,
  ProductCreateOneTime$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/productsCreate.js
function productsCreate(client, request, options) {
  return new APIPromise($do146(client, request, options));
}
async function $do146(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(ProductCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/products/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "products:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Product$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/productsget.js
var ProductsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/productsGet.js
function productsGet(client, request, options) {
  return new APIPromise($do147(client, request, options));
}
async function $do147(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(ProductsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/products/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "products:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Product$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourceproduct.js
var ListResourceProduct$inboundSchema = object({
  items: array(Product$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productsortproperty.js
var ProductSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Name: "name",
  MinusName: "-name",
  PriceAmountType: "price_amount_type",
  MinusPriceAmountType: "-price_amount_type",
  PriceAmount: "price_amount",
  MinusPriceAmount: "-price_amount"
};
var ProductSortProperty$outboundSchema = _enum2(ProductSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/productslist.js
var QueryParamProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var ProductsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var BenefitIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var ProductsListRequest$outboundSchema = pipe(object({
  id: optional(nullable(smartUnion([string2(), array(string2())]))),
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  query: optional(nullable(string2())),
  isArchived: optional(nullable(boolean2())),
  isRecurring: optional(nullable(boolean2())),
  benefitId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(ProductSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), MetadataQuery$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    isArchived: "is_archived",
    isRecurring: "is_recurring",
    benefitId: "benefit_id"
  });
}));
var ProductsListResponse$inboundSchema = pipe(object({
  Result: ListResourceProduct$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/productsList.js
function productsList(client, request, options) {
  return new APIPromise($do148(client, request, options));
}
async function $do148(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(ProductsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/products/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "benefit_id": payload.benefit_id,
    "id": payload.id,
    "is_archived": payload.is_archived,
    "is_recurring": payload.is_recurring,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "query": payload.query,
    "sorting": payload.sorting
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "products:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, ProductsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => productsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/existingproductprice.js
var ExistingProductPrice$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productupdate.js
var ProductUpdateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var Two$outboundSchema = union([
  ProductPriceCustomCreate$outboundSchema,
  ProductPriceFixedCreate$outboundSchema,
  ProductPriceFreeCreate$outboundSchema,
  ProductPriceMeteredUnitCreate$outboundSchema,
  ProductPriceSeatBasedCreate$outboundSchema
]);
var ProductUpdatePrices$outboundSchema = smartUnion([
  ExistingProductPrice$outboundSchema,
  union([
    ProductPriceCustomCreate$outboundSchema,
    ProductPriceFixedCreate$outboundSchema,
    ProductPriceFreeCreate$outboundSchema,
    ProductPriceMeteredUnitCreate$outboundSchema,
    ProductPriceSeatBasedCreate$outboundSchema
  ])
]);
var ProductUpdate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  trialInterval: optional(nullable(TrialInterval$outboundSchema)),
  trialIntervalCount: optional(nullable(int())),
  name: optional(nullable(string2())),
  description: optional(nullable(string2())),
  recurringInterval: optional(nullable(SubscriptionRecurringInterval$outboundSchema)),
  recurringIntervalCount: optional(nullable(int())),
  isArchived: optional(nullable(boolean2())),
  prices: optional(nullable(array(smartUnion([
    ExistingProductPrice$outboundSchema,
    union([
      ProductPriceCustomCreate$outboundSchema,
      ProductPriceFixedCreate$outboundSchema,
      ProductPriceFreeCreate$outboundSchema,
      ProductPriceMeteredUnitCreate$outboundSchema,
      ProductPriceSeatBasedCreate$outboundSchema
    ])
  ])))),
  medias: optional(nullable(array(string2()))),
  attachedCustomFields: optional(nullable(array(AttachedCustomFieldCreate$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    trialInterval: "trial_interval",
    trialIntervalCount: "trial_interval_count",
    recurringInterval: "recurring_interval",
    recurringIntervalCount: "recurring_interval_count",
    isArchived: "is_archived",
    attachedCustomFields: "attached_custom_fields"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/productsupdate.js
var ProductsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  productUpdate: ProductUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    productUpdate: "ProductUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/productsUpdate.js
function productsUpdate(client, request, options) {
  return new APIPromise($do149(client, request, options));
}
async function $do149(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(ProductsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ProductUpdate, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/products/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "products:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Product$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/productbenefitsupdate.js
var ProductBenefitsUpdate$outboundSchema = object({
  benefits: array(string2())
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/productsupdatebenefits.js
var ProductsUpdateBenefitsRequest$outboundSchema = pipe(object({
  id: string2(),
  productBenefitsUpdate: ProductBenefitsUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    productBenefitsUpdate: "ProductBenefitsUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/productsUpdateBenefits.js
function productsUpdateBenefits(client, request, options) {
  return new APIPromise($do150(client, request, options));
}
async function $do150(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(ProductsUpdateBenefitsRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ProductBenefitsUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/products/{id}/benefits")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "products:update_benefits",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Product$inboundSchema), jsonErr(403, NotPermitted$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/products.js
var Products = class extends ClientSDK {
  /**
   * List Products
   *
   * @remarks
   * List products.
   *
   * **Scopes**: `products:read` `products:write`
   */
  async list(request, options) {
    return unwrapResultIterator(productsList(this, request, options));
  }
  /**
   * Create Product
   *
   * @remarks
   * Create a product.
   *
   * **Scopes**: `products:write`
   */
  async create(request, options) {
    return unwrapAsync(productsCreate(this, request, options));
  }
  /**
   * Get Product
   *
   * @remarks
   * Get a product by ID.
   *
   * **Scopes**: `products:read` `products:write`
   */
  async get(request, options) {
    return unwrapAsync(productsGet(this, request, options));
  }
  /**
   * Update Product
   *
   * @remarks
   * Update a product.
   *
   * **Scopes**: `products:write`
   */
  async update(request, options) {
    return unwrapAsync(productsUpdate(this, request, options));
  }
  /**
   * Update Product Benefits
   *
   * @remarks
   * Update benefits granted by a product.
   *
   * **Scopes**: `products:write`
   */
  async updateBenefits(request, options) {
    return unwrapAsync(productsUpdateBenefits(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refundcreate.js
var RefundCreateMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var RefundCreate$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  orderId: string2(),
  reason: RefundReason$outboundSchema,
  amount: int(),
  comment: optional(nullable(string2())),
  revokeBenefits: _default2(boolean2(), false)
}), transform((v2) => {
  return remap(v2, {
    orderId: "order_id",
    revokeBenefits: "revoke_benefits"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/refundedalready.js
var RefundedAlready = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "RefundedAlready";
  }
};
var RefundedAlready$inboundSchema = pipe(object({
  error: literal("RefundedAlready"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new RefundedAlready(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/refundsCreate.js
function refundsCreate(client, request, options) {
  return new APIPromise($do151(client, request, options));
}
async function $do151(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(RefundCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/refunds/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "refunds:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, optional(Refund$inboundSchema)), nil(201, optional(Refund$inboundSchema)), jsonErr(403, RefundedAlready$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcerefund.js
var ListResourceRefund$inboundSchema = object({
  items: array(Refund$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/refundsortproperty.js
var RefundSortProperty = {
  CreatedAt: "created_at",
  MinusCreatedAt: "-created_at",
  Amount: "amount",
  MinusAmount: "-amount"
};
var RefundSortProperty$outboundSchema = _enum2(RefundSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/refundslist.js
var RefundIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var RefundsListQueryParamOrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var OrderIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var SubscriptionIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var RefundsListQueryParamCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var RefundsListQueryParamExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var RefundsListRequest$outboundSchema = pipe(object({
  id: optional(nullable(smartUnion([string2(), array(string2())]))),
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  orderId: optional(nullable(smartUnion([string2(), array(string2())]))),
  subscriptionId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  succeeded: optional(nullable(boolean2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(RefundSortProperty$outboundSchema)))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    orderId: "order_id",
    subscriptionId: "subscription_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id"
  });
}));
var RefundsListResponse$inboundSchema = pipe(object({
  Result: ListResourceRefund$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/refundsList.js
function refundsList(client, request, options) {
  return new APIPromise($do152(client, request, options));
}
async function $do152(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(RefundsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/refunds/")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "external_customer_id": payload.external_customer_id,
    "id": payload.id,
    "limit": payload.limit,
    "order_id": payload.order_id,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "sorting": payload.sorting,
    "subscription_id": payload.subscription_id,
    "succeeded": payload.succeeded
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "refunds:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, RefundsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => refundsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/refunds.js
var Refunds = class extends ClientSDK {
  /**
   * List Refunds
   *
   * @remarks
   * List refunds.
   *
   * **Scopes**: `refunds:read` `refunds:write`
   */
  async list(request, options) {
    return unwrapResultIterator(refundsList(this, request, options));
  }
  /**
   * Create Refund
   *
   * @remarks
   * Create a refund.
   *
   * **Scopes**: `refunds:write`
   */
  async create(request, options) {
    return unwrapAsync(refundsCreate(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncreatecustomer.js
var Metadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var SubscriptionCreateCustomer$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  productId: string2(),
  customerId: string2()
}), transform((v2) => {
  return remap(v2, {
    productId: "product_id",
    customerId: "customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncreateexternalcustomer.js
var SubscriptionCreateExternalCustomerMetadata$outboundSchema = smartUnion([string2(), int(), number2(), boolean2()]);
var SubscriptionCreateExternalCustomer$outboundSchema = pipe(object({
  metadata: optional(record(string2(), smartUnion([string2(), int(), number2(), boolean2()]))),
  productId: string2(),
  externalCustomerId: string2()
}), transform((v2) => {
  return remap(v2, {
    productId: "product_id",
    externalCustomerId: "external_customer_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/subscriptionscreate.js
var SubscriptionsCreateSubscriptionCreate$outboundSchema = smartUnion([
  SubscriptionCreateCustomer$outboundSchema,
  SubscriptionCreateExternalCustomer$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/subscriptionsCreate.js
function subscriptionsCreate(client, request, options) {
  return new APIPromise($do153(client, request, options));
}
async function $do153(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SubscriptionsCreateSubscriptionCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/subscriptions/")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "subscriptions:create",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, Subscription$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/subscriptionsexport.js
var OrganizationId$outboundSchema = smartUnion([string2(), array(string2())]);
var SubscriptionsExportRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())])))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/subscriptionsExport.js
function subscriptionsExport(client, request, options) {
  return new APIPromise($do154(client, request, options));
}
async function $do154(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SubscriptionsExportRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/subscriptions/export")();
  const query = encodeFormQuery({
    "organization_id": payload.organization_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "subscriptions:export",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, any()), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/subscriptionsget.js
var SubscriptionsGetRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/subscriptionsGet.js
function subscriptionsGet(client, request, options) {
  return new APIPromise($do155(client, request, options));
}
async function $do155(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SubscriptionsGetRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "subscriptions:get",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Subscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcesubscription.js
var ListResourceSubscription$inboundSchema = object({
  items: array(Subscription$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionsortproperty.js
var SubscriptionSortProperty = {
  Customer: "customer",
  MinusCustomer: "-customer",
  Status: "status",
  MinusStatus: "-status",
  StartedAt: "started_at",
  MinusStartedAt: "-started_at",
  CurrentPeriodEnd: "current_period_end",
  MinusCurrentPeriodEnd: "-current_period_end",
  EndedAt: "ended_at",
  MinusEndedAt: "-ended_at",
  EndsAt: "ends_at",
  MinusEndsAt: "-ends_at",
  Amount: "amount",
  MinusAmount: "-amount",
  Product: "product",
  MinusProduct: "-product",
  Discount: "discount",
  MinusDiscount: "-discount"
};
var SubscriptionSortProperty$outboundSchema = _enum2(SubscriptionSortProperty);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/subscriptionslist.js
var OrganizationIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var ProductIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var CustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var ExternalCustomerIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var DiscountIDFilter$outboundSchema = smartUnion([string2(), array(string2())]);
var SubscriptionsListRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  productId: optional(nullable(smartUnion([string2(), array(string2())]))),
  customerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  externalCustomerId: optional(nullable(smartUnion([string2(), array(string2())]))),
  discountId: optional(nullable(smartUnion([string2(), array(string2())]))),
  active: optional(nullable(boolean2())),
  cancelAtPeriodEnd: optional(nullable(boolean2())),
  page: _default2(int(), 1),
  limit: _default2(int(), 10),
  sorting: optional(nullable(array(SubscriptionSortProperty$outboundSchema))),
  metadata: optional(nullable(record(string2(), _lazy2(() => MetadataQuery$outboundSchema))))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id",
    productId: "product_id",
    customerId: "customer_id",
    externalCustomerId: "external_customer_id",
    discountId: "discount_id",
    cancelAtPeriodEnd: "cancel_at_period_end"
  });
}));
var SubscriptionsListResponse$inboundSchema = pipe(object({
  Result: ListResourceSubscription$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/subscriptionsList.js
function subscriptionsList(client, request, options) {
  return new APIPromise($do156(client, request, options));
}
async function $do156(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SubscriptionsListRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/subscriptions/")();
  const query = queryJoin(encodeDeepObjectQuery({
    "metadata": payload.metadata
  }), encodeFormQuery({
    "active": payload.active,
    "cancel_at_period_end": payload.cancel_at_period_end,
    "customer_id": payload.customer_id,
    "discount_id": payload.discount_id,
    "external_customer_id": payload.external_customer_id,
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page,
    "product_id": payload.product_id,
    "sorting": payload.sorting
  }));
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "subscriptions:list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, SubscriptionsListResponse$inboundSchema, { key: "Result" }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => subscriptionsList(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/errors/subscriptionlocked.js
var SubscriptionLocked = class extends PolarError {
  constructor(err, httpMeta) {
    const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.error = err.error;
    this.detail = err.detail;
    this.name = "SubscriptionLocked";
  }
};
var SubscriptionLocked$inboundSchema = pipe(object({
  error: literal("SubscriptionLocked"),
  detail: string2(),
  request$: custom((x2) => x2 instanceof Request),
  response$: custom((x2) => x2 instanceof Response),
  body$: string2()
}), transform((v2) => {
  return new SubscriptionLocked(v2, {
    request: v2.request$,
    response: v2.response$,
    body: v2.body$
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/subscriptionsrevoke.js
var SubscriptionsRevokeRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/subscriptionsRevoke.js
function subscriptionsRevoke(client, request, options) {
  return new APIPromise($do157(client, request, options));
}
async function $do157(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SubscriptionsRevokeRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "subscriptions:revoke",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "409", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Subscription$inboundSchema), jsonErr(403, AlreadyCanceledSubscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(409, SubscriptionLocked$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptioncancel.js
var SubscriptionCancel$outboundSchema = pipe(object({
  customerCancellationReason: optional(nullable(CustomerCancellationReason$outboundSchema)),
  customerCancellationComment: optional(nullable(string2())),
  cancelAtPeriodEnd: boolean2()
}), transform((v2) => {
  return remap(v2, {
    customerCancellationReason: "customer_cancellation_reason",
    customerCancellationComment: "customer_cancellation_comment",
    cancelAtPeriodEnd: "cancel_at_period_end"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionrevoke.js
var SubscriptionRevoke$outboundSchema = pipe(object({
  customerCancellationReason: optional(nullable(CustomerCancellationReason$outboundSchema)),
  customerCancellationComment: optional(nullable(string2())),
  revoke: literal(true)
}), transform((v2) => {
  return remap(v2, {
    customerCancellationReason: "customer_cancellation_reason",
    customerCancellationComment: "customer_cancellation_comment"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionupdatebillingperiod.js
var SubscriptionUpdateBillingPeriod$outboundSchema = pipe(object({
  currentBillingPeriodEnd: pipe(date2(), transform((v2) => v2.toISOString()))
}), transform((v2) => {
  return remap(v2, {
    currentBillingPeriodEnd: "current_billing_period_end"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionupdatediscount.js
var SubscriptionUpdateDiscount$outboundSchema = pipe(object({
  discountId: nullable(string2())
}), transform((v2) => {
  return remap(v2, {
    discountId: "discount_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionupdateproduct.js
var SubscriptionUpdateProduct$outboundSchema = pipe(object({
  productId: string2(),
  prorationBehavior: optional(nullable(SubscriptionProrationBehavior$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    productId: "product_id",
    prorationBehavior: "proration_behavior"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionupdateseats.js
var SubscriptionUpdateSeats$outboundSchema = pipe(object({
  seats: int(),
  prorationBehavior: optional(nullable(SubscriptionProrationBehavior$outboundSchema))
}), transform((v2) => {
  return remap(v2, {
    prorationBehavior: "proration_behavior"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionupdatetrial.js
var SubscriptionUpdateTrial$outboundSchema = pipe(object({
  trialEnd: pipe(date2(), transform((v2) => v2.toISOString()))
}), transform((v2) => {
  return remap(v2, {
    trialEnd: "trial_end"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/subscriptionupdate.js
var SubscriptionUpdate$outboundSchema = smartUnion([
  SubscriptionUpdateProduct$outboundSchema,
  SubscriptionUpdateDiscount$outboundSchema,
  SubscriptionUpdateTrial$outboundSchema,
  SubscriptionUpdateSeats$outboundSchema,
  SubscriptionUpdateBillingPeriod$outboundSchema,
  SubscriptionCancel$outboundSchema,
  SubscriptionRevoke$outboundSchema
]);

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/subscriptionsupdate.js
var SubscriptionsUpdateRequest$outboundSchema = pipe(object({
  id: string2(),
  subscriptionUpdate: SubscriptionUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    subscriptionUpdate: "SubscriptionUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/subscriptionsUpdate.js
function subscriptionsUpdate(client, request, options) {
  return new APIPromise($do158(client, request, options));
}
async function $do158(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(SubscriptionsUpdateRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.SubscriptionUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "subscriptions:update",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "409", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, Subscription$inboundSchema), jsonErr(403, AlreadyCanceledSubscription$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(409, SubscriptionLocked$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/subscriptions.js
var Subscriptions = class extends ClientSDK {
  /**
   * List Subscriptions
   *
   * @remarks
   * List subscriptions.
   *
   * **Scopes**: `subscriptions:read` `subscriptions:write`
   */
  async list(request, options) {
    return unwrapResultIterator(subscriptionsList(this, request, options));
  }
  /**
   * Create Subscription
   *
   * @remarks
   * Create a subscription programmatically.
   *
   * This endpoint only allows to create subscription on free products.
   * For paid products, use the checkout flow.
   *
   * No initial order will be created and no confirmation email will be sent.
   *
   * **Scopes**: `subscriptions:write`
   */
  async create(request, options) {
    return unwrapAsync(subscriptionsCreate(this, request, options));
  }
  /**
   * Export Subscriptions
   *
   * @remarks
   * Export subscriptions as a CSV file.
   *
   * **Scopes**: `subscriptions:read` `subscriptions:write`
   */
  async export(request, options) {
    return unwrapAsync(subscriptionsExport(this, request, options));
  }
  /**
   * Get Subscription
   *
   * @remarks
   * Get a subscription by ID.
   *
   * **Scopes**: `subscriptions:read` `subscriptions:write`
   */
  async get(request, options) {
    return unwrapAsync(subscriptionsGet(this, request, options));
  }
  /**
   * Update Subscription
   *
   * @remarks
   * Update a subscription.
   *
   * **Scopes**: `subscriptions:write`
   */
  async update(request, options) {
    return unwrapAsync(subscriptionsUpdate(this, request, options));
  }
  /**
   * Revoke Subscription
   *
   * @remarks
   * Revoke a subscription, i.e cancel immediately.
   *
   * **Scopes**: `subscriptions:write`
   */
  async revoke(request, options) {
    return unwrapAsync(subscriptionsRevoke(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookeventtype.js
var WebhookEventType = {
  CheckoutCreated: "checkout.created",
  CheckoutUpdated: "checkout.updated",
  CustomerCreated: "customer.created",
  CustomerUpdated: "customer.updated",
  CustomerDeleted: "customer.deleted",
  CustomerStateChanged: "customer.state_changed",
  CustomerSeatAssigned: "customer_seat.assigned",
  CustomerSeatClaimed: "customer_seat.claimed",
  CustomerSeatRevoked: "customer_seat.revoked",
  OrderCreated: "order.created",
  OrderUpdated: "order.updated",
  OrderPaid: "order.paid",
  OrderRefunded: "order.refunded",
  SubscriptionCreated: "subscription.created",
  SubscriptionUpdated: "subscription.updated",
  SubscriptionActive: "subscription.active",
  SubscriptionCanceled: "subscription.canceled",
  SubscriptionUncanceled: "subscription.uncanceled",
  SubscriptionRevoked: "subscription.revoked",
  SubscriptionPastDue: "subscription.past_due",
  RefundCreated: "refund.created",
  RefundUpdated: "refund.updated",
  ProductCreated: "product.created",
  ProductUpdated: "product.updated",
  BenefitCreated: "benefit.created",
  BenefitUpdated: "benefit.updated",
  BenefitGrantCreated: "benefit_grant.created",
  BenefitGrantCycled: "benefit_grant.cycled",
  BenefitGrantUpdated: "benefit_grant.updated",
  BenefitGrantRevoked: "benefit_grant.revoked",
  OrganizationUpdated: "organization.updated"
};
var WebhookEventType$inboundSchema = _enum2(WebhookEventType);
var WebhookEventType$outboundSchema = WebhookEventType$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookformat.js
var WebhookFormat = {
  Raw: "raw",
  Discord: "discord",
  Slack: "slack"
};
var WebhookFormat$inboundSchema = _enum2(WebhookFormat);
var WebhookFormat$outboundSchema = WebhookFormat$inboundSchema;

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookendpoint.js
var WebhookEndpoint$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  url: string2(),
  format: WebhookFormat$inboundSchema,
  secret: string2(),
  organization_id: string2(),
  events: array(WebhookEventType$inboundSchema),
  enabled: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "organization_id": "organizationId"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookendpointcreate.js
var WebhookEndpointCreate$outboundSchema = pipe(object({
  url: string2(),
  secret: optional(nullable(string2())),
  format: WebhookFormat$outboundSchema,
  events: array(WebhookEventType$outboundSchema),
  organizationId: optional(nullable(string2()))
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksCreateWebhookEndpoint.js
function webhooksCreateWebhookEndpoint(client, request, options) {
  return new APIPromise($do159(client, request, options));
}
async function $do159(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhookEndpointCreate$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/v1/webhooks/endpoints")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:create_webhook_endpoint",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(201, WebhookEndpoint$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhooksdeletewebhookendpoint.js
var WebhooksDeleteWebhookEndpointRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksDeleteWebhookEndpoint.js
function webhooksDeleteWebhookEndpoint(client, request, options) {
  return new APIPromise($do160(client, request, options));
}
async function $do160(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksDeleteWebhookEndpointRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/webhooks/endpoints/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:delete_webhook_endpoint",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(nil(204, _void2()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhooksgetwebhookendpoint.js
var WebhooksGetWebhookEndpointRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksGetWebhookEndpoint.js
function webhooksGetWebhookEndpoint(client, request, options) {
  return new APIPromise($do161(client, request, options));
}
async function $do161(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksGetWebhookEndpointRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/webhooks/endpoints/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:get_webhook_endpoint",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, WebhookEndpoint$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookevent.js
var WebhookEvent$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  last_http_code: optional(nullable(int())),
  succeeded: optional(nullable(boolean2())),
  skipped: boolean2(),
  payload: nullable(string2()),
  type: WebhookEventType$inboundSchema,
  is_archived: boolean2()
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "last_http_code": "lastHttpCode",
    "is_archived": "isArchived"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookdelivery.js
var WebhookDelivery$inboundSchema = pipe(object({
  created_at: pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2))),
  modified_at: nullable(pipe(iso_exports.datetime({ offset: true }), transform((v2) => new Date(v2)))),
  id: string2(),
  succeeded: boolean2(),
  http_code: nullable(int()),
  response: nullable(string2()),
  webhook_event: WebhookEvent$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "created_at": "createdAt",
    "modified_at": "modifiedAt",
    "http_code": "httpCode",
    "webhook_event": "webhookEvent"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcewebhookdelivery.js
var ListResourceWebhookDelivery$inboundSchema = object({
  items: array(WebhookDelivery$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhookslistwebhookdeliveries.js
var HttpCodeClass = {
  Twoxx: "2xx",
  Threexx: "3xx",
  Fourxx: "4xx",
  Fivexx: "5xx"
};
var EndpointId$outboundSchema = smartUnion([string2(), array(string2())]);
var HttpCodeClass$outboundSchema = _enum2(HttpCodeClass);
var EventType$outboundSchema = smartUnion([
  WebhookEventType$outboundSchema,
  array(WebhookEventType$outboundSchema)
]);
var WebhooksListWebhookDeliveriesRequest$outboundSchema = pipe(object({
  endpointId: optional(nullable(smartUnion([string2(), array(string2())]))),
  startTimestamp: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  endTimestamp: optional(nullable(pipe(date2(), transform((v2) => v2.toISOString())))),
  succeeded: optional(nullable(boolean2())),
  query: optional(nullable(string2())),
  httpCodeClass: optional(nullable(HttpCodeClass$outboundSchema)),
  eventType: optional(nullable(smartUnion([
    WebhookEventType$outboundSchema,
    array(WebhookEventType$outboundSchema)
  ]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    endpointId: "endpoint_id",
    startTimestamp: "start_timestamp",
    endTimestamp: "end_timestamp",
    httpCodeClass: "http_code_class",
    eventType: "event_type"
  });
}));
var WebhooksListWebhookDeliveriesResponse$inboundSchema = pipe(object({
  Result: ListResourceWebhookDelivery$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksListWebhookDeliveries.js
function webhooksListWebhookDeliveries(client, request, options) {
  return new APIPromise($do162(client, request, options));
}
async function $do162(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksListWebhookDeliveriesRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/webhooks/deliveries")();
  const query = encodeFormQuery({
    "end_timestamp": payload.end_timestamp,
    "endpoint_id": payload.endpoint_id,
    "event_type": payload.event_type,
    "http_code_class": payload.http_code_class,
    "limit": payload.limit,
    "page": payload.page,
    "query": payload.query,
    "start_timestamp": payload.start_timestamp,
    "succeeded": payload.succeeded
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:list_webhook_deliveries",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, WebhooksListWebhookDeliveriesResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => webhooksListWebhookDeliveries(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/listresourcewebhookendpoint.js
var ListResourceWebhookEndpoint$inboundSchema = object({
  items: array(WebhookEndpoint$inboundSchema),
  pagination: Pagination$inboundSchema
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhookslistwebhookendpoints.js
var QueryParamOrganizationId$outboundSchema = smartUnion([string2(), array(string2())]);
var WebhooksListWebhookEndpointsRequest$outboundSchema = pipe(object({
  organizationId: optional(nullable(smartUnion([string2(), array(string2())]))),
  page: _default2(int(), 1),
  limit: _default2(int(), 10)
}), transform((v2) => {
  return remap(v2, {
    organizationId: "organization_id"
  });
}));
var WebhooksListWebhookEndpointsResponse$inboundSchema = pipe(object({
  Result: ListResourceWebhookEndpoint$inboundSchema
}), transform((v2) => {
  return remap(v2, {
    "Result": "result"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksListWebhookEndpoints.js
function webhooksListWebhookEndpoints(client, request, options) {
  return new APIPromise($do163(client, request, options));
}
async function $do163(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksListWebhookEndpointsRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [haltIterator(parsed), { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/webhooks/endpoints")();
  const query = encodeFormQuery({
    "limit": payload.limit,
    "organization_id": payload.organization_id,
    "page": payload.page
  });
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:list_webhook_endpoints",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [haltIterator(requestRes), { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [haltIterator(doResult), { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result, raw] = await match(json(200, WebhooksListWebhookEndpointsResponse$inboundSchema, {
    key: "Result"
  }), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [haltIterator(result), {
      status: "complete",
      request: req,
      response
    }];
  }
  const nextFunc = (responseData) => {
    const page2 = request?.page ?? 1;
    const nextPage = page2 + 1;
    const numPages = dlv(responseData, "pagination.max_page");
    if (typeof numPages !== "number" || numPages <= page2) {
      return { next: () => null };
    }
    if (!responseData) {
      return { next: () => null };
    }
    const results = dlv(responseData, "items");
    if (!Array.isArray(results) || !results.length) {
      return { next: () => null };
    }
    const limit = request?.limit ?? 10;
    if (results.length < limit) {
      return { next: () => null };
    }
    const nextVal = () => webhooksListWebhookEndpoints(client, {
      ...request,
      page: nextPage
    }, options);
    return { next: nextVal, "~next": { page: nextPage } };
  };
  const page = { ...result, ...nextFunc(raw) };
  return [{ ...page, ...createPageIterator(page, (v2) => !v2.ok) }, {
    status: "complete",
    request: req,
    response
  }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhooksredeliverwebhookevent.js
var WebhooksRedeliverWebhookEventRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksRedeliverWebhookEvent.js
function webhooksRedeliverWebhookEvent(client, request, options) {
  return new APIPromise($do164(client, request, options));
}
async function $do164(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksRedeliverWebhookEventRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/webhooks/events/{id}/redeliver")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:redeliver_webhook_event",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(202, any()), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhooksresetwebhookendpointsecret.js
var WebhooksResetWebhookEndpointSecretRequest$outboundSchema = object({
  id: string2()
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksResetWebhookEndpointSecret.js
function webhooksResetWebhookEndpointSecret(client, request, options) {
  return new APIPromise($do165(client, request, options));
}
async function $do165(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksResetWebhookEndpointSecretRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/webhooks/endpoints/{id}/secret")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:reset_webhook_endpoint_secret",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, WebhookEndpoint$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/components/webhookendpointupdate.js
var WebhookEndpointUpdate$outboundSchema = object({
  url: optional(nullable(string2())),
  secret: optional(nullable(string2())),
  format: optional(nullable(WebhookFormat$outboundSchema)),
  events: optional(nullable(array(WebhookEventType$outboundSchema))),
  enabled: optional(nullable(boolean2()))
});

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/models/operations/webhooksupdatewebhookendpoint.js
var WebhooksUpdateWebhookEndpointRequest$outboundSchema = pipe(object({
  id: string2(),
  webhookEndpointUpdate: WebhookEndpointUpdate$outboundSchema
}), transform((v2) => {
  return remap(v2, {
    webhookEndpointUpdate: "WebhookEndpointUpdate"
  });
}));

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/funcs/webhooksUpdateWebhookEndpoint.js
function webhooksUpdateWebhookEndpoint(client, request, options) {
  return new APIPromise($do166(client, request, options));
}
async function $do166(client, request, options) {
  const parsed = safeParse2(request, (value) => parse(WebhooksUpdateWebhookEndpointRequest$outboundSchema, value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.WebhookEndpointUpdate, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/webhooks/endpoints/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const secConfig = await extractSecurity(client._options.accessToken);
  const securityInput = secConfig == null ? {} : { accessToken: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "webhooks:update_webhook_endpoint",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.accessToken,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "422", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json(200, WebhookEndpoint$inboundSchema), jsonErr(404, ResourceNotFound$inboundSchema), jsonErr(422, HTTPValidationError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/webhooks.js
var Webhooks = class extends ClientSDK {
  /**
   * List Webhook Endpoints
   *
   * @remarks
   * List webhook endpoints.
   *
   * **Scopes**: `webhooks:read` `webhooks:write`
   */
  async listWebhookEndpoints(request, options) {
    return unwrapResultIterator(webhooksListWebhookEndpoints(this, request, options));
  }
  /**
   * Create Webhook Endpoint
   *
   * @remarks
   * Create a webhook endpoint.
   *
   * **Scopes**: `webhooks:write`
   */
  async createWebhookEndpoint(request, options) {
    return unwrapAsync(webhooksCreateWebhookEndpoint(this, request, options));
  }
  /**
   * Get Webhook Endpoint
   *
   * @remarks
   * Get a webhook endpoint by ID.
   *
   * **Scopes**: `webhooks:read` `webhooks:write`
   */
  async getWebhookEndpoint(request, options) {
    return unwrapAsync(webhooksGetWebhookEndpoint(this, request, options));
  }
  /**
   * Update Webhook Endpoint
   *
   * @remarks
   * Update a webhook endpoint.
   *
   * **Scopes**: `webhooks:write`
   */
  async updateWebhookEndpoint(request, options) {
    return unwrapAsync(webhooksUpdateWebhookEndpoint(this, request, options));
  }
  /**
   * Delete Webhook Endpoint
   *
   * @remarks
   * Delete a webhook endpoint.
   *
   * **Scopes**: `webhooks:write`
   */
  async deleteWebhookEndpoint(request, options) {
    return unwrapAsync(webhooksDeleteWebhookEndpoint(this, request, options));
  }
  /**
   * Reset Webhook Endpoint Secret
   *
   * @remarks
   * Regenerate a webhook endpoint secret.
   *
   * **Scopes**: `webhooks:write`
   */
  async resetWebhookEndpointSecret(request, options) {
    return unwrapAsync(webhooksResetWebhookEndpointSecret(this, request, options));
  }
  /**
   * List Webhook Deliveries
   *
   * @remarks
   * List webhook deliveries.
   *
   * Deliveries are all the attempts to deliver a webhook event to an endpoint.
   *
   * **Scopes**: `webhooks:read` `webhooks:write`
   */
  async listWebhookDeliveries(request, options) {
    return unwrapResultIterator(webhooksListWebhookDeliveries(this, request, options));
  }
  /**
   * Redeliver Webhook Event
   *
   * @remarks
   * Schedule the re-delivery of a webhook event.
   *
   * **Scopes**: `webhooks:write`
   */
  async redeliverWebhookEvent(request, options) {
    return unwrapAsync(webhooksRedeliverWebhookEvent(this, request, options));
  }
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/sdk/sdk.js
var Polar = class extends ClientSDK {
  get organizations() {
    return this._organizations ?? (this._organizations = new Organizations(this._options));
  }
  get subscriptions() {
    return this._subscriptions ?? (this._subscriptions = new Subscriptions(this._options));
  }
  get oauth2() {
    return this._oauth2 ?? (this._oauth2 = new Oauth2(this._options));
  }
  get benefits() {
    return this._benefits ?? (this._benefits = new Benefits(this._options));
  }
  get benefitGrants() {
    return this._benefitGrants ?? (this._benefitGrants = new BenefitGrants(this._options));
  }
  get webhooks() {
    return this._webhooks ?? (this._webhooks = new Webhooks(this._options));
  }
  get products() {
    return this._products ?? (this._products = new Products(this._options));
  }
  get orders() {
    return this._orders ?? (this._orders = new Orders(this._options));
  }
  get refunds() {
    return this._refunds ?? (this._refunds = new Refunds(this._options));
  }
  get disputes() {
    return this._disputes ?? (this._disputes = new Disputes(this._options));
  }
  get checkouts() {
    return this._checkouts ?? (this._checkouts = new Checkouts(this._options));
  }
  get files() {
    return this._files ?? (this._files = new Files(this._options));
  }
  get metrics() {
    return this._metrics ?? (this._metrics = new Metrics(this._options));
  }
  get licenseKeys() {
    return this._licenseKeys ?? (this._licenseKeys = new LicenseKeys(this._options));
  }
  get checkoutLinks() {
    return this._checkoutLinks ?? (this._checkoutLinks = new CheckoutLinks(this._options));
  }
  get customFields() {
    return this._customFields ?? (this._customFields = new CustomFields(this._options));
  }
  get discounts() {
    return this._discounts ?? (this._discounts = new Discounts(this._options));
  }
  get customers() {
    return this._customers ?? (this._customers = new Customers(this._options));
  }
  get members() {
    return this._members ?? (this._members = new Members(this._options));
  }
  get customerPortal() {
    return this._customerPortal ?? (this._customerPortal = new CustomerPortal(this._options));
  }
  get customerSeats() {
    return this._customerSeats ?? (this._customerSeats = new CustomerSeats(this._options));
  }
  get customerSessions() {
    return this._customerSessions ?? (this._customerSessions = new CustomerSessions(this._options));
  }
  get memberSessions() {
    return this._memberSessions ?? (this._memberSessions = new MemberSessions(this._options));
  }
  get events() {
    return this._events ?? (this._events = new Events(this._options));
  }
  get eventTypes() {
    return this._eventTypes ?? (this._eventTypes = new EventTypes(this._options));
  }
  get meters() {
    return this._meters ?? (this._meters = new Meters(this._options));
  }
  get organizationAccessTokens() {
    return this._organizationAccessTokens ?? (this._organizationAccessTokens = new OrganizationAccessTokens(this._options));
  }
  get customerMeters() {
    return this._customerMeters ?? (this._customerMeters = new CustomerMeters(this._options));
  }
  get payments() {
    return this._payments ?? (this._payments = new Payments(this._options));
  }
  async validateWebhook({ request }) {
    return unwrapAsync(validateWebhook(this, { request }));
  }
};

// src/modules/payment/polar.service.ts
init_config();
var polar = null;
function getPolarInstance() {
  if (!config2.POLAR_ACCESS_TOKEN) {
    return null;
  }
  if (!polar) {
    polar = new Polar({
      accessToken: config2.POLAR_ACCESS_TOKEN,
      server: config2.POLAR_SERVER
    });
  }
  return polar;
}
var PolarBackendService = class {
  getPolarInstance() {
    const instance = getPolarInstance();
    if (!instance) {
      throw new Error(
        "Polar SDK is not configured. Please set POLAR_ACCESS_TOKEN environment variable."
      );
    }
    return instance;
  }
  async createCheckout(params) {
    try {
      const polar4 = this.getPolarInstance();
      const checkout = await polar4.checkouts.create({
        products: [config2.POLAR_PRODUCT_ID],
        customerEmail: params.customerEmail,
        customerName: params.customerName,
        externalCustomerId: params.externalCustomerId,
        successUrl: params.successUrl || config2.SUCCESS_URL,
        returnUrl: params.returnUrl || config2.RETURN_URL
      });
      return {
        checkoutId: checkout.id,
        checkoutUrl: checkout.url,
        expiresAt: checkout.expiresAt,
        status: checkout.status
      };
    } catch (error48) {
      console.error("Failed to create checkout:", error48);
      throw new Error("Checkout creation failed");
    }
  }
  async getCheckout(checkoutId) {
    try {
      const polar4 = this.getPolarInstance();
      const checkout = await polar4.checkouts.get({ id: checkoutId });
      return checkout;
    } catch (error48) {
      console.error("Failed to get checkout:", error48);
      throw error48;
    }
  }
  async createCustomer(params) {
    try {
      const polar4 = this.getPolarInstance();
      const customer = await polar4.customers.create({
        email: params.email,
        name: params.name,
        externalId: params.externalId,
        metadata: params.metadata,
        organizationId: params.organizationId || config2.POLAR_ORGANIZATION_ID
      });
      return {
        customerId: customer.id,
        email: customer.email,
        name: customer.name,
        externalId: customer.externalId
      };
    } catch (error48) {
      console.error("Failed to create customer:", error48);
      throw error48;
    }
  }
  async getCustomer(customerId) {
    try {
      const polar4 = this.getPolarInstance();
      const customer = await polar4.customers.get({ id: customerId });
      return customer;
    } catch (error48) {
      console.error("Failed to get customer:", error48);
      throw error48;
    }
  }
  async getCustomerByExternalId(externalId) {
    try {
      const polar4 = this.getPolarInstance();
      const customer = await polar4.customers.getExternal({
        externalId
      });
      return customer;
    } catch (error48) {
      console.error("Failed to get customer by external ID:", error48);
      return null;
    }
  }
  async listCustomers(limit = 20) {
    try {
      const polar4 = this.getPolarInstance();
      const customersResponse = await polar4.customers.list({
        organizationId: config2.POLAR_ORGANIZATION_ID,
        limit
      });
      const customers = [];
      for await (const page of customersResponse) {
        customers.push(...page.result.items);
        if (customers.length >= limit) break;
      }
      return customers.slice(0, limit);
    } catch (error48) {
      console.error("Failed to list customers:", error48);
      throw error48;
    }
  }
  async getCustomerSubscriptions(customerId) {
    try {
      const polar4 = this.getPolarInstance();
      const subscriptionsResponse = await polar4.subscriptions.list({
        customerId,
        organizationId: config2.POLAR_ORGANIZATION_ID
      });
      const subscriptions2 = [];
      for await (const page of subscriptionsResponse) {
        subscriptions2.push(...page.result.items);
      }
      return subscriptions2;
    } catch (error48) {
      console.error("Failed to get customer subscriptions:", error48);
      throw error48;
    }
  }
  async getSubscription(subscriptionId) {
    try {
      const polar4 = this.getPolarInstance();
      const subscription = await polar4.subscriptions.get({
        id: subscriptionId
      });
      return subscription;
    } catch (error48) {
      console.error("Failed to get subscription:", error48);
      throw error48;
    }
  }
  async hasActiveSubscription(customerId) {
    try {
      const subscriptions2 = await this.getCustomerSubscriptions(customerId);
      const productId = config2.POLAR_PRODUCT_ID;
      const activeSubscription = subscriptions2.find((sub) => {
        const isActive = sub.status === "active";
        if (productId) {
          return isActive && sub.productId === productId;
        }
        return isActive;
      });
      return !!activeSubscription;
    } catch (error48) {
      console.error("Failed to check subscription status:", error48);
      return false;
    }
  }
  async revokeSubscription(subscriptionId) {
    try {
      const polar4 = this.getPolarInstance();
      const subscription = await polar4.subscriptions.revoke({
        id: subscriptionId
      });
      return subscription;
    } catch (error48) {
      console.error("Failed to revoke subscription:", error48);
      throw error48;
    }
  }
  async cancelSubscriptionAtPeriodEnd(subscriptionId) {
    try {
      const subscription = await polar.subscriptions.update({
        id: subscriptionId,
        subscriptionUpdate: {
          cancelAtPeriodEnd: true
        }
      });
      return subscription;
    } catch (error48) {
      console.error("Failed to cancel subscription:", error48);
      throw error48;
    }
  }
  async listProducts() {
    try {
      const productsResponse = await polar.products.list({
        organizationId: config2.POLAR_ORGANIZATION_ID
      });
      const products = [];
      for await (const page of productsResponse) {
        products.push(...page.result.items);
      }
      return products;
    } catch (error48) {
      console.error("Failed to list products:", error48);
      throw error48;
    }
  }
  async getProduct(productId) {
    try {
      const polar4 = this.getPolarInstance();
      const product2 = await polar4.products.get({ id: productId });
      return product2;
    } catch (error48) {
      console.error("Failed to get product:", error48);
      throw error48;
    }
  }
  async getCustomerOrders(customerId) {
    try {
      const ordersResponse = await polar.orders.list({
        customerId,
        organizationId: config2.POLAR_ORGANIZATION_ID
      });
      const orders2 = [];
      for await (const page of ordersResponse) {
        orders2.push(...page.result.items);
      }
      return orders2;
    } catch (error48) {
      console.error("Failed to get customer orders:", error48);
      throw error48;
    }
  }
  async getOrder(orderId) {
    try {
      const polar4 = this.getPolarInstance();
      const order = await polar4.orders.get({ id: orderId });
      return order;
    } catch (error48) {
      console.error("Failed to get order:", error48);
      throw error48;
    }
  }
  async listBenefits() {
    try {
      const benefitsResponse = await polar.benefits.list({
        organizationId: config2.POLAR_ORGANIZATION_ID
      });
      const benefits = [];
      for await (const page of benefitsResponse) {
        benefits.push(...page.result.items);
      }
      return benefits;
    } catch (error48) {
      console.error("Failed to list benefits:", error48);
      throw error48;
    }
  }
  async checkUserAccess(userExternalId) {
    try {
      const customer = await this.getCustomerByExternalId(userExternalId);
      if (!customer) {
        return { hasAccess: false, subscription: null, customer: null };
      }
      const subscriptions2 = await this.getCustomerSubscriptions(customer.id);
      const activeSubscription = subscriptions2.find(
        (sub) => sub.status === "active"
      );
      return {
        hasAccess: !!activeSubscription,
        subscription: activeSubscription || null,
        customer
      };
    } catch (error48) {
      console.error("Failed to check user access:", error48);
      return { hasAccess: false, subscription: null, customer: null };
    }
  }
  async getCustomerState(customerId) {
    try {
      const polar4 = this.getPolarInstance();
      const state = await polar4.customers.getState({ id: customerId });
      return state;
    } catch (error48) {
      console.error("Failed to get customer state:", error48);
      throw error48;
    }
  }
  async getCustomerStateByExternalId(externalId) {
    try {
      const polar4 = this.getPolarInstance();
      const state = await polar4.customers.getStateExternal({ externalId });
      return state;
    } catch (error48) {
      console.error("Failed to get customer state by external ID:", error48);
      return null;
    }
  }
  async getUserPlanTier(userExternalId) {
    try {
      const { subscription } = await this.checkUserAccess(userExternalId);
      if (!subscription) {
        return "free";
      }
      const productId = subscription.productId;
      const product2 = await this.getProduct(productId);
      const productName = product2.name.toLowerCase();
      if (productName.includes("enterprise")) return "enterprise";
      if (productName.includes("pro")) return "pro";
      if (productName.includes("basic") || productName.includes("starter"))
        return "basic";
      return "basic";
    } catch (error48) {
      console.error("Failed to get user plan tier:", error48);
      return "free";
    }
  }
};
var polarService = new PolarBackendService();

// src/modules/payment.service.ts
init_config();

// src/sample/orders.sample.ts
var ordersSample = [
  {
    id: 1,
    userId: 1,
    totalAmount: 300,
    // 100 + 200 (product 1 + product 2)
    status: "processing",
    shippingAddress: "123 Main St, City, Country",
    paymentMethod: "credit_card",
    notes: "Please deliver before 5 PM",
    createdAt: /* @__PURE__ */ new Date("2026-01-15T10:00:00Z"),
    updatedAt: /* @__PURE__ */ new Date("2026-01-15T10:00:00Z")
  },
  {
    id: 2,
    userId: 1,
    totalAmount: 400,
    // product 4 (Electronics)
    status: "delivered",
    shippingAddress: "456 Oak Ave, Town, Country",
    paymentMethod: "paypal",
    notes: null,
    createdAt: /* @__PURE__ */ new Date("2026-01-10T14:30:00Z"),
    updatedAt: /* @__PURE__ */ new Date("2026-01-12T09:00:00Z")
  },
  {
    id: 3,
    userId: 2,
    totalAmount: 1800,
    // 500 + 600 + 700 (products 5, 6, 7)
    status: "cancelled",
    shippingAddress: "789 Pine Rd, Village, Country",
    paymentMethod: "bank_transfer",
    notes: "Customer requested cancellation",
    createdAt: /* @__PURE__ */ new Date("2026-01-20T08:15:00Z"),
    updatedAt: /* @__PURE__ */ new Date("2026-01-21T11:00:00Z")
  }
];
var orderProductsSample = [
  // Order 1: 2 products
  {
    id: 1,
    orderId: 1,
    productId: 134213432,
    // Product 1
    quantity: 1,
    priceAtOrder: 100,
    createdAt: /* @__PURE__ */ new Date("2026-01-15T10:00:00Z")
  },
  {
    id: 2,
    orderId: 1,
    productId: 134213432,
    // Product 2
    quantity: 1,
    priceAtOrder: 200,
    createdAt: /* @__PURE__ */ new Date("2026-01-15T10:00:00Z")
  },
  // Order 2: 1 product
  {
    id: 3,
    orderId: 2,
    productId: 134213432,
    // Product 4
    quantity: 1,
    priceAtOrder: 400,
    createdAt: /* @__PURE__ */ new Date("2026-01-10T14:30:00Z")
  },
  // Order 3: 3 products
  {
    id: 4,
    orderId: 3,
    productId: 134213432,
    // Product 5
    quantity: 1,
    priceAtOrder: 500,
    createdAt: /* @__PURE__ */ new Date("2026-01-20T08:15:00Z")
  },
  {
    id: 5,
    orderId: 3,
    productId: 134213432,
    // Product 6
    quantity: 1,
    priceAtOrder: 600,
    createdAt: /* @__PURE__ */ new Date("2026-01-20T08:15:00Z")
  },
  {
    id: 6,
    orderId: 3,
    productId: 134213432,
    // Product 7
    quantity: 1,
    priceAtOrder: 700,
    createdAt: /* @__PURE__ */ new Date("2026-01-20T08:15:00Z")
  }
];

// src/sample/payments.sample.ts
var paymentsSample = [
  {
    id: "checkout_1",
    orderId: 1,
    amount: 300,
    currency: "usd",
    status: "pending",
    paymentMethod: "polar",
    createdAt: /* @__PURE__ */ new Date("2026-01-15T10:05:00Z")
  },
  {
    id: "checkout_2",
    orderId: 2,
    amount: 400,
    currency: "usd",
    status: "succeeded",
    paymentMethod: "polar",
    createdAt: /* @__PURE__ */ new Date("2026-01-10T14:35:00Z")
  }
];
function addPayment(payment) {
  paymentsSample.push(payment);
  return payment;
}

// src/modules/payment.service.ts
var PaymentService = class {
  /**
   * Create a Polar Checkout for a specific Order
   * This generates a payment link for the user to pay for an order
   *
   * @param orderId The ID of the order to pay for
   */
  async createPaymentCheckout(orderId) {
    const order = ordersSample.find((order2) => order2.id === orderId);
    if (!order) {
      throw new Error(`Order with ID ${orderId} not found`);
    }
    const orderData = order;
    const checkout = await polarService.createCheckout({
      customerEmail: "sandbox_user@example.com",
      // Pre-fill for easier testing
      successUrl: `${config2.SUCCESS_URL}?orderId=${orderId}`,
      metadata: {
        orderId: orderId.toString(),
        environment: "sandbox"
      }
    });
    const newPayment = {
      id: checkout.checkoutId,
      // Using Checkout ID as temporary ref
      orderId,
      amount: orderData.totalAmount,
      // Amount in cents
      currency: "usd",
      status: "pending",
      paymentMethod: "polar",
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (!checkout.checkoutUrl || !checkout.checkoutId) {
      throw new Error("Failed to create Polar checkout");
    }
    if (!newPayment.id) {
      throw new Error("Payment ID is required");
    }
    addPayment(newPayment);
    return {
      checkoutUrl: checkout.checkoutUrl,
      checkoutId: checkout.checkoutId
    };
  }
};
var paymentService = new PaymentService();

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/external.js
var external_exports2 = {};
__export(external_exports2, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default3,
  _function: () => _function,
  any: () => any2,
  array: () => array2,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint3,
  boolean: () => boolean4,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports2,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom2,
  date: () => date6,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum3,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int2,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection2,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports2,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal2,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable2,
  nullish: () => nullish2,
  number: () => number4,
  object: () => object2,
  optional: () => optional2,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe2,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record2,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse3,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string4,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform2,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union2,
  unknown: () => unknown2,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void3,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/schemas.js
var schemas_exports3 = {};
__export(schemas_exports3, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default3,
  _function: () => _function,
  any: () => any2,
  array: () => array2,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint3,
  boolean: () => boolean4,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom2,
  date: () => date6,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum3,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int2,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection2,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal2,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable2,
  nullish: () => nullish2,
  number: () => number4,
  object: () => object2,
  optional: () => optional2,
  partialRecord: () => partialRecord,
  pipe: () => pipe2,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record2,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string4,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform2,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union2,
  unknown: () => unknown2,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void3,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date5,
  datetime: () => datetime3,
  duration: () => duration3,
  time: () => time3
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime3(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date5(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time3(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration3(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse3(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check3, params) => inst.check(refine(check3, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional2(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def2) => _default3(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => stringProcessor(inst, ctx, json4, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime3(params));
  inst.date = (params) => inst.check(date5(params));
  inst.time = (params) => inst.check(time3(params));
  inst.duration = (params) => inst.check(duration3(params));
});
function string4(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => numberProcessor(inst, ctx, json4, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number4(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int2(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => booleanProcessor(inst, ctx, json4, params);
});
function boolean4(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => bigintProcessor(inst, ctx, json4, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint3(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => symbolProcessor(inst, ctx, json4, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => undefinedProcessor(inst, ctx, json4, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => nullProcessor(inst, ctx, json4, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => anyProcessor(inst, ctx, json4, params);
});
function any2() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => unknownProcessor(inst, ctx, json4, params);
});
function unknown2() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => neverProcessor(inst, ctx, json4, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => voidProcessor(inst, ctx, json4, params);
});
function _void3(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => dateProcessor(inst, ctx, json4, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date6(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => arrayProcessor(inst, ctx, json4, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum3(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => objectProcessor(inst, ctx, json4, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum3(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown2(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => unionProcessor(inst, ctx, json4, params);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => unionProcessor(inst, ctx, json4, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => intersectionProcessor(inst, ctx, json4, params);
});
function intersection2(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => tupleProcessor(inst, ctx, json4, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => recordProcessor(inst, ctx, json4, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record2(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => mapProcessor(inst, ctx, json4, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => setProcessor(inst, ctx, json4, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => enumProcessor(inst, ctx, json4, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum3(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => literalProcessor(inst, ctx, json4, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => fileProcessor(inst, ctx, json4, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => transformProcessor(inst, ctx, json4, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => optionalProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => optionalProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => nullableProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional2(nullable2(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => defaultProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default3(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => prefaultProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => nonoptionalProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => successProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => catchProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => nanProcessor(inst, ctx, json4, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => pipeProcessor(inst, ctx, json4, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => readonlyProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => templateLiteralProcessor(inst, ctx, json4, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => lazyProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => promiseProcessor(inst, ctx, json4, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => functionProcessor(inst, ctx, json4, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json4, params) => customProcessor(inst, ctx, json4, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json2(params) {
  const jsonSchema2 = lazy(() => {
    return union2([string4(params), number4(), boolean4(), _null3(), array2(jsonSchema2), record2(string4(), jsonSchema2)]);
  });
  return jsonSchema2;
}
function preprocess(fn, schema) {
  return pipe2(transform2(fn), schema);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports3,
  ...checks_exports2,
  iso: iso_exports2
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v2) => typeof v2 === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v2) => z.literal(v2));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version3 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version3,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint4,
  boolean: () => boolean5,
  date: () => date7,
  number: () => number5,
  string: () => string5
});
function string5(params) {
  return _coercedString(ZodString, params);
}
function number5(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean5(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint4(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date7(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/.pnpm/zod@4.3.6/node_modules/zod/index.js
var zod_default = external_exports2;

// src/modules/payment/razorpay.service.ts
var import_razorpay = __toESM(require_razorpay());
init_config();
import crypto2 from "crypto";

// node_modules/.pnpm/@neondatabase+serverless@1.0.2/node_modules/@neondatabase/serverless/index.mjs
var So = Object.create;
var Ie = Object.defineProperty;
var Eo = Object.getOwnPropertyDescriptor;
var Ao = Object.getOwnPropertyNames;
var Co = Object.getPrototypeOf;
var _o = Object.prototype.hasOwnProperty;
var Io = (r, e, t) => e in r ? Ie(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var a = (r, e) => Ie(r, "name", { value: e, configurable: true });
var G = (r, e) => () => (r && (e = r(r = 0)), e);
var T = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var ie = (r, e) => {
  for (var t in e) Ie(r, t, {
    get: e[t],
    enumerable: true
  });
};
var Dn = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function") for (let i of Ao(e)) !_o.call(r, i) && i !== t && Ie(r, i, { get: () => e[i], enumerable: !(n = Eo(e, i)) || n.enumerable });
  return r;
};
var Se = (r, e, t) => (t = r != null ? So(Co(r)) : {}, Dn(e || !r || !r.__esModule ? Ie(t, "default", { value: r, enumerable: true }) : t, r));
var O = (r) => Dn(Ie({}, "__esModule", { value: true }), r);
var E = (r, e, t) => Io(r, typeof e != "symbol" ? e + "" : e, t);
var Qn = T((lt2) => {
  "use strict";
  p();
  lt2.byteLength = Po;
  lt2.toByteArray = Ro;
  lt2.fromByteArray = ko;
  var ae = [], te = [], To = typeof Uint8Array < "u" ? Uint8Array : Array, qt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Ee = 0, On = qt.length; Ee < On; ++Ee) ae[Ee] = qt[Ee], te[qt.charCodeAt(Ee)] = Ee;
  var Ee, On;
  te[45] = 62;
  te[95] = 63;
  function qn(r) {
    var e = r.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [t, n];
  }
  a(qn, "getLens");
  function Po(r) {
    var e = qn(r), t = e[0], n = e[1];
    return (t + n) * 3 / 4 - n;
  }
  a(Po, "byteLength");
  function Bo(r, e, t) {
    return (e + t) * 3 / 4 - t;
  }
  a(Bo, "_byteLength");
  function Ro(r) {
    var e, t = qn(r), n = t[0], i = t[1], s = new To(Bo(r, n, i)), o = 0, u = i > 0 ? n - 4 : n, c;
    for (c = 0; c < u; c += 4) e = te[r.charCodeAt(c)] << 18 | te[r.charCodeAt(c + 1)] << 12 | te[r.charCodeAt(c + 2)] << 6 | te[r.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i === 2 && (e = te[r.charCodeAt(
      c
    )] << 2 | te[r.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = te[r.charCodeAt(c)] << 10 | te[r.charCodeAt(c + 1)] << 4 | te[r.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
  }
  a(Ro, "toByteArray");
  function Lo(r) {
    return ae[r >> 18 & 63] + ae[r >> 12 & 63] + ae[r >> 6 & 63] + ae[r & 63];
  }
  a(Lo, "tripletToBase64");
  function Fo(r, e, t) {
    for (var n, i = [], s = e; s < t; s += 3) n = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), i.push(Lo(n));
    return i.join("");
  }
  a(Fo, "encodeChunk");
  function ko(r) {
    for (var e, t = r.length, n = t % 3, i = [], s = 16383, o = 0, u = t - n; o < u; o += s) i.push(Fo(
      r,
      o,
      o + s > u ? u : o + s
    ));
    return n === 1 ? (e = r[t - 1], i.push(ae[e >> 2] + ae[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(ae[e >> 10] + ae[e >> 4 & 63] + ae[e << 2 & 63] + "=")), i.join("");
  }
  a(ko, "fromByteArray");
});
var Nn = T((Qt) => {
  p();
  Qt.read = function(r, e, t, n, i) {
    var s, o, u = i * 8 - n - 1, c = (1 << u) - 1, l = c >> 1, f = -7, y = t ? i - 1 : 0, g = t ? -1 : 1, A = r[e + y];
    for (y += g, s = A & (1 << -f) - 1, A >>= -f, f += u; f > 0; s = s * 256 + r[e + y], y += g, f -= 8) ;
    for (o = s & (1 << -f) - 1, s >>= -f, f += n; f > 0; o = o * 256 + r[e + y], y += g, f -= 8) ;
    if (s === 0) s = 1 - l;
    else {
      if (s === c) return o ? NaN : (A ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, n), s = s - l;
    }
    return (A ? -1 : 1) * o * Math.pow(2, s - n);
  };
  Qt.write = function(r, e, t, n, i, s) {
    var o, u, c, l = s * 8 - i - 1, f = (1 << l) - 1, y = f >> 1, g = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, A = n ? 0 : s - 1, C = n ? 1 : -1, D = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, o = f) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + y >= 1 ? e += g / c : e += g * Math.pow(2, 1 - y), e * c >= 2 && (o++, c /= 2), o + y >= f ? (u = 0, o = f) : o + y >= 1 ? (u = (e * c - 1) * Math.pow(2, i), o = o + y) : (u = e * Math.pow(2, y - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + A] = u & 255, A += C, u /= 256, i -= 8) ;
    for (o = o << i | u, l += i; l > 0; r[t + A] = o & 255, A += C, o /= 256, l -= 8) ;
    r[t + A - C] |= D * 128;
  };
});
var ii = T((Re) => {
  "use strict";
  p();
  var Nt = Qn(), Pe = Nn(), Wn = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
  Re.Buffer = h;
  Re.SlowBuffer = Qo;
  Re.INSPECT_MAX_BYTES = 50;
  var ft = 2147483647;
  Re.kMaxLength = ft;
  h.TYPED_ARRAY_SUPPORT = Mo();
  !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Mo() {
    try {
      let r = new Uint8Array(1), e = { foo: a(function() {
        return 42;
      }, "foo") };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42;
    } catch {
      return false;
    }
  }
  a(Mo, "typedArraySupport");
  Object.defineProperty(h.prototype, "parent", { enumerable: true, get: a(function() {
    if (h.isBuffer(this)) return this.buffer;
  }, "get") });
  Object.defineProperty(h.prototype, "offset", { enumerable: true, get: a(function() {
    if (h.isBuffer(
      this
    )) return this.byteOffset;
  }, "get") });
  function he(r) {
    if (r > ft) throw new RangeError('The value "' + r + '" is invalid for option "size"');
    let e = new Uint8Array(r);
    return Object.setPrototypeOf(e, h.prototype), e;
  }
  a(he, "createBuffer");
  function h(r, e, t) {
    if (typeof r == "number") {
      if (typeof e == "string") throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      );
      return $t(r);
    }
    return Gn(r, e, t);
  }
  a(h, "Buffer");
  h.poolSize = 8192;
  function Gn(r, e, t) {
    if (typeof r == "string") return Do(r, e);
    if (ArrayBuffer.isView(r)) return Oo(r);
    if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
    if (ue(r, ArrayBuffer) || r && ue(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ue(r, SharedArrayBuffer) || r && ue(
      r.buffer,
      SharedArrayBuffer
    ))) return jt(r, e, t);
    if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n = r.valueOf && r.valueOf();
    if (n != null && n !== r) return h.from(n, e, t);
    let i = qo(r);
    if (i) return i;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return h.from(r[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
  }
  a(Gn, "from");
  h.from = function(r, e, t) {
    return Gn(r, e, t);
  };
  Object.setPrototypeOf(
    h.prototype,
    Uint8Array.prototype
  );
  Object.setPrototypeOf(h, Uint8Array);
  function Vn(r) {
    if (typeof r != "number") throw new TypeError(
      '"size" argument must be of type number'
    );
    if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"');
  }
  a(Vn, "assertSize");
  function Uo(r, e, t) {
    return Vn(r), r <= 0 ? he(r) : e !== void 0 ? typeof t == "string" ? he(r).fill(e, t) : he(r).fill(e) : he(r);
  }
  a(Uo, "alloc");
  h.alloc = function(r, e, t) {
    return Uo(r, e, t);
  };
  function $t(r) {
    return Vn(r), he(r < 0 ? 0 : Gt(r) | 0);
  }
  a($t, "allocUnsafe");
  h.allocUnsafe = function(r) {
    return $t(
      r
    );
  };
  h.allocUnsafeSlow = function(r) {
    return $t(r);
  };
  function Do(r, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
    let t = zn(r, e) | 0, n = he(t), i = n.write(
      r,
      e
    );
    return i !== t && (n = n.slice(0, i)), n;
  }
  a(Do, "fromString");
  function Wt(r) {
    let e = r.length < 0 ? 0 : Gt(r.length) | 0, t = he(e);
    for (let n = 0; n < e; n += 1) t[n] = r[n] & 255;
    return t;
  }
  a(Wt, "fromArrayLike");
  function Oo(r) {
    if (ue(r, Uint8Array)) {
      let e = new Uint8Array(r);
      return jt(e.buffer, e.byteOffset, e.byteLength);
    }
    return Wt(r);
  }
  a(Oo, "fromArrayView");
  function jt(r, e, t) {
    if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
    if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(
      r,
      e,
      t
    ), Object.setPrototypeOf(n, h.prototype), n;
  }
  a(jt, "fromArrayBuffer");
  function qo(r) {
    if (h.isBuffer(r)) {
      let e = Gt(r.length) | 0, t = he(e);
      return t.length === 0 || r.copy(t, 0, 0, e), t;
    }
    if (r.length !== void 0) return typeof r.length != "number" || zt(r.length) ? he(0) : Wt(r);
    if (r.type === "Buffer" && Array.isArray(r.data)) return Wt(r.data);
  }
  a(qo, "fromObject");
  function Gt(r) {
    if (r >= ft) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ft.toString(16) + " bytes");
    return r | 0;
  }
  a(Gt, "checked");
  function Qo(r) {
    return +r != r && (r = 0), h.alloc(+r);
  }
  a(Qo, "SlowBuffer");
  h.isBuffer = a(function(e) {
    return e != null && e._isBuffer === true && e !== h.prototype;
  }, "isBuffer");
  h.compare = a(function(e, t) {
    if (ue(e, Uint8Array) && (e = h.from(e, e.offset, e.byteLength)), ue(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(e) || !h.isBuffer(t)) throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    );
    if (e === t) return 0;
    let n = e.length, i = t.length;
    for (let s = 0, o = Math.min(n, i); s < o; ++s) if (e[s] !== t[s]) {
      n = e[s], i = t[s];
      break;
    }
    return n < i ? -1 : i < n ? 1 : 0;
  }, "compare");
  h.isEncoding = a(function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  h.concat = a(function(e, t) {
    if (!Array.isArray(e)) throw new TypeError(
      '"list" argument must be an Array of Buffers'
    );
    if (e.length === 0) return h.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
    let i = h.allocUnsafe(t), s = 0;
    for (n = 0; n < e.length; ++n) {
      let o = e[n];
      if (ue(o, Uint8Array)) s + o.length > i.length ? (h.isBuffer(o) || (o = h.from(o)), o.copy(i, s)) : Uint8Array.prototype.set.call(i, o, s);
      else if (h.isBuffer(o)) o.copy(i, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  }, "concat");
  function zn(r, e) {
    if (h.isBuffer(r)) return r.length;
    if (ArrayBuffer.isView(r) || ue(r, ArrayBuffer)) return r.byteLength;
    if (typeof r != "string") throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r
    );
    let t = r.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && t === 0) return 0;
    let i = false;
    for (; ; ) switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
        return Ht(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return ni(r).length;
      default:
        if (i) return n ? -1 : Ht(r).length;
        e = ("" + e).toLowerCase(), i = true;
    }
  }
  a(zn, "byteLength");
  h.byteLength = zn;
  function No(r, e, t) {
    let n = false;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
    for (r || (r = "utf8"); ; ) switch (r) {
      case "hex":
        return Zo(this, e, t);
      case "utf8":
      case "utf-8":
        return Yn(this, e, t);
      case "ascii":
        return Ko(this, e, t);
      case "latin1":
      case "binary":
        return Yo(
          this,
          e,
          t
        );
      case "base64":
        return Vo(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Jo(
          this,
          e,
          t
        );
      default:
        if (n) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), n = true;
    }
  }
  a(
    No,
    "slowToString"
  );
  h.prototype._isBuffer = true;
  function Ae(r, e, t) {
    let n = r[e];
    r[e] = r[t], r[t] = n;
  }
  a(Ae, "swap");
  h.prototype.swap16 = a(function() {
    let e = this.length;
    if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2) Ae(this, t, t + 1);
    return this;
  }, "swap16");
  h.prototype.swap32 = a(function() {
    let e = this.length;
    if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4) Ae(this, t, t + 3), Ae(this, t + 1, t + 2);
    return this;
  }, "swap32");
  h.prototype.swap64 = a(
    function() {
      let e = this.length;
      if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0; t < e; t += 8) Ae(this, t, t + 7), Ae(this, t + 1, t + 6), Ae(this, t + 2, t + 5), Ae(this, t + 3, t + 4);
      return this;
    },
    "swap64"
  );
  h.prototype.toString = a(function() {
    let e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? Yn(
      this,
      0,
      e
    ) : No.apply(this, arguments);
  }, "toString");
  h.prototype.toLocaleString = h.prototype.toString;
  h.prototype.equals = a(function(e) {
    if (!h.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? true : h.compare(this, e) === 0;
  }, "equals");
  h.prototype.inspect = a(function() {
    let e = "", t = Re.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
  }, "inspect");
  Wn && (h.prototype[Wn] = h.prototype.inspect);
  h.prototype.compare = a(function(e, t, n, i, s) {
    if (ue(e, Uint8Array) && (e = h.from(e, e.offset, e.byteLength)), !h.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
    if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), s === void 0 && (s = this.length), t < 0 || n > e.length || i < 0 || s > this.length) throw new RangeError("out of range index");
    if (i >= s && t >= n) return 0;
    if (i >= s) return -1;
    if (t >= n) return 1;
    if (t >>>= 0, n >>>= 0, i >>>= 0, s >>>= 0, this === e) return 0;
    let o = s - i, u = n - t, c = Math.min(o, u), l = this.slice(
      i,
      s
    ), f = e.slice(t, n);
    for (let y = 0; y < c; ++y) if (l[y] !== f[y]) {
      o = l[y], u = f[y];
      break;
    }
    return o < u ? -1 : u < o ? 1 : 0;
  }, "compare");
  function Kn(r, e, t, n, i) {
    if (r.length === 0) return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, zt(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
      if (i) return -1;
      t = r.length - 1;
    } else if (t < 0) if (i) t = 0;
    else return -1;
    if (typeof e == "string" && (e = h.from(
      e,
      n
    )), h.isBuffer(e)) return e.length === 0 ? -1 : jn(r, e, t, n, i);
    if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : jn(r, [e], t, n, i);
    throw new TypeError("val must be string, number or Buffer");
  }
  a(Kn, "bidirectionalIndexOf");
  function jn(r, e, t, n, i) {
    let s = 1, o = r.length, u = e.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (r.length < 2 || e.length < 2) return -1;
      s = 2, o /= 2, u /= 2, t /= 2;
    }
    function c(f, y) {
      return s === 1 ? f[y] : f.readUInt16BE(y * s);
    }
    a(c, "read");
    let l;
    if (i) {
      let f = -1;
      for (l = t; l < o; l++) if (c(r, l) === c(e, f === -1 ? 0 : l - f)) {
        if (f === -1 && (f = l), l - f + 1 === u) return f * s;
      } else f !== -1 && (l -= l - f), f = -1;
    } else for (t + u > o && (t = o - u), l = t; l >= 0; l--) {
      let f = true;
      for (let y = 0; y < u; y++) if (c(r, l + y) !== c(e, y)) {
        f = false;
        break;
      }
      if (f) return l;
    }
    return -1;
  }
  a(jn, "arrayIndexOf");
  h.prototype.includes = a(function(e, t, n) {
    return this.indexOf(
      e,
      t,
      n
    ) !== -1;
  }, "includes");
  h.prototype.indexOf = a(function(e, t, n) {
    return Kn(this, e, t, n, true);
  }, "indexOf");
  h.prototype.lastIndexOf = a(function(e, t, n) {
    return Kn(this, e, t, n, false);
  }, "lastIndexOf");
  function Wo(r, e, t, n) {
    t = Number(t) || 0;
    let i = r.length - t;
    n ? (n = Number(n), n > i && (n = i)) : n = i;
    let s = e.length;
    n > s / 2 && (n = s / 2);
    let o;
    for (o = 0; o < n; ++o) {
      let u = parseInt(e.substr(o * 2, 2), 16);
      if (zt(u)) return o;
      r[t + o] = u;
    }
    return o;
  }
  a(Wo, "hexWrite");
  function jo(r, e, t, n) {
    return ht(Ht(e, r.length - t), r, t, n);
  }
  a(jo, "utf8Write");
  function Ho(r, e, t, n) {
    return ht(ra(e), r, t, n);
  }
  a(
    Ho,
    "asciiWrite"
  );
  function $o(r, e, t, n) {
    return ht(ni(e), r, t, n);
  }
  a($o, "base64Write");
  function Go(r, e, t, n) {
    return ht(
      na(e, r.length - t),
      r,
      t,
      n
    );
  }
  a(Go, "ucs2Write");
  h.prototype.write = a(function(e, t, n, i) {
    if (t === void 0) i = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let s = this.length - t;
    if ((n === void 0 || n > s) && (n = s), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let o = false;
    for (; ; ) switch (i) {
      case "hex":
        return Wo(this, e, t, n);
      case "utf8":
      case "utf-8":
        return jo(this, e, t, n);
      case "ascii":
      case "latin1":
      case "binary":
        return Ho(this, e, t, n);
      case "base64":
        return $o(this, e, t, n);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Go(this, e, t, n);
      default:
        if (o) throw new TypeError("Unknown encoding: " + i);
        i = ("" + i).toLowerCase(), o = true;
    }
  }, "write");
  h.prototype.toJSON = a(function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  }, "toJSON");
  function Vo(r, e, t) {
    return e === 0 && t === r.length ? Nt.fromByteArray(r) : Nt.fromByteArray(r.slice(e, t));
  }
  a(Vo, "base64Slice");
  function Yn(r, e, t) {
    t = Math.min(r.length, t);
    let n = [], i = e;
    for (; i < t; ) {
      let s = r[i], o = null, u = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + u <= t) {
        let c, l, f, y;
        switch (u) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            c = r[i + 1], (c & 192) === 128 && (y = (s & 31) << 6 | c & 63, y > 127 && (o = y));
            break;
          case 3:
            c = r[i + 1], l = r[i + 2], (c & 192) === 128 && (l & 192) === 128 && (y = (s & 15) << 12 | (c & 63) << 6 | l & 63, y > 2047 && (y < 55296 || y > 57343) && (o = y));
            break;
          case 4:
            c = r[i + 1], l = r[i + 2], f = r[i + 3], (c & 192) === 128 && (l & 192) === 128 && (f & 192) === 128 && (y = (s & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | f & 63, y > 65535 && y < 1114112 && (o = y));
        }
      }
      o === null ? (o = 65533, u = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), i += u;
    }
    return zo(n);
  }
  a(Yn, "utf8Slice");
  var Hn = 4096;
  function zo(r) {
    let e = r.length;
    if (e <= Hn) return String.fromCharCode.apply(String, r);
    let t = "", n = 0;
    for (; n < e; ) t += String.fromCharCode.apply(String, r.slice(n, n += Hn));
    return t;
  }
  a(zo, "decodeCodePointsArray");
  function Ko(r, e, t) {
    let n = "";
    t = Math.min(r.length, t);
    for (let i = e; i < t; ++i) n += String.fromCharCode(r[i] & 127);
    return n;
  }
  a(Ko, "asciiSlice");
  function Yo(r, e, t) {
    let n = "";
    t = Math.min(r.length, t);
    for (let i = e; i < t; ++i) n += String.fromCharCode(r[i]);
    return n;
  }
  a(Yo, "latin1Slice");
  function Zo(r, e, t) {
    let n = r.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
    let i = "";
    for (let s = e; s < t; ++s) i += ia[r[s]];
    return i;
  }
  a(Zo, "hexSlice");
  function Jo(r, e, t) {
    let n = r.slice(e, t), i = "";
    for (let s = 0; s < n.length - 1; s += 2) i += String.fromCharCode(n[s] + n[s + 1] * 256);
    return i;
  }
  a(Jo, "utf16leSlice");
  h.prototype.slice = a(function(e, t) {
    let n = this.length;
    e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
    let i = this.subarray(e, t);
    return Object.setPrototypeOf(i, h.prototype), i;
  }, "slice");
  function q(r, e, t) {
    if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
    if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
  }
  a(q, "checkOffset");
  h.prototype.readUintLE = h.prototype.readUIntLE = a(
    function(e, t, n) {
      e = e >>> 0, t = t >>> 0, n || q(e, t, this.length);
      let i = this[e], s = 1, o = 0;
      for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
      return i;
    },
    "readUIntLE"
  );
  h.prototype.readUintBE = h.prototype.readUIntBE = a(function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || q(
      e,
      t,
      this.length
    );
    let i = this[e + --t], s = 1;
    for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
    return i;
  }, "readUIntBE");
  h.prototype.readUint8 = h.prototype.readUInt8 = a(
    function(e, t) {
      return e = e >>> 0, t || q(e, 1, this.length), this[e];
    },
    "readUInt8"
  );
  h.prototype.readUint16LE = h.prototype.readUInt16LE = a(function(e, t) {
    return e = e >>> 0, t || q(
      e,
      2,
      this.length
    ), this[e] | this[e + 1] << 8;
  }, "readUInt16LE");
  h.prototype.readUint16BE = h.prototype.readUInt16BE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 2, this.length), this[e] << 8 | this[e + 1];
  }, "readUInt16BE");
  h.prototype.readUint32LE = h.prototype.readUInt32LE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  }, "readUInt32LE");
  h.prototype.readUint32BE = h.prototype.readUInt32BE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  }, "readUInt32BE");
  h.prototype.readBigUInt64LE = we(a(function(e) {
    e = e >>> 0, Be(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
    return BigInt(i) + (BigInt(s) << BigInt(32));
  }, "readBigUInt64LE"));
  h.prototype.readBigUInt64BE = we(a(function(e) {
    e = e >>> 0, Be(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
    return (BigInt(i) << BigInt(
      32
    )) + BigInt(s);
  }, "readBigUInt64BE"));
  h.prototype.readIntLE = a(function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || q(
      e,
      t,
      this.length
    );
    let i = this[e], s = 1, o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
  }, "readIntLE");
  h.prototype.readIntBE = a(function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || q(e, t, this.length);
    let i = t, s = 1, o = this[e + --i];
    for (; i > 0 && (s *= 256); ) o += this[e + --i] * s;
    return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o;
  }, "readIntBE");
  h.prototype.readInt8 = a(function(e, t) {
    return e = e >>> 0, t || q(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  }, "readInt8");
  h.prototype.readInt16LE = a(function(e, t) {
    e = e >>> 0, t || q(
      e,
      2,
      this.length
    );
    let n = this[e] | this[e + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, "readInt16LE");
  h.prototype.readInt16BE = a(function(e, t) {
    e = e >>> 0, t || q(e, 2, this.length);
    let n = this[e + 1] | this[e] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, "readInt16BE");
  h.prototype.readInt32LE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  }, "readInt32LE");
  h.prototype.readInt32BE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  }, "readInt32BE");
  h.prototype.readBigInt64LE = we(a(function(e) {
    e = e >>> 0, Be(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
    return (BigInt(i) << BigInt(
      32
    )) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  }, "readBigInt64LE"));
  h.prototype.readBigInt64BE = we(a(function(e) {
    e = e >>> 0, Be(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(i) << BigInt(32)) + BigInt(
      this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n
    );
  }, "readBigInt64BE"));
  h.prototype.readFloatLE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 4, this.length), Pe.read(this, e, true, 23, 4);
  }, "readFloatLE");
  h.prototype.readFloatBE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 4, this.length), Pe.read(this, e, false, 23, 4);
  }, "readFloatBE");
  h.prototype.readDoubleLE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 8, this.length), Pe.read(this, e, true, 52, 8);
  }, "readDoubleLE");
  h.prototype.readDoubleBE = a(function(e, t) {
    return e = e >>> 0, t || q(e, 8, this.length), Pe.read(
      this,
      e,
      false,
      52,
      8
    );
  }, "readDoubleBE");
  function V(r, e, t, n, i, s) {
    if (!h.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s) throw new RangeError('"value" argument is out of bounds');
    if (t + n > r.length) throw new RangeError("Index out of range");
  }
  a(V, "checkInt");
  h.prototype.writeUintLE = h.prototype.writeUIntLE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
      let u = Math.pow(2, 8 * n) - 1;
      V(
        this,
        e,
        t,
        n,
        u,
        0
      );
    }
    let s = 1, o = 0;
    for (this[t] = e & 255; ++o < n && (s *= 256); ) this[t + o] = e / s & 255;
    return t + n;
  }, "writeUIntLE");
  h.prototype.writeUintBE = h.prototype.writeUIntBE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
      let u = Math.pow(2, 8 * n) - 1;
      V(this, e, t, n, u, 0);
    }
    let s = n - 1, o = 1;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); ) this[t + s] = e / o & 255;
    return t + n;
  }, "writeUIntBE");
  h.prototype.writeUint8 = h.prototype.writeUInt8 = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1;
  }, "writeUInt8");
  h.prototype.writeUint16LE = h.prototype.writeUInt16LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, "writeUInt16LE");
  h.prototype.writeUint16BE = h.prototype.writeUInt16BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, "writeUInt16BE");
  h.prototype.writeUint32LE = h.prototype.writeUInt32LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(
      this,
      e,
      t,
      4,
      4294967295,
      0
    ), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4;
  }, "writeUInt32LE");
  h.prototype.writeUint32BE = h.prototype.writeUInt32BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(
      this,
      e,
      t,
      4,
      4294967295,
      0
    ), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  }, "writeUInt32BE");
  function Zn(r, e, t, n, i) {
    ri(e, n, i, r, t, 7);
    let s = Number(e & BigInt(4294967295));
    r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s;
    let o = Number(e >> BigInt(32) & BigInt(4294967295));
    return r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, t;
  }
  a(Zn, "wrtBigUInt64LE");
  function Jn(r, e, t, n, i) {
    ri(e, n, i, r, t, 7);
    let s = Number(e & BigInt(4294967295));
    r[t + 7] = s, s = s >> 8, r[t + 6] = s, s = s >> 8, r[t + 5] = s, s = s >> 8, r[t + 4] = s;
    let o = Number(e >> BigInt(32) & BigInt(4294967295));
    return r[t + 3] = o, o = o >> 8, r[t + 2] = o, o = o >> 8, r[t + 1] = o, o = o >> 8, r[t] = o, t + 8;
  }
  a(Jn, "wrtBigUInt64BE");
  h.prototype.writeBigUInt64LE = we(a(function(e, t = 0) {
    return Zn(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64LE"));
  h.prototype.writeBigUInt64BE = we(a(function(e, t = 0) {
    return Jn(this, e, t, BigInt(0), BigInt(
      "0xffffffffffffffff"
    ));
  }, "writeBigUInt64BE"));
  h.prototype.writeIntLE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, !i) {
      let c = Math.pow(2, 8 * n - 1);
      V(this, e, t, n, c - 1, -c);
    }
    let s = 0, o = 1, u = 0;
    for (this[t] = e & 255; ++s < n && (o *= 256); )
      e < 0 && u === 0 && this[t + s - 1] !== 0 && (u = 1), this[t + s] = (e / o >> 0) - u & 255;
    return t + n;
  }, "writeIntLE");
  h.prototype.writeIntBE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, !i) {
      let c = Math.pow(2, 8 * n - 1);
      V(this, e, t, n, c - 1, -c);
    }
    let s = n - 1, o = 1, u = 0;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); ) e < 0 && u === 0 && this[t + s + 1] !== 0 && (u = 1), this[t + s] = (e / o >> 0) - u & 255;
    return t + n;
  }, "writeIntBE");
  h.prototype.writeInt8 = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
  }, "writeInt8");
  h.prototype.writeInt16LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, "writeInt16LE");
  h.prototype.writeInt16BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, "writeInt16BE");
  h.prototype.writeInt32LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(
      this,
      e,
      t,
      4,
      2147483647,
      -2147483648
    ), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
  }, "writeInt32LE");
  h.prototype.writeInt32BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || V(
      this,
      e,
      t,
      4,
      2147483647,
      -2147483648
    ), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  }, "writeInt32BE");
  h.prototype.writeBigInt64LE = we(a(function(e, t = 0) {
    return Zn(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64LE"));
  h.prototype.writeBigInt64BE = we(
    a(function(e, t = 0) {
      return Jn(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE")
  );
  function Xn(r, e, t, n, i, s) {
    if (t + n > r.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  a(Xn, "checkIEEE754");
  function ei(r, e, t, n, i) {
    return e = +e, t = t >>> 0, i || Xn(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), Pe.write(r, e, t, n, 23, 4), t + 4;
  }
  a(
    ei,
    "writeFloat"
  );
  h.prototype.writeFloatLE = a(function(e, t, n) {
    return ei(this, e, t, true, n);
  }, "writeFloatLE");
  h.prototype.writeFloatBE = a(function(e, t, n) {
    return ei(this, e, t, false, n);
  }, "writeFloatBE");
  function ti(r, e, t, n, i) {
    return e = +e, t = t >>> 0, i || Xn(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), Pe.write(
      r,
      e,
      t,
      n,
      52,
      8
    ), t + 8;
  }
  a(ti, "writeDouble");
  h.prototype.writeDoubleLE = a(function(e, t, n) {
    return ti(this, e, t, true, n);
  }, "writeDoubleLE");
  h.prototype.writeDoubleBE = a(function(e, t, n) {
    return ti(this, e, t, false, n);
  }, "writeDoubleBE");
  h.prototype.copy = a(function(e, t, n, i) {
    if (!h.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
    let s = i - n;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), s;
  }, "copy");
  h.prototype.fill = a(function(e, t, n, i) {
    if (typeof e == "string") {
      if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !h.isEncoding(i)) throw new TypeError(
        "Unknown encoding: " + i
      );
      if (e.length === 1) {
        let o = e.charCodeAt(0);
        (i === "utf8" && o < 128 || i === "latin1") && (e = o);
      }
    } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
    if (n <= t) return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
    let s;
    if (typeof e == "number") for (s = t; s < n; ++s) this[s] = e;
    else {
      let o = h.isBuffer(e) ? e : h.from(
        e,
        i
      ), u = o.length;
      if (u === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (s = 0; s < n - t; ++s) this[s + t] = o[s % u];
    }
    return this;
  }, "fill");
  var Te = {};
  function Vt(r, e, t) {
    var n;
    Te[r] = (n = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${r}]`, this.stack, delete this.name;
      }
      get code() {
        return r;
      }
      set code(s) {
        Object.defineProperty(
          this,
          "code",
          { configurable: true, enumerable: true, value: s, writable: true }
        );
      }
      toString() {
        return `${this.name} [${r}]: ${this.message}`;
      }
    }, a(n, "NodeError"), n);
  }
  a(Vt, "E");
  Vt("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
    return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Vt(
    "ERR_INVALID_ARG_TYPE",
    function(r, e) {
      return `The "${r}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  );
  Vt("ERR_OUT_OF_RANGE", function(r, e, t) {
    let n = `The value of "${r}" is out of range.`, i = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = $n(String(t)) : typeof t == "bigint" && (i = String(
      t
    ), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = $n(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n;
  }, RangeError);
  function $n(r) {
    let e = "", t = r.length, n = r[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3) e = `_${r.slice(t - 3, t)}${e}`;
    return `${r.slice(0, t)}${e}`;
  }
  a($n, "addNumericalSeparator");
  function Xo(r, e, t) {
    Be(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && je(e, r.length - (t + 1));
  }
  a(Xo, "checkBounds");
  function ri(r, e, t, n, i, s) {
    if (r > t || r < e) {
      let o = typeof e == "bigint" ? "n" : "", u;
      throw s > 3 ? e === 0 || e === BigInt(0) ? u = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}` : u = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${(s + 1) * 8 - 1}${o}` : u = `>= ${e}${o} and <= ${t}${o}`, new Te.ERR_OUT_OF_RANGE("value", u, r);
    }
    Xo(n, i, s);
  }
  a(ri, "checkIntBI");
  function Be(r, e) {
    if (typeof r != "number") throw new Te.ERR_INVALID_ARG_TYPE(e, "number", r);
  }
  a(Be, "validateNumber");
  function je(r, e, t) {
    throw Math.floor(r) !== r ? (Be(r, t), new Te.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new Te.ERR_BUFFER_OUT_OF_BOUNDS() : new Te.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${e}`, r);
  }
  a(je, "boundsError");
  var ea = /[^+/0-9A-Za-z-_]/g;
  function ta(r) {
    if (r = r.split("=")[0], r = r.trim().replace(ea, ""), r.length < 2) return "";
    for (; r.length % 4 !== 0; ) r = r + "=";
    return r;
  }
  a(ta, "base64clean");
  function Ht(r, e) {
    e = e || 1 / 0;
    let t, n = r.length, i = null, s = [];
    for (let o = 0; o < n; ++o) {
      if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === n) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), i = t;
          continue;
        }
        t = (i - 55296 << 10 | t - 56320) + 65536;
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (i = null, t < 128) {
        if ((e -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0) break;
        s.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0) break;
        s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break;
        s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  a(Ht, "utf8ToBytes");
  function ra(r) {
    let e = [];
    for (let t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
    return e;
  }
  a(
    ra,
    "asciiToBytes"
  );
  function na(r, e) {
    let t, n, i, s = [];
    for (let o = 0; o < r.length && !((e -= 2) < 0); ++o) t = r.charCodeAt(
      o
    ), n = t >> 8, i = t % 256, s.push(i), s.push(n);
    return s;
  }
  a(na, "utf16leToBytes");
  function ni(r) {
    return Nt.toByteArray(
      ta(r)
    );
  }
  a(ni, "base64ToBytes");
  function ht(r, e, t, n) {
    let i;
    for (i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i)
      e[i + t] = r[i];
    return i;
  }
  a(ht, "blitBuffer");
  function ue(r, e) {
    return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name;
  }
  a(ue, "isInstance");
  function zt(r) {
    return r !== r;
  }
  a(zt, "numberIsNaN");
  var ia = (function() {
    let r = "0123456789abcdef", e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let n = t * 16;
      for (let i = 0; i < 16; ++i) e[n + i] = r[t] + r[i];
    }
    return e;
  })();
  function we(r) {
    return typeof BigInt > "u" ? sa : r;
  }
  a(we, "defineBigIntMethod");
  function sa() {
    throw new Error("BigInt not supported");
  }
  a(sa, "BufferBigIntNotDefined");
});
var b;
var v;
var x;
var d;
var m;
var p = G(() => {
  "use strict";
  b = globalThis, v = globalThis.setImmediate ?? ((r) => setTimeout(r, 0)), x = globalThis.clearImmediate ?? ((r) => clearTimeout(r)), d = typeof globalThis.Buffer == "function" && typeof globalThis.Buffer.allocUnsafe == "function" ? globalThis.Buffer : ii().Buffer, m = globalThis.process ?? {};
  m.env ?? (m.env = {});
  try {
    m.nextTick(() => {
    });
  } catch {
    let e = Promise.resolve();
    m.nextTick = e.then.bind(e);
  }
});
var ge = T((Rl, Kt) => {
  "use strict";
  p();
  var Le = typeof Reflect == "object" ? Reflect : null, si = Le && typeof Le.apply == "function" ? Le.apply : a(function(e, t, n) {
    return Function.prototype.apply.call(e, t, n);
  }, "ReflectApply"), pt;
  Le && typeof Le.ownKeys == "function" ? pt = Le.ownKeys : Object.getOwnPropertySymbols ? pt = a(function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  }, "ReflectOwnKeys") : pt = a(function(e) {
    return Object.getOwnPropertyNames(e);
  }, "ReflectOwnKeys");
  function oa(r) {
    console && console.warn && console.warn(r);
  }
  a(
    oa,
    "ProcessEmitWarning"
  );
  var ai = Number.isNaN || a(function(e) {
    return e !== e;
  }, "NumberIsNaN");
  function B() {
    B.init.call(this);
  }
  a(B, "EventEmitter");
  Kt.exports = B;
  Kt.exports.once = la;
  B.EventEmitter = B;
  B.prototype._events = void 0;
  B.prototype._eventsCount = 0;
  B.prototype._maxListeners = void 0;
  var oi = 10;
  function dt(r) {
    if (typeof r != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
  }
  a(dt, "checkListener");
  Object.defineProperty(B, "defaultMaxListeners", { enumerable: true, get: a(function() {
    return oi;
  }, "get"), set: a(
    function(r) {
      if (typeof r != "number" || r < 0 || ai(r)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
      oi = r;
    },
    "set"
  ) });
  B.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  B.prototype.setMaxListeners = a(function(e) {
    if (typeof e != "number" || e < 0 || ai(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  }, "setMaxListeners");
  function ui(r) {
    return r._maxListeners === void 0 ? B.defaultMaxListeners : r._maxListeners;
  }
  a(ui, "_getMaxListeners");
  B.prototype.getMaxListeners = a(function() {
    return ui(this);
  }, "getMaxListeners");
  B.prototype.emit = a(function(e) {
    for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
    var i = e === "error", s = this._events;
    if (s !== void 0) i = i && s.error === void 0;
    else if (!i) return false;
    if (i) {
      var o;
      if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
      var u = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
      throw u.context = o, u;
    }
    var c = s[e];
    if (c === void 0) return false;
    if (typeof c == "function") si(c, this, t);
    else for (var l = c.length, f = pi(c, l), n = 0; n < l; ++n) si(f[n], this, t);
    return true;
  }, "emit");
  function ci(r, e, t, n) {
    var i, s, o;
    if (dt(
      t
    ), s = r._events, s === void 0 ? (s = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (s.newListener !== void 0 && (r.emit("newListener", e, t.listener ? t.listener : t), s = r._events), o = s[e]), o === void 0) o = s[e] = t, ++r._eventsCount;
    else if (typeof o == "function" ? o = s[e] = n ? [t, o] : [o, t] : n ? o.unshift(t) : o.push(t), i = ui(r), i > 0 && o.length > i && !o.warned) {
      o.warned = true;
      var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u.name = "MaxListenersExceededWarning", u.emitter = r, u.type = e, u.count = o.length, oa(u);
    }
    return r;
  }
  a(ci, "_addListener");
  B.prototype.addListener = a(function(e, t) {
    return ci(this, e, t, false);
  }, "addListener");
  B.prototype.on = B.prototype.addListener;
  B.prototype.prependListener = a(function(e, t) {
    return ci(this, e, t, true);
  }, "prependListener");
  function aa() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  a(aa, "onceWrapper");
  function li(r, e, t) {
    var n = {
      fired: false,
      wrapFn: void 0,
      target: r,
      type: e,
      listener: t
    }, i = aa.bind(n);
    return i.listener = t, n.wrapFn = i, i;
  }
  a(li, "_onceWrap");
  B.prototype.once = a(function(e, t) {
    return dt(t), this.on(e, li(this, e, t)), this;
  }, "once");
  B.prototype.prependOnceListener = a(function(e, t) {
    return dt(t), this.prependListener(e, li(this, e, t)), this;
  }, "prependOnceListener");
  B.prototype.removeListener = a(function(e, t) {
    var n, i, s, o, u;
    if (dt(t), i = this._events, i === void 0) return this;
    if (n = i[e], n === void 0) return this;
    if (n === t || n.listener === t) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
    else if (typeof n != "function") {
      for (s = -1, o = n.length - 1; o >= 0; o--) if (n[o] === t || n[o].listener === t) {
        u = n[o].listener, s = o;
        break;
      }
      if (s < 0) return this;
      s === 0 ? n.shift() : ua(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || t);
    }
    return this;
  }, "removeListener");
  B.prototype.off = B.prototype.removeListener;
  B.prototype.removeAllListeners = a(function(e) {
    var t, n, i;
    if (n = this._events, n === void 0) return this;
    if (n.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
    if (arguments.length === 0) {
      var s = Object.keys(n), o;
      for (i = 0; i < s.length; ++i) o = s[i], o !== "removeListener" && this.removeAllListeners(
        o
      );
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t = n[e], typeof t == "function") this.removeListener(e, t);
    else if (t !== void 0) for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
    return this;
  }, "removeAllListeners");
  function fi(r, e, t) {
    var n = r._events;
    if (n === void 0) return [];
    var i = n[e];
    return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? ca(i) : pi(i, i.length);
  }
  a(fi, "_listeners");
  B.prototype.listeners = a(function(e) {
    return fi(this, e, true);
  }, "listeners");
  B.prototype.rawListeners = a(function(e) {
    return fi(this, e, false);
  }, "rawListeners");
  B.listenerCount = function(r, e) {
    return typeof r.listenerCount == "function" ? r.listenerCount(e) : hi.call(r, e);
  };
  B.prototype.listenerCount = hi;
  function hi(r) {
    var e = this._events;
    if (e !== void 0) {
      var t = e[r];
      if (typeof t == "function")
        return 1;
      if (t !== void 0) return t.length;
    }
    return 0;
  }
  a(hi, "listenerCount");
  B.prototype.eventNames = a(function() {
    return this._eventsCount > 0 ? pt(this._events) : [];
  }, "eventNames");
  function pi(r, e) {
    for (var t = new Array(e), n = 0; n < e; ++n) t[n] = r[n];
    return t;
  }
  a(pi, "arrayClone");
  function ua(r, e) {
    for (; e + 1 < r.length; e++) r[e] = r[e + 1];
    r.pop();
  }
  a(ua, "spliceOne");
  function ca(r) {
    for (var e = new Array(r.length), t = 0; t < e.length; ++t) e[t] = r[t].listener || r[t];
    return e;
  }
  a(ca, "unwrapListeners");
  function la(r, e) {
    return new Promise(function(t, n) {
      function i(o) {
        r.removeListener(e, s), n(o);
      }
      a(i, "errorListener");
      function s() {
        typeof r.removeListener == "function" && r.removeListener("error", i), t([].slice.call(arguments));
      }
      a(s, "resolver"), di(r, e, s, { once: true }), e !== "error" && fa(r, i, { once: true });
    });
  }
  a(la, "once");
  function fa(r, e, t) {
    typeof r.on == "function" && di(r, "error", e, t);
  }
  a(
    fa,
    "addErrorHandlerIfEventEmitter"
  );
  function di(r, e, t, n) {
    if (typeof r.on == "function") n.once ? r.once(e, t) : r.on(e, t);
    else if (typeof r.addEventListener == "function") r.addEventListener(e, a(function i(s) {
      n.once && r.removeEventListener(e, i), t(s);
    }, "wrapListener"));
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
  }
  a(di, "eventTargetAgnosticAddListener");
});
var wi = {};
ie(wi, { Socket: () => ce, isIP: () => ha });
function ha(r) {
  return 0;
}
var mi;
var yi;
var S;
var ce;
var Fe = G(() => {
  "use strict";
  p();
  mi = Se(ge(), 1);
  a(ha, "isIP");
  yi = /^[^.]+\./, S = class S2 extends mi.EventEmitter {
    constructor() {
      super(...arguments);
      E(this, "opts", {});
      E(this, "connecting", false);
      E(this, "pending", true);
      E(
        this,
        "writable",
        true
      );
      E(this, "encrypted", false);
      E(this, "authorized", false);
      E(this, "destroyed", false);
      E(this, "ws", null);
      E(this, "writeBuffer");
      E(this, "tlsState", 0);
      E(this, "tlsRead");
      E(this, "tlsWrite");
    }
    static get poolQueryViaFetch() {
      return S2.opts.poolQueryViaFetch ?? S2.defaults.poolQueryViaFetch;
    }
    static set poolQueryViaFetch(t) {
      S2.opts.poolQueryViaFetch = t;
    }
    static get fetchEndpoint() {
      return S2.opts.fetchEndpoint ?? S2.defaults.fetchEndpoint;
    }
    static set fetchEndpoint(t) {
      S2.opts.fetchEndpoint = t;
    }
    static get fetchConnectionCache() {
      return true;
    }
    static set fetchConnectionCache(t) {
      console.warn("The `fetchConnectionCache` option is deprecated (now always `true`)");
    }
    static get fetchFunction() {
      return S2.opts.fetchFunction ?? S2.defaults.fetchFunction;
    }
    static set fetchFunction(t) {
      S2.opts.fetchFunction = t;
    }
    static get webSocketConstructor() {
      return S2.opts.webSocketConstructor ?? S2.defaults.webSocketConstructor;
    }
    static set webSocketConstructor(t) {
      S2.opts.webSocketConstructor = t;
    }
    get webSocketConstructor() {
      return this.opts.webSocketConstructor ?? S2.webSocketConstructor;
    }
    set webSocketConstructor(t) {
      this.opts.webSocketConstructor = t;
    }
    static get wsProxy() {
      return S2.opts.wsProxy ?? S2.defaults.wsProxy;
    }
    static set wsProxy(t) {
      S2.opts.wsProxy = t;
    }
    get wsProxy() {
      return this.opts.wsProxy ?? S2.wsProxy;
    }
    set wsProxy(t) {
      this.opts.wsProxy = t;
    }
    static get coalesceWrites() {
      return S2.opts.coalesceWrites ?? S2.defaults.coalesceWrites;
    }
    static set coalesceWrites(t) {
      S2.opts.coalesceWrites = t;
    }
    get coalesceWrites() {
      return this.opts.coalesceWrites ?? S2.coalesceWrites;
    }
    set coalesceWrites(t) {
      this.opts.coalesceWrites = t;
    }
    static get useSecureWebSocket() {
      return S2.opts.useSecureWebSocket ?? S2.defaults.useSecureWebSocket;
    }
    static set useSecureWebSocket(t) {
      S2.opts.useSecureWebSocket = t;
    }
    get useSecureWebSocket() {
      return this.opts.useSecureWebSocket ?? S2.useSecureWebSocket;
    }
    set useSecureWebSocket(t) {
      this.opts.useSecureWebSocket = t;
    }
    static get forceDisablePgSSL() {
      return S2.opts.forceDisablePgSSL ?? S2.defaults.forceDisablePgSSL;
    }
    static set forceDisablePgSSL(t) {
      S2.opts.forceDisablePgSSL = t;
    }
    get forceDisablePgSSL() {
      return this.opts.forceDisablePgSSL ?? S2.forceDisablePgSSL;
    }
    set forceDisablePgSSL(t) {
      this.opts.forceDisablePgSSL = t;
    }
    static get disableSNI() {
      return S2.opts.disableSNI ?? S2.defaults.disableSNI;
    }
    static set disableSNI(t) {
      S2.opts.disableSNI = t;
    }
    get disableSNI() {
      return this.opts.disableSNI ?? S2.disableSNI;
    }
    set disableSNI(t) {
      this.opts.disableSNI = t;
    }
    static get disableWarningInBrowsers() {
      return S2.opts.disableWarningInBrowsers ?? S2.defaults.disableWarningInBrowsers;
    }
    static set disableWarningInBrowsers(t) {
      S2.opts.disableWarningInBrowsers = t;
    }
    get disableWarningInBrowsers() {
      return this.opts.disableWarningInBrowsers ?? S2.disableWarningInBrowsers;
    }
    set disableWarningInBrowsers(t) {
      this.opts.disableWarningInBrowsers = t;
    }
    static get pipelineConnect() {
      return S2.opts.pipelineConnect ?? S2.defaults.pipelineConnect;
    }
    static set pipelineConnect(t) {
      S2.opts.pipelineConnect = t;
    }
    get pipelineConnect() {
      return this.opts.pipelineConnect ?? S2.pipelineConnect;
    }
    set pipelineConnect(t) {
      this.opts.pipelineConnect = t;
    }
    static get subtls() {
      return S2.opts.subtls ?? S2.defaults.subtls;
    }
    static set subtls(t) {
      S2.opts.subtls = t;
    }
    get subtls() {
      return this.opts.subtls ?? S2.subtls;
    }
    set subtls(t) {
      this.opts.subtls = t;
    }
    static get pipelineTLS() {
      return S2.opts.pipelineTLS ?? S2.defaults.pipelineTLS;
    }
    static set pipelineTLS(t) {
      S2.opts.pipelineTLS = t;
    }
    get pipelineTLS() {
      return this.opts.pipelineTLS ?? S2.pipelineTLS;
    }
    set pipelineTLS(t) {
      this.opts.pipelineTLS = t;
    }
    static get rootCerts() {
      return S2.opts.rootCerts ?? S2.defaults.rootCerts;
    }
    static set rootCerts(t) {
      S2.opts.rootCerts = t;
    }
    get rootCerts() {
      return this.opts.rootCerts ?? S2.rootCerts;
    }
    set rootCerts(t) {
      this.opts.rootCerts = t;
    }
    wsProxyAddrForHost(t, n) {
      let i = this.wsProxy;
      if (i === void 0) throw new Error("No WebSocket proxy is configured. Please see https://github.com/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--string");
      return typeof i == "function" ? i(t, n) : `${i}?address=${t}:${n}`;
    }
    setNoDelay() {
      return this;
    }
    setKeepAlive() {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    connect(t, n, i) {
      this.connecting = true, i && this.once("connect", i);
      let s = a(() => {
        this.connecting = false, this.pending = false, this.emit("connect"), this.emit("ready");
      }, "handleWebSocketOpen"), o = a((c, l = false) => {
        c.binaryType = "arraybuffer", c.addEventListener("error", (f) => {
          this.emit("error", f), this.emit("close");
        }), c.addEventListener("message", (f) => {
          if (this.tlsState === 0) {
            let y = d.from(f.data);
            this.emit("data", y);
          }
        }), c.addEventListener("close", () => {
          this.emit("close");
        }), l ? s() : c.addEventListener(
          "open",
          s
        );
      }, "configureWebSocket"), u;
      try {
        u = this.wsProxyAddrForHost(n, typeof t == "string" ? parseInt(t, 10) : t);
      } catch (c) {
        this.emit("error", c), this.emit("close");
        return;
      }
      try {
        let l = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + u;
        if (this.webSocketConstructor !== void 0) this.ws = new this.webSocketConstructor(l), o(this.ws);
        else try {
          this.ws = new WebSocket(l), o(this.ws);
        } catch {
          this.ws = new __unstable_WebSocket(l), o(this.ws);
        }
      } catch (c) {
        let f = (this.useSecureWebSocket ? "https:" : "http:") + "//" + u;
        fetch(f, { headers: { Upgrade: "websocket" } }).then(
          (y) => {
            if (this.ws = y.webSocket, this.ws == null) throw c;
            this.ws.accept(), o(this.ws, true);
          }
        ).catch((y) => {
          this.emit(
            "error",
            new Error(`All attempts to open a WebSocket to connect to the database failed. Please refer to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websocket--undefined. Details: ${y}`)
          ), this.emit("close");
        });
      }
    }
    async startTls(t) {
      if (this.subtls === void 0) throw new Error(
        "For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://github.com/neondatabase/serverless/blob/main/CONFIG.md for more information."
      );
      this.tlsState = 1;
      let n = await this.subtls.TrustedCert.databaseFromPEM(this.rootCerts), i = new this.subtls.WebSocketReadQueue(this.ws), s = i.read.bind(i), o = this.rawWrite.bind(this), { read: u, write: c } = await this.subtls.startTls(t, n, s, o, { useSNI: !this.disableSNI, expectPreData: this.pipelineTLS ? new Uint8Array([83]) : void 0 });
      this.tlsRead = u, this.tlsWrite = c, this.tlsState = 2, this.encrypted = true, this.authorized = true, this.emit("secureConnection", this), this.tlsReadLoop();
    }
    async tlsReadLoop() {
      for (; ; ) {
        let t = await this.tlsRead();
        if (t === void 0) break;
        {
          let n = d.from(t);
          this.emit("data", n);
        }
      }
    }
    rawWrite(t) {
      if (!this.coalesceWrites) {
        this.ws && this.ws.send(t);
        return;
      }
      if (this.writeBuffer === void 0) this.writeBuffer = t, setTimeout(() => {
        this.ws && this.ws.send(this.writeBuffer), this.writeBuffer = void 0;
      }, 0);
      else {
        let n = new Uint8Array(
          this.writeBuffer.length + t.length
        );
        n.set(this.writeBuffer), n.set(t, this.writeBuffer.length), this.writeBuffer = n;
      }
    }
    write(t, n = "utf8", i = (s) => {
    }) {
      return t.length === 0 ? (i(), true) : (typeof t == "string" && (t = d.from(t, n)), this.tlsState === 0 ? (this.rawWrite(t), i()) : this.tlsState === 1 ? this.once("secureConnection", () => {
        this.write(
          t,
          n,
          i
        );
      }) : (this.tlsWrite(t), i()), true);
    }
    end(t = d.alloc(0), n = "utf8", i = () => {
    }) {
      return this.write(t, n, () => {
        this.ws.close(), i();
      }), this;
    }
    destroy() {
      return this.destroyed = true, this.end();
    }
  };
  a(S, "Socket"), E(S, "defaults", {
    poolQueryViaFetch: false,
    fetchEndpoint: a((t, n, i) => {
      let s;
      return i?.jwtAuth ? s = t.replace(yi, "apiauth.") : s = t.replace(yi, "api."), "https://" + s + "/sql";
    }, "fetchEndpoint"),
    fetchConnectionCache: true,
    fetchFunction: void 0,
    webSocketConstructor: void 0,
    wsProxy: a((t) => t + "/v2", "wsProxy"),
    useSecureWebSocket: true,
    forceDisablePgSSL: true,
    coalesceWrites: true,
    pipelineConnect: "password",
    subtls: void 0,
    rootCerts: "",
    pipelineTLS: false,
    disableSNI: false,
    disableWarningInBrowsers: false
  }), E(S, "opts", {});
  ce = S;
});
var gi = {};
ie(gi, { parse: () => Yt });
function Yt(r, e = false) {
  let { protocol: t } = new URL(r), n = "http:" + r.substring(
    t.length
  ), { username: i, password: s, host: o, hostname: u, port: c, pathname: l, search: f, searchParams: y, hash: g } = new URL(
    n
  );
  s = decodeURIComponent(s), i = decodeURIComponent(i), l = decodeURIComponent(l);
  let A = i + ":" + s, C = e ? Object.fromEntries(y.entries()) : f;
  return {
    href: r,
    protocol: t,
    auth: A,
    username: i,
    password: s,
    host: o,
    hostname: u,
    port: c,
    pathname: l,
    search: f,
    query: C,
    hash: g
  };
}
var Zt = G(() => {
  "use strict";
  p();
  a(Yt, "parse");
});
var tr = T((Ai) => {
  "use strict";
  p();
  Ai.parse = function(r, e) {
    return new er(r, e).parse();
  };
  var vt = class vt2 {
    constructor(e, t) {
      this.source = e, this.transform = t || Ca, this.position = 0, this.entries = [], this.recorded = [], this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var e = this.source[this.position++];
      return e === "\\" ? { value: this.source[this.position++], escaped: true } : { value: e, escaped: false };
    }
    record(e) {
      this.recorded.push(
        e
      );
    }
    newEntry(e) {
      var t;
      (this.recorded.length > 0 || e) && (t = this.recorded.join(""), t === "NULL" && !e && (t = null), t !== null && (t = this.transform(t)), this.entries.push(t), this.recorded = []);
    }
    consumeDimensions() {
      if (this.source[0] === "[") for (; !this.isEof(); ) {
        var e = this.nextCharacter();
        if (e.value === "=") break;
      }
    }
    parse(e) {
      var t, n, i;
      for (this.consumeDimensions(); !this.isEof(); ) if (t = this.nextCharacter(), t.value === "{" && !i) this.dimension++, this.dimension > 1 && (n = new vt2(this.source.substr(this.position - 1), this.transform), this.entries.push(n.parse(
        true
      )), this.position += n.position - 2);
      else if (t.value === "}" && !i) {
        if (this.dimension--, !this.dimension && (this.newEntry(), e)) return this.entries;
      } else t.value === '"' && !t.escaped ? (i && this.newEntry(true), i = !i) : t.value === "," && !i ? this.newEntry() : this.record(t.value);
      if (this.dimension !== 0) throw new Error("array dimension not balanced");
      return this.entries;
    }
  };
  a(vt, "ArrayParser");
  var er = vt;
  function Ca(r) {
    return r;
  }
  a(Ca, "identity");
});
var rr = T((Zl, Ci) => {
  p();
  var _a3 = tr();
  Ci.exports = { create: a(function(r, e) {
    return { parse: a(function() {
      return _a3.parse(r, e);
    }, "parse") };
  }, "create") };
});
var Ti = T((ef, Ii) => {
  "use strict";
  p();
  var Ia = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/, Ta = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/, Pa = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/, Ba = /^-?infinity$/;
  Ii.exports = a(function(e) {
    if (Ba.test(e)) return Number(e.replace("i", "I"));
    var t = Ia.exec(e);
    if (!t) return Ra(
      e
    ) || null;
    var n = !!t[8], i = parseInt(t[1], 10);
    n && (i = _i(i));
    var s = parseInt(t[2], 10) - 1, o = t[3], u = parseInt(
      t[4],
      10
    ), c = parseInt(t[5], 10), l = parseInt(t[6], 10), f = t[7];
    f = f ? 1e3 * parseFloat(f) : 0;
    var y, g = La(e);
    return g != null ? (y = new Date(Date.UTC(i, s, o, u, c, l, f)), nr(i) && y.setUTCFullYear(i), g !== 0 && y.setTime(y.getTime() - g)) : (y = new Date(i, s, o, u, c, l, f), nr(i) && y.setFullYear(i)), y;
  }, "parseDate");
  function Ra(r) {
    var e = Ta.exec(r);
    if (e) {
      var t = parseInt(e[1], 10), n = !!e[4];
      n && (t = _i(t));
      var i = parseInt(e[2], 10) - 1, s = e[3], o = new Date(t, i, s);
      return nr(
        t
      ) && o.setFullYear(t), o;
    }
  }
  a(Ra, "getDate");
  function La(r) {
    if (r.endsWith("+00")) return 0;
    var e = Pa.exec(r.split(" ")[1]);
    if (e) {
      var t = e[1];
      if (t === "Z") return 0;
      var n = t === "-" ? -1 : 1, i = parseInt(e[2], 10) * 3600 + parseInt(
        e[3] || 0,
        10
      ) * 60 + parseInt(e[4] || 0, 10);
      return i * n * 1e3;
    }
  }
  a(La, "timeZoneOffset");
  function _i(r) {
    return -(r - 1);
  }
  a(_i, "bcYearToNegativeYear");
  function nr(r) {
    return r >= 0 && r < 100;
  }
  a(nr, "is0To99");
});
var Bi = T((nf, Pi) => {
  p();
  Pi.exports = ka;
  var Fa = Object.prototype.hasOwnProperty;
  function ka(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) Fa.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }
  a(ka, "extend");
});
var Fi = T((af, Li) => {
  "use strict";
  p();
  var Ma = Bi();
  Li.exports = ke;
  function ke(r) {
    if (!(this instanceof ke))
      return new ke(r);
    Ma(this, Va(r));
  }
  a(ke, "PostgresInterval");
  var Ua = [
    "seconds",
    "minutes",
    "hours",
    "days",
    "months",
    "years"
  ];
  ke.prototype.toPostgres = function() {
    var r = Ua.filter(this.hasOwnProperty, this);
    return this.milliseconds && r.indexOf("seconds") < 0 && r.push("seconds"), r.length === 0 ? "0" : r.map(function(e) {
      var t = this[e] || 0;
      return e === "seconds" && this.milliseconds && (t = (t + this.milliseconds / 1e3).toFixed(6).replace(
        /\.?0+$/,
        ""
      )), t + " " + e;
    }, this).join(" ");
  };
  var Da = { years: "Y", months: "M", days: "D", hours: "H", minutes: "M", seconds: "S" }, Oa = ["years", "months", "days"], qa = ["hours", "minutes", "seconds"];
  ke.prototype.toISOString = ke.prototype.toISO = function() {
    var r = Oa.map(t, this).join(""), e = qa.map(t, this).join("");
    return "P" + r + "T" + e;
    function t(n) {
      var i = this[n] || 0;
      return n === "seconds" && this.milliseconds && (i = (i + this.milliseconds / 1e3).toFixed(6).replace(
        /0+$/,
        ""
      )), i + Da[n];
    }
  };
  var ir = "([+-]?\\d+)", Qa = ir + "\\s+years?", Na = ir + "\\s+mons?", Wa = ir + "\\s+days?", ja = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?", Ha = new RegExp([Qa, Na, Wa, ja].map(function(r) {
    return "(" + r + ")?";
  }).join("\\s*")), Ri = { years: 2, months: 4, days: 6, hours: 9, minutes: 10, seconds: 11, milliseconds: 12 }, $a = ["hours", "minutes", "seconds", "milliseconds"];
  function Ga(r) {
    var e = r + "000000".slice(r.length);
    return parseInt(
      e,
      10
    ) / 1e3;
  }
  a(Ga, "parseMilliseconds");
  function Va(r) {
    if (!r) return {};
    var e = Ha.exec(r), t = e[8] === "-";
    return Object.keys(Ri).reduce(function(n, i) {
      var s = Ri[i], o = e[s];
      return !o || (o = i === "milliseconds" ? Ga(o) : parseInt(o, 10), !o) || (t && ~$a.indexOf(i) && (o *= -1), n[i] = o), n;
    }, {});
  }
  a(Va, "parse");
});
var Mi = T((lf, ki) => {
  "use strict";
  p();
  ki.exports = a(function(e) {
    if (/^\\x/.test(e)) return new d(e.substr(
      2
    ), "hex");
    for (var t = "", n = 0; n < e.length; ) if (e[n] !== "\\") t += e[n], ++n;
    else if (/[0-7]{3}/.test(e.substr(n + 1, 3))) t += String.fromCharCode(parseInt(e.substr(n + 1, 3), 8)), n += 4;
    else {
      for (var i = 1; n + i < e.length && e[n + i] === "\\"; ) i++;
      for (var s = 0; s < Math.floor(i / 2); ++s) t += "\\";
      n += Math.floor(i / 2) * 2;
    }
    return new d(t, "binary");
  }, "parseBytea");
});
var Wi = T((pf, Ni) => {
  p();
  var Ve = tr(), ze = rr(), xt = Ti(), Di = Fi(), Oi = Mi();
  function St(r) {
    return a(function(t) {
      return t === null ? t : r(t);
    }, "nullAllowed");
  }
  a(St, "allowNull");
  function qi(r) {
    return r === null ? r : r === "TRUE" || r === "t" || r === "true" || r === "y" || r === "yes" || r === "on" || r === "1";
  }
  a(qi, "parseBool");
  function za(r) {
    return r ? Ve.parse(r, qi) : null;
  }
  a(za, "parseBoolArray");
  function Ka(r) {
    return parseInt(r, 10);
  }
  a(Ka, "parseBaseTenInt");
  function sr(r) {
    return r ? Ve.parse(r, St(Ka)) : null;
  }
  a(sr, "parseIntegerArray");
  function Ya(r) {
    return r ? Ve.parse(r, St(function(e) {
      return Qi(e).trim();
    })) : null;
  }
  a(Ya, "parseBigIntegerArray");
  var Za = a(function(r) {
    if (!r) return null;
    var e = ze.create(r, function(t) {
      return t !== null && (t = cr(t)), t;
    });
    return e.parse();
  }, "parsePointArray"), or2 = a(function(r) {
    if (!r) return null;
    var e = ze.create(r, function(t) {
      return t !== null && (t = parseFloat(t)), t;
    });
    return e.parse();
  }, "parseFloatArray"), re = a(function(r) {
    if (!r) return null;
    var e = ze.create(r);
    return e.parse();
  }, "parseStringArray"), ar = a(function(r) {
    if (!r) return null;
    var e = ze.create(
      r,
      function(t) {
        return t !== null && (t = xt(t)), t;
      }
    );
    return e.parse();
  }, "parseDateArray"), Ja = a(function(r) {
    if (!r)
      return null;
    var e = ze.create(r, function(t) {
      return t !== null && (t = Di(t)), t;
    });
    return e.parse();
  }, "parseIntervalArray"), Xa = a(function(r) {
    return r ? Ve.parse(r, St(Oi)) : null;
  }, "parseByteAArray"), ur = a(function(r) {
    return parseInt(r, 10);
  }, "parseInteger"), Qi = a(function(r) {
    var e = String(r);
    return /^\d+$/.test(e) ? e : r;
  }, "parseBigInteger"), Ui = a(function(r) {
    return r ? Ve.parse(r, St(JSON.parse)) : null;
  }, "parseJsonArray"), cr = a(
    function(r) {
      return r[0] !== "(" ? null : (r = r.substring(1, r.length - 1).split(","), { x: parseFloat(r[0]), y: parseFloat(
        r[1]
      ) });
    },
    "parsePoint"
  ), eu = a(function(r) {
    if (r[0] !== "<" && r[1] !== "(") return null;
    for (var e = "(", t = "", n = false, i = 2; i < r.length - 1; i++) {
      if (n || (e += r[i]), r[i] === ")") {
        n = true;
        continue;
      } else if (!n) continue;
      r[i] !== "," && (t += r[i]);
    }
    var s = cr(e);
    return s.radius = parseFloat(t), s;
  }, "parseCircle"), tu = a(function(r) {
    r(20, Qi), r(21, ur), r(23, ur), r(26, ur), r(700, parseFloat), r(701, parseFloat), r(16, qi), r(1082, xt), r(1114, xt), r(1184, xt), r(
      600,
      cr
    ), r(651, re), r(718, eu), r(1e3, za), r(1001, Xa), r(1005, sr), r(1007, sr), r(1028, sr), r(1016, Ya), r(1017, Za), r(1021, or2), r(1022, or2), r(1231, or2), r(1014, re), r(1015, re), r(1008, re), r(1009, re), r(1040, re), r(1041, re), r(
      1115,
      ar
    ), r(1182, ar), r(1185, ar), r(1186, Di), r(1187, Ja), r(17, Oi), r(114, JSON.parse.bind(JSON)), r(3802, JSON.parse.bind(JSON)), r(199, Ui), r(3807, Ui), r(3907, re), r(2951, re), r(791, re), r(1183, re), r(1270, re);
  }, "init");
  Ni.exports = { init: tu };
});
var Hi = T((mf, ji) => {
  "use strict";
  p();
  var z2 = 1e6;
  function ru(r) {
    var e = r.readInt32BE(0), t = r.readUInt32BE(
      4
    ), n = "";
    e < 0 && (e = ~e + (t === 0), t = ~t + 1 >>> 0, n = "-");
    var i = "", s, o, u, c, l, f;
    {
      if (s = e % z2, e = e / z2 >>> 0, o = 4294967296 * s + t, t = o / z2 >>> 0, u = "" + (o - z2 * t), t === 0 && e === 0) return n + u + i;
      for (c = "", l = 6 - u.length, f = 0; f < l; f++) c += "0";
      i = c + u + i;
    }
    {
      if (s = e % z2, e = e / z2 >>> 0, o = 4294967296 * s + t, t = o / z2 >>> 0, u = "" + (o - z2 * t), t === 0 && e === 0) return n + u + i;
      for (c = "", l = 6 - u.length, f = 0; f < l; f++) c += "0";
      i = c + u + i;
    }
    {
      if (s = e % z2, e = e / z2 >>> 0, o = 4294967296 * s + t, t = o / z2 >>> 0, u = "" + (o - z2 * t), t === 0 && e === 0) return n + u + i;
      for (c = "", l = 6 - u.length, f = 0; f < l; f++) c += "0";
      i = c + u + i;
    }
    return s = e % z2, o = 4294967296 * s + t, u = "" + o % z2, n + u + i;
  }
  a(ru, "readInt8");
  ji.exports = ru;
});
var Ki = T((bf, zi) => {
  p();
  var nu = Hi(), L = a(function(r, e, t, n, i) {
    t = t || 0, n = n || false, i = i || function(A, C, D) {
      return A * Math.pow(2, D) + C;
    };
    var s = t >> 3, o = a(function(A) {
      return n ? ~A & 255 : A;
    }, "inv"), u = 255, c = 8 - t % 8;
    e < c && (u = 255 << 8 - e & 255, c = e), t && (u = u >> t % 8);
    var l = 0;
    t % 8 + e >= 8 && (l = i(0, o(r[s]) & u, c));
    for (var f = e + t >> 3, y = s + 1; y < f; y++) l = i(l, o(
      r[y]
    ), 8);
    var g = (e + t) % 8;
    return g > 0 && (l = i(l, o(r[f]) >> 8 - g, g)), l;
  }, "parseBits"), Vi = a(function(r, e, t) {
    var n = Math.pow(2, t - 1) - 1, i = L(r, 1), s = L(r, t, 1);
    if (s === 0) return 0;
    var o = 1, u = a(function(l, f, y) {
      l === 0 && (l = 1);
      for (var g = 1; g <= y; g++) o /= 2, (f & 1 << y - g) > 0 && (l += o);
      return l;
    }, "parsePrecisionBits"), c = L(r, e, t + 1, false, u);
    return s == Math.pow(
      2,
      t + 1
    ) - 1 ? c === 0 ? i === 0 ? 1 / 0 : -1 / 0 : NaN : (i === 0 ? 1 : -1) * Math.pow(2, s - n) * c;
  }, "parseFloatFromBits"), iu = a(function(r) {
    return L(r, 1) == 1 ? -1 * (L(r, 15, 1, true) + 1) : L(r, 15, 1);
  }, "parseInt16"), $i = a(function(r) {
    return L(r, 1) == 1 ? -1 * (L(
      r,
      31,
      1,
      true
    ) + 1) : L(r, 31, 1);
  }, "parseInt32"), su = a(function(r) {
    return Vi(r, 23, 8);
  }, "parseFloat32"), ou = a(function(r) {
    return Vi(r, 52, 11);
  }, "parseFloat64"), au = a(function(r) {
    var e = L(r, 16, 32);
    if (e == 49152) return NaN;
    for (var t = Math.pow(1e4, L(r, 16, 16)), n = 0, i = [], s = L(r, 16), o = 0; o < s; o++) n += L(r, 16, 64 + 16 * o) * t, t /= 1e4;
    var u = Math.pow(10, L(
      r,
      16,
      48
    ));
    return (e === 0 ? 1 : -1) * Math.round(n * u) / u;
  }, "parseNumeric"), Gi = a(function(r, e) {
    var t = L(e, 1), n = L(
      e,
      63,
      1
    ), i = new Date((t === 0 ? 1 : -1) * n / 1e3 + 9466848e5);
    return r || i.setTime(i.getTime() + i.getTimezoneOffset() * 6e4), i.usec = n % 1e3, i.getMicroSeconds = function() {
      return this.usec;
    }, i.setMicroSeconds = function(s) {
      this.usec = s;
    }, i.getUTCMicroSeconds = function() {
      return this.usec;
    }, i;
  }, "parseDate"), Ke = a(
    function(r) {
      for (var e = L(
        r,
        32
      ), t = L(r, 32, 32), n = L(r, 32, 64), i = 96, s = [], o = 0; o < e; o++) s[o] = L(r, 32, i), i += 32, i += 32;
      var u = a(function(l) {
        var f = L(r, 32, i);
        if (i += 32, f == 4294967295) return null;
        var y;
        if (l == 23 || l == 20) return y = L(r, f * 8, i), i += f * 8, y;
        if (l == 25) return y = r.toString(this.encoding, i >> 3, (i += f << 3) >> 3), y;
        console.log("ERROR: ElementType not implemented: " + l);
      }, "parseElement"), c = a(function(l, f) {
        var y = [], g;
        if (l.length > 1) {
          var A = l.shift();
          for (g = 0; g < A; g++) y[g] = c(l, f);
          l.unshift(A);
        } else for (g = 0; g < l[0]; g++) y[g] = u(f);
        return y;
      }, "parse");
      return c(s, n);
    },
    "parseArray"
  ), uu = a(function(r) {
    return r.toString("utf8");
  }, "parseText"), cu = a(function(r) {
    return r === null ? null : L(r, 8) > 0;
  }, "parseBool"), lu = a(function(r) {
    r(20, nu), r(21, iu), r(23, $i), r(26, $i), r(1700, au), r(700, su), r(701, ou), r(16, cu), r(1114, Gi.bind(null, false)), r(1184, Gi.bind(null, true)), r(1e3, Ke), r(1007, Ke), r(1016, Ke), r(1008, Ke), r(1009, Ke), r(25, uu);
  }, "init");
  zi.exports = { init: lu };
});
var Zi = T((Sf, Yi) => {
  p();
  Yi.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});
var Je = T((Ze) => {
  p();
  var fu = Wi(), hu = Ki(), pu = rr(), du = Zi();
  Ze.getTypeParser = yu;
  Ze.setTypeParser = mu;
  Ze.arrayParser = pu;
  Ze.builtins = du;
  var Ye = { text: {}, binary: {} };
  function Ji(r) {
    return String(r);
  }
  a(Ji, "noParse");
  function yu(r, e) {
    return e = e || "text", Ye[e] && Ye[e][r] || Ji;
  }
  a(yu, "getTypeParser");
  function mu(r, e, t) {
    typeof e == "function" && (t = e, e = "text"), Ye[e][r] = t;
  }
  a(mu, "setTypeParser");
  fu.init(function(r, e) {
    Ye.text[r] = e;
  });
  hu.init(function(r, e) {
    Ye.binary[r] = e;
  });
});
var At = T((If, Xi) => {
  "use strict";
  p();
  var wu = Je();
  function Et(r) {
    this._types = r || wu, this.text = {}, this.binary = {};
  }
  a(Et, "TypeOverrides");
  Et.prototype.getOverrides = function(r) {
    switch (r) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  Et.prototype.setTypeParser = function(r, e, t) {
    typeof e == "function" && (t = e, e = "text"), this.getOverrides(e)[r] = t;
  };
  Et.prototype.getTypeParser = function(r, e) {
    return e = e || "text", this.getOverrides(e)[r] || this._types.getTypeParser(r, e);
  };
  Xi.exports = Et;
});
function Xe(r) {
  let e = 1779033703, t = 3144134277, n = 1013904242, i = 2773480762, s = 1359893119, o = 2600822924, u = 528734635, c = 1541459225, l = 0, f = 0, y = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], g = a((I, w) => I >>> w | I << 32 - w, "rrot"), A = new Uint32Array(64), C = new Uint8Array(64), D = a(() => {
    for (let R = 0, j = 0; R < 16; R++, j += 4) A[R] = C[j] << 24 | C[j + 1] << 16 | C[j + 2] << 8 | C[j + 3];
    for (let R = 16; R < 64; R++) {
      let j = g(A[R - 15], 7) ^ g(A[R - 15], 18) ^ A[R - 15] >>> 3, le = g(
        A[R - 2],
        17
      ) ^ g(A[R - 2], 19) ^ A[R - 2] >>> 10;
      A[R] = A[R - 16] + j + A[R - 7] + le | 0;
    }
    let I = e, w = t, Z = n, W = i, J = s, X = o, se = u, oe = c;
    for (let R = 0; R < 64; R++) {
      let j = g(J, 6) ^ g(J, 11) ^ g(J, 25), le = J & X ^ ~J & se, de = oe + j + le + y[R] + A[R] | 0, We = g(I, 2) ^ g(
        I,
        13
      ) ^ g(I, 22), fe = I & w ^ I & Z ^ w & Z, _e = We + fe | 0;
      oe = se, se = X, X = J, J = W + de | 0, W = Z, Z = w, w = I, I = de + _e | 0;
    }
    e = e + I | 0, t = t + w | 0, n = n + Z | 0, i = i + W | 0, s = s + J | 0, o = o + X | 0, u = u + se | 0, c = c + oe | 0, f = 0;
  }, "process"), Y = a((I) => {
    typeof I == "string" && (I = new TextEncoder().encode(I));
    for (let w = 0; w < I.length; w++) C[f++] = I[w], f === 64 && D();
    l += I.length;
  }, "add"), P = a(() => {
    if (C[f++] = 128, f == 64 && D(), f + 8 > 64) {
      for (; f < 64; ) C[f++] = 0;
      D();
    }
    for (; f < 58; ) C[f++] = 0;
    let I = l * 8;
    C[f++] = I / 1099511627776 & 255, C[f++] = I / 4294967296 & 255, C[f++] = I >>> 24, C[f++] = I >>> 16 & 255, C[f++] = I >>> 8 & 255, C[f++] = I & 255, D();
    let w = new Uint8Array(
      32
    );
    return w[0] = e >>> 24, w[1] = e >>> 16 & 255, w[2] = e >>> 8 & 255, w[3] = e & 255, w[4] = t >>> 24, w[5] = t >>> 16 & 255, w[6] = t >>> 8 & 255, w[7] = t & 255, w[8] = n >>> 24, w[9] = n >>> 16 & 255, w[10] = n >>> 8 & 255, w[11] = n & 255, w[12] = i >>> 24, w[13] = i >>> 16 & 255, w[14] = i >>> 8 & 255, w[15] = i & 255, w[16] = s >>> 24, w[17] = s >>> 16 & 255, w[18] = s >>> 8 & 255, w[19] = s & 255, w[20] = o >>> 24, w[21] = o >>> 16 & 255, w[22] = o >>> 8 & 255, w[23] = o & 255, w[24] = u >>> 24, w[25] = u >>> 16 & 255, w[26] = u >>> 8 & 255, w[27] = u & 255, w[28] = c >>> 24, w[29] = c >>> 16 & 255, w[30] = c >>> 8 & 255, w[31] = c & 255, w;
  }, "digest");
  return r === void 0 ? { add: Y, digest: P } : (Y(r), P());
}
var es = G(() => {
  "use strict";
  p();
  a(Xe, "sha256");
});
var U;
var et;
var ts = G(() => {
  "use strict";
  p();
  U = class U2 {
    constructor() {
      E(this, "_dataLength", 0);
      E(this, "_bufferLength", 0);
      E(this, "_state", new Int32Array(4));
      E(this, "_buffer", new ArrayBuffer(68));
      E(this, "_buffer8");
      E(this, "_buffer32");
      this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
    }
    static hashByteArray(e, t = false) {
      return this.onePassHasher.start().appendByteArray(
        e
      ).end(t);
    }
    static hashStr(e, t = false) {
      return this.onePassHasher.start().appendStr(e).end(t);
    }
    static hashAsciiStr(e, t = false) {
      return this.onePassHasher.start().appendAsciiStr(e).end(t);
    }
    static _hex(e) {
      let t = U2.hexChars, n = U2.hexOut, i, s, o, u;
      for (u = 0; u < 4; u += 1) for (s = u * 8, i = e[u], o = 0; o < 8; o += 2) n[s + 1 + o] = t.charAt(i & 15), i >>>= 4, n[s + 0 + o] = t.charAt(
        i & 15
      ), i >>>= 4;
      return n.join("");
    }
    static _md5cycle(e, t) {
      let n = e[0], i = e[1], s = e[2], o = e[3];
      n += (i & s | ~i & o) + t[0] - 680876936 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[1] - 389564586 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[2] + 606105819 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[3] - 1044525330 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[4] - 176418897 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[5] + 1200080426 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[6] - 1473231341 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[7] - 45705983 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[8] + 1770035416 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[9] - 1958414417 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[10] - 42063 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[11] - 1990404162 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[12] + 1804603682 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[13] - 40341101 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[14] - 1502002290 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[15] + 1236535329 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & o | s & ~o) + t[1] - 165796510 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[6] - 1069501632 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[11] + 643717713 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[0] - 373897302 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[5] - 701558691 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[10] + 38016083 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[15] - 660478335 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[4] - 405537848 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[9] + 568446438 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[14] - 1019803690 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[3] - 187363961 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[8] + 1163531501 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[13] - 1444681467 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[2] - 51403784 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[7] + 1735328473 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[12] - 1926607734 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i ^ s ^ o) + t[5] - 378558 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[8] - 2022574463 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[11] + 1839030562 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[14] - 35309556 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[1] - 1530992060 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[4] + 1272893353 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[7] - 155497632 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[10] - 1094730640 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[13] + 681279174 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[0] - 358537222 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[3] - 722521979 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[6] + 76029189 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[9] - 640364487 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[12] - 421815835 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[15] + 530742520 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[2] - 995338651 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (s ^ (i | ~o)) + t[0] - 198630844 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[7] + 1126891415 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[14] - 1416354905 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[5] - 57434055 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[12] + 1700485571 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[3] - 1894986606 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[10] - 1051523 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[1] - 2054922799 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[8] + 1873313359 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[15] - 30611744 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[6] - 1560198380 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[13] + 1309151649 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[4] - 145523070 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[11] - 1120210379 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[2] + 718787259 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[9] - 343485551 | 0, i = (i << 21 | i >>> 11) + s | 0, e[0] = n + e[0] | 0, e[1] = i + e[1] | 0, e[2] = s + e[2] | 0, e[3] = o + e[3] | 0;
    }
    start() {
      return this._dataLength = 0, this._bufferLength = 0, this._state.set(U2.stateIdentity), this;
    }
    appendStr(e) {
      let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o;
      for (o = 0; o < e.length; o += 1) {
        if (s = e.charCodeAt(o), s < 128) t[i++] = s;
        else if (s < 2048) t[i++] = (s >>> 6) + 192, t[i++] = s & 63 | 128;
        else if (s < 55296 || s > 56319) t[i++] = (s >>> 12) + 224, t[i++] = s >>> 6 & 63 | 128, t[i++] = s & 63 | 128;
        else {
          if (s = (s - 55296) * 1024 + (e.charCodeAt(++o) - 56320) + 65536, s > 1114111) throw new Error(
            "Unicode standard supports code points up to U+10FFFF"
          );
          t[i++] = (s >>> 18) + 240, t[i++] = s >>> 12 & 63 | 128, t[i++] = s >>> 6 & 63 | 128, t[i++] = s & 63 | 128;
        }
        i >= 64 && (this._dataLength += 64, U2._md5cycle(this._state, n), i -= 64, n[0] = n[16]);
      }
      return this._bufferLength = i, this;
    }
    appendAsciiStr(e) {
      let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o = 0;
      for (; ; ) {
        for (s = Math.min(e.length - o, 64 - i); s--; ) t[i++] = e.charCodeAt(o++);
        if (i < 64) break;
        this._dataLength += 64, U2._md5cycle(this._state, n), i = 0;
      }
      return this._bufferLength = i, this;
    }
    appendByteArray(e) {
      let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o = 0;
      for (; ; ) {
        for (s = Math.min(e.length - o, 64 - i); s--; ) t[i++] = e[o++];
        if (i < 64) break;
        this._dataLength += 64, U2._md5cycle(this._state, n), i = 0;
      }
      return this._bufferLength = i, this;
    }
    getState() {
      let e = this._state;
      return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e[0], e[1], e[2], e[3]] };
    }
    setState(e) {
      let t = e.buffer, n = e.state, i = this._state, s;
      for (this._dataLength = e.length, this._bufferLength = e.buflen, i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], s = 0; s < t.length; s += 1) this._buffer8[s] = t.charCodeAt(s);
    }
    end(e = false) {
      let t = this._bufferLength, n = this._buffer8, i = this._buffer32, s = (t >> 2) + 1;
      this._dataLength += t;
      let o = this._dataLength * 8;
      if (n[t] = 128, n[t + 1] = n[t + 2] = n[t + 3] = 0, i.set(U2.buffer32Identity.subarray(s), s), t > 55 && (U2._md5cycle(this._state, i), i.set(U2.buffer32Identity)), o <= 4294967295) i[14] = o;
      else {
        let u = o.toString(16).match(/(.*?)(.{0,8})$/);
        if (u === null) return;
        let c = parseInt(
          u[2],
          16
        ), l = parseInt(u[1], 16) || 0;
        i[14] = c, i[15] = l;
      }
      return U2._md5cycle(this._state, i), e ? this._state : U2._hex(
        this._state
      );
    }
  };
  a(U, "Md5"), E(U, "stateIdentity", new Int32Array([1732584193, -271733879, -1732584194, 271733878])), E(U, "buffer32Identity", new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), E(U, "hexChars", "0123456789abcdef"), E(U, "hexOut", []), E(U, "onePassHasher", new U());
  et = U;
});
var lr = {};
ie(lr, { createHash: () => bu, createHmac: () => vu, randomBytes: () => gu });
function gu(r) {
  return crypto.getRandomValues(d.alloc(r));
}
function bu(r) {
  if (r === "sha256") return { update: a(function(e) {
    return { digest: a(
      function() {
        return d.from(Xe(e));
      },
      "digest"
    ) };
  }, "update") };
  if (r === "md5") return { update: a(function(e) {
    return {
      digest: a(function() {
        return typeof e == "string" ? et.hashStr(e) : et.hashByteArray(e);
      }, "digest")
    };
  }, "update") };
  throw new Error(`Hash type '${r}' not supported`);
}
function vu(r, e) {
  if (r !== "sha256") throw new Error(`Only sha256 is supported (requested: '${r}')`);
  return { update: a(function(t) {
    return { digest: a(
      function() {
        typeof e == "string" && (e = new TextEncoder().encode(e)), typeof t == "string" && (t = new TextEncoder().encode(
          t
        ));
        let n = e.length;
        if (n > 64) e = Xe(e);
        else if (n < 64) {
          let c = new Uint8Array(64);
          c.set(e), e = c;
        }
        let i = new Uint8Array(
          64
        ), s = new Uint8Array(64);
        for (let c = 0; c < 64; c++) i[c] = 54 ^ e[c], s[c] = 92 ^ e[c];
        let o = new Uint8Array(t.length + 64);
        o.set(i, 0), o.set(t, 64);
        let u = new Uint8Array(96);
        return u.set(s, 0), u.set(Xe(o), 64), d.from(Xe(u));
      },
      "digest"
    ) };
  }, "update") };
}
var fr = G(() => {
  "use strict";
  p();
  es();
  ts();
  a(gu, "randomBytes");
  a(bu, "createHash");
  a(vu, "createHmac");
});
var tt = T((Qf, hr) => {
  "use strict";
  p();
  hr.exports = {
    host: "localhost",
    user: m.platform === "win32" ? m.env.USERNAME : m.env.USER,
    database: void 0,
    password: null,
    connectionString: void 0,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 3e4,
    client_encoding: "",
    ssl: false,
    application_name: void 0,
    fallback_application_name: void 0,
    options: void 0,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var Me = Je(), xu = Me.getTypeParser(20, "text"), Su = Me.getTypeParser(
    1016,
    "text"
  );
  hr.exports.__defineSetter__("parseInt8", function(r) {
    Me.setTypeParser(20, "text", r ? Me.getTypeParser(
      23,
      "text"
    ) : xu), Me.setTypeParser(1016, "text", r ? Me.getTypeParser(1007, "text") : Su);
  });
});
var rt = T((Wf, ns) => {
  "use strict";
  p();
  var Eu = (fr(), O(lr)), Au = tt();
  function Cu(r) {
    var e = r.replace(
      /\\/g,
      "\\\\"
    ).replace(/"/g, '\\"');
    return '"' + e + '"';
  }
  a(Cu, "escapeElement");
  function rs(r) {
    for (var e = "{", t = 0; t < r.length; t++) t > 0 && (e = e + ","), r[t] === null || typeof r[t] > "u" ? e = e + "NULL" : Array.isArray(r[t]) ? e = e + rs(r[t]) : r[t] instanceof d ? e += "\\\\x" + r[t].toString("hex") : e += Cu(Ct(r[t]));
    return e = e + "}", e;
  }
  a(rs, "arrayString");
  var Ct = a(function(r, e) {
    if (r == null) return null;
    if (r instanceof d) return r;
    if (ArrayBuffer.isView(r)) {
      var t = d.from(r.buffer, r.byteOffset, r.byteLength);
      return t.length === r.byteLength ? t : t.slice(r.byteOffset, r.byteOffset + r.byteLength);
    }
    return r instanceof Date ? Au.parseInputDatesAsUTC ? Tu(r) : Iu(r) : Array.isArray(r) ? rs(r) : typeof r == "object" ? _u(r, e) : r.toString();
  }, "prepareValue");
  function _u(r, e) {
    if (r && typeof r.toPostgres == "function") {
      if (e = e || [], e.indexOf(r) !== -1) throw new Error('circular reference detected while preparing "' + r + '" for query');
      return e.push(r), Ct(r.toPostgres(Ct), e);
    }
    return JSON.stringify(r);
  }
  a(_u, "prepareObject");
  function N(r, e) {
    for (r = "" + r; r.length < e; ) r = "0" + r;
    return r;
  }
  a(N, "pad");
  function Iu(r) {
    var e = -r.getTimezoneOffset(), t = r.getFullYear(), n = t < 1;
    n && (t = Math.abs(t) + 1);
    var i = N(t, 4) + "-" + N(r.getMonth() + 1, 2) + "-" + N(r.getDate(), 2) + "T" + N(
      r.getHours(),
      2
    ) + ":" + N(r.getMinutes(), 2) + ":" + N(r.getSeconds(), 2) + "." + N(r.getMilliseconds(), 3);
    return e < 0 ? (i += "-", e *= -1) : i += "+", i += N(Math.floor(e / 60), 2) + ":" + N(e % 60, 2), n && (i += " BC"), i;
  }
  a(Iu, "dateToString");
  function Tu(r) {
    var e = r.getUTCFullYear(), t = e < 1;
    t && (e = Math.abs(e) + 1);
    var n = N(e, 4) + "-" + N(r.getUTCMonth() + 1, 2) + "-" + N(r.getUTCDate(), 2) + "T" + N(r.getUTCHours(), 2) + ":" + N(r.getUTCMinutes(), 2) + ":" + N(r.getUTCSeconds(), 2) + "." + N(
      r.getUTCMilliseconds(),
      3
    );
    return n += "+00:00", t && (n += " BC"), n;
  }
  a(Tu, "dateToStringUTC");
  function Pu(r, e, t) {
    return r = typeof r == "string" ? { text: r } : r, e && (typeof e == "function" ? r.callback = e : r.values = e), t && (r.callback = t), r;
  }
  a(Pu, "normalizeQueryConfig");
  var pr = a(function(r) {
    return Eu.createHash("md5").update(r, "utf-8").digest("hex");
  }, "md5"), Bu = a(
    function(r, e, t) {
      var n = pr(e + r), i = pr(d.concat([d.from(n), t]));
      return "md5" + i;
    },
    "postgresMd5PasswordHash"
  );
  ns.exports = {
    prepareValue: a(function(e) {
      return Ct(e);
    }, "prepareValueWrapper"),
    normalizeQueryConfig: Pu,
    postgresMd5PasswordHash: Bu,
    md5: pr
  };
});
var nt = {};
ie(nt, { default: () => ku });
var ku;
var it = G(() => {
  "use strict";
  p();
  ku = {};
});
var ds = T((th, ps) => {
  "use strict";
  p();
  var yr = (fr(), O(lr));
  function Mu(r) {
    if (r.indexOf("SCRAM-SHA-256") === -1) throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    let e = yr.randomBytes(
      18
    ).toString("base64");
    return { mechanism: "SCRAM-SHA-256", clientNonce: e, response: "n,,n=*,r=" + e, message: "SASLInitialResponse" };
  }
  a(Mu, "startSession");
  function Uu(r, e, t) {
    if (r.message !== "SASLInitialResponse") throw new Error(
      "SASL: Last message was not SASLInitialResponse"
    );
    if (typeof e != "string") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    if (typeof t != "string") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    let n = qu(t);
    if (n.nonce.startsWith(r.clientNonce)) {
      if (n.nonce.length === r.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    var i = d.from(n.salt, "base64"), s = Wu(e, i, n.iteration), o = Ue(s, "Client Key"), u = Nu(
      o
    ), c = "n=*,r=" + r.clientNonce, l = "r=" + n.nonce + ",s=" + n.salt + ",i=" + n.iteration, f = "c=biws,r=" + n.nonce, y = c + "," + l + "," + f, g = Ue(u, y), A = hs(o, g), C = A.toString("base64"), D = Ue(s, "Server Key"), Y = Ue(D, y);
    r.message = "SASLResponse", r.serverSignature = Y.toString("base64"), r.response = f + ",p=" + C;
  }
  a(Uu, "continueSession");
  function Du(r, e) {
    if (r.message !== "SASLResponse") throw new Error("SASL: Last message was not SASLResponse");
    if (typeof e != "string") throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    let { serverSignature: t } = Qu(
      e
    );
    if (t !== r.serverSignature) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
  }
  a(Du, "finalizeSession");
  function Ou(r) {
    if (typeof r != "string") throw new TypeError("SASL: text must be a string");
    return r.split("").map((e, t) => r.charCodeAt(t)).every((e) => e >= 33 && e <= 43 || e >= 45 && e <= 126);
  }
  a(Ou, "isPrintableChars");
  function ls(r) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(r);
  }
  a(ls, "isBase64");
  function fs(r) {
    if (typeof r != "string") throw new TypeError("SASL: attribute pairs text must be a string");
    return new Map(r.split(",").map((e) => {
      if (!/^.=/.test(e)) throw new Error("SASL: Invalid attribute pair entry");
      let t = e[0], n = e.substring(2);
      return [t, n];
    }));
  }
  a(fs, "parseAttributePairs");
  function qu(r) {
    let e = fs(r), t = e.get("r");
    if (t) {
      if (!Ou(t)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    let n = e.get("s");
    if (n) {
      if (!ls(n)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    let i = e.get("i");
    if (i) {
      if (!/^[1-9][0-9]*$/.test(i)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    let s = parseInt(i, 10);
    return { nonce: t, salt: n, iteration: s };
  }
  a(qu, "parseServerFirstMessage");
  function Qu(r) {
    let t = fs(r).get("v");
    if (t) {
      if (!ls(t)) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    } else throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    return { serverSignature: t };
  }
  a(Qu, "parseServerFinalMessage");
  function hs(r, e) {
    if (!d.isBuffer(r)) throw new TypeError("first argument must be a Buffer");
    if (!d.isBuffer(e)) throw new TypeError(
      "second argument must be a Buffer"
    );
    if (r.length !== e.length) throw new Error("Buffer lengths must match");
    if (r.length === 0) throw new Error("Buffers cannot be empty");
    return d.from(r.map((t, n) => r[n] ^ e[n]));
  }
  a(hs, "xorBuffers");
  function Nu(r) {
    return yr.createHash("sha256").update(r).digest();
  }
  a(Nu, "sha256");
  function Ue(r, e) {
    return yr.createHmac("sha256", r).update(e).digest();
  }
  a(Ue, "hmacSha256");
  function Wu(r, e, t) {
    for (var n = Ue(
      r,
      d.concat([e, d.from([0, 0, 0, 1])])
    ), i = n, s = 0; s < t - 1; s++) n = Ue(r, n), i = hs(i, n);
    return i;
  }
  a(Wu, "Hi");
  ps.exports = { startSession: Mu, continueSession: Uu, finalizeSession: Du };
});
var mr = {};
ie(mr, { join: () => ju });
function ju(...r) {
  return r.join("/");
}
var wr = G(() => {
  "use strict";
  p();
  a(
    ju,
    "join"
  );
});
var gr = {};
ie(gr, { stat: () => Hu });
function Hu(r, e) {
  e(new Error("No filesystem"));
}
var br = G(() => {
  "use strict";
  p();
  a(Hu, "stat");
});
var vr = {};
ie(vr, { default: () => $u });
var $u;
var xr = G(() => {
  "use strict";
  p();
  $u = {};
});
var ys = {};
ie(ys, { StringDecoder: () => Sr });
var Er;
var Sr;
var ms = G(() => {
  "use strict";
  p();
  Er = class Er {
    constructor(e) {
      E(this, "td");
      this.td = new TextDecoder(e);
    }
    write(e) {
      return this.td.decode(e, { stream: true });
    }
    end(e) {
      return this.td.decode(e);
    }
  };
  a(Er, "StringDecoder");
  Sr = Er;
});
var vs = T((fh, bs) => {
  "use strict";
  p();
  var { Transform: Gu } = (xr(), O(vr)), { StringDecoder: Vu } = (ms(), O(ys)), ve = /* @__PURE__ */ Symbol(
    "last"
  ), It = /* @__PURE__ */ Symbol("decoder");
  function zu(r, e, t) {
    let n;
    if (this.overflow) {
      if (n = this[It].write(r).split(
        this.matcher
      ), n.length === 1) return t();
      n.shift(), this.overflow = false;
    } else this[ve] += this[It].write(r), n = this[ve].split(this.matcher);
    this[ve] = n.pop();
    for (let i = 0; i < n.length; i++) try {
      gs(this, this.mapper(n[i]));
    } catch (s) {
      return t(s);
    }
    if (this.overflow = this[ve].length > this.maxLength, this.overflow && !this.skipOverflow) {
      t(new Error(
        "maximum buffer reached"
      ));
      return;
    }
    t();
  }
  a(zu, "transform");
  function Ku(r) {
    if (this[ve] += this[It].end(), this[ve])
      try {
        gs(this, this.mapper(this[ve]));
      } catch (e) {
        return r(e);
      }
    r();
  }
  a(Ku, "flush");
  function gs(r, e) {
    e !== void 0 && r.push(e);
  }
  a(gs, "push");
  function ws(r) {
    return r;
  }
  a(ws, "noop");
  function Yu(r, e, t) {
    switch (r = r || /\r?\n/, e = e || ws, t = t || {}, arguments.length) {
      case 1:
        typeof r == "function" ? (e = r, r = /\r?\n/) : typeof r == "object" && !(r instanceof RegExp) && !r[Symbol.split] && (t = r, r = /\r?\n/);
        break;
      case 2:
        typeof r == "function" ? (t = e, e = r, r = /\r?\n/) : typeof e == "object" && (t = e, e = ws);
    }
    t = Object.assign({}, t), t.autoDestroy = true, t.transform = zu, t.flush = Ku, t.readableObjectMode = true;
    let n = new Gu(t);
    return n[ve] = "", n[It] = new Vu("utf8"), n.matcher = r, n.mapper = e, n.maxLength = t.maxLength, n.skipOverflow = t.skipOverflow || false, n.overflow = false, n._destroy = function(i, s) {
      this._writableState.errorEmitted = false, s(i);
    }, n;
  }
  a(Yu, "split");
  bs.exports = Yu;
});
var Es = T((dh, pe) => {
  "use strict";
  p();
  var xs = (wr(), O(mr)), Zu = (xr(), O(vr)).Stream, Ju = vs(), Ss = (it(), O(nt)), Xu = 5432, Tt = m.platform === "win32", st = m.stderr, ec = 56, tc = 7, rc = 61440, nc = 32768;
  function ic(r) {
    return (r & rc) == nc;
  }
  a(ic, "isRegFile");
  var De = ["host", "port", "database", "user", "password"], Ar = De.length, sc = De[Ar - 1];
  function Cr() {
    var r = st instanceof Zu && st.writable === true;
    if (r) {
      var e = Array.prototype.slice.call(arguments).concat(`
`);
      st.write(Ss.format.apply(Ss, e));
    }
  }
  a(Cr, "warn");
  Object.defineProperty(pe.exports, "isWin", { get: a(function() {
    return Tt;
  }, "get"), set: a(function(r) {
    Tt = r;
  }, "set") });
  pe.exports.warnTo = function(r) {
    var e = st;
    return st = r, e;
  };
  pe.exports.getFileName = function(r) {
    var e = r || m.env, t = e.PGPASSFILE || (Tt ? xs.join(e.APPDATA || "./", "postgresql", "pgpass.conf") : xs.join(e.HOME || "./", ".pgpass"));
    return t;
  };
  pe.exports.usePgPass = function(r, e) {
    return Object.prototype.hasOwnProperty.call(m.env, "PGPASSWORD") ? false : Tt ? true : (e = e || "<unkn>", ic(r.mode) ? r.mode & (ec | tc) ? (Cr('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', e), false) : true : (Cr('WARNING: password file "%s" is not a plain file', e), false));
  };
  var oc = pe.exports.match = function(r, e) {
    return De.slice(0, -1).reduce(function(t, n, i) {
      return i == 1 && Number(r[n] || Xu) === Number(
        e[n]
      ) ? t && true : t && (e[n] === "*" || e[n] === r[n]);
    }, true);
  };
  pe.exports.getPassword = function(r, e, t) {
    var n, i = e.pipe(
      Ju()
    );
    function s(c) {
      var l = ac(c);
      l && uc(l) && oc(r, l) && (n = l[sc], i.end());
    }
    a(s, "onLine");
    var o = a(function() {
      e.destroy(), t(n);
    }, "onEnd"), u = a(function(c) {
      e.destroy(), Cr("WARNING: error on reading file: %s", c), t(
        void 0
      );
    }, "onErr");
    e.on("error", u), i.on("data", s).on("end", o).on("error", u);
  };
  var ac = pe.exports.parseLine = function(r) {
    if (r.length < 11 || r.match(/^\s+#/)) return null;
    for (var e = "", t = "", n = 0, i = 0, s = 0, o = {}, u = false, c = a(
      function(f, y, g) {
        var A = r.substring(y, g);
        Object.hasOwnProperty.call(m.env, "PGPASS_NO_DEESCAPE") || (A = A.replace(/\\([:\\])/g, "$1")), o[De[f]] = A;
      },
      "addToObj"
    ), l = 0; l < r.length - 1; l += 1) {
      if (e = r.charAt(l + 1), t = r.charAt(
        l
      ), u = n == Ar - 1, u) {
        c(n, i);
        break;
      }
      l >= 0 && e == ":" && t !== "\\" && (c(n, i, l + 1), i = l + 2, n += 1);
    }
    return o = Object.keys(o).length === Ar ? o : null, o;
  }, uc = pe.exports.isValidEntry = function(r) {
    for (var e = { 0: function(o) {
      return o.length > 0;
    }, 1: function(o) {
      return o === "*" ? true : (o = Number(o), isFinite(o) && o > 0 && o < 9007199254740992 && Math.floor(o) === o);
    }, 2: function(o) {
      return o.length > 0;
    }, 3: function(o) {
      return o.length > 0;
    }, 4: function(o) {
      return o.length > 0;
    } }, t = 0; t < De.length; t += 1) {
      var n = e[t], i = r[De[t]] || "", s = n(i);
      if (!s) return false;
    }
    return true;
  };
});
var Cs = T((gh, _r) => {
  "use strict";
  p();
  var wh = (wr(), O(mr)), As = (br(), O(gr)), Pt = Es();
  _r.exports = function(r, e) {
    var t = Pt.getFileName();
    As.stat(t, function(n, i) {
      if (n || !Pt.usePgPass(i, t)) return e(void 0);
      var s = As.createReadStream(
        t
      );
      Pt.getPassword(r, s, e);
    });
  };
  _r.exports.warnTo = Pt.warnTo;
});
var _s = {};
ie(_s, { default: () => cc });
var cc;
var Is = G(() => {
  "use strict";
  p();
  cc = {};
});
var Ps = T((xh, Ts) => {
  "use strict";
  p();
  var lc = (Zt(), O(gi)), Ir = (br(), O(gr));
  function Tr(r) {
    if (r.charAt(0) === "/") {
      var t = r.split(" ");
      return { host: t[0], database: t[1] };
    }
    var e = lc.parse(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(r) ? encodeURI(r).replace(/\%25(\d\d)/g, "%$1") : r, true), t = e.query;
    for (var n in t) Array.isArray(t[n]) && (t[n] = t[n][t[n].length - 1]);
    var i = (e.auth || ":").split(":");
    if (t.user = i[0], t.password = i.splice(1).join(
      ":"
    ), t.port = e.port, e.protocol == "socket:") return t.host = decodeURI(e.pathname), t.database = e.query.db, t.client_encoding = e.query.encoding, t;
    t.host || (t.host = e.hostname);
    var s = e.pathname;
    if (!t.host && s && /^%2f/i.test(s)) {
      var o = s.split("/");
      t.host = decodeURIComponent(o[0]), s = o.splice(1).join("/");
    }
    switch (s && s.charAt(
      0
    ) === "/" && (s = s.slice(1) || null), t.database = s && decodeURI(s), (t.ssl === "true" || t.ssl === "1") && (t.ssl = true), t.ssl === "0" && (t.ssl = false), (t.sslcert || t.sslkey || t.sslrootcert || t.sslmode) && (t.ssl = {}), t.sslcert && (t.ssl.cert = Ir.readFileSync(t.sslcert).toString()), t.sslkey && (t.ssl.key = Ir.readFileSync(t.sslkey).toString()), t.sslrootcert && (t.ssl.ca = Ir.readFileSync(t.sslrootcert).toString()), t.sslmode) {
      case "disable": {
        t.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        break;
      case "no-verify": {
        t.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return t;
  }
  a(Tr, "parse");
  Ts.exports = Tr;
  Tr.parse = Tr;
});
var Bt = T((Ah, Ls) => {
  "use strict";
  p();
  var fc = (Is(), O(_s)), Rs = tt(), Bs = Ps().parse, H = a(function(r, e, t) {
    return t === void 0 ? t = m.env["PG" + r.toUpperCase()] : t === false || (t = m.env[t]), e[r] || t || Rs[r];
  }, "val"), hc = a(function() {
    switch (m.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return Rs.ssl;
  }, "readSSLConfigFromEnvironment"), Oe = a(function(r) {
    return "'" + ("" + r).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  }, "quoteParamValue"), ne2 = a(function(r, e, t) {
    var n = e[t];
    n != null && r.push(t + "=" + Oe(n));
  }, "add"), Br = class Br {
    constructor(e) {
      e = typeof e == "string" ? Bs(e) : e || {}, e.connectionString && (e = Object.assign({}, e, Bs(e.connectionString))), this.user = H("user", e), this.database = H("database", e), this.database === void 0 && (this.database = this.user), this.port = parseInt(H("port", e), 10), this.host = H("host", e), Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: H("password", e)
      }), this.binary = H("binary", e), this.options = H("options", e), this.ssl = typeof e.ssl > "u" ? hc() : e.ssl, typeof this.ssl == "string" && this.ssl === "true" && (this.ssl = true), this.ssl === "no-verify" && (this.ssl = { rejectUnauthorized: false }), this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this.client_encoding = H("client_encoding", e), this.replication = H("replication", e), this.isDomainSocket = !(this.host || "").indexOf("/"), this.application_name = H("application_name", e, "PGAPPNAME"), this.fallback_application_name = H("fallback_application_name", e, false), this.statement_timeout = H("statement_timeout", e, false), this.lock_timeout = H("lock_timeout", e, false), this.idle_in_transaction_session_timeout = H("idle_in_transaction_session_timeout", e, false), this.query_timeout = H("query_timeout", e, false), e.connectionTimeoutMillis === void 0 ? this.connect_timeout = m.env.PGCONNECT_TIMEOUT || 0 : this.connect_timeout = Math.floor(e.connectionTimeoutMillis / 1e3), e.keepAlive === false ? this.keepalives = 0 : e.keepAlive === true && (this.keepalives = 1), typeof e.keepAliveInitialDelayMillis == "number" && (this.keepalives_idle = Math.floor(e.keepAliveInitialDelayMillis / 1e3));
    }
    getLibpqConnectionString(e) {
      var t = [];
      ne2(t, this, "user"), ne2(t, this, "password"), ne2(t, this, "port"), ne2(t, this, "application_name"), ne2(
        t,
        this,
        "fallback_application_name"
      ), ne2(t, this, "connect_timeout"), ne2(t, this, "options");
      var n = typeof this.ssl == "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      if (ne2(t, n, "sslmode"), ne2(t, n, "sslca"), ne2(t, n, "sslkey"), ne2(t, n, "sslcert"), ne2(t, n, "sslrootcert"), this.database && t.push("dbname=" + Oe(this.database)), this.replication && t.push("replication=" + Oe(this.replication)), this.host && t.push("host=" + Oe(this.host)), this.isDomainSocket) return e(null, t.join(" "));
      this.client_encoding && t.push("client_encoding=" + Oe(this.client_encoding)), fc.lookup(this.host, function(i, s) {
        return i ? e(i, null) : (t.push("hostaddr=" + Oe(s)), e(null, t.join(" ")));
      });
    }
  };
  a(Br, "ConnectionParameters");
  var Pr = Br;
  Ls.exports = Pr;
});
var Ms = T((Ih, ks) => {
  "use strict";
  p();
  var pc = Je(), Fs = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/, Lr = class Lr {
    constructor(e, t) {
      this.command = null, this.rowCount = null, this.oid = null, this.rows = [], this.fields = [], this._parsers = void 0, this._types = t, this.RowCtor = null, this.rowAsArray = e === "array", this.rowAsArray && (this.parseRow = this._parseRowAsArray);
    }
    addCommandComplete(e) {
      var t;
      e.text ? t = Fs.exec(e.text) : t = Fs.exec(e.command), t && (this.command = t[1], t[3] ? (this.oid = parseInt(
        t[2],
        10
      ), this.rowCount = parseInt(t[3], 10)) : t[2] && (this.rowCount = parseInt(t[2], 10)));
    }
    _parseRowAsArray(e) {
      for (var t = new Array(
        e.length
      ), n = 0, i = e.length; n < i; n++) {
        var s = e[n];
        s !== null ? t[n] = this._parsers[n](s) : t[n] = null;
      }
      return t;
    }
    parseRow(e) {
      for (var t = {}, n = 0, i = e.length; n < i; n++) {
        var s = e[n], o = this.fields[n].name;
        s !== null ? t[o] = this._parsers[n](
          s
        ) : t[o] = null;
      }
      return t;
    }
    addRow(e) {
      this.rows.push(e);
    }
    addFields(e) {
      this.fields = e, this.fields.length && (this._parsers = new Array(e.length));
      for (var t = 0; t < e.length; t++) {
        var n = e[t];
        this._types ? this._parsers[t] = this._types.getTypeParser(n.dataTypeID, n.format || "text") : this._parsers[t] = pc.getTypeParser(n.dataTypeID, n.format || "text");
      }
    }
  };
  a(Lr, "Result");
  var Rr = Lr;
  ks.exports = Rr;
});
var qs = T((Bh, Os) => {
  "use strict";
  p();
  var { EventEmitter: dc } = ge(), Us = Ms(), Ds = rt(), kr = class kr extends dc {
    constructor(e, t, n) {
      super(), e = Ds.normalizeQueryConfig(e, t, n), this.text = e.text, this.values = e.values, this.rows = e.rows, this.types = e.types, this.name = e.name, this.binary = e.binary, this.portal = e.portal || "", this.callback = e.callback, this._rowMode = e.rowMode, m.domain && e.callback && (this.callback = m.domain.bind(e.callback)), this._result = new Us(this._rowMode, this.types), this._results = this._result, this.isPreparedStatement = false, this._canceledDueToError = false, this._promise = null;
    }
    requiresPreparation() {
      return this.name || this.rows ? true : !this.text || !this.values ? false : this.values.length > 0;
    }
    _checkForMultirow() {
      this._result.command && (Array.isArray(this._results) || (this._results = [this._result]), this._result = new Us(this._rowMode, this.types), this._results.push(this._result));
    }
    handleRowDescription(e) {
      this._checkForMultirow(), this._result.addFields(e.fields), this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(e) {
      let t;
      if (!this._canceledDueToError) {
        try {
          t = this._result.parseRow(
            e.fields
          );
        } catch (n) {
          this._canceledDueToError = n;
          return;
        }
        this.emit("row", t, this._result), this._accumulateRows && this._result.addRow(t);
      }
    }
    handleCommandComplete(e, t) {
      this._checkForMultirow(), this._result.addCommandComplete(
        e
      ), this.rows && t.sync();
    }
    handleEmptyQuery(e) {
      this.rows && e.sync();
    }
    handleError(e, t) {
      if (this._canceledDueToError && (e = this._canceledDueToError, this._canceledDueToError = false), this.callback) return this.callback(e);
      this.emit("error", e);
    }
    handleReadyForQuery(e) {
      if (this._canceledDueToError) return this.handleError(
        this._canceledDueToError,
        e
      );
      if (this.callback) try {
        this.callback(null, this._results);
      } catch (t) {
        m.nextTick(() => {
          throw t;
        });
      }
      this.emit(
        "end",
        this._results
      );
    }
    submit(e) {
      if (typeof this.text != "string" && typeof this.name != "string") return new Error(
        "A query must have either text or a name. Supplying neither is unsupported."
      );
      let t = e.parsedStatements[this.name];
      return this.text && t && this.text !== t ? new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`) : this.values && !Array.isArray(this.values) ? new Error("Query values must be an array") : (this.requiresPreparation() ? this.prepare(e) : e.query(this.text), null);
    }
    hasBeenParsed(e) {
      return this.name && e.parsedStatements[this.name];
    }
    handlePortalSuspended(e) {
      this._getRows(e, this.rows);
    }
    _getRows(e, t) {
      e.execute({ portal: this.portal, rows: t }), t ? e.flush() : e.sync();
    }
    prepare(e) {
      this.isPreparedStatement = true, this.hasBeenParsed(e) || e.parse({ text: this.text, name: this.name, types: this.types });
      try {
        e.bind({ portal: this.portal, statement: this.name, values: this.values, binary: this.binary, valueMapper: Ds.prepareValue });
      } catch (t) {
        this.handleError(t, e);
        return;
      }
      e.describe({ type: "P", name: this.portal || "" }), this._getRows(e, this.rows);
    }
    handleCopyInResponse(e) {
      e.sendCopyFail("No source stream defined");
    }
    handleCopyData(e, t) {
    }
  };
  a(kr, "Query");
  var Fr = kr;
  Os.exports = Fr;
});
var ln = T((_) => {
  "use strict";
  p();
  Object.defineProperty(_, "__esModule", { value: true });
  _.NoticeMessage = _.DataRowMessage = _.CommandCompleteMessage = _.ReadyForQueryMessage = _.NotificationResponseMessage = _.BackendKeyDataMessage = _.AuthenticationMD5Password = _.ParameterStatusMessage = _.ParameterDescriptionMessage = _.RowDescriptionMessage = _.Field = _.CopyResponse = _.CopyDataMessage = _.DatabaseError = _.copyDone = _.emptyQuery = _.replicationStart = _.portalSuspended = _.noData = _.closeComplete = _.bindComplete = _.parseComplete = void 0;
  _.parseComplete = { name: "parseComplete", length: 5 };
  _.bindComplete = { name: "bindComplete", length: 5 };
  _.closeComplete = { name: "closeComplete", length: 5 };
  _.noData = { name: "noData", length: 5 };
  _.portalSuspended = { name: "portalSuspended", length: 5 };
  _.replicationStart = { name: "replicationStart", length: 4 };
  _.emptyQuery = { name: "emptyQuery", length: 4 };
  _.copyDone = { name: "copyDone", length: 4 };
  var Kr = class Kr extends Error {
    constructor(e, t, n) {
      super(e), this.length = t, this.name = n;
    }
  };
  a(Kr, "DatabaseError");
  var Mr = Kr;
  _.DatabaseError = Mr;
  var Yr = class Yr {
    constructor(e, t) {
      this.length = e, this.chunk = t, this.name = "copyData";
    }
  };
  a(Yr, "CopyDataMessage");
  var Ur = Yr;
  _.CopyDataMessage = Ur;
  var Zr = class Zr {
    constructor(e, t, n, i) {
      this.length = e, this.name = t, this.binary = n, this.columnTypes = new Array(i);
    }
  };
  a(Zr, "CopyResponse");
  var Dr = Zr;
  _.CopyResponse = Dr;
  var Jr = class Jr {
    constructor(e, t, n, i, s, o, u) {
      this.name = e, this.tableID = t, this.columnID = n, this.dataTypeID = i, this.dataTypeSize = s, this.dataTypeModifier = o, this.format = u;
    }
  };
  a(Jr, "Field");
  var Or = Jr;
  _.Field = Or;
  var Xr = class Xr {
    constructor(e, t) {
      this.length = e, this.fieldCount = t, this.name = "rowDescription", this.fields = new Array(this.fieldCount);
    }
  };
  a(Xr, "RowDescriptionMessage");
  var qr = Xr;
  _.RowDescriptionMessage = qr;
  var en = class en {
    constructor(e, t) {
      this.length = e, this.parameterCount = t, this.name = "parameterDescription", this.dataTypeIDs = new Array(this.parameterCount);
    }
  };
  a(en, "ParameterDescriptionMessage");
  var Qr = en;
  _.ParameterDescriptionMessage = Qr;
  var tn = class tn {
    constructor(e, t, n) {
      this.length = e, this.parameterName = t, this.parameterValue = n, this.name = "parameterStatus";
    }
  };
  a(tn, "ParameterStatusMessage");
  var Nr = tn;
  _.ParameterStatusMessage = Nr;
  var rn = class rn {
    constructor(e, t) {
      this.length = e, this.salt = t, this.name = "authenticationMD5Password";
    }
  };
  a(rn, "AuthenticationMD5Password");
  var Wr = rn;
  _.AuthenticationMD5Password = Wr;
  var nn = class nn {
    constructor(e, t, n) {
      this.length = e, this.processID = t, this.secretKey = n, this.name = "backendKeyData";
    }
  };
  a(nn, "BackendKeyDataMessage");
  var jr = nn;
  _.BackendKeyDataMessage = jr;
  var sn = class sn {
    constructor(e, t, n, i) {
      this.length = e, this.processId = t, this.channel = n, this.payload = i, this.name = "notification";
    }
  };
  a(sn, "NotificationResponseMessage");
  var Hr = sn;
  _.NotificationResponseMessage = Hr;
  var on = class on {
    constructor(e, t) {
      this.length = e, this.status = t, this.name = "readyForQuery";
    }
  };
  a(on, "ReadyForQueryMessage");
  var $r = on;
  _.ReadyForQueryMessage = $r;
  var an = class an {
    constructor(e, t) {
      this.length = e, this.text = t, this.name = "commandComplete";
    }
  };
  a(an, "CommandCompleteMessage");
  var Gr = an;
  _.CommandCompleteMessage = Gr;
  var un = class un {
    constructor(e, t) {
      this.length = e, this.fields = t, this.name = "dataRow", this.fieldCount = t.length;
    }
  };
  a(un, "DataRowMessage");
  var Vr = un;
  _.DataRowMessage = Vr;
  var cn = class cn {
    constructor(e, t) {
      this.length = e, this.message = t, this.name = "notice";
    }
  };
  a(cn, "NoticeMessage");
  var zr = cn;
  _.NoticeMessage = zr;
});
var Qs = T((Rt) => {
  "use strict";
  p();
  Object.defineProperty(Rt, "__esModule", { value: true });
  Rt.Writer = void 0;
  var hn = class hn {
    constructor(e = 256) {
      this.size = e, this.offset = 5, this.headerPosition = 0, this.buffer = d.allocUnsafe(e);
    }
    ensure(e) {
      if (this.buffer.length - this.offset < e) {
        let n = this.buffer, i = n.length + (n.length >> 1) + e;
        this.buffer = d.allocUnsafe(i), n.copy(
          this.buffer
        );
      }
    }
    addInt32(e) {
      return this.ensure(4), this.buffer[this.offset++] = e >>> 24 & 255, this.buffer[this.offset++] = e >>> 16 & 255, this.buffer[this.offset++] = e >>> 8 & 255, this.buffer[this.offset++] = e >>> 0 & 255, this;
    }
    addInt16(e) {
      return this.ensure(2), this.buffer[this.offset++] = e >>> 8 & 255, this.buffer[this.offset++] = e >>> 0 & 255, this;
    }
    addCString(e) {
      if (!e) this.ensure(1);
      else {
        let t = d.byteLength(e);
        this.ensure(t + 1), this.buffer.write(e, this.offset, "utf-8"), this.offset += t;
      }
      return this.buffer[this.offset++] = 0, this;
    }
    addString(e = "") {
      let t = d.byteLength(e);
      return this.ensure(t), this.buffer.write(e, this.offset), this.offset += t, this;
    }
    add(e) {
      return this.ensure(
        e.length
      ), e.copy(this.buffer, this.offset), this.offset += e.length, this;
    }
    join(e) {
      if (e) {
        this.buffer[this.headerPosition] = e;
        let t = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(t, this.headerPosition + 1);
      }
      return this.buffer.slice(e ? 0 : 5, this.offset);
    }
    flush(e) {
      let t = this.join(e);
      return this.offset = 5, this.headerPosition = 0, this.buffer = d.allocUnsafe(this.size), t;
    }
  };
  a(hn, "Writer");
  var fn = hn;
  Rt.Writer = fn;
});
var Ws = T((Ft) => {
  "use strict";
  p();
  Object.defineProperty(Ft, "__esModule", { value: true });
  Ft.serialize = void 0;
  var pn = Qs(), F = new pn.Writer(), yc = a((r) => {
    F.addInt16(3).addInt16(0);
    for (let n of Object.keys(r)) F.addCString(
      n
    ).addCString(r[n]);
    F.addCString("client_encoding").addCString("UTF8");
    let e = F.addCString("").flush(), t = e.length + 4;
    return new pn.Writer().addInt32(t).add(e).flush();
  }, "startup"), mc = a(() => {
    let r = d.allocUnsafe(
      8
    );
    return r.writeInt32BE(8, 0), r.writeInt32BE(80877103, 4), r;
  }, "requestSsl"), wc = a((r) => F.addCString(r).flush(
    112
  ), "password"), gc = a(function(r, e) {
    return F.addCString(r).addInt32(d.byteLength(e)).addString(e), F.flush(112);
  }, "sendSASLInitialResponseMessage"), bc = a(function(r) {
    return F.addString(r).flush(112);
  }, "sendSCRAMClientFinalMessage"), vc = a((r) => F.addCString(r).flush(81), "query"), Ns = [], xc = a((r) => {
    let e = r.name || "";
    e.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", e, e.length), console.error("This can cause conflicts and silent errors executing queries"));
    let t = r.types || Ns, n = t.length, i = F.addCString(e).addCString(r.text).addInt16(n);
    for (let s = 0; s < n; s++) i.addInt32(t[s]);
    return F.flush(80);
  }, "parse"), qe = new pn.Writer(), Sc = a(function(r, e) {
    for (let t = 0; t < r.length; t++) {
      let n = e ? e(r[t], t) : r[t];
      n == null ? (F.addInt16(0), qe.addInt32(-1)) : n instanceof d ? (F.addInt16(
        1
      ), qe.addInt32(n.length), qe.add(n)) : (F.addInt16(0), qe.addInt32(d.byteLength(n)), qe.addString(n));
    }
  }, "writeValues"), Ec = a((r = {}) => {
    let e = r.portal || "", t = r.statement || "", n = r.binary || false, i = r.values || Ns, s = i.length;
    return F.addCString(e).addCString(t), F.addInt16(s), Sc(i, r.valueMapper), F.addInt16(s), F.add(qe.flush()), F.addInt16(n ? 1 : 0), F.flush(66);
  }, "bind"), Ac = d.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]), Cc = a((r) => {
    if (!r || !r.portal && !r.rows) return Ac;
    let e = r.portal || "", t = r.rows || 0, n = d.byteLength(e), i = 4 + n + 1 + 4, s = d.allocUnsafe(1 + i);
    return s[0] = 69, s.writeInt32BE(i, 1), s.write(e, 5, "utf-8"), s[n + 5] = 0, s.writeUInt32BE(t, s.length - 4), s;
  }, "execute"), _c = a(
    (r, e) => {
      let t = d.allocUnsafe(16);
      return t.writeInt32BE(16, 0), t.writeInt16BE(1234, 4), t.writeInt16BE(
        5678,
        6
      ), t.writeInt32BE(r, 8), t.writeInt32BE(e, 12), t;
    },
    "cancel"
  ), dn = a((r, e) => {
    let n = 4 + d.byteLength(e) + 1, i = d.allocUnsafe(1 + n);
    return i[0] = r, i.writeInt32BE(n, 1), i.write(e, 5, "utf-8"), i[n] = 0, i;
  }, "cstringMessage"), Ic = F.addCString("P").flush(68), Tc = F.addCString("S").flush(68), Pc = a((r) => r.name ? dn(68, `${r.type}${r.name || ""}`) : r.type === "P" ? Ic : Tc, "describe"), Bc = a((r) => {
    let e = `${r.type}${r.name || ""}`;
    return dn(67, e);
  }, "close"), Rc = a((r) => F.add(r).flush(100), "copyData"), Lc = a((r) => dn(102, r), "copyFail"), Lt = a((r) => d.from([r, 0, 0, 0, 4]), "codeOnlyBuffer"), Fc = Lt(72), kc = Lt(83), Mc = Lt(88), Uc = Lt(99), Dc = {
    startup: yc,
    password: wc,
    requestSsl: mc,
    sendSASLInitialResponseMessage: gc,
    sendSCRAMClientFinalMessage: bc,
    query: vc,
    parse: xc,
    bind: Ec,
    execute: Cc,
    describe: Pc,
    close: Bc,
    flush: a(
      () => Fc,
      "flush"
    ),
    sync: a(() => kc, "sync"),
    end: a(() => Mc, "end"),
    copyData: Rc,
    copyDone: a(() => Uc, "copyDone"),
    copyFail: Lc,
    cancel: _c
  };
  Ft.serialize = Dc;
});
var js = T((kt) => {
  "use strict";
  p();
  Object.defineProperty(kt, "__esModule", { value: true });
  kt.BufferReader = void 0;
  var Oc = d.allocUnsafe(0), mn = class mn {
    constructor(e = 0) {
      this.offset = e, this.buffer = Oc, this.encoding = "utf-8";
    }
    setBuffer(e, t) {
      this.offset = e, this.buffer = t;
    }
    int16() {
      let e = this.buffer.readInt16BE(this.offset);
      return this.offset += 2, e;
    }
    byte() {
      let e = this.buffer[this.offset];
      return this.offset++, e;
    }
    int32() {
      let e = this.buffer.readInt32BE(
        this.offset
      );
      return this.offset += 4, e;
    }
    uint32() {
      let e = this.buffer.readUInt32BE(this.offset);
      return this.offset += 4, e;
    }
    string(e) {
      let t = this.buffer.toString(this.encoding, this.offset, this.offset + e);
      return this.offset += e, t;
    }
    cstring() {
      let e = this.offset, t = e;
      for (; this.buffer[t++] !== 0; ) ;
      return this.offset = t, this.buffer.toString(this.encoding, e, t - 1);
    }
    bytes(e) {
      let t = this.buffer.slice(this.offset, this.offset + e);
      return this.offset += e, t;
    }
  };
  a(mn, "BufferReader");
  var yn = mn;
  kt.BufferReader = yn;
});
var Gs = T((Mt) => {
  "use strict";
  p();
  Object.defineProperty(Mt, "__esModule", { value: true });
  Mt.Parser = void 0;
  var k = ln(), qc = js(), wn = 1, Qc = 4, Hs = wn + Qc, $s = d.allocUnsafe(0), bn = class bn {
    constructor(e) {
      if (this.buffer = $s, this.bufferLength = 0, this.bufferOffset = 0, this.reader = new qc.BufferReader(), e?.mode === "binary") throw new Error("Binary mode not supported yet");
      this.mode = e?.mode || "text";
    }
    parse(e, t) {
      this.mergeBuffer(e);
      let n = this.bufferOffset + this.bufferLength, i = this.bufferOffset;
      for (; i + Hs <= n; ) {
        let s = this.buffer[i], o = this.buffer.readUInt32BE(
          i + wn
        ), u = wn + o;
        if (u + i <= n) {
          let c = this.handlePacket(i + Hs, s, o, this.buffer);
          t(c), i += u;
        } else break;
      }
      i === n ? (this.buffer = $s, this.bufferLength = 0, this.bufferOffset = 0) : (this.bufferLength = n - i, this.bufferOffset = i);
    }
    mergeBuffer(e) {
      if (this.bufferLength > 0) {
        let t = this.bufferLength + e.byteLength;
        if (t + this.bufferOffset > this.buffer.byteLength) {
          let i;
          if (t <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) i = this.buffer;
          else {
            let s = this.buffer.byteLength * 2;
            for (; t >= s; ) s *= 2;
            i = d.allocUnsafe(s);
          }
          this.buffer.copy(i, 0, this.bufferOffset, this.bufferOffset + this.bufferLength), this.buffer = i, this.bufferOffset = 0;
        }
        e.copy(this.buffer, this.bufferOffset + this.bufferLength), this.bufferLength = t;
      } else this.buffer = e, this.bufferOffset = 0, this.bufferLength = e.byteLength;
    }
    handlePacket(e, t, n, i) {
      switch (t) {
        case 50:
          return k.bindComplete;
        case 49:
          return k.parseComplete;
        case 51:
          return k.closeComplete;
        case 110:
          return k.noData;
        case 115:
          return k.portalSuspended;
        case 99:
          return k.copyDone;
        case 87:
          return k.replicationStart;
        case 73:
          return k.emptyQuery;
        case 68:
          return this.parseDataRowMessage(e, n, i);
        case 67:
          return this.parseCommandCompleteMessage(
            e,
            n,
            i
          );
        case 90:
          return this.parseReadyForQueryMessage(e, n, i);
        case 65:
          return this.parseNotificationMessage(
            e,
            n,
            i
          );
        case 82:
          return this.parseAuthenticationResponse(e, n, i);
        case 83:
          return this.parseParameterStatusMessage(
            e,
            n,
            i
          );
        case 75:
          return this.parseBackendKeyData(e, n, i);
        case 69:
          return this.parseErrorMessage(e, n, i, "error");
        case 78:
          return this.parseErrorMessage(e, n, i, "notice");
        case 84:
          return this.parseRowDescriptionMessage(
            e,
            n,
            i
          );
        case 116:
          return this.parseParameterDescriptionMessage(e, n, i);
        case 71:
          return this.parseCopyInMessage(
            e,
            n,
            i
          );
        case 72:
          return this.parseCopyOutMessage(e, n, i);
        case 100:
          return this.parseCopyData(e, n, i);
        default:
          return new k.DatabaseError("received invalid response: " + t.toString(16), n, "error");
      }
    }
    parseReadyForQueryMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.string(1);
      return new k.ReadyForQueryMessage(t, i);
    }
    parseCommandCompleteMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.cstring();
      return new k.CommandCompleteMessage(t, i);
    }
    parseCopyData(e, t, n) {
      let i = n.slice(e, e + (t - 4));
      return new k.CopyDataMessage(t, i);
    }
    parseCopyInMessage(e, t, n) {
      return this.parseCopyMessage(
        e,
        t,
        n,
        "copyInResponse"
      );
    }
    parseCopyOutMessage(e, t, n) {
      return this.parseCopyMessage(e, t, n, "copyOutResponse");
    }
    parseCopyMessage(e, t, n, i) {
      this.reader.setBuffer(e, n);
      let s = this.reader.byte() !== 0, o = this.reader.int16(), u = new k.CopyResponse(t, i, s, o);
      for (let c = 0; c < o; c++) u.columnTypes[c] = this.reader.int16();
      return u;
    }
    parseNotificationMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int32(), s = this.reader.cstring(), o = this.reader.cstring();
      return new k.NotificationResponseMessage(t, i, s, o);
    }
    parseRowDescriptionMessage(e, t, n) {
      this.reader.setBuffer(
        e,
        n
      );
      let i = this.reader.int16(), s = new k.RowDescriptionMessage(t, i);
      for (let o = 0; o < i; o++) s.fields[o] = this.parseField();
      return s;
    }
    parseField() {
      let e = this.reader.cstring(), t = this.reader.uint32(), n = this.reader.int16(), i = this.reader.uint32(), s = this.reader.int16(), o = this.reader.int32(), u = this.reader.int16() === 0 ? "text" : "binary";
      return new k.Field(e, t, n, i, s, o, u);
    }
    parseParameterDescriptionMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int16(), s = new k.ParameterDescriptionMessage(t, i);
      for (let o = 0; o < i; o++)
        s.dataTypeIDs[o] = this.reader.int32();
      return s;
    }
    parseDataRowMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int16(), s = new Array(i);
      for (let o = 0; o < i; o++) {
        let u = this.reader.int32();
        s[o] = u === -1 ? null : this.reader.string(u);
      }
      return new k.DataRowMessage(t, s);
    }
    parseParameterStatusMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.cstring(), s = this.reader.cstring();
      return new k.ParameterStatusMessage(
        t,
        i,
        s
      );
    }
    parseBackendKeyData(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int32(), s = this.reader.int32();
      return new k.BackendKeyDataMessage(t, i, s);
    }
    parseAuthenticationResponse(e, t, n) {
      this.reader.setBuffer(
        e,
        n
      );
      let i = this.reader.int32(), s = { name: "authenticationOk", length: t };
      switch (i) {
        case 0:
          break;
        case 3:
          s.length === 8 && (s.name = "authenticationCleartextPassword");
          break;
        case 5:
          if (s.length === 12) {
            s.name = "authenticationMD5Password";
            let o = this.reader.bytes(4);
            return new k.AuthenticationMD5Password(t, o);
          }
          break;
        case 10:
          {
            s.name = "authenticationSASL", s.mechanisms = [];
            let o;
            do
              o = this.reader.cstring(), o && s.mechanisms.push(o);
            while (o);
          }
          break;
        case 11:
          s.name = "authenticationSASLContinue", s.data = this.reader.string(t - 8);
          break;
        case 12:
          s.name = "authenticationSASLFinal", s.data = this.reader.string(t - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + i);
      }
      return s;
    }
    parseErrorMessage(e, t, n, i) {
      this.reader.setBuffer(e, n);
      let s = {}, o = this.reader.string(1);
      for (; o !== "\0"; ) s[o] = this.reader.cstring(), o = this.reader.string(1);
      let u = s.M, c = i === "notice" ? new k.NoticeMessage(t, u) : new k.DatabaseError(u, t, i);
      return c.severity = s.S, c.code = s.C, c.detail = s.D, c.hint = s.H, c.position = s.P, c.internalPosition = s.p, c.internalQuery = s.q, c.where = s.W, c.schema = s.s, c.table = s.t, c.column = s.c, c.dataType = s.d, c.constraint = s.n, c.file = s.F, c.line = s.L, c.routine = s.R, c;
    }
  };
  a(bn, "Parser");
  var gn = bn;
  Mt.Parser = gn;
});
var vn = T((xe) => {
  "use strict";
  p();
  Object.defineProperty(xe, "__esModule", { value: true });
  xe.DatabaseError = xe.serialize = xe.parse = void 0;
  var Nc = ln();
  Object.defineProperty(xe, "DatabaseError", { enumerable: true, get: a(
    function() {
      return Nc.DatabaseError;
    },
    "get"
  ) });
  var Wc = Ws();
  Object.defineProperty(xe, "serialize", {
    enumerable: true,
    get: a(function() {
      return Wc.serialize;
    }, "get")
  });
  var jc = Gs();
  function Hc(r, e) {
    let t = new jc.Parser();
    return r.on("data", (n) => t.parse(n, e)), new Promise((n) => r.on("end", () => n()));
  }
  a(Hc, "parse");
  xe.parse = Hc;
});
var Vs = {};
ie(Vs, { connect: () => $c });
function $c({ socket: r, servername: e }) {
  return r.startTls(e), r;
}
var zs = G(
  () => {
    "use strict";
    p();
    a($c, "connect");
  }
);
var En = T((Xh, Zs) => {
  "use strict";
  p();
  var Ks = (Fe(), O(wi)), Gc = ge().EventEmitter, { parse: Vc, serialize: Q } = vn(), Ys = Q.flush(), zc = Q.sync(), Kc = Q.end(), Sn = class Sn extends Gc {
    constructor(e) {
      super(), e = e || {}, this.stream = e.stream || new Ks.Socket(), this._keepAlive = e.keepAlive, this._keepAliveInitialDelayMillis = e.keepAliveInitialDelayMillis, this.lastBuffer = false, this.parsedStatements = {}, this.ssl = e.ssl || false, this._ending = false, this._emitMessage = false;
      var t = this;
      this.on("newListener", function(n) {
        n === "message" && (t._emitMessage = true);
      });
    }
    connect(e, t) {
      var n = this;
      this._connecting = true, this.stream.setNoDelay(true), this.stream.connect(e, t), this.stream.once("connect", function() {
        n._keepAlive && n.stream.setKeepAlive(true, n._keepAliveInitialDelayMillis), n.emit("connect");
      });
      let i = a(function(s) {
        n._ending && (s.code === "ECONNRESET" || s.code === "EPIPE") || n.emit("error", s);
      }, "reportStreamError");
      if (this.stream.on("error", i), this.stream.on("close", function() {
        n.emit("end");
      }), !this.ssl) return this.attachListeners(
        this.stream
      );
      this.stream.once("data", function(s) {
        var o = s.toString("utf8");
        switch (o) {
          case "S":
            break;
          case "N":
            return n.stream.end(), n.emit("error", new Error("The server does not support SSL connections"));
          default:
            return n.stream.end(), n.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        var u = (zs(), O(Vs));
        let c = { socket: n.stream };
        n.ssl !== true && (Object.assign(c, n.ssl), "key" in n.ssl && (c.key = n.ssl.key)), Ks.isIP(t) === 0 && (c.servername = t);
        try {
          n.stream = u.connect(c);
        } catch (l) {
          return n.emit(
            "error",
            l
          );
        }
        n.attachListeners(n.stream), n.stream.on("error", i), n.emit("sslconnect");
      });
    }
    attachListeners(e) {
      e.on(
        "end",
        () => {
          this.emit("end");
        }
      ), Vc(e, (t) => {
        var n = t.name === "error" ? "errorMessage" : t.name;
        this._emitMessage && this.emit("message", t), this.emit(n, t);
      });
    }
    requestSsl() {
      this.stream.write(Q.requestSsl());
    }
    startup(e) {
      this.stream.write(Q.startup(e));
    }
    cancel(e, t) {
      this._send(Q.cancel(e, t));
    }
    password(e) {
      this._send(Q.password(e));
    }
    sendSASLInitialResponseMessage(e, t) {
      this._send(Q.sendSASLInitialResponseMessage(e, t));
    }
    sendSCRAMClientFinalMessage(e) {
      this._send(Q.sendSCRAMClientFinalMessage(
        e
      ));
    }
    _send(e) {
      return this.stream.writable ? this.stream.write(e) : false;
    }
    query(e) {
      this._send(Q.query(e));
    }
    parse(e) {
      this._send(Q.parse(e));
    }
    bind(e) {
      this._send(Q.bind(e));
    }
    execute(e) {
      this._send(Q.execute(e));
    }
    flush() {
      this.stream.writable && this.stream.write(Ys);
    }
    sync() {
      this._ending = true, this._send(Ys), this._send(zc);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      if (this._ending = true, !this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(Kc, () => {
        this.stream.end();
      });
    }
    close(e) {
      this._send(Q.close(e));
    }
    describe(e) {
      this._send(Q.describe(e));
    }
    sendCopyFromChunk(e) {
      this._send(Q.copyData(e));
    }
    endCopyFrom() {
      this._send(Q.copyDone());
    }
    sendCopyFail(e) {
      this._send(Q.copyFail(e));
    }
  };
  a(Sn, "Connection");
  var xn = Sn;
  Zs.exports = xn;
});
var eo = T((np, Xs) => {
  "use strict";
  p();
  var Yc = ge().EventEmitter, rp = (it(), O(nt)), Zc = rt(), An = ds(), Jc = Cs(), Xc = At(), el = Bt(), Js = qs(), tl = tt(), rl = En(), Cn = class Cn extends Yc {
    constructor(e) {
      super(), this.connectionParameters = new el(e), this.user = this.connectionParameters.user, this.database = this.connectionParameters.database, this.port = this.connectionParameters.port, this.host = this.connectionParameters.host, Object.defineProperty(
        this,
        "password",
        { configurable: true, enumerable: false, writable: true, value: this.connectionParameters.password }
      ), this.replication = this.connectionParameters.replication;
      var t = e || {};
      this._Promise = t.Promise || b.Promise, this._types = new Xc(t.types), this._ending = false, this._connecting = false, this._connected = false, this._connectionError = false, this._queryable = true, this.connection = t.connection || new rl({ stream: t.stream, ssl: this.connectionParameters.ssl, keepAlive: t.keepAlive || false, keepAliveInitialDelayMillis: t.keepAliveInitialDelayMillis || 0, encoding: this.connectionParameters.client_encoding || "utf8" }), this.queryQueue = [], this.binary = t.binary || tl.binary, this.processID = null, this.secretKey = null, this.ssl = this.connectionParameters.ssl || false, this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this._connectionTimeoutMillis = t.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(e) {
      let t = a((n) => {
        m.nextTick(() => {
          n.handleError(e, this.connection);
        });
      }, "enqueueError");
      this.activeQuery && (t(this.activeQuery), this.activeQuery = null), this.queryQueue.forEach(t), this.queryQueue.length = 0;
    }
    _connect(e) {
      var t = this, n = this.connection;
      if (this._connectionCallback = e, this._connecting || this._connected) {
        let i = new Error("Client has already been connected. You cannot reuse a client.");
        m.nextTick(
          () => {
            e(i);
          }
        );
        return;
      }
      this._connecting = true, this.connectionTimeoutHandle, this._connectionTimeoutMillis > 0 && (this.connectionTimeoutHandle = setTimeout(() => {
        n._ending = true, n.stream.destroy(new Error("timeout expired"));
      }, this._connectionTimeoutMillis)), this.host && this.host.indexOf("/") === 0 ? n.connect(this.host + "/.s.PGSQL." + this.port) : n.connect(this.port, this.host), n.on("connect", function() {
        t.ssl ? n.requestSsl() : n.startup(t.getStartupConf());
      }), n.on("sslconnect", function() {
        n.startup(t.getStartupConf());
      }), this._attachListeners(
        n
      ), n.once("end", () => {
        let i = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle), this._errorAllQueries(i), this._ending || (this._connecting && !this._connectionError ? this._connectionCallback ? this._connectionCallback(i) : this._handleErrorEvent(i) : this._connectionError || this._handleErrorEvent(i)), m.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(e) {
      if (e) {
        this._connect(e);
        return;
      }
      return new this._Promise((t, n) => {
        this._connect((i) => {
          i ? n(i) : t();
        });
      });
    }
    _attachListeners(e) {
      e.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this)), e.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this)), e.on("authenticationSASL", this._handleAuthSASL.bind(this)), e.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this)), e.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this)), e.on("backendKeyData", this._handleBackendKeyData.bind(this)), e.on("error", this._handleErrorEvent.bind(this)), e.on("errorMessage", this._handleErrorMessage.bind(this)), e.on("readyForQuery", this._handleReadyForQuery.bind(this)), e.on("notice", this._handleNotice.bind(this)), e.on("rowDescription", this._handleRowDescription.bind(this)), e.on("dataRow", this._handleDataRow.bind(this)), e.on("portalSuspended", this._handlePortalSuspended.bind(
        this
      )), e.on("emptyQuery", this._handleEmptyQuery.bind(this)), e.on("commandComplete", this._handleCommandComplete.bind(this)), e.on("parseComplete", this._handleParseComplete.bind(this)), e.on("copyInResponse", this._handleCopyInResponse.bind(this)), e.on("copyData", this._handleCopyData.bind(this)), e.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(e) {
      let t = this.connection;
      typeof this.password == "function" ? this._Promise.resolve().then(() => this.password()).then((n) => {
        if (n !== void 0) {
          if (typeof n != "string") {
            t.emit("error", new TypeError(
              "Password must be a string"
            ));
            return;
          }
          this.connectionParameters.password = this.password = n;
        } else this.connectionParameters.password = this.password = null;
        e();
      }).catch((n) => {
        t.emit("error", n);
      }) : this.password !== null ? e() : Jc(
        this.connectionParameters,
        (n) => {
          n !== void 0 && (this.connectionParameters.password = this.password = n), e();
        }
      );
    }
    _handleAuthCleartextPassword(e) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(e) {
      this._checkPgPass(
        () => {
          let t = Zc.postgresMd5PasswordHash(this.user, this.password, e.salt);
          this.connection.password(t);
        }
      );
    }
    _handleAuthSASL(e) {
      this._checkPgPass(() => {
        this.saslSession = An.startSession(e.mechanisms), this.connection.sendSASLInitialResponseMessage(
          this.saslSession.mechanism,
          this.saslSession.response
        );
      });
    }
    _handleAuthSASLContinue(e) {
      An.continueSession(
        this.saslSession,
        this.password,
        e.data
      ), this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
    }
    _handleAuthSASLFinal(e) {
      An.finalizeSession(this.saslSession, e.data), this.saslSession = null;
    }
    _handleBackendKeyData(e) {
      this.processID = e.processID, this.secretKey = e.secretKey;
    }
    _handleReadyForQuery(e) {
      this._connecting && (this._connecting = false, this._connected = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback && (this._connectionCallback(null, this), this._connectionCallback = null), this.emit("connect"));
      let { activeQuery: t } = this;
      this.activeQuery = null, this.readyForQuery = true, t && t.handleReadyForQuery(this.connection), this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(e) {
      if (!this._connectionError) {
        if (this._connectionError = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback) return this._connectionCallback(e);
        this.emit("error", e);
      }
    }
    _handleErrorEvent(e) {
      if (this._connecting) return this._handleErrorWhileConnecting(e);
      this._queryable = false, this._errorAllQueries(e), this.emit("error", e);
    }
    _handleErrorMessage(e) {
      if (this._connecting) return this._handleErrorWhileConnecting(e);
      let t = this.activeQuery;
      if (!t) {
        this._handleErrorEvent(e);
        return;
      }
      this.activeQuery = null, t.handleError(
        e,
        this.connection
      );
    }
    _handleRowDescription(e) {
      this.activeQuery.handleRowDescription(e);
    }
    _handleDataRow(e) {
      this.activeQuery.handleDataRow(e);
    }
    _handlePortalSuspended(e) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(e) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(e) {
      this.activeQuery.handleCommandComplete(e, this.connection);
    }
    _handleParseComplete(e) {
      this.activeQuery.name && (this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text);
    }
    _handleCopyInResponse(e) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(e) {
      this.activeQuery.handleCopyData(
        e,
        this.connection
      );
    }
    _handleNotification(e) {
      this.emit("notification", e);
    }
    _handleNotice(e) {
      this.emit("notice", e);
    }
    getStartupConf() {
      var e = this.connectionParameters, t = { user: e.user, database: e.database }, n = e.application_name || e.fallback_application_name;
      return n && (t.application_name = n), e.replication && (t.replication = "" + e.replication), e.statement_timeout && (t.statement_timeout = String(parseInt(e.statement_timeout, 10))), e.lock_timeout && (t.lock_timeout = String(parseInt(e.lock_timeout, 10))), e.idle_in_transaction_session_timeout && (t.idle_in_transaction_session_timeout = String(parseInt(e.idle_in_transaction_session_timeout, 10))), e.options && (t.options = e.options), t;
    }
    cancel(e, t) {
      if (e.activeQuery === t) {
        var n = this.connection;
        this.host && this.host.indexOf("/") === 0 ? n.connect(this.host + "/.s.PGSQL." + this.port) : n.connect(this.port, this.host), n.on("connect", function() {
          n.cancel(
            e.processID,
            e.secretKey
          );
        });
      } else e.queryQueue.indexOf(t) !== -1 && e.queryQueue.splice(e.queryQueue.indexOf(t), 1);
    }
    setTypeParser(e, t, n) {
      return this._types.setTypeParser(e, t, n);
    }
    getTypeParser(e, t) {
      return this._types.getTypeParser(e, t);
    }
    escapeIdentifier(e) {
      return '"' + e.replace(/"/g, '""') + '"';
    }
    escapeLiteral(e) {
      for (var t = false, n = "'", i = 0; i < e.length; i++) {
        var s = e[i];
        s === "'" ? n += s + s : s === "\\" ? (n += s + s, t = true) : n += s;
      }
      return n += "'", t === true && (n = " E" + n), n;
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) if (this.activeQuery = this.queryQueue.shift(), this.activeQuery) {
        this.readyForQuery = false, this.hasExecuted = true;
        let e = this.activeQuery.submit(this.connection);
        e && m.nextTick(() => {
          this.activeQuery.handleError(e, this.connection), this.readyForQuery = true, this._pulseQueryQueue();
        });
      } else this.hasExecuted && (this.activeQuery = null, this.emit("drain"));
    }
    query(e, t, n) {
      var i, s, o, u, c;
      if (e == null) throw new TypeError(
        "Client was passed a null or undefined query"
      );
      return typeof e.submit == "function" ? (o = e.query_timeout || this.connectionParameters.query_timeout, s = i = e, typeof t == "function" && (i.callback = i.callback || t)) : (o = this.connectionParameters.query_timeout, i = new Js(e, t, n), i.callback || (s = new this._Promise((l, f) => {
        i.callback = (y, g) => y ? f(y) : l(g);
      }))), o && (c = i.callback, u = setTimeout(() => {
        var l = new Error("Query read timeout");
        m.nextTick(
          () => {
            i.handleError(l, this.connection);
          }
        ), c(l), i.callback = () => {
        };
        var f = this.queryQueue.indexOf(i);
        f > -1 && this.queryQueue.splice(f, 1), this._pulseQueryQueue();
      }, o), i.callback = (l, f) => {
        clearTimeout(u), c(l, f);
      }), this.binary && !i.binary && (i.binary = true), i._result && !i._result._types && (i._result._types = this._types), this._queryable ? this._ending ? (m.nextTick(() => {
        i.handleError(new Error("Client was closed and is not queryable"), this.connection);
      }), s) : (this.queryQueue.push(i), this._pulseQueryQueue(), s) : (m.nextTick(() => {
        i.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
      }), s);
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(e) {
      if (this._ending = true, !this.connection._connecting) if (e) e();
      else return this._Promise.resolve();
      if (this.activeQuery || !this._queryable ? this.connection.stream.destroy() : this.connection.end(), e) this.connection.once("end", e);
      else return new this._Promise((t) => {
        this.connection.once("end", t);
      });
    }
  };
  a(Cn, "Client");
  var Ut = Cn;
  Ut.Query = Js;
  Xs.exports = Ut;
});
var io = T((op, no) => {
  "use strict";
  p();
  var nl = ge().EventEmitter, to = a(function() {
  }, "NOOP"), ro = a((r, e) => {
    let t = r.findIndex(e);
    return t === -1 ? void 0 : r.splice(t, 1)[0];
  }, "removeWhere"), Tn = class Tn {
    constructor(e, t, n) {
      this.client = e, this.idleListener = t, this.timeoutId = n;
    }
  };
  a(Tn, "IdleItem");
  var _n = Tn, Pn = class Pn {
    constructor(e) {
      this.callback = e;
    }
  };
  a(Pn, "PendingItem");
  var Qe = Pn;
  function il() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  a(il, "throwOnDoubleRelease");
  function Dt(r, e) {
    if (e)
      return { callback: e, result: void 0 };
    let t, n, i = a(function(o, u) {
      o ? t(o) : n(u);
    }, "cb"), s = new r(function(o, u) {
      n = o, t = u;
    }).catch((o) => {
      throw Error.captureStackTrace(o), o;
    });
    return { callback: i, result: s };
  }
  a(Dt, "promisify");
  function sl(r, e) {
    return a(function t(n) {
      n.client = e, e.removeListener("error", t), e.on("error", () => {
        r.log(
          "additional client error after disconnection due to error",
          n
        );
      }), r._remove(e), r.emit("error", n, e);
    }, "idleListener");
  }
  a(sl, "makeIdleListener");
  var Bn = class Bn extends nl {
    constructor(e, t) {
      super(), this.options = Object.assign({}, e), e != null && "password" in e && Object.defineProperty(this.options, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: e.password
      }), e != null && e.ssl && e.ssl.key && Object.defineProperty(this.options.ssl, "key", { enumerable: false }), this.options.max = this.options.max || this.options.poolSize || 10, this.options.min = this.options.min || 0, this.options.maxUses = this.options.maxUses || 1 / 0, this.options.allowExitOnIdle = this.options.allowExitOnIdle || false, this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0, this.log = this.options.log || function() {
      }, this.Client = this.options.Client || t || ot().Client, this.Promise = this.options.Promise || b.Promise, typeof this.options.idleTimeoutMillis > "u" && (this.options.idleTimeoutMillis = 1e4), this._clients = [], this._idle = [], this._expired = /* @__PURE__ */ new WeakSet(), this._pendingQueue = [], this._endCallback = void 0, this.ending = false, this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      if (this.log("pulse queue"), this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending"), this._idle.length && this._idle.slice().map((t) => {
          this._remove(t.client);
        }), this._clients.length || (this.ended = true, this._endCallback());
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) return;
      let e = this._pendingQueue.shift();
      if (this._idle.length) {
        let t = this._idle.pop();
        clearTimeout(
          t.timeoutId
        );
        let n = t.client;
        n.ref && n.ref();
        let i = t.idleListener;
        return this._acquireClient(n, e, i, false);
      }
      if (!this._isFull()) return this.newClient(e);
      throw new Error("unexpected condition");
    }
    _remove(e) {
      let t = ro(
        this._idle,
        (n) => n.client === e
      );
      t !== void 0 && clearTimeout(t.timeoutId), this._clients = this._clients.filter(
        (n) => n !== e
      ), e.end(), this.emit("remove", e);
    }
    connect(e) {
      if (this.ending) {
        let i = new Error("Cannot use a pool after calling end on the pool");
        return e ? e(i) : this.Promise.reject(i);
      }
      let t = Dt(this.Promise, e), n = t.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length && m.nextTick(() => this._pulseQueue()), !this.options.connectionTimeoutMillis) return this._pendingQueue.push(new Qe(t.callback)), n;
        let i = a((u, c, l) => {
          clearTimeout(o), t.callback(u, c, l);
        }, "queueCallback"), s = new Qe(i), o = setTimeout(() => {
          ro(
            this._pendingQueue,
            (u) => u.callback === i
          ), s.timedOut = true, t.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        return o.unref && o.unref(), this._pendingQueue.push(s), n;
      }
      return this.newClient(new Qe(t.callback)), n;
    }
    newClient(e) {
      let t = new this.Client(this.options);
      this._clients.push(
        t
      );
      let n = sl(this, t);
      this.log("checking client timeout");
      let i, s = false;
      this.options.connectionTimeoutMillis && (i = setTimeout(() => {
        this.log("ending client due to timeout"), s = true, t.connection ? t.connection.stream.destroy() : t.end();
      }, this.options.connectionTimeoutMillis)), this.log("connecting new client"), t.connect((o) => {
        if (i && clearTimeout(i), t.on("error", n), o) this.log("client failed to connect", o), this._clients = this._clients.filter((u) => u !== t), s && (o = new Error("Connection terminated due to connection timeout", { cause: o })), this._pulseQueue(), e.timedOut || e.callback(o, void 0, to);
        else {
          if (this.log("new client connected"), this.options.maxLifetimeSeconds !== 0) {
            let u = setTimeout(() => {
              this.log("ending client due to expired lifetime"), this._expired.add(t), this._idle.findIndex((l) => l.client === t) !== -1 && this._acquireClient(
                t,
                new Qe((l, f, y) => y()),
                n,
                false
              );
            }, this.options.maxLifetimeSeconds * 1e3);
            u.unref(), t.once("end", () => clearTimeout(u));
          }
          return this._acquireClient(t, e, n, true);
        }
      });
    }
    _acquireClient(e, t, n, i) {
      i && this.emit("connect", e), this.emit("acquire", e), e.release = this._releaseOnce(e, n), e.removeListener("error", n), t.timedOut ? i && this.options.verify ? this.options.verify(e, e.release) : e.release() : i && this.options.verify ? this.options.verify(e, (s) => {
        if (s) return e.release(s), t.callback(s, void 0, to);
        t.callback(void 0, e, e.release);
      }) : t.callback(void 0, e, e.release);
    }
    _releaseOnce(e, t) {
      let n = false;
      return (i) => {
        n && il(), n = true, this._release(e, t, i);
      };
    }
    _release(e, t, n) {
      if (e.on("error", t), e._poolUseCount = (e._poolUseCount || 0) + 1, this.emit("release", n, e), n || this.ending || !e._queryable || e._ending || e._poolUseCount >= this.options.maxUses) {
        e._poolUseCount >= this.options.maxUses && this.log("remove expended client"), this._remove(e), this._pulseQueue();
        return;
      }
      if (this._expired.has(e)) {
        this.log("remove expired client"), this._expired.delete(e), this._remove(e), this._pulseQueue();
        return;
      }
      let s;
      this.options.idleTimeoutMillis && this._isAboveMin() && (s = setTimeout(() => {
        this.log("remove idle client"), this._remove(e);
      }, this.options.idleTimeoutMillis), this.options.allowExitOnIdle && s.unref()), this.options.allowExitOnIdle && e.unref(), this._idle.push(new _n(
        e,
        t,
        s
      )), this._pulseQueue();
    }
    query(e, t, n) {
      if (typeof e == "function") {
        let s = Dt(this.Promise, e);
        return v(function() {
          return s.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        }), s.result;
      }
      typeof t == "function" && (n = t, t = void 0);
      let i = Dt(this.Promise, n);
      return n = i.callback, this.connect((s, o) => {
        if (s) return n(s);
        let u = false, c = a((l) => {
          u || (u = true, o.release(l), n(l));
        }, "onError");
        o.once("error", c), this.log("dispatching query");
        try {
          o.query(e, t, (l, f) => {
            if (this.log("query dispatched"), o.removeListener(
              "error",
              c
            ), !u) return u = true, o.release(l), l ? n(l) : n(void 0, f);
          });
        } catch (l) {
          return o.release(l), n(l);
        }
      }), i.result;
    }
    end(e) {
      if (this.log("ending"), this.ending) {
        let n = new Error("Called end on pool more than once");
        return e ? e(n) : this.Promise.reject(n);
      }
      this.ending = true;
      let t = Dt(this.Promise, e);
      return this._endCallback = t.callback, this._pulseQueue(), t.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((e, t) => e + (this._expired.has(t) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  };
  a(Bn, "Pool");
  var In = Bn;
  no.exports = In;
});
var so = {};
ie(so, { default: () => ol });
var ol;
var oo = G(() => {
  "use strict";
  p();
  ol = {};
});
var ao = T((lp, al) => {
  al.exports = { name: "pg", version: "8.8.0", description: "PostgreSQL client - pure javascript & libpq with the same API", keywords: [
    "database",
    "libpq",
    "pg",
    "postgre",
    "postgres",
    "postgresql",
    "rdbms"
  ], homepage: "https://github.com/brianc/node-postgres", repository: { type: "git", url: "git://github.com/brianc/node-postgres.git", directory: "packages/pg" }, author: "Brian Carlson <brian.m.carlson@gmail.com>", main: "./lib", dependencies: { "buffer-writer": "2.0.0", "packet-reader": "1.0.0", "pg-connection-string": "^2.5.0", "pg-pool": "^3.5.2", "pg-protocol": "^1.5.0", "pg-types": "^2.1.0", pgpass: "1.x" }, devDependencies: {
    async: "2.6.4",
    bluebird: "3.5.2",
    co: "4.6.0",
    "pg-copy-streams": "0.3.0"
  }, peerDependencies: { "pg-native": ">=3.0.1" }, peerDependenciesMeta: { "pg-native": { optional: true } }, scripts: { test: "make test-all" }, files: ["lib", "SPONSORS.md"], license: "MIT", engines: { node: ">= 8.0.0" }, gitHead: "c99fb2c127ddf8d712500db2c7b9a5491a178655" };
});
var lo = T((fp, co) => {
  "use strict";
  p();
  var uo = ge().EventEmitter, ul = (it(), O(nt)), Rn = rt(), Ne = co.exports = function(r, e, t) {
    uo.call(this), r = Rn.normalizeQueryConfig(r, e, t), this.text = r.text, this.values = r.values, this.name = r.name, this.callback = r.callback, this.state = "new", this._arrayMode = r.rowMode === "array", this._emitRowEvents = false, this.on("newListener", function(n) {
      n === "row" && (this._emitRowEvents = true);
    }.bind(this));
  };
  ul.inherits(Ne, uo);
  var cl = { sqlState: "code", statementPosition: "position", messagePrimary: "message", context: "where", schemaName: "schema", tableName: "table", columnName: "column", dataTypeName: "dataType", constraintName: "constraint", sourceFile: "file", sourceLine: "line", sourceFunction: "routine" };
  Ne.prototype.handleError = function(r) {
    var e = this.native.pq.resultErrorFields();
    if (e) for (var t in e) {
      var n = cl[t] || t;
      r[n] = e[t];
    }
    this.callback ? this.callback(r) : this.emit("error", r), this.state = "error";
  };
  Ne.prototype.then = function(r, e) {
    return this._getPromise().then(
      r,
      e
    );
  };
  Ne.prototype.catch = function(r) {
    return this._getPromise().catch(r);
  };
  Ne.prototype._getPromise = function() {
    return this._promise ? this._promise : (this._promise = new Promise(function(r, e) {
      this._once("end", r), this._once("error", e);
    }.bind(this)), this._promise);
  };
  Ne.prototype.submit = function(r) {
    this.state = "running";
    var e = this;
    this.native = r.native, r.native.arrayMode = this._arrayMode;
    var t = a(function(s, o, u) {
      if (r.native.arrayMode = false, v(function() {
        e.emit("_done");
      }), s) return e.handleError(s);
      e._emitRowEvents && (u.length > 1 ? o.forEach(
        (c, l) => {
          c.forEach((f) => {
            e.emit("row", f, u[l]);
          });
        }
      ) : o.forEach(function(c) {
        e.emit("row", c, u);
      })), e.state = "end", e.emit("end", u), e.callback && e.callback(null, u);
    }, "after");
    if (m.domain && (t = m.domain.bind(t)), this.name) {
      this.name.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", this.name, this.name.length), console.error("This can cause conflicts and silent errors executing queries"));
      var n = (this.values || []).map(Rn.prepareValue);
      if (r.namedQueries[this.name]) {
        if (this.text && r.namedQueries[this.name] !== this.text) {
          let s = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return t(s);
        }
        return r.native.execute(this.name, n, t);
      }
      return r.native.prepare(this.name, this.text, n.length, function(s) {
        return s ? t(s) : (r.namedQueries[e.name] = e.text, e.native.execute(e.name, n, t));
      });
    } else if (this.values) {
      if (!Array.isArray(
        this.values
      )) {
        let s = new Error("Query values must be an array");
        return t(s);
      }
      var i = this.values.map(Rn.prepareValue);
      r.native.query(this.text, i, t);
    } else r.native.query(this.text, t);
  };
});
var yo = T((yp, po) => {
  "use strict";
  p();
  var ll = (oo(), O(so)), fl = At(), dp = ao(), fo = ge().EventEmitter, hl = (it(), O(nt)), pl = Bt(), ho = lo(), K = po.exports = function(r) {
    fo.call(this), r = r || {}, this._Promise = r.Promise || b.Promise, this._types = new fl(r.types), this.native = new ll({ types: this._types }), this._queryQueue = [], this._ending = false, this._connecting = false, this._connected = false, this._queryable = true;
    var e = this.connectionParameters = new pl(r);
    this.user = e.user, Object.defineProperty(this, "password", { configurable: true, enumerable: false, writable: true, value: e.password }), this.database = e.database, this.host = e.host, this.port = e.port, this.namedQueries = {};
  };
  K.Query = ho;
  hl.inherits(K, fo);
  K.prototype._errorAllQueries = function(r) {
    let e = a((t) => {
      m.nextTick(() => {
        t.native = this.native, t.handleError(r);
      });
    }, "enqueueError");
    this._hasActiveQuery() && (e(this._activeQuery), this._activeQuery = null), this._queryQueue.forEach(e), this._queryQueue.length = 0;
  };
  K.prototype._connect = function(r) {
    var e = this;
    if (this._connecting) {
      m.nextTick(() => r(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true, this.connectionParameters.getLibpqConnectionString(function(t, n) {
      if (t) return r(t);
      e.native.connect(n, function(i) {
        if (i) return e.native.end(), r(i);
        e._connected = true, e.native.on("error", function(s) {
          e._queryable = false, e._errorAllQueries(s), e.emit("error", s);
        }), e.native.on("notification", function(s) {
          e.emit("notification", { channel: s.relname, payload: s.extra });
        }), e.emit("connect"), e._pulseQueryQueue(true), r();
      });
    });
  };
  K.prototype.connect = function(r) {
    if (r) {
      this._connect(r);
      return;
    }
    return new this._Promise((e, t) => {
      this._connect((n) => {
        n ? t(n) : e();
      });
    });
  };
  K.prototype.query = function(r, e, t) {
    var n, i, s, o, u;
    if (r == null) throw new TypeError("Client was passed a null or undefined query");
    if (typeof r.submit == "function") s = r.query_timeout || this.connectionParameters.query_timeout, i = n = r, typeof e == "function" && (r.callback = e);
    else if (s = this.connectionParameters.query_timeout, n = new ho(r, e, t), !n.callback) {
      let c, l;
      i = new this._Promise((f, y) => {
        c = f, l = y;
      }), n.callback = (f, y) => f ? l(f) : c(y);
    }
    return s && (u = n.callback, o = setTimeout(() => {
      var c = new Error(
        "Query read timeout"
      );
      m.nextTick(() => {
        n.handleError(c, this.connection);
      }), u(c), n.callback = () => {
      };
      var l = this._queryQueue.indexOf(n);
      l > -1 && this._queryQueue.splice(l, 1), this._pulseQueryQueue();
    }, s), n.callback = (c, l) => {
      clearTimeout(o), u(c, l);
    }), this._queryable ? this._ending ? (n.native = this.native, m.nextTick(() => {
      n.handleError(
        new Error("Client was closed and is not queryable")
      );
    }), i) : (this._queryQueue.push(n), this._pulseQueryQueue(), i) : (n.native = this.native, m.nextTick(() => {
      n.handleError(new Error("Client has encountered a connection error and is not queryable"));
    }), i);
  };
  K.prototype.end = function(r) {
    var e = this;
    this._ending = true, this._connected || this.once("connect", this.end.bind(this, r));
    var t;
    return r || (t = new this._Promise(function(n, i) {
      r = a((s) => s ? i(s) : n(), "cb");
    })), this.native.end(function() {
      e._errorAllQueries(new Error("Connection terminated")), m.nextTick(() => {
        e.emit("end"), r && r();
      });
    }), t;
  };
  K.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  K.prototype._pulseQueryQueue = function(r) {
    if (this._connected && !this._hasActiveQuery()) {
      var e = this._queryQueue.shift();
      if (!e) {
        r || this.emit("drain");
        return;
      }
      this._activeQuery = e, e.submit(this);
      var t = this;
      e.once("_done", function() {
        t._pulseQueryQueue();
      });
    }
  };
  K.prototype.cancel = function(r) {
    this._activeQuery === r ? this.native.cancel(function() {
    }) : this._queryQueue.indexOf(r) !== -1 && this._queryQueue.splice(this._queryQueue.indexOf(r), 1);
  };
  K.prototype.ref = function() {
  };
  K.prototype.unref = function() {
  };
  K.prototype.setTypeParser = function(r, e, t) {
    return this._types.setTypeParser(
      r,
      e,
      t
    );
  };
  K.prototype.getTypeParser = function(r, e) {
    return this._types.getTypeParser(r, e);
  };
});
var Ln = T((gp, mo) => {
  "use strict";
  p();
  mo.exports = yo();
});
var ot = T((vp, at) => {
  "use strict";
  p();
  var dl = eo(), yl = tt(), ml = En(), wl = io(), { DatabaseError: gl } = vn(), bl = a(
    (r) => {
      var e;
      return e = class extends wl {
        constructor(n) {
          super(n, r);
        }
      }, a(e, "BoundPool"), e;
    },
    "poolFactory"
  ), Fn = a(
    function(r) {
      this.defaults = yl, this.Client = r, this.Query = this.Client.Query, this.Pool = bl(this.Client), this._pools = [], this.Connection = ml, this.types = Je(), this.DatabaseError = gl;
    },
    "PG"
  );
  typeof m.env.NODE_PG_FORCE_NATIVE < "u" ? at.exports = new Fn(Ln()) : (at.exports = new Fn(dl), Object.defineProperty(at.exports, "native", {
    configurable: true,
    enumerable: false,
    get() {
      var r = null;
      try {
        r = new Fn(Ln());
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND") throw e;
      }
      return Object.defineProperty(at.exports, "native", { value: r }), r;
    }
  }));
});
p();
p();
Fe();
Zt();
p();
var pa = Object.defineProperty;
var da = Object.defineProperties;
var ya = Object.getOwnPropertyDescriptors;
var bi = Object.getOwnPropertySymbols;
var ma = Object.prototype.hasOwnProperty;
var wa = Object.prototype.propertyIsEnumerable;
var vi = a(
  (r, e, t) => e in r ? pa(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t,
  "__defNormalProp"
);
var ga = a((r, e) => {
  for (var t in e || (e = {})) ma.call(e, t) && vi(r, t, e[t]);
  if (bi) for (var t of bi(e)) wa.call(e, t) && vi(r, t, e[t]);
  return r;
}, "__spreadValues");
var ba = a((r, e) => da(r, ya(e)), "__spreadProps");
var va = 1008e3;
var xi = new Uint8Array(
  new Uint16Array([258]).buffer
)[0] === 2;
var xa = new TextDecoder();
var Jt = new TextEncoder();
var yt = Jt.encode("0123456789abcdef");
var mt = Jt.encode("0123456789ABCDEF");
var Sa = Jt.encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var Si = Sa.slice();
Si[62] = 45;
Si[63] = 95;
var He;
var wt;
function Ea(r, { alphabet: e, scratchArr: t } = {}) {
  if (!He) if (He = new Uint16Array(256), wt = new Uint16Array(256), xi) for (let C = 0; C < 256; C++) He[C] = yt[C & 15] << 8 | yt[C >>> 4], wt[C] = mt[C & 15] << 8 | mt[C >>> 4];
  else for (let C = 0; C < 256; C++) He[C] = yt[C & 15] | yt[C >>> 4] << 8, wt[C] = mt[C & 15] | mt[C >>> 4] << 8;
  r.byteOffset % 4 !== 0 && (r = new Uint8Array(r));
  let n = r.length, i = n >>> 1, s = n >>> 2, o = t || new Uint16Array(n), u = new Uint32Array(
    r.buffer,
    r.byteOffset,
    s
  ), c = new Uint32Array(o.buffer, o.byteOffset, i), l = e === "upper" ? wt : He, f = 0, y = 0, g;
  if (xi)
    for (; f < s; ) g = u[f++], c[y++] = l[g >>> 8 & 255] << 16 | l[g & 255], c[y++] = l[g >>> 24] << 16 | l[g >>> 16 & 255];
  else for (; f < s; )
    g = u[f++], c[y++] = l[g >>> 24] << 16 | l[g >>> 16 & 255], c[y++] = l[g >>> 8 & 255] << 16 | l[g & 255];
  for (f <<= 2; f < n; ) o[f] = l[r[f++]];
  return xa.decode(o.subarray(0, n));
}
a(Ea, "_toHex");
function Aa(r, e = {}) {
  let t = "", n = r.length, i = va >>> 1, s = Math.ceil(n / i), o = new Uint16Array(s > 1 ? i : n);
  for (let u = 0; u < s; u++) {
    let c = u * i, l = c + i;
    t += Ea(r.subarray(c, l), ba(ga(
      {},
      e
    ), { scratchArr: o }));
  }
  return t;
}
a(Aa, "_toHexChunked");
function Ei(r, e = {}) {
  return e.alphabet !== "upper" && typeof r.toHex == "function" ? r.toHex() : Aa(r, e);
}
a(Ei, "toHex");
p();
var gt2 = class gt3 {
  constructor(e, t) {
    this.strings = e;
    this.values = t;
  }
  toParameterizedQuery(e = { query: "", params: [] }) {
    let { strings: t, values: n } = this;
    for (let i = 0, s = t.length; i < s; i++) if (e.query += t[i], i < n.length) {
      let o = n[i];
      if (o instanceof Ge) e.query += o.sql;
      else if (o instanceof Ce) if (o.queryData instanceof gt3) o.queryData.toParameterizedQuery(
        e
      );
      else {
        if (o.queryData.params?.length) throw new Error("This query is not composable");
        e.query += o.queryData.query;
      }
      else {
        let { params: u } = e;
        u.push(o), e.query += "$" + u.length, (o instanceof d || ArrayBuffer.isView(o)) && (e.query += "::bytea");
      }
    }
    return e;
  }
};
a(gt2, "SqlTemplate");
var $e = gt2;
var Xt = class Xt2 {
  constructor(e) {
    this.sql = e;
  }
};
a(Xt, "UnsafeRawSql");
var Ge = Xt;
p();
function bt() {
  typeof window < "u" && typeof document < "u" && typeof console < "u" && typeof console.warn == "function" && console.warn(`          
        ************************************************************
        *                                                          *
        *  WARNING: Running SQL directly from the browser can have *
        *  security implications. Even if your database is         *
        *  protected by Row-Level Security (RLS), use it at your   *
        *  own risk. This approach is great for fast prototyping,  *
        *  but ensure proper safeguards are in place to prevent    *
        *  misuse or execution of expensive SQL queries by your    *
        *  end users.                                              *
        *                                                          *
        *  If you've assessed the risks, suppress this message     *
        *  using the disableWarningInBrowsers configuration        *
        *  parameter.                                              *
        *                                                          *
        ************************************************************`);
}
a(bt, "warnIfBrowser");
Fe();
var as = Se(At());
var us = Se(rt());
var _t = class _t2 extends Error {
  constructor(t) {
    super(t);
    E(this, "name", "NeonDbError");
    E(this, "severity");
    E(this, "code");
    E(this, "detail");
    E(this, "hint");
    E(this, "position");
    E(this, "internalPosition");
    E(
      this,
      "internalQuery"
    );
    E(this, "where");
    E(this, "schema");
    E(this, "table");
    E(this, "column");
    E(this, "dataType");
    E(this, "constraint");
    E(this, "file");
    E(this, "line");
    E(this, "routine");
    E(this, "sourceError");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, _t2);
  }
};
a(
  _t,
  "NeonDbError"
);
var be = _t;
var is = "transaction() expects an array of queries, or a function returning an array of queries";
var Ru = ["severity", "code", "detail", "hint", "position", "internalPosition", "internalQuery", "where", "schema", "table", "column", "dataType", "constraint", "file", "line", "routine"];
function Lu(r) {
  return r instanceof d ? "\\x" + Ei(r) : r;
}
a(Lu, "encodeBuffersAsBytea");
function ss(r) {
  let { query: e, params: t } = r instanceof $e ? r.toParameterizedQuery() : r;
  return { query: e, params: t.map((n) => Lu((0, us.prepareValue)(n))) };
}
a(ss, "prepareQuery");
function cs(r, {
  arrayMode: e,
  fullResults: t,
  fetchOptions: n,
  isolationLevel: i,
  readOnly: s,
  deferrable: o,
  authToken: u,
  disableWarningInBrowsers: c
} = {}) {
  if (!r) throw new Error("No database connection string was provided to `neon()`. Perhaps an environment variable has not been set?");
  let l;
  try {
    l = Yt(r);
  } catch {
    throw new Error(
      "Database connection string provided to `neon()` is not a valid URL. Connection string: " + String(r)
    );
  }
  let { protocol: f, username: y, hostname: g, port: A, pathname: C } = l;
  if (f !== "postgres:" && f !== "postgresql:" || !y || !g || !C) throw new Error("Database connection string format for `neon()` should be: postgresql://user:password@host.tld/dbname?option=value");
  function D(P, ...I) {
    if (!(Array.isArray(P) && Array.isArray(P.raw) && Array.isArray(I))) throw new Error('This function can now be called only as a tagged-template function: sql`SELECT ${value}`, not sql("SELECT $1", [value], options). For a conventional function call with value placeholders ($1, $2, etc.), use sql.query("SELECT $1", [value], options).');
    return new Ce(
      Y,
      new $e(P, I)
    );
  }
  a(D, "templateFn"), D.query = (P, I, w) => new Ce(Y, { query: P, params: I ?? [] }, w), D.unsafe = (P) => new Ge(
    P
  ), D.transaction = async (P, I) => {
    if (typeof P == "function" && (P = P(D)), !Array.isArray(P)) throw new Error(is);
    P.forEach((W) => {
      if (!(W instanceof Ce)) throw new Error(is);
    });
    let w = P.map((W) => W.queryData), Z = P.map((W) => W.opts ?? {});
    return Y(w, Z, I);
  };
  async function Y(P, I, w) {
    let { fetchEndpoint: Z, fetchFunction: W } = ce, J = Array.isArray(
      P
    ) ? { queries: P.map((ee) => ss(ee)) } : ss(P), X = n ?? {}, se = e ?? false, oe = t ?? false, R = i, j = s, le = o;
    w !== void 0 && (w.fetchOptions !== void 0 && (X = { ...X, ...w.fetchOptions }), w.arrayMode !== void 0 && (se = w.arrayMode), w.fullResults !== void 0 && (oe = w.fullResults), w.isolationLevel !== void 0 && (R = w.isolationLevel), w.readOnly !== void 0 && (j = w.readOnly), w.deferrable !== void 0 && (le = w.deferrable)), I !== void 0 && !Array.isArray(I) && I.fetchOptions !== void 0 && (X = { ...X, ...I.fetchOptions });
    let de = u;
    !Array.isArray(I) && I?.authToken !== void 0 && (de = I.authToken);
    let We = typeof Z == "function" ? Z(g, A, { jwtAuth: de !== void 0 }) : Z, fe = { "Neon-Connection-String": r, "Neon-Raw-Text-Output": "true", "Neon-Array-Mode": "true" }, _e = await Fu(de);
    _e && (fe.Authorization = `Bearer ${_e}`), Array.isArray(P) && (R !== void 0 && (fe["Neon-Batch-Isolation-Level"] = R), j !== void 0 && (fe["Neon-Batch-Read-Only"] = String(j)), le !== void 0 && (fe["Neon-Batch-Deferrable"] = String(le))), c || ce.disableWarningInBrowsers || bt();
    let ye;
    try {
      ye = await (W ?? fetch)(We, { method: "POST", body: JSON.stringify(J), headers: fe, ...X });
    } catch (ee) {
      let M = new be(
        `Error connecting to database: ${ee}`
      );
      throw M.sourceError = ee, M;
    }
    if (ye.ok) {
      let ee = await ye.json();
      if (Array.isArray(P)) {
        let M = ee.results;
        if (!Array.isArray(M)) throw new be("Neon internal error: unexpected result format");
        return M.map(($, me) => {
          let Ot = I[me] ?? {}, vo = Ot.arrayMode ?? se, xo = Ot.fullResults ?? oe;
          return os(
            $,
            { arrayMode: vo, fullResults: xo, types: Ot.types }
          );
        });
      } else {
        let M = I ?? {}, $ = M.arrayMode ?? se, me = M.fullResults ?? oe;
        return os(ee, { arrayMode: $, fullResults: me, types: M.types });
      }
    } else {
      let { status: ee } = ye;
      if (ee === 400) {
        let M = await ye.json(), $ = new be(M.message);
        for (let me of Ru) $[me] = M[me] ?? void 0;
        throw $;
      } else {
        let M = await ye.text();
        throw new be(
          `Server error (HTTP status ${ee}): ${M}`
        );
      }
    }
  }
  return a(Y, "execute"), D;
}
a(cs, "neon");
var dr = class dr2 {
  constructor(e, t, n) {
    this.execute = e;
    this.queryData = t;
    this.opts = n;
  }
  then(e, t) {
    return this.execute(this.queryData, this.opts).then(e, t);
  }
  catch(e) {
    return this.execute(this.queryData, this.opts).catch(e);
  }
  finally(e) {
    return this.execute(
      this.queryData,
      this.opts
    ).finally(e);
  }
};
a(dr, "NeonQueryPromise");
var Ce = dr;
function os(r, {
  arrayMode: e,
  fullResults: t,
  types: n
}) {
  let i = new as.default(n), s = r.fields.map((c) => c.name), o = r.fields.map((c) => i.getTypeParser(
    c.dataTypeID
  )), u = e === true ? r.rows.map((c) => c.map((l, f) => l === null ? null : o[f](l))) : r.rows.map((c) => Object.fromEntries(
    c.map((l, f) => [s[f], l === null ? null : o[f](l)])
  ));
  return t ? (r.viaNeonFetch = true, r.rowAsArray = e, r.rows = u, r._parsers = o, r._types = i, r) : u;
}
a(os, "processQueryResult");
async function Fu(r) {
  if (typeof r == "string") return r;
  if (typeof r == "function") try {
    return await Promise.resolve(r());
  } catch (e) {
    let t = new be("Error getting auth token.");
    throw e instanceof Error && (t = new be(`Error getting auth token: ${e.message}`)), t;
  }
}
a(Fu, "getAuthToken");
p();
var go = Se(ot());
p();
var wo = Se(ot());
var kn = class kn2 extends wo.Client {
  constructor(t) {
    super(t);
    this.config = t;
  }
  get neonConfig() {
    return this.connection.stream;
  }
  connect(t) {
    let { neonConfig: n } = this;
    n.forceDisablePgSSL && (this.ssl = this.connection.ssl = false), this.ssl && n.useSecureWebSocket && console.warn("SSL is enabled for both Postgres (e.g. ?sslmode=require in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSocket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disable SSL in the Postgres connection parameters or set forceDisablePgSSL = true.");
    let i = typeof this.config != "string" && this.config?.host !== void 0 || typeof this.config != "string" && this.config?.connectionString !== void 0 || m.env.PGHOST !== void 0, s = m.env.USER ?? m.env.USERNAME;
    if (!i && this.host === "localhost" && this.user === s && this.database === s && this.password === null) throw new Error(`No database host or connection string was set, and key parameters have default values (host: localhost, user: ${s}, db: ${s}, password: null). Is an environment variable missing? Alternatively, if you intended to connect with these parameters, please set the host to 'localhost' explicitly.`);
    let o = super.connect(t), u = n.pipelineTLS && this.ssl, c = n.pipelineConnect === "password";
    if (!u && !n.pipelineConnect) return o;
    let l = this.connection;
    if (u && l.on(
      "connect",
      () => l.stream.emit("data", "S")
    ), c) {
      l.removeAllListeners("authenticationCleartextPassword"), l.removeAllListeners("readyForQuery"), l.once("readyForQuery", () => l.on("readyForQuery", this._handleReadyForQuery.bind(this)));
      let f = this.ssl ? "sslconnect" : "connect";
      l.on(f, () => {
        this.neonConfig.disableWarningInBrowsers || bt(), this._handleAuthCleartextPassword(), this._handleReadyForQuery();
      });
    }
    return o;
  }
  async _handleAuthSASLContinue(t) {
    if (typeof crypto > "u" || crypto.subtle === void 0 || crypto.subtle.importKey === void 0) throw new Error("Cannot use SASL auth when `crypto.subtle` is not defined");
    let n = crypto.subtle, i = this.saslSession, s = this.password, o = t.data;
    if (i.message !== "SASLInitialResponse" || typeof s != "string" || typeof o != "string") throw new Error(
      "SASL: protocol error"
    );
    let u = Object.fromEntries(o.split(",").map((M) => {
      if (!/^.=/.test(M)) throw new Error(
        "SASL: Invalid attribute pair entry"
      );
      let $ = M[0], me = M.substring(2);
      return [$, me];
    })), c = u.r, l = u.s, f = u.i;
    if (!c || !/^[!-+--~]+$/.test(c)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unprintable");
    if (!l || !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(l)) throw new Error(
      "SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64"
    );
    if (!f || !/^[1-9][0-9]*$/.test(f)) throw new Error(
      "SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count"
    );
    if (!c.startsWith(i.clientNonce))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    if (c.length === i.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    let y = parseInt(f, 10), g = d.from(l, "base64"), A = new TextEncoder(), C = A.encode(s), D = await n.importKey(
      "raw",
      C,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), Y = new Uint8Array(await n.sign("HMAC", D, d.concat(
      [g, d.from([0, 0, 0, 1])]
    ))), P = Y;
    for (var I = 0; I < y - 1; I++) Y = new Uint8Array(await n.sign("HMAC", D, Y)), P = d.from(
      P.map((M, $) => P[$] ^ Y[$])
    );
    let w = P, Z = await n.importKey(
      "raw",
      w,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), W = new Uint8Array(await n.sign("HMAC", Z, A.encode("Client Key"))), J = await n.digest(
      "SHA-256",
      W
    ), X = "n=*,r=" + i.clientNonce, se = "r=" + c + ",s=" + l + ",i=" + y, oe = "c=biws,r=" + c, R = X + "," + se + "," + oe, j = await n.importKey(
      "raw",
      J,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    );
    var le = new Uint8Array(await n.sign(
      "HMAC",
      j,
      A.encode(R)
    )), de = d.from(W.map((M, $) => W[$] ^ le[$])), We = de.toString("base64");
    let fe = await n.importKey(
      "raw",
      w,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), _e = await n.sign("HMAC", fe, A.encode("Server Key")), ye = await n.importKey("raw", _e, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    var ee = d.from(
      await n.sign("HMAC", ye, A.encode(R))
    );
    i.message = "SASLResponse", i.serverSignature = ee.toString("base64"), i.response = oe + ",p=" + We, this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
  }
};
a(
  kn,
  "NeonClient"
);
var ut = kn;
Fe();
var bo = Se(Bt());
function vl(r, e) {
  if (e) return { callback: e, result: void 0 };
  let t, n, i = a(function(o, u) {
    o ? t(o) : n(u);
  }, "cb"), s = new r(function(o, u) {
    n = o, t = u;
  });
  return { callback: i, result: s };
}
a(vl, "promisify");
var Un = class Un2 extends go.Pool {
  constructor() {
    super(...arguments);
    E(this, "Client", ut);
    E(this, "hasFetchUnsupportedListeners", false);
    E(this, "addListener", this.on);
  }
  on(t, n) {
    return t !== "error" && (this.hasFetchUnsupportedListeners = true), super.on(t, n);
  }
  query(t, n, i) {
    if (!ce.poolQueryViaFetch || this.hasFetchUnsupportedListeners || typeof t == "function") return super.query(
      t,
      n,
      i
    );
    typeof n == "function" && (i = n, n = void 0);
    let s = vl(this.Promise, i);
    i = s.callback;
    try {
      let o = new bo.default(
        this.options
      ), u = encodeURIComponent, c = encodeURI, l = `postgresql://${u(o.user)}:${u(o.password)}@${u(o.host)}/${c(o.database)}`, f = typeof t == "string" ? t : t.text, y = n ?? t.values ?? [];
      cs(l, { fullResults: true, arrayMode: t.rowMode === "array" }).query(f, y, { types: t.types ?? this.options?.types }).then((A) => i(void 0, A)).catch((A) => i(
        A
      ));
    } catch (o) {
      i(o);
    }
    return s.result;
  }
};
a(Un, "NeonPool");
Fe();
var ct = Se(ot());
var export_DatabaseError = ct.DatabaseError;
var export_defaults = ct.defaults;
var export_escapeIdentifier = ct.escapeIdentifier;
var export_escapeLiteral = ct.escapeLiteral;
var export_types = ct.types;

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/entity.js
var entityKind = /* @__PURE__ */ Symbol.for("drizzle:entityKind");
function is2(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/logger.js
var ConsoleLogWriter = class {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
};
var DefaultLogger = class {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config3) {
    this.writer = config3?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p2) => {
      try {
        return JSON.stringify(p2);
      } catch {
        return String(p2);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
var NoopLogger = class {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/query-promise.js
var QueryPromise = class {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value) => {
        onFinally?.();
        return value;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/column.js
var Column = class {
  constructor(table, config3) {
    this.table = table;
    this.config = config3;
    this.name = config3.name;
    this.keyAsName = config3.keyAsName;
    this.notNull = config3.notNull;
    this.default = config3.default;
    this.defaultFn = config3.defaultFn;
    this.onUpdateFn = config3.onUpdateFn;
    this.hasDefault = config3.hasDefault;
    this.primary = config3.primaryKey;
    this.isUnique = config3.isUnique;
    this.uniqueName = config3.uniqueName;
    this.uniqueType = config3.uniqueType;
    this.dataType = config3.dataType;
    this.columnType = config3.columnType;
    this.generated = config3.generated;
    this.generatedIdentity = config3.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  generated = void 0;
  generatedIdentity = void 0;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  // ** @internal */
  shouldDisableInsert() {
    return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/column-builder.js
var ColumnBuilder = class {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType,
      generated: void 0
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a dynamic update value to the column.
   * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
   * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $onUpdateFn}.
   */
  $onUpdate = this.$onUpdateFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  /** @internal Sets the name of the column to the key within the table definition if a name was not given. */
  setName(name) {
    if (this.config.name !== "") return;
    this.config.name = name;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/table.utils.js
var TableName = /* @__PURE__ */ Symbol.for("drizzle:Name");

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/foreign-keys.js
var ForeignKeyBuilder = class {
  static [entityKind] = "PgForeignKeyBuilder";
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config3, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config3();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table) {
    return new ForeignKey(table, this);
  }
};
var ForeignKey = class {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  static [entityKind] = "PgUniqueConstraintBuilder";
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table) {
    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
var UniqueOnConstraintBuilder = class {
  static [entityKind] = "PgUniqueOnConstraintBuilder";
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
var UniqueConstraint = class {
  constructor(table, columns, nullsNotDistinct, name) {
    this.table = table;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  static [entityKind] = "PgUniqueConstraint";
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom; i < arrayString.length; i++) {
    const char2 = arrayString[i];
    if (char2 === "\\") {
      i++;
      continue;
    }
    if (char2 === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char2 === "," || char2 === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char2 = arrayString[i];
    if (char2 === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char2 === "\\") {
      i += 2;
      continue;
    }
    if (char2 === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char2 === "}") {
      return [result, i + 1];
    }
    if (char2 === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array3) {
  return `{${array3.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/common.js
var PgColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config3) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config3?.nulls;
    return this;
  }
  generatedAlwaysAs(as2) {
    this.config.generated = {
      as: as2,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife(
        (ref2, actions2) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref2();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions2.onUpdate) {
            builder.onUpdate(actions2.onUpdate);
          }
          if (actions2.onDelete) {
            builder.onDelete(actions2.onDelete);
          }
          return builder.build(table);
        },
        ref,
        actions
      );
    });
  }
  /** @internal */
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
};
var PgColumn = class extends Column {
  constructor(table, config3) {
    if (!config3.uniqueName) {
      config3.uniqueName = uniqueKeyName(table, [config3.name]);
    }
    super(table, config3);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
};
var ExtraConfigColumn = class extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: void 0
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  /**
   * ### PostgreSQL documentation quote
   *
   * > An operator class with optional parameters can be specified for each column of an index.
   * The operator class identifies the operators to be used by the index for that column.
   * For example, a B-tree index on four-byte integers would use the int4_ops class;
   * this operator class includes comparison functions for four-byte integers.
   * In practice the default operator class for the column's data type is usually sufficient.
   * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
   * For example, we might want to sort a complex-number data type either by absolute value or by real part.
   * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
   * More information about operator classes check:
   *
   * ### Useful links
   * https://www.postgresql.org/docs/current/sql-createindex.html
   *
   * https://www.postgresql.org/docs/current/indexes-opclass.html
   *
   * https://www.postgresql.org/docs/current/xindex.html
   *
   * ### Additional types
   * If you have the `pg_vector` extension installed in your database, you can use the
   * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
   *
   * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
   *
   * @param opClass
   * @returns
   */
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
};
var IndexedColumn = class {
  static [entityKind] = "IndexedColumn";
  constructor(name, keyAsName, type, indexConfig) {
    this.name = name;
    this.keyAsName = keyAsName;
    this.type = type;
    this.indexConfig = indexConfig;
  }
  name;
  keyAsName;
  type;
  indexConfig;
};
var PgArrayBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  /** @internal */
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(
      table,
      this.config,
      baseColumn
    );
  }
};
var PgArray = class _PgArray extends PgColumn {
  constructor(table, config3, baseColumn, range) {
    super(table, config3);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config3.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v2) => this.baseColumn.mapFromDriverValue(v2));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a2 = value.map(
      (v2) => v2 === null ? null : is2(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v2, true) : this.baseColumn.mapToDriverValue(v2)
    );
    if (isNestedArray) return a2;
    return makePgArray(a2);
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/enum.js
var PgEnumObjectColumnBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgEnumObjectColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumObjectColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table) {
    return new PgEnumObjectColumn(
      table,
      this.config
    );
  }
};
var PgEnumObjectColumn = class extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config3) {
    super(table, config3);
    this.enum = config3.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};
var isPgEnumSym = /* @__PURE__ */ Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
var PgEnumColumnBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table) {
    return new PgEnumColumn(
      table,
      this.config
    );
  }
};
var PgEnumColumn = class extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config3) {
    super(table, config3);
    this.enum = config3.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};
function pgEnum(enumName, input) {
  return Array.isArray(input) ? pgEnumWithSchema(enumName, [...input], void 0) : pgEnumObjectWithSchema(enumName, input, void 0);
}
function pgEnumWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign(
    (name) => new PgEnumColumnBuilder(name ?? "", enumInstance),
    {
      enumName,
      enumValues: values,
      schema,
      [isPgEnumSym]: true
    }
  );
  return enumInstance;
}
function pgEnumObjectWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign(
    (name) => new PgEnumObjectColumnBuilder(name ?? "", enumInstance),
    {
      enumName,
      enumValues: Object.values(values),
      schema,
      [isPgEnumSym]: true
    }
  );
  return enumInstance;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/subquery.js
var Subquery = class {
  static [entityKind] = "Subquery";
  constructor(sql3, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql: sql3,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
  // getSQL(): SQL<unknown> {
  // 	return new SQL([this]);
  // }
};
var WithSubquery = class extends Subquery {
  static [entityKind] = "WithSubquery";
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/version.js
var version2 = "0.45.1";

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version2);
    }
    return iife(
      (otel2, rawTracer2) => rawTracer2.startActiveSpan(
        name,
        (span) => {
          try {
            return fn(span);
          } catch (e) {
            span.setStatus({
              code: otel2.SpanStatusCode.ERROR,
              message: e instanceof Error ? e.message : "Unknown error"
              // eslint-disable-line no-instanceof/no-instanceof
            });
            throw e;
          } finally {
            span.end();
          }
        }
      ),
      otel,
      rawTracer
    );
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = /* @__PURE__ */ Symbol.for("drizzle:ViewBaseConfig");

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/table.js
var Schema = /* @__PURE__ */ Symbol.for("drizzle:Schema");
var Columns = /* @__PURE__ */ Symbol.for("drizzle:Columns");
var ExtraConfigColumns = /* @__PURE__ */ Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = /* @__PURE__ */ Symbol.for("drizzle:OriginalName");
var BaseName = /* @__PURE__ */ Symbol.for("drizzle:BaseName");
var IsAlias = /* @__PURE__ */ Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = /* @__PURE__ */ Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = /* @__PURE__ */ Symbol.for("drizzle:IsDrizzleTable");
var Table = class {
  static [entityKind] = "Table";
  /** @internal */
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [TableName];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema];
  /** @internal */
  [Columns];
  /** @internal */
  [ExtraConfigColumns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [IsDrizzleTable] = true;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
};
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/sql/sql.js
var FakePrimitiveParam = class {
  static [entityKind] = "FakePrimitiveParam";
};
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
var StringChunk = class {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
};
var SQL = class _SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is2(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(
          schemaName === void 0 ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]
        );
      }
    }
  }
  static [entityKind] = "SQL";
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  /** @internal */
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config3) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config3);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config3 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config3;
    return mergeQueries(chunks.map((chunk) => {
      if (is2(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is2(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p2] of chunk.entries()) {
          result.push(p2);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config3);
      }
      if (is2(chunk, _SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config3,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is2(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is2(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === void 0 ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is2(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is2(chunk, Param)) {
        if (is2(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is2(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config3);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config3), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is2(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is2(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is2(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config3);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config3);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config3);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config3), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  /**
   * This method is used to conditionally include a part of the query.
   *
   * @param condition - Condition to check
   * @returns itself if the condition is `true`, otherwise `undefined`
   */
  if(condition) {
    return condition ? this : void 0;
  }
};
var Name = class {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var Param = class {
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql22) => {
  function empty() {
    return new SQL([]);
  }
  sql22.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql22.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql22.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql22.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql22.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql22.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql22.param = param2;
})(sql || (sql = {}));
((SQL2) => {
  class Aliased {
    constructor(sql22, fieldAlias) {
      this.sql = sql22;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var Placeholder = class {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
};
function fillPlaceholders(params, values) {
  return params.map((p2) => {
    if (is2(p2, Placeholder)) {
      if (!(p2.name in values)) {
        throw new Error(`No value for placeholder "${p2.name}" was provided`);
      }
      return values[p2.name];
    }
    if (is2(p2, Param) && is2(p2.value, Placeholder)) {
      if (!(p2.value.name in values)) {
        throw new Error(`No value for placeholder "${p2.value.name}" was provided`);
      }
      return p2.encoder.mapToDriverValue(values[p2.value.name]);
    }
    return p2;
  });
}
var IsDrizzleView = /* @__PURE__ */ Symbol.for("drizzle:IsDrizzleView");
var View = class {
  static [entityKind] = "View";
  /** @internal */
  [ViewBaseConfig];
  /** @internal */
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
function isView(view) {
  return typeof view === "object" && view !== null && IsDrizzleView in view;
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/alias.js
var ColumnAliasProxyHandler = class {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
var TableAliasProxyHandler = class {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(
          columns[key],
          new ColumnAliasProxyHandler(new Proxy(target, this))
        );
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is2(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
};
var RelationTableAliasProxyHandler = class {
  constructor(alias) {
    this.alias = alias;
  }
  static [entityKind] = "RelationTableAliasProxyHandler";
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is2(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is2(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is2(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/selection-proxy.js
var SelectionProxyHandler = class _SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config3) {
    this.config = { ...config3 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(
          subquery._.selectedFields,
          this
        )
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(
          subquery[ViewBaseConfig].selectedFields,
          this
        )
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is2(subquery, Subquery) ? subquery._.selectedFields : is2(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is2(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is2(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(
        `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
      );
    }
    if (is2(value, Column)) {
      if (this.config.alias) {
        return new Proxy(
          value,
          new ColumnAliasProxyHandler(
            new Proxy(
              value.table,
              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
            )
          )
        );
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new _SelectionProxyHandler(this.config));
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder;
      if (is2(field, Column)) {
        decoder = field;
      } else if (is2(field, SQL)) {
        decoder = field.decoder;
      } else if (is2(field, Subquery)) {
        decoder = field._.sql.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is2(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is2(field, Column) || is2(field, SQL) || is2(field, SQL.Aliased) || is2(field, Subquery)) {
      result.push({ path: newPath, field });
    } else if (is2(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index2, key] of leftKeys.entries()) {
    if (key !== rightKeys[index2]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is2(value, SQL) || is2(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor") continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getViewSelectedFields(view) {
  return view[ViewBaseConfig].selectedFields;
}
function getTableLikeName(table) {
  return is2(table, Subquery) ? table._.alias : is2(table, View) ? table[ViewBaseConfig].name : is2(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a2, b2) {
  return {
    name: typeof a2 === "string" && a2.length > 0 ? a2 : "",
    config: typeof a2 === "object" ? a2 : b2
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null) return false;
  if (data.constructor.name !== "Object") return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined") return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined") return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined") return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== void 0) return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined") return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined") return false;
    return true;
  }
  if (Object.keys(data).length === 0) return true;
  return false;
}
var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder();

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/int.common.js
var PgIntColumnBaseBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/bigint.js
var PgBigInt53Builder = class extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  /** @internal */
  build(table) {
    return new PgBigInt53(table, this.config);
  }
};
var PgBigInt53 = class extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
};
var PgBigInt64Builder = class extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  /** @internal */
  build(table) {
    return new PgBigInt64(
      table,
      this.config
    );
  }
};
var PgBigInt64 = class extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  // eslint-disable-next-line unicorn/prefer-native-coercion-functions
  mapFromDriverValue(value) {
    return BigInt(value);
  }
};
function bigint5(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (config3.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/bigserial.js
var PgBigSerial53Builder = class extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  /** @internal */
  build(table) {
    return new PgBigSerial53(
      table,
      this.config
    );
  }
};
var PgBigSerial53 = class extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
};
var PgBigSerial64Builder = class extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  /** @internal */
  build(table) {
    return new PgBigSerial64(
      table,
      this.config
    );
  }
};
var PgBigSerial64 = class extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  // eslint-disable-next-line unicorn/prefer-native-coercion-functions
  mapFromDriverValue(value) {
    return BigInt(value);
  }
};
function bigserial(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (config3.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/boolean.js
var PgBooleanBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  /** @internal */
  build(table) {
    return new PgBoolean(table, this.config);
  }
};
var PgBoolean = class extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
};
function boolean6(name) {
  return new PgBooleanBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/char.js
var PgCharBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config3) {
    super(name, "string", "PgChar");
    this.config.length = config3.length;
    this.config.enumValues = config3.enum;
  }
  /** @internal */
  build(table) {
    return new PgChar(
      table,
      this.config
    );
  }
};
var PgChar = class extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === void 0 ? `char` : `char(${this.length})`;
  }
};
function char(a2, b2 = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgCharBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/cidr.js
var PgCidrBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  /** @internal */
  build(table) {
    return new PgCidr(table, this.config);
  }
};
var PgCidr = class extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
};
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/custom.js
var PgCustomColumnBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  /** @internal */
  build(table) {
    return new PgCustomColumn(
      table,
      this.config
    );
  }
};
var PgCustomColumn = class extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config3) {
    super(table, config3);
    this.sqlName = config3.customTypeParams.dataType(config3.fieldConfig);
    this.mapTo = config3.customTypeParams.toDriver;
    this.mapFrom = config3.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
};
function customType(customTypeParams) {
  return (a2, b2) => {
    const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
    return new PgCustomColumnBuilder(name, config3, customTypeParams);
  };
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/date.common.js
var PgDateColumnBaseBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/date.js
var PgDateBuilder = class extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  /** @internal */
  build(table) {
    return new PgDate(table, this.config);
  }
};
var PgDate = class extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") return new Date(value);
    return value;
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
};
var PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  /** @internal */
  build(table) {
    return new PgDateString(
      table,
      this.config
    );
  }
};
var PgDateString = class extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") return value;
    return value.toISOString().slice(0, -14);
  }
};
function date8(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (config3?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/double-precision.js
var PgDoublePrecisionBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  /** @internal */
  build(table) {
    return new PgDoublePrecision(
      table,
      this.config
    );
  }
};
var PgDoublePrecision = class extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
};
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/inet.js
var PgInetBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  /** @internal */
  build(table) {
    return new PgInet(table, this.config);
  }
};
var PgInet = class extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
};
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/integer.js
var PgIntegerBuilder = class extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  /** @internal */
  build(table) {
    return new PgInteger(table, this.config);
  }
};
var PgInteger = class extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
};
function integer2(name) {
  return new PgIntegerBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/interval.js
var PgIntervalBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  /** @internal */
  build(table) {
    return new PgInterval(table, this.config);
  }
};
var PgInterval = class extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
};
function interval(a2, b2 = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgIntervalBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/json.js
var PgJsonBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  /** @internal */
  build(table) {
    return new PgJson(table, this.config);
  }
};
var PgJson = class extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config3) {
    super(table, config3);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
function json3(name) {
  return new PgJsonBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/jsonb.js
var PgJsonbBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  /** @internal */
  build(table) {
    return new PgJsonb(table, this.config);
  }
};
var PgJsonb = class extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config3) {
    super(table, config3);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/line.js
var PgLineBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  /** @internal */
  build(table) {
    return new PgLineTuple(
      table,
      this.config
    );
  }
};
var PgLineTuple = class extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a2, b2, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a2), Number.parseFloat(b2), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
};
var PgLineABCBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  /** @internal */
  build(table) {
    return new PgLineABC(
      table,
      this.config
    );
  }
};
var PgLineABC = class extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a2, b2, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a2), b: Number.parseFloat(b2), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
};
function line(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (!config3?.mode || config3.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/macaddr.js
var PgMacaddrBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  /** @internal */
  build(table) {
    return new PgMacaddr(table, this.config);
  }
};
var PgMacaddr = class extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
};
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/macaddr8.js
var PgMacaddr8Builder = class extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  /** @internal */
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
};
var PgMacaddr8 = class extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
};
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/numeric.js
var PgNumericBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new PgNumeric(table, this.config);
  }
};
var PgNumeric = class extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config3) {
    super(table, config3);
    this.precision = config3.precision;
    this.scale = config3.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
var PgNumericNumberBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name, precision, scale) {
    super(name, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new PgNumericNumber(
      table,
      this.config
    );
  }
};
var PgNumericNumber = class extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config3) {
    super(table, config3);
    this.precision = config3.precision;
    this.scale = config3.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
var PgNumericBigIntBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name, precision, scale) {
    super(name, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new PgNumericBigInt(
      table,
      this.config
    );
  }
};
var PgNumericBigInt = class extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config3) {
    super(table, config3);
    this.precision = config3.precision;
    this.scale = config3.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
function numeric(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  const mode = config3?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config3?.precision, config3?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config3?.precision, config3?.scale) : new PgNumericBuilder(name, config3?.precision, config3?.scale);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/point.js
var PgPointTupleBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  /** @internal */
  build(table) {
    return new PgPointTuple(
      table,
      this.config
    );
  }
};
var PgPointTuple = class extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x2), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
};
var PgPointObjectBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  /** @internal */
  build(table) {
    return new PgPointObject(
      table,
      this.config
    );
  }
};
var PgPointObject = class extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x2), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
};
function point(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (!config3?.mode || config3.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex3) {
  const bytes = [];
  for (let c = 0; c < hex3.length; c += 2) {
    bytes.push(Number.parseInt(hex3.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0; i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex3) {
  const bytes = hexToBytes(hex3);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x2 = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x2, y];
  }
  throw new Error("Unsupported geometry type");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
var PgGeometryBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  /** @internal */
  build(table) {
    return new PgGeometry(
      table,
      this.config
    );
  }
};
var PgGeometry = class extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
};
var PgGeometryObjectBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  /** @internal */
  build(table) {
    return new PgGeometryObject(
      table,
      this.config
    );
  }
};
var PgGeometryObject = class extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
};
function geometry(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (!config3?.mode || config3.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/real.js
var PgRealBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  /** @internal */
  build(table) {
    return new PgReal(table, this.config);
  }
};
var PgReal = class extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config3) {
    super(table, config3);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
};
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/serial.js
var PgSerialBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  /** @internal */
  build(table) {
    return new PgSerial(table, this.config);
  }
};
var PgSerial = class extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
};
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/smallint.js
var PgSmallIntBuilder = class extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  /** @internal */
  build(table) {
    return new PgSmallInt(table, this.config);
  }
};
var PgSmallInt = class extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
};
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/smallserial.js
var PgSmallSerialBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  /** @internal */
  build(table) {
    return new PgSmallSerial(
      table,
      this.config
    );
  }
};
var PgSmallSerial = class extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
};
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/text.js
var PgTextBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config3) {
    super(name, "string", "PgText");
    this.config.enumValues = config3.enum;
  }
  /** @internal */
  build(table) {
    return new PgText(table, this.config);
  }
};
var PgText = class extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
};
function text(a2, b2 = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgTextBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/time.js
var PgTimeBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  /** @internal */
  build(table) {
    return new PgTime(table, this.config);
  }
};
var PgTime = class extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config3) {
    super(table, config3);
    this.withTimezone = config3.withTimezone;
    this.precision = config3.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
function time4(a2, b2 = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgTimeBuilder(name, config3.withTimezone ?? false, config3.precision);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/timestamp.js
var PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestamp(table, this.config);
  }
};
var PgTimestamp = class extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config3) {
    super(table, config3);
    this.withTimezone = config3.withTimezone;
    this.precision = config3.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") return new Date(this.withTimezone ? value : value + "+0000");
    return value;
  }
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
};
var PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestampString(
      table,
      this.config
    );
  }
};
var PgTimestampString = class extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config3) {
    super(table, config3);
    this.withTimezone = config3.withTimezone;
    this.precision = config3.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") return value;
    const shortened = value.toISOString().slice(0, -1).replace("T", " ");
    if (this.withTimezone) {
      const offset = value.getTimezoneOffset();
      const sign = offset <= 0 ? "+" : "-";
      return `${shortened}${sign}${Math.floor(Math.abs(offset) / 60).toString().padStart(2, "0")}`;
    }
    return shortened;
  }
};
function timestamp(a2, b2 = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  if (config3?.mode === "string") {
    return new PgTimestampStringBuilder(name, config3.withTimezone ?? false, config3.precision);
  }
  return new PgTimestampBuilder(name, config3?.withTimezone ?? false, config3?.precision);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/uuid.js
var PgUUIDBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  /**
   * Adds `default gen_random_uuid()` to the column definition.
   */
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  /** @internal */
  build(table) {
    return new PgUUID(table, this.config);
  }
};
var PgUUID = class extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
};
function uuid3(name) {
  return new PgUUIDBuilder(name ?? "");
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/varchar.js
var PgVarcharBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config3) {
    super(name, "string", "PgVarchar");
    this.config.length = config3.length;
    this.config.enumValues = config3.enum;
  }
  /** @internal */
  build(table) {
    return new PgVarchar(
      table,
      this.config
    );
  }
};
var PgVarchar = class extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
  }
};
function varchar(a2, b2 = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgVarcharBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
var PgBinaryVectorBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config3) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config3.dimensions;
  }
  /** @internal */
  build(table) {
    return new PgBinaryVector(
      table,
      this.config
    );
  }
};
var PgBinaryVector = class extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
};
function bit(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgBinaryVectorBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
var PgHalfVectorBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config3) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config3.dimensions;
  }
  /** @internal */
  build(table) {
    return new PgHalfVector(
      table,
      this.config
    );
  }
};
var PgHalfVector = class extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v2) => Number.parseFloat(v2));
  }
};
function halfvec(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgHalfVectorBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
var PgSparseVectorBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config3) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config3.dimensions;
  }
  /** @internal */
  build(table) {
    return new PgSparseVector(
      table,
      this.config
    );
  }
};
var PgSparseVector = class extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
};
function sparsevec(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgSparseVectorBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
var PgVectorBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config3) {
    super(name, "array", "PgVector");
    this.config.dimensions = config3.dimensions;
  }
  /** @internal */
  build(table) {
    return new PgVector(
      table,
      this.config
    );
  }
};
var PgVector = class extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v2) => Number.parseFloat(v2));
  }
};
function vector(a2, b2) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b2);
  return new PgVectorBuilder(name, config3);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint: bigint5,
    bigserial,
    boolean: boolean6,
    char,
    cidr,
    customType,
    date: date8,
    doublePrecision,
    inet,
    integer: integer2,
    interval,
    json: json3,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time: time4,
    timestamp,
    uuid: uuid3,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = /* @__PURE__ */ Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = /* @__PURE__ */ Symbol.for("drizzle:EnableRLS");
var PgTable = class extends Table {
  static [entityKind] = "PgTable";
  /** @internal */
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  /**@internal */
  [InlineForeignKeys] = [];
  /** @internal */
  [EnableRLS] = false;
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
  /** @internal */
  [Table.Symbol.ExtraConfigColumns] = {};
};
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const builtColumnsForExtraConfig = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.buildExtraConfigColumn(rawTable);
      return [name2, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, void 0);
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/indexes.js
var IndexBuilderOn = class {
  constructor(unique, name) {
    this.unique = unique;
    this.name = name;
  }
  static [entityKind] = "PgIndexBuilderOn";
  on(...columns) {
    return new IndexBuilder(
      columns.map((it2) => {
        if (is2(it2, SQL)) {
          return it2;
        }
        it2 = it2;
        const clonedIndexedColumn = new IndexedColumn(it2.name, !!it2.keyAsName, it2.columnType, it2.indexConfig);
        it2.indexConfig = JSON.parse(JSON.stringify(it2.defaultConfig));
        return clonedIndexedColumn;
      }),
      this.unique,
      false,
      this.name
    );
  }
  onOnly(...columns) {
    return new IndexBuilder(
      columns.map((it2) => {
        if (is2(it2, SQL)) {
          return it2;
        }
        it2 = it2;
        const clonedIndexedColumn = new IndexedColumn(it2.name, !!it2.keyAsName, it2.columnType, it2.indexConfig);
        it2.indexConfig = it2.defaultConfig;
        return clonedIndexedColumn;
      }),
      this.unique,
      true,
      this.name
    );
  }
  /**
   * Specify what index method to use. Choices are `btree`, `hash`, `gist`, `spgist`, `gin`, `brin`, or user-installed access methods like `bloom`. The default method is `btree.
   *
   * If you have the `pg_vector` extension installed in your database, you can use the `hnsw` and `ivfflat` options, which are predefined types.
   *
   * **You can always specify any string you want in the method, in case Drizzle doesn't have it natively in its types**
   *
   * @param method The name of the index method to be used
   * @param columns
   * @returns
   */
  using(method, ...columns) {
    return new IndexBuilder(
      columns.map((it2) => {
        if (is2(it2, SQL)) {
          return it2;
        }
        it2 = it2;
        const clonedIndexedColumn = new IndexedColumn(it2.name, !!it2.keyAsName, it2.columnType, it2.indexConfig);
        it2.indexConfig = JSON.parse(JSON.stringify(it2.defaultConfig));
        return clonedIndexedColumn;
      }),
      this.unique,
      true,
      this.name,
      method
    );
  }
};
var IndexBuilder = class {
  static [entityKind] = "PgIndexBuilder";
  /** @internal */
  config;
  constructor(columns, unique, only, name, method = "btree") {
    this.config = {
      name,
      columns,
      unique,
      only,
      method
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  with(obj) {
    this.config.with = obj;
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  /** @internal */
  build(table) {
    return new Index(this.config, table);
  }
};
var Index = class {
  static [entityKind] = "PgIndex";
  config;
  constructor(config3, table) {
    this.config = { ...config3, table };
  }
};
function index(name) {
  return new IndexBuilderOn(false, name);
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/primary-keys.js
var PrimaryKeyBuilder = class {
  static [entityKind] = "PgPrimaryKeyBuilder";
  /** @internal */
  columns;
  /** @internal */
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  /** @internal */
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
};
var PrimaryKey = class {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}
var CasingCache = class {
  static [entityKind] = "CasingCache";
  /** @internal */
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName) return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/errors.js
var DrizzleError = class extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
};
var DrizzleQueryError = class _DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, _DrizzleQueryError);
    if (cause) this.cause = cause;
  }
};
var TransactionRollbackError = class extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is2(value, Param) && !is2(value, Placeholder) && !is2(value, Column) && !is2(value, Table) && !is2(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt4 = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v2) => bindIfParam(v2, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v2) => bindIfParam(v2, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/relations.js
var Relation = class {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
};
var Relations = class {
  constructor(table, config3) {
    this.table = table;
    this.config = config3;
  }
  static [entityKind] = "Relations";
};
var One = class _One extends Relation {
  constructor(sourceTable, referencedTable, config3, isNullable) {
    super(sourceTable, referencedTable, config3?.relationName);
    this.config = config3;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new _One(
      this.sourceTable,
      this.referencedTable,
      this.config,
      this.isNullable
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = class _Many extends Relation {
  constructor(sourceTable, referencedTable, config3) {
    super(sourceTable, referencedTable, config3?.relationName);
    this.config = config3;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new _Many(
      this.sourceTable,
      this.referencedTable,
      this.config
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt: gt4,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is2(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is2(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is2(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is2(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config3) {
    return new One(
      sourceTable,
      table,
      config3,
      config3?.fields.reduce((res, f) => res && f.notNull, true) ?? false
    );
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config3) {
    return new Many(sourceTable, referencedTable, config3);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is2(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is2(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is2(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is2(field, Column)) {
        decoder = field;
      } else if (is2(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/view-base.js
var PgViewBase = class extends View {
  static [entityKind] = "PgViewBase";
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/dialect.js
var PgDialect = class {
  static [entityKind] = "PgDialect";
  /** @internal */
  casing;
  constructor(config3) {
    this.casing = new CasingCache(config3?.casing);
  }
  async migrate(migrations, session, config3) {
    const migrationsTable = typeof config3 === "string" ? "__drizzle_migrations" : config3.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config3 === "string" ? "drizzle" : config3.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(
      sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`
    );
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(
            sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length) return void 0;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set2) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter(
      (colName) => set2[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
    );
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const onUpdateFnResult = col.onUpdateFn?.();
      const value = set2[colName] ?? (is2(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col));
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set: set2, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? void 0 : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set2);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is2(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is2(field, SQL.Aliased) || is2(field, SQL)) {
        const query = is2(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(
            new SQL(
              query.queryChunks.map((c) => {
                if (is2(c, PgColumn)) {
                  return sql.identifier(this.casing.getColumnCasing(c));
                }
                return c;
              })
            )
          );
        } else {
          chunk.push(query);
        }
        if (is2(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is2(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      } else if (is2(field, Subquery)) {
        const entries = Object.entries(field._.selectedFields);
        if (entries.length === 1) {
          const entry = entries[0][1];
          const fieldDecoder = is2(entry, SQL) ? entry.decoder : is2(entry, Column) ? { mapFromDriverValue: (v2) => entry.mapFromDriverValue(v2) } : entry.sql.decoder;
          if (fieldDecoder) {
            field._.sql.decoder = fieldDecoder;
          }
        }
        chunk.push(field);
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return void 0;
    }
    const joinsArray = [];
    for (const [index2, joinMeta] of joins.entries()) {
      if (index2 === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : void 0;
      if (is2(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? void 0 : joinMeta.alias;
        joinsArray.push(
          sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`
        );
      } else if (is2(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? void 0 : joinMeta.alias;
        joinsArray.push(
          sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`
        );
      } else {
        joinsArray.push(
          sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`
        );
      }
      if (index2 < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is2(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is2(f.field, Column) && getTableName(f.field.table) !== (is2(table, Subquery) ? table._.alias : is2(table, PgViewBase) ? table[ViewBaseConfig].name : is2(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(
        ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])
      ))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(
          `Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
        );
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(
          sql` of ${sql.join(
            Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],
            sql`, `
          )}`
        );
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(
      this.buildSetOperationQuery({ leftSelect, setOperator }),
      rest
    );
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is2(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is2(singleOrderBy, SQL)) {
          for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is2(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(
      ([, column]) => sql.identifier(this.casing.getColumnCasing(column))
    );
    if (select) {
      const select2 = valuesOrSelect;
      if (is2(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === void 0 || is2(colValue, Param) && colValue.value === void 0) {
            if (col.defaultFn !== void 0) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is2(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== void 0) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is2(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : void 0;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : void 0;
    const withNoDataSql = withNoData ? sql` with no data` : void 0;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is2(encoder, PgJsonb) || is2(encoder, PgJson)) {
      return "json";
    } else if (is2(encoder, PgNumeric)) {
      return "decimal";
    } else if (is2(encoder, PgTime)) {
      return "time";
    } else if (is2(encoder, PgTimestamp) || is2(encoder, PgTimestampString)) {
      return "timestamp";
    } else if (is2(encoder, PgDate) || is2(encoder, PgDateString)) {
      return "date";
    } else if (is2(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql22, invokeSource) {
    return sql22.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  // buildRelationalQueryWithPK({
  // 	fullSchema,
  // 	schema,
  // 	tableNamesMap,
  // 	table,
  // 	tableConfig,
  // 	queryConfig: config,
  // 	tableAlias,
  // 	isRoot = false,
  // 	joinOn,
  // }: {
  // 	fullSchema: Record<string, unknown>;
  // 	schema: TablesRelationalConfig;
  // 	tableNamesMap: Record<string, string>;
  // 	table: PgTable;
  // 	tableConfig: TableRelationalConfig;
  // 	queryConfig: true | DBQueryConfig<'many', true>;
  // 	tableAlias: string;
  // 	isRoot?: boolean;
  // 	joinOn?: SQL;
  // }): BuildRelationalQueryResult<PgTable, PgColumn> {
  // 	// For { "<relation>": true }, return a table with selection of all columns
  // 	if (config === true) {
  // 		const selectionEntries = Object.entries(tableConfig.columns);
  // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
  // 			[key, value],
  // 		) => ({
  // 			dbKey: value.name,
  // 			tsKey: key,
  // 			field: value as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection,
  // 		};
  // 	}
  // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// let selectionForBuild = selection;
  // 	const aliasedColumns = Object.fromEntries(
  // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
  // 	);
  // 	const aliasedRelations = Object.fromEntries(
  // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
  // 	);
  // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
  // 	let where, hasUserDefinedWhere;
  // 	if (config.where) {
  // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
  // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
  // 		hasUserDefinedWhere = !!where;
  // 	}
  // 	where = and(joinOn, where);
  // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
  // 	let joins: Join[] = [];
  // 	let selectedColumns: string[] = [];
  // 	// Figure out which columns to select
  // 	if (config.columns) {
  // 		let isIncludeMode = false;
  // 		for (const [field, value] of Object.entries(config.columns)) {
  // 			if (value === undefined) {
  // 				continue;
  // 			}
  // 			if (field in tableConfig.columns) {
  // 				if (!isIncludeMode && value === true) {
  // 					isIncludeMode = true;
  // 				}
  // 				selectedColumns.push(field);
  // 			}
  // 		}
  // 		if (selectedColumns.length > 0) {
  // 			selectedColumns = isIncludeMode
  // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
  // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
  // 		}
  // 	} else {
  // 		// Select all columns if selection is not specified
  // 		selectedColumns = Object.keys(tableConfig.columns);
  // 	}
  // 	// for (const field of selectedColumns) {
  // 	// 	const column = tableConfig.columns[field]! as PgColumn;
  // 	// 	fieldsSelection.push({ tsKey: field, value: column });
  // 	// }
  // 	let initiallySelectedRelations: {
  // 		tsKey: string;
  // 		queryConfig: true | DBQueryConfig<'many', false>;
  // 		relation: Relation;
  // 	}[] = [];
  // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// Figure out which relations to select
  // 	if (config.with) {
  // 		initiallySelectedRelations = Object.entries(config.with)
  // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
  // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
  // 	}
  // 	const manyRelations = initiallySelectedRelations.filter((r) =>
  // 		is(r.relation, Many)
  // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
  // 	);
  // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
  // 	const isInnermostQuery = manyRelations.length < 2;
  // 	const selectedExtras: {
  // 		tsKey: string;
  // 		value: SQL.Aliased;
  // 	}[] = [];
  // 	// Figure out which extras to select
  // 	if (isInnermostQuery && config.extras) {
  // 		const extras = typeof config.extras === 'function'
  // 			? config.extras(aliasedFields, { sql })
  // 			: config.extras;
  // 		for (const [tsKey, value] of Object.entries(extras)) {
  // 			selectedExtras.push({
  // 				tsKey,
  // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
  // 			});
  // 		}
  // 	}
  // 	// Transform `fieldsSelection` into `selection`
  // 	// `fieldsSelection` shouldn't be used after this point
  // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
  // 	// 	selection.push({
  // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
  // 	// 		tsKey,
  // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
  // 	// 		relationTableTsKey: undefined,
  // 	// 		isJson: false,
  // 	// 		isExtra,
  // 	// 		selection: [],
  // 	// 	});
  // 	// }
  // 	let orderByOrig = typeof config.orderBy === 'function'
  // 		? config.orderBy(aliasedFields, orderByOperators)
  // 		: config.orderBy ?? [];
  // 	if (!Array.isArray(orderByOrig)) {
  // 		orderByOrig = [orderByOrig];
  // 	}
  // 	const orderBy = orderByOrig.map((orderByValue) => {
  // 		if (is(orderByValue, Column)) {
  // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
  // 		}
  // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
  // 	});
  // 	const limit = isInnermostQuery ? config.limit : undefined;
  // 	const offset = isInnermostQuery ? config.offset : undefined;
  // 	// For non-root queries without additional config except columns, return a table with selection
  // 	if (
  // 		!isRoot
  // 		&& initiallySelectedRelations.length === 0
  // 		&& selectedExtras.length === 0
  // 		&& !where
  // 		&& orderBy.length === 0
  // 		&& limit === undefined
  // 		&& offset === undefined
  // 	) {
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection: selectedColumns.map((key) => ({
  // 				dbKey: tableConfig.columns[key]!.name,
  // 				tsKey: key,
  // 				field: tableConfig.columns[key] as PgColumn,
  // 				relationTableTsKey: undefined,
  // 				isJson: false,
  // 				selection: [],
  // 			})),
  // 		};
  // 	}
  // 	const selectedRelationsWithoutPK:
  // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of initiallySelectedRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length > 0) {
  // 			continue;
  // 		}
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithoutPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 			nestedQueryRelation: relation,
  // 		});
  // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
  // 		joins.push({
  // 			on: sql`true`,
  // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: true,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
  // 		is(r.relation, One)
  // 	);
  // 	// Process all One relations with PKs, because they can all be joined on the same level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of oneRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length === 0) {
  // 			continue;
  // 		}
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
  // 			sql.join(
  // 				builtRelation.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelation.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: is(builtRelation.sql, SQL)
  // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
  // 				: aliasedTable(builtRelation.sql, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: is(builtRelation.sql, SQL),
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	let distinct: PgSelectConfig['distinct'];
  // 	let tableFrom: PgTable | Subquery = table;
  // 	// Process first Many relation - each one requires a nested subquery
  // 	const manyRelation = manyRelations[0];
  // 	if (manyRelation) {
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			relation,
  // 		} = manyRelation;
  // 		distinct = {
  // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
  // 		};
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const builtRelationSelectionField = sql`case when ${
  // 			sql.identifier(relationTableAlias)
  // 		} is null then '[]' else json_agg(json_build_array(${
  // 			sql.join(
  // 				builtRelationJoin.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: isLateralJoin
  // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
  // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: isLateralJoin,
  // 		});
  // 		// Build the "from" subquery with the remaining Many relations
  // 		const builtTableFrom = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table,
  // 			tableConfig,
  // 			queryConfig: {
  // 				...config,
  // 				where: undefined,
  // 				orderBy: undefined,
  // 				limit: undefined,
  // 				offset: undefined,
  // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
  // 					(result, { tsKey, queryConfig: configValue }) => {
  // 						result[tsKey] = configValue;
  // 						return result;
  // 					},
  // 					{},
  // 				),
  // 			},
  // 			tableAlias,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field: builtRelationSelectionField,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelationJoin.selection,
  // 		});
  // 		// selection = builtTableFrom.selection.map((item) =>
  // 		// 	is(item.field, SQL.Aliased)
  // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 		// 		: item
  // 		// );
  // 		// selectionForBuild = [{
  // 		// 	dbKey: '*',
  // 		// 	tsKey: '*',
  // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
  // 		// 	selection: [],
  // 		// 	isJson: false,
  // 		// 	relationTableTsKey: undefined,
  // 		// }];
  // 		// const newSelectionItem: (typeof selection)[number] = {
  // 		// 	dbKey: selectedRelationTsKey,
  // 		// 	tsKey: selectedRelationTsKey,
  // 		// 	field,
  // 		// 	relationTableTsKey: relationTableTsName,
  // 		// 	isJson: true,
  // 		// 	selection: builtRelationJoin.selection,
  // 		// };
  // 		// selection.push(newSelectionItem);
  // 		// selectionForBuild.push(newSelectionItem);
  // 		tableFrom = is(builtTableFrom.sql, PgTable)
  // 			? builtTableFrom.sql
  // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
  // 	}
  // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
  // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
  // 	}
  // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
  // 	function prepareSelectedColumns() {
  // 		return selectedColumns.map((key) => ({
  // 			dbKey: tableConfig.columns[key]!.name,
  // 			tsKey: key,
  // 			field: tableConfig.columns[key] as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	function prepareSelectedExtras() {
  // 		return selectedExtras.map((item) => ({
  // 			dbKey: item.value.fieldAlias,
  // 			tsKey: item.tsKey,
  // 			field: item.value,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	if (isRoot) {
  // 		selection = [
  // 			...prepareSelectedColumns(),
  // 			...prepareSelectedExtras(),
  // 		];
  // 	}
  // 	if (hasUserDefinedWhere || orderBy.length > 0) {
  // 		tableFrom = new Subquery(
  // 			this.buildSelectQuery({
  // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 				fields: {},
  // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 					path: [],
  // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 				})),
  // 				joins,
  // 				distinct,
  // 			}),
  // 			{},
  // 			tableAlias,
  // 		);
  // 		selectionForBuild = selection.map((item) =>
  // 			is(item.field, SQL.Aliased)
  // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 				: item
  // 		);
  // 		joins = [];
  // 		distinct = undefined;
  // 	}
  // 	const result = this.buildSelectQuery({
  // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 		fields: {},
  // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 			path: [],
  // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 		})),
  // 		where,
  // 		limit,
  // 		offset,
  // 		joins,
  // 		orderBy,
  // 		distinct,
  // 	});
  // 	return {
  // 		tableTsKey: tableConfig.tsName,
  // 		sql: result,
  // 		selection,
  // 	};
  // }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config3,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config3 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(
        Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
      );
      if (config3.where) {
        const whereSql = typeof config3.where === "function" ? config3.where(aliasedColumns, getOperators()) : config3.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config3.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config3.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config3.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config3.with) {
        selectedRelations = Object.entries(config3.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig2]) => ({ tsKey, queryConfig: queryConfig2, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config3.extras) {
        extras = typeof config3.extras === "function" ? config3.extras(aliasedColumns, { sql }) : config3.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is2(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is2(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config3.orderBy === "function" ? config3.orderBy(aliasedColumns, getOrderByOperators()) : config3.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is2(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config3.limit;
      offset = config3.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(
          ...normalizedRelation.fields.map(
            (field2, i) => eq(
              aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
              aliasedTableColumn(field2, tableAlias)
            )
          )
        );
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is2(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(
        selection.map(
          ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is2(field2, SQL.Aliased) ? field2.sql : field2
        ),
        sql`, `
      )})`;
      if (is2(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is2(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is2(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is2(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/query-builders/query-builder.js
var TypedQueryBuilder = class {
  static [entityKind] = "TypedQueryBuilder";
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/select.js
var PgSelectBuilder = class {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config3) {
    this.fields = config3.fields;
    this.session = config3.session;
    this.dialect = config3.dialect;
    if (config3.withList) {
      this.withList = config3.withList;
    }
    this.distinct = config3.distinct;
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  /**
   * Specify the table, subquery, or other target that you're
   * building a select query against.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}
   */
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is2(src, Subquery)) {
      fields = Object.fromEntries(
        Object.keys(src._.selectedFields).map((key) => [key, src[key]])
      );
    } else if (is2(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is2(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
};
var PgSelectQueryBuilderBase = class extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = void 0;
  usedTables = /* @__PURE__ */ new Set();
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table)) this.usedTables.add(item);
  }
  /** @internal */
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table)) this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is2(table, SQL)) {
          const selection = is2(table, Subquery) ? table._.selectedFields : is2(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(
          new Proxy(
            this.config.fields,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * Executes a `left join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet | null; }[] = await db.select()
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number | null; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  leftJoin = this.createJoin("left", false);
  /**
   * Executes a `left join lateral` operation by adding subquery to the current query.
   *
   * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.
   *
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join-lateral}
   *
   * @param table the subquery to join.
   * @param on the `on` clause.
   */
  leftJoinLateral = this.createJoin("left", true);
  /**
   * Executes a `right join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet; }[] = await db.select()
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  rightJoin = this.createJoin("right", false);
  /**
   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
   *
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  innerJoin = this.createJoin("inner", false);
  /**
   * Executes an `inner join lateral` operation, creating a new table by combining rows from two queries that have matching values.
   *
   * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.
   *
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join-lateral}
   *
   * @param table the subquery to join.
   * @param on the `on` clause.
   */
  innerJoinLateral = this.createJoin("inner", true);
  /**
   * Executes a `full join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet | null; }[] = await db.select()
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number | null; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  fullJoin = this.createJoin("full", false);
  /**
   * Executes a `cross join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging all rows from each table.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join}
   *
   * @param table the table to join.
   *
   * @example
   *
   * ```ts
   * // Select all users, each user with every pet
   * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()
   *   .from(users)
   *   .crossJoin(pets)
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .crossJoin(pets)
   * ```
   */
  crossJoin = this.createJoin("cross", false);
  /**
   * Executes a `cross join lateral` operation by combining rows from two queries into a new table.
   *
   * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.
   *
   * Calling this method retrieves all rows from both main and joined queries, merging all rows from each query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join-lateral}
   *
   * @param table the query to join.
   */
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  /**
   * Adds `union` set operator to the query.
   *
   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
   *
   * @example
   *
   * ```ts
   * // Select all unique names from customers and users tables
   * await db.select({ name: users.name })
   *   .from(users)
   *   .union(
   *     db.select({ name: customers.name }).from(customers)
   *   );
   * // or
   * import { union } from 'drizzle-orm/pg-core'
   *
   * await union(
   *   db.select({ name: users.name }).from(users),
   *   db.select({ name: customers.name }).from(customers)
   * );
   * ```
   */
  union = this.createSetOperator("union", false);
  /**
   * Adds `union all` set operator to the query.
   *
   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
   *
   * @example
   *
   * ```ts
   * // Select all transaction ids from both online and in-store sales
   * await db.select({ transaction: onlineSales.transactionId })
   *   .from(onlineSales)
   *   .unionAll(
   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   *   );
   * // or
   * import { unionAll } from 'drizzle-orm/pg-core'
   *
   * await unionAll(
   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   * );
   * ```
   */
  unionAll = this.createSetOperator("union", true);
  /**
   * Adds `intersect` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
   *
   * @example
   *
   * ```ts
   * // Select course names that are offered in both departments A and B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .intersect(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { intersect } from 'drizzle-orm/pg-core'
   *
   * await intersect(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  intersect = this.createSetOperator("intersect", false);
  /**
   * Adds `intersect all` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets including all duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
   *
   * @example
   *
   * ```ts
   * // Select all products and quantities that are ordered by both regular and VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered
   * })
   * .from(regularCustomerOrders)
   * .intersectAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { intersectAll } from 'drizzle-orm/pg-core'
   *
   * await intersectAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  intersectAll = this.createSetOperator("intersect", true);
  /**
   * Adds `except` set operator to the query.
   *
   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
   *
   * @example
   *
   * ```ts
   * // Select all courses offered in department A but not in department B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .except(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { except } from 'drizzle-orm/pg-core'
   *
   * await except(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  except = this.createSetOperator("except", false);
  /**
   * Adds `except all` set operator to the query.
   *
   * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
   *
   * @example
   *
   * ```ts
   * // Select all products that are ordered by regular customers but not by VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered,
   * })
   * .from(regularCustomerOrders)
   * .exceptAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered,
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { exceptAll } from 'drizzle-orm/pg-core'
   *
   * await exceptAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  exceptAll = this.createSetOperator("except", true);
  /** @internal */
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be selected.
   *
   * ```ts
   * // Select all cars with green color
   * await db.select().from(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Select all BMW cars with a green color
   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Select all cars with the green or blue color
   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    if (typeof where === "function") {
      where = where(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.where = where;
    return this;
  }
  /**
   * Adds a `having` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
   *
   * @param having the `having` clause.
   *
   * @example
   *
   * ```ts
   * // Select all brands with more than one car
   * await db.select({
   * 	brand: cars.brand,
   * 	count: sql<number>`cast(count(${cars.id}) as int)`,
   * })
   *   .from(cars)
   *   .groupBy(cars.brand)
   *   .having(({ count }) => gt(count, 1));
   * ```
   */
  having(having) {
    if (typeof having === "function") {
      having = having(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  /**
   * Adds a `limit` clause to the query.
   *
   * Calling this method will set the maximum number of rows that will be returned by this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param limit the `limit` clause.
   *
   * @example
   *
   * ```ts
   * // Get the first 10 people from this query.
   * await db.select().from(people).limit(10);
   * ```
   */
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  /**
   * Adds an `offset` clause to the query.
   *
   * Calling this method will skip a number of rows when returning results from this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param offset the `offset` clause.
   *
   * @example
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * await db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  /**
   * Adds a `for` clause to the query.
   *
   * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
   *
   * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}
   *
   * @param strength the lock strength.
   * @param config the lock configuration.
   */
  for(strength, config3 = {}) {
    this.config.lockingClause = { strength, config: config3 };
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it2 of this.config.joins) usedTables.push(...extractUsedTable(it2.table));
    }
    return new Proxy(
      new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]),
      new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  /** @internal */
  getSelectedFields() {
    return new Proxy(
      this.config.fields,
      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  $dynamic() {
    return this;
  }
  $withCache(config3) {
    this.cacheConfig = config3 === void 0 ? { config: {}, enable: true, autoInvalidate: true } : config3 === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config3 };
    return this;
  }
};
var PgSelectBase = class extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  /** @internal */
  _prepare(name) {
    const { session, config: config3, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const { fields } = config3;
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, void 0, {
        type: "select",
        tables: [...usedTables]
      }, cacheConfig);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  /**
   * Create a prepared statement for this query. This allows
   * the database to remember this query for the given session
   * and call it by name, rather than specifying the full query.
   *
   * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}
   */
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
};
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union: union3,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union3 = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var QueryBuilder = class {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is2(dialect, PgDialect) ? dialect : void 0;
    this.dialectConfig = is2(dialect, PgDialect) ? void 0 : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as2 = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(
        new WithSubquery(
          qb.getSQL(),
          selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
          alias,
          true
        ),
        new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
      );
    };
    return { as: as2 };
  };
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/utils.js
function extractUsedTable(table) {
  if (is2(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is2(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is2(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/delete.js
var PgDeleteBase = class extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  cacheConfig;
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will delete only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be deleted.
   *
   * ```ts
   * // Delete all cars with green color
   * await db.delete(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.delete(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Delete all BMW cars with a green color
   * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Delete all cars with the green or blue color
   * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, void 0, {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  /** @internal */
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(
      this.config.returningFields,
      new SelectionProxyHandler({
        alias: getTableName(this.config.table),
        sqlAliasedBehavior: "alias",
        sqlBehavior: "error"
      })
    ) : void 0;
  }
  $dynamic() {
    return this;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/insert.js
var PgInsertBuilder = class {
  constructor(table, session, dialect, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is2(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(
      this.table,
      mappedValues,
      this.session,
      this.dialect,
      this.withList,
      false,
      this.overridingSystemValue_
    ).setToken(this.authToken);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder()) : selectQuery;
    if (!is2(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error(
        "Insert select error: selected fields are not the same or are in a different order compared to the table definition"
      );
    }
    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
};
var PgInsertBase = class extends QueryPromise {
  constructor(table, values, session, dialect, withList, select, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList, select, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  cacheConfig;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /**
   * Adds an `on conflict do nothing` clause to the query.
   *
   * Calling this method simply avoids inserting a row as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
   *
   * @param config The `target` and `where` clauses.
   *
   * @example
   * ```ts
   * // Insert one row and cancel the insert if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing();
   *
   * // Explicitly specify conflict target
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing({ target: cars.id });
   * ```
   */
  onConflictDoNothing(config3 = {}) {
    if (config3.target === void 0) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config3.target) ? config3.target.map((it2) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it2))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config3.target));
      const whereSql = config3.where ? sql` where ${config3.where}` : void 0;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  /**
   * Adds an `on conflict do update` clause to the query.
   *
   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
   *
   * @param config The `target`, `set` and `where` clauses.
   *
   * @example
   * ```ts
   * // Update the row if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'Porsche' }
   *   });
   *
   * // Upsert with 'where' clause
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'newBMW' },
   *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,
   *   });
   * ```
   */
  onConflictDoUpdate(config3) {
    if (config3.where && (config3.targetWhere || config3.setWhere)) {
      throw new Error(
        'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
      );
    }
    const whereSql = config3.where ? sql` where ${config3.where}` : void 0;
    const targetWhereSql = config3.targetWhere ? sql` where ${config3.targetWhere}` : void 0;
    const setWhereSql = config3.setWhere ? sql` where ${config3.setWhere}` : void 0;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config3.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config3.target) ? config3.target.map((it2) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it2))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config3.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, void 0, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  /** @internal */
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(
      this.config.returningFields,
      new SelectionProxyHandler({
        alias: getTableName(this.config.table),
        sqlAliasedBehavior: "alias",
        sqlBehavior: "error"
      })
    ) : void 0;
  }
  $dynamic() {
    return this;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
var PgRefreshMaterializedView = class extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/update.js
var PgUpdateBuilder = class {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values) {
    return new PgUpdateBase(
      this.table,
      mapUpdateSet(this.table, values),
      this.session,
      this.dialect,
      this.withList
    ).setToken(this.authToken);
  }
};
var PgUpdateBase = class extends QueryPromise {
  constructor(table, set2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set2, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  cacheConfig;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is2(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is2(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is2(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : void 0;
        on = on(
          new Proxy(
            this.config.table[Table.Symbol.Columns],
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          ),
          from && new Proxy(
            from,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  /**
   * Adds a 'where' clause to the query.
   *
   * Calling this method will update only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param where the 'where' clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   *
   * ```ts
   * // Update all cars with green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * await db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Update all BMW cars with a green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Update all cars with the green or blue color
   * await db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is2(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is2(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, void 0, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  /** @internal */
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(
      this.config.returningFields,
      new SelectionProxyHandler({
        alias: getTableName(this.config.table),
        sqlAliasedBehavior: "alias",
        sqlBehavior: "error"
      })
    ) : void 0;
  }
  $dynamic() {
    return this;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/count.js
var PgCountBuilder = class _PgCountBuilder extends SQL {
  constructor(params) {
    super(_PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = _PgCountBuilder.buildCount(
      params.source,
      params.filters
    );
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  /** @intrnal */
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(
      onfulfilled,
      onrejected
    );
  }
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value) => {
        onFinally?.();
        return value;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/query.js
var RelationalQueryBuilder = class {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config3) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config3 ? config3 : {},
      "many"
    );
  }
  findFirst(config3) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config3 ? { ...config3, limit: 1 } : { limit: 1 },
      "first"
    );
  }
};
var PgRelationalQuery = class extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config3, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config3;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(
        builtQuery,
        void 0,
        name,
        true,
        (rawRows, mapColumnValue) => {
          const rows = rawRows.map(
            (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
          );
          if (this.mode === "first") {
            return rows[0];
          }
          return rows;
        }
      );
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  /** @internal */
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(void 0, this.authToken);
    });
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/query-builders/raw.js
var PgRaw = class extends QueryPromise {
  constructor(execute, sql3, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql3;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  /** @internal */
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  /** @internal */
  isResponseInArrayMode() {
    return false;
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/db.js
var PgDatabase = class {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session
    } : {
      schema: void 0,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
    this.$cache = { invalidate: async (_params) => {
    } };
  }
  static [entityKind] = "PgDatabase";
  query;
  /**
   * Creates a subquery that defines a temporary named result set as a CTE.
   *
   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param alias The alias for the subquery.
   *
   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
   *
   * @example
   *
   * ```ts
   * // Create a subquery with alias 'sq' and use it in the select query
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * const result = await db.with(sq).select().from(sq);
   * ```
   *
   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
   *
   * ```ts
   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
   * const sq = db.$with('sq').as(db.select({
   *   name: sql<string>`upper(${users.name})`.as('name'),
   * })
   * .from(users));
   *
   * const result = await db.with(sq).select({ name: sq.name }).from(sq);
   * ```
   */
  $with = (alias, selection) => {
    const self2 = this;
    const as2 = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self2.dialect));
      }
      return new Proxy(
        new WithSubquery(
          qb.getSQL(),
          selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
          alias,
          true
        ),
        new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
      );
    };
    return { as: as2 };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  $cache;
  /**
   * Incorporates a previously defined CTE (using `$with`) into the main query.
   *
   * This method allows the main query to reference a temporary named result set.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param queries The CTEs to incorporate into the main query.
   *
   * @example
   *
   * ```ts
   * // Define a subquery 'sq' as a CTE using $with
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * // Incorporate the CTE 'sq' into the main query and select from it
   * const result = await db.with(sq).select().from(sq);
   * ```
   */
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self2.session, self2.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self2.session, self2.dialect, queries);
    }
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  /**
   * Creates an update query.
   *
   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
   *
   * Use `.set()` method to specify which values to update.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param table The table to update.
   *
   * @example
   *
   * ```ts
   * // Update all rows in the 'cars' table
   * await db.update(cars).set({ color: 'red' });
   *
   * // Update rows with filters and conditions
   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
   *
   * // Update with returning clause
   * const updatedCar: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  /**
   * Creates an insert query.
   *
   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert}
   *
   * @param table The table to insert into.
   *
   * @example
   *
   * ```ts
   * // Insert one row
   * await db.insert(cars).values({ brand: 'BMW' });
   *
   * // Insert multiple rows
   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
   *
   * // Insert with returning clause
   * const insertedCar: Car[] = await db.insert(cars)
   *   .values({ brand: 'BMW' })
   *   .returning();
   * ```
   */
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  /**
   * Creates a delete query.
   *
   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param table The table to delete from.
   *
   * @example
   *
   * ```ts
   * // Delete all rows in the 'cars' table
   * await db.delete(cars);
   *
   * // Delete rows with filters and conditions
   * await db.delete(cars).where(eq(cars.color, 'green'));
   *
   * // Delete with returning clause
   * const deletedCar: Car[] = await db.delete(cars)
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(
      builtQuery,
      void 0,
      void 0,
      false
    );
    return new PgRaw(
      () => prepared.execute(void 0, this.authToken),
      sequel,
      builtQuery,
      (result) => prepared.mapResult(result, true)
    );
  }
  transaction(transaction, config3) {
    return this.session.transaction(transaction, config3);
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/cache/core/cache.js
var Cache = class {
  static [entityKind] = "Cache";
};
var NoopCache = class extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return void 0;
  }
  async put(_hashedQuery, _response, _tables, _config) {
  }
  async onMutate(_params) {
  }
};
async function hashQuery(sql3, params) {
  const dataToHash = `${sql3}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder();
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b2) => b2.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/pg-core/session.js
var PgPreparedQuery = class {
  constructor(query, cache, queryMetadata, cacheConfig) {
    this.query = query;
    this.cache = cache;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache && cache.strategy() === "all" && cacheConfig === void 0) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = void 0;
    }
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  /** @internal */
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  /** @internal */
  joinsNotNullableMap;
  /** @internal */
  async queryWithCache(queryString, params, query) {
    if (this.cache === void 0 || is2(this.cache, NoopCache) || this.queryMetadata === void 0) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(
        this.cacheConfig.tag ?? await hashQuery(queryString, params),
        this.queryMetadata.tables,
        this.cacheConfig.tag !== void 0,
        this.cacheConfig.autoInvalidate
      );
      if (fromCache === void 0) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(
          this.cacheConfig.tag ?? await hashQuery(queryString, params),
          result,
          // make sure we send tables that were used in a query only if user wants to invalidate it on each write
          this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [],
          this.cacheConfig.tag !== void 0,
          this.cacheConfig.config
        );
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
};
var PgSession = class {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  /** @internal */
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0,
          void 0,
          false
        );
      });
      return prepared.setToken(token).execute(void 0, token);
    });
  }
  all(query) {
    return this.prepareQuery(
      this.dialect.sqlToQuery(query),
      void 0,
      void 0,
      false
    ).all();
  }
  /** @internal */
  async count(sql22, token) {
    const res = await this.execute(sql22, token);
    return Number(
      res[0]["count"]
    );
  }
};
var PgTransaction = class extends PgDatabase {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError();
  }
  /** @internal */
  getTransactionConfigSQL(config3) {
    const chunks = [];
    if (config3.isolationLevel) {
      chunks.push(`isolation level ${config3.isolationLevel}`);
    }
    if (config3.accessMode) {
      chunks.push(config3.accessMode);
    }
    if (typeof config3.deferrable === "boolean") {
      chunks.push(config3.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config3) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config3)}`);
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/neon-http/session.js
var rawQueryConfig = {
  arrayMode: false,
  fullResults: true
};
var queryConfig = {
  arrayMode: true,
  fullResults: true
};
var NeonHttpPreparedQuery = class extends PgPreparedQuery {
  constructor(client, query, logger, cache, queryMetadata, cacheConfig, fields, _isResponseInArrayMode, customResultMapper) {
    super(query, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.clientQuery = client.query ?? client;
  }
  static [entityKind] = "NeonHttpPreparedQuery";
  clientQuery;
  /** @internal */
  async execute(placeholderValues = {}, token = this.authToken) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    const { fields, clientQuery, query, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      return this.queryWithCache(query.sql, params, async () => {
        return clientQuery(
          query.sql,
          params,
          token === void 0 ? rawQueryConfig : {
            ...rawQueryConfig,
            authToken: token
          }
        );
      });
    }
    const result = await this.queryWithCache(query.sql, params, async () => {
      return await clientQuery(
        query.sql,
        params,
        token === void 0 ? queryConfig : {
          ...queryConfig,
          authToken: token
        }
      );
    });
    return this.mapResult(result);
  }
  mapResult(result) {
    if (!this.fields && !this.customResultMapper) {
      return result;
    }
    const rows = result.rows;
    if (this.customResultMapper) {
      return this.customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    return this.clientQuery(
      this.query.sql,
      params,
      this.authToken === void 0 ? rawQueryConfig : {
        ...rawQueryConfig,
        authToken: this.authToken
      }
    ).then((result) => result.rows);
  }
  /** @internal */
  values(placeholderValues = {}, token) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    return this.clientQuery(this.query.sql, params, { arrayMode: true, fullResults: true, authToken: token }).then((result) => result.rows);
  }
  /** @internal */
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
};
var NeonHttpSession = class extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.clientQuery = client.query ?? client;
    this.logger = options.logger ?? new NoopLogger();
    this.cache = options.cache ?? new NoopCache();
  }
  static [entityKind] = "NeonHttpSession";
  clientQuery;
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new NeonHttpPreparedQuery(
      this.client,
      query,
      this.logger,
      this.cache,
      queryMetadata,
      cacheConfig,
      fields,
      isResponseInArrayMode,
      customResultMapper
    );
  }
  async batch(queries) {
    const preparedQueries = [];
    const builtQueries = [];
    for (const query of queries) {
      const preparedQuery = query._prepare();
      const builtQuery = preparedQuery.getQuery();
      preparedQueries.push(preparedQuery);
      builtQueries.push(
        this.clientQuery(builtQuery.sql, builtQuery.params, {
          fullResults: true,
          arrayMode: preparedQuery.isResponseInArrayMode()
        })
      );
    }
    const batchResults = await this.client.transaction(builtQueries, queryConfig);
    return batchResults.map((result, i) => preparedQueries[i].mapResult(result, true));
  }
  // change return type to QueryRows<true>
  async query(query, params) {
    this.logger.logQuery(query, params);
    const result = await this.clientQuery(query, params, { arrayMode: true, fullResults: true });
    return result;
  }
  // change return type to QueryRows<false>
  async queryObjects(query, params) {
    return this.clientQuery(query, params, { arrayMode: false, fullResults: true });
  }
  /** @internal */
  async count(sql3, token) {
    const res = await this.execute(sql3, token);
    return Number(
      res["rows"][0]["count"]
    );
  }
  async transaction(_transaction, _config = {}) {
    throw new Error("No transactions support in neon-http driver");
  }
};
var NeonTransaction = class extends PgTransaction {
  static [entityKind] = "NeonHttpTransaction";
  async transaction(_transaction) {
    throw new Error("No transactions support in neon-http driver");
  }
};

// node_modules/.pnpm/drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverless@1.0.2_@types+pg@8.16.0/node_modules/drizzle-orm/neon-http/driver.js
var NeonHttpDriver = class {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
    this.initMappers();
  }
  static [entityKind] = "NeonHttpDriver";
  createSession(schema) {
    return new NeonHttpSession(this.client, this.dialect, schema, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
  initMappers() {
    export_types.setTypeParser(export_types.builtins.TIMESTAMPTZ, (val) => val);
    export_types.setTypeParser(export_types.builtins.TIMESTAMP, (val) => val);
    export_types.setTypeParser(export_types.builtins.DATE, (val) => val);
    export_types.setTypeParser(export_types.builtins.INTERVAL, (val) => val);
    export_types.setTypeParser(1231, (val) => val);
    export_types.setTypeParser(1115, (val) => val);
    export_types.setTypeParser(1185, (val) => val);
    export_types.setTypeParser(1187, (val) => val);
    export_types.setTypeParser(1182, (val) => val);
  }
};
function wrap(target, token, cb, deep) {
  return new Proxy(target, {
    get(target2, p2) {
      const element = target2[p2];
      if (typeof element !== "function" && (typeof element !== "object" || element === null)) return element;
      if (deep) return wrap(element, token, cb);
      if (p2 === "query") return wrap(element, token, cb, true);
      return new Proxy(element, {
        apply(target3, thisArg, argArray) {
          const res = target3.call(thisArg, ...argArray);
          if (typeof res === "object" && res !== null && "setToken" in res && typeof res.setToken === "function") {
            res.setToken(token);
          }
          return cb(target3, p2, res);
        }
      });
    }
  });
}
var NeonHttpDatabase = class extends PgDatabase {
  static [entityKind] = "NeonHttpDatabase";
  $withAuth(token) {
    this.authToken = token;
    return wrap(this, token, (target, p2, res) => {
      if (p2 === "with") {
        return wrap(res, token, (_, __, res2) => res2);
      }
      return res;
    });
  }
  async batch(batch) {
    return this.session.batch(batch);
  }
};
function construct(client, config3 = {}) {
  const dialect = new PgDialect({ casing: config3.casing });
  let logger;
  if (config3.logger === true) {
    logger = new DefaultLogger();
  } else if (config3.logger !== false) {
    logger = config3.logger;
  }
  let schema;
  if (config3.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config3.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config3.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NeonHttpDriver(client, dialect, { logger, cache: config3.cache });
  const session = driver.createSession(schema);
  const db2 = new NeonHttpDatabase(
    dialect,
    session,
    schema
  );
  db2.$client = client;
  db2.$cache = config3.cache;
  if (db2.$cache) {
    db2.$cache["invalidate"] = config3.cache?.onMutate;
  }
  return db2;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = cs(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client) return construct(client, drizzleConfig);
    if (typeof connection === "object") {
      const { connectionString, ...options } = connection;
      const instance2 = cs(connectionString, options);
      return construct(instance2, drizzleConfig);
    }
    const instance = cs(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config3) {
    return construct({}, config3);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/db/schema.ts
var schema_exports = {};
__export(schema_exports, {
  categoryEnum: () => categoryEnum,
  categoryEnumValues: () => categoryEnumValues,
  currencyEnum: () => currencyEnum,
  orderInsertSchema: () => orderInsertSchema,
  orderProduct: () => orderProduct,
  orderProductInsertSchema: () => orderProductInsertSchema,
  orderProductSelectSchema: () => orderProductSelectSchema,
  orderSelectSchema: () => orderSelectSchema,
  orderStatusEnum: () => orderStatusEnum,
  orders: () => orders,
  paymentInsertSchema: () => paymentInsertSchema,
  paymentMethodEnum: () => paymentMethodEnum,
  paymentSelectSchema: () => paymentSelectSchema,
  paymentStatusEnum: () => paymentStatusEnum,
  payments: () => payments,
  product: () => product,
  subscriptionStatusEnum: () => subscriptionStatusEnum,
  subscriptions: () => subscriptions,
  users: () => users
});

// node_modules/.pnpm/drizzle-zod@0.8.3_drizzle-orm@0.45.1_@electric-sql+pglite@0.3.15_@neondatabase+serverle_2031f85ad7b2b0871eb3f58264a7695f/node_modules/drizzle-zod/index.mjs
var CONSTANTS = {
  INT8_MIN: -128,
  INT8_MAX: 127,
  INT8_UNSIGNED_MAX: 255,
  INT16_MIN: -32768,
  INT16_MAX: 32767,
  INT16_UNSIGNED_MAX: 65535,
  INT24_MIN: -8388608,
  INT24_MAX: 8388607,
  INT24_UNSIGNED_MAX: 16777215,
  INT32_MIN: -2147483648,
  INT32_MAX: 2147483647,
  INT32_UNSIGNED_MAX: 4294967295,
  INT48_MIN: -140737488355328,
  INT48_MAX: 140737488355327,
  INT48_UNSIGNED_MAX: 281474976710655,
  INT64_MIN: -9223372036854775808n,
  INT64_MAX: 9223372036854775807n,
  INT64_UNSIGNED_MAX: 18446744073709551615n
};
function isColumnType(column, columnTypes) {
  return columnTypes.includes(column.columnType);
}
function isWithEnum(column) {
  return "enumValues" in column && Array.isArray(column.enumValues) && column.enumValues.length > 0;
}
var isPgEnum2 = isWithEnum;
var literalSchema = external_exports2.union([external_exports2.string(), external_exports2.number(), external_exports2.boolean(), external_exports2.null()]);
var jsonSchema = external_exports2.union([
  literalSchema,
  external_exports2.record(external_exports2.string(), external_exports2.any()),
  external_exports2.array(external_exports2.any())
]);
var bufferSchema = external_exports2.custom((v2) => v2 instanceof Buffer);
function columnToSchema(column, factory) {
  const z$1 = factory?.zodInstance ?? external_exports2;
  const coerce = factory?.coerce ?? {};
  let schema;
  if (isWithEnum(column)) {
    schema = column.enumValues.length ? z$1.enum(column.enumValues) : z$1.string();
  }
  if (!schema) {
    if (isColumnType(column, ["PgGeometry", "PgPointTuple"])) {
      schema = z$1.tuple([z$1.number(), z$1.number()]);
    } else if (isColumnType(column, ["PgGeometryObject", "PgPointObject"])) {
      schema = z$1.object({ x: z$1.number(), y: z$1.number() });
    } else if (isColumnType(column, ["PgHalfVector", "PgVector"])) {
      schema = z$1.array(z$1.number());
      schema = column.dimensions ? schema.length(column.dimensions) : schema;
    } else if (isColumnType(column, ["PgLine"])) {
      schema = z$1.tuple([z$1.number(), z$1.number(), z$1.number()]);
    } else if (isColumnType(column, ["PgLineABC"])) {
      schema = z$1.object({
        a: z$1.number(),
        b: z$1.number(),
        c: z$1.number()
      });
    } else if (isColumnType(column, ["PgArray"])) {
      schema = z$1.array(columnToSchema(column.baseColumn, factory));
      schema = column.size ? schema.length(column.size) : schema;
    } else if (column.dataType === "array") {
      schema = z$1.array(z$1.any());
    } else if (column.dataType === "number") {
      schema = numberColumnToSchema(column, z$1, coerce);
    } else if (column.dataType === "bigint") {
      schema = bigintColumnToSchema(column, z$1, coerce);
    } else if (column.dataType === "boolean") {
      schema = coerce === true || coerce.boolean ? z$1.coerce.boolean() : z$1.boolean();
    } else if (column.dataType === "date") {
      schema = coerce === true || coerce.date ? z$1.coerce.date() : z$1.date();
    } else if (column.dataType === "string") {
      schema = stringColumnToSchema(column, z$1, coerce);
    } else if (column.dataType === "json") {
      schema = jsonSchema;
    } else if (column.dataType === "custom") {
      schema = z$1.any();
    } else if (column.dataType === "buffer") {
      schema = bufferSchema;
    }
  }
  if (!schema) {
    schema = z$1.any();
  }
  return schema;
}
function numberColumnToSchema(column, z2, coerce) {
  let unsigned = column.getSQLType().includes("unsigned");
  let min;
  let max;
  let integer3 = false;
  if (isColumnType(column, ["MySqlTinyInt", "SingleStoreTinyInt"])) {
    min = unsigned ? 0 : CONSTANTS.INT8_MIN;
    max = unsigned ? CONSTANTS.INT8_UNSIGNED_MAX : CONSTANTS.INT8_MAX;
    integer3 = true;
  } else if (isColumnType(column, [
    "PgSmallInt",
    "PgSmallSerial",
    "MySqlSmallInt",
    "SingleStoreSmallInt"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT16_MIN;
    max = unsigned ? CONSTANTS.INT16_UNSIGNED_MAX : CONSTANTS.INT16_MAX;
    integer3 = true;
  } else if (isColumnType(column, [
    "PgReal",
    "MySqlFloat",
    "MySqlMediumInt",
    "SingleStoreMediumInt",
    "SingleStoreFloat"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT24_MIN;
    max = unsigned ? CONSTANTS.INT24_UNSIGNED_MAX : CONSTANTS.INT24_MAX;
    integer3 = isColumnType(column, ["MySqlMediumInt", "SingleStoreMediumInt"]);
  } else if (isColumnType(column, [
    "PgInteger",
    "PgSerial",
    "MySqlInt",
    "SingleStoreInt"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT32_MIN;
    max = unsigned ? CONSTANTS.INT32_UNSIGNED_MAX : CONSTANTS.INT32_MAX;
    integer3 = true;
  } else if (isColumnType(column, [
    "PgDoublePrecision",
    "MySqlReal",
    "MySqlDouble",
    "SingleStoreReal",
    "SingleStoreDouble",
    "SQLiteReal"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT48_MIN;
    max = unsigned ? CONSTANTS.INT48_UNSIGNED_MAX : CONSTANTS.INT48_MAX;
  } else if (isColumnType(column, [
    "PgBigInt53",
    "PgBigSerial53",
    "MySqlBigInt53",
    "MySqlSerial",
    "SingleStoreBigInt53",
    "SingleStoreSerial",
    "SQLiteInteger"
  ])) {
    unsigned = unsigned || isColumnType(column, ["MySqlSerial", "SingleStoreSerial"]);
    min = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    max = Number.MAX_SAFE_INTEGER;
    integer3 = true;
  } else if (isColumnType(column, ["MySqlYear", "SingleStoreYear"])) {
    min = 1901;
    max = 2155;
    integer3 = true;
  } else {
    min = Number.MIN_SAFE_INTEGER;
    max = Number.MAX_SAFE_INTEGER;
  }
  let schema = coerce === true || coerce?.number ? integer3 ? z2.coerce.number() : z2.coerce.number().int() : integer3 ? z2.int() : z2.number();
  schema = schema.gte(min).lte(max);
  return schema;
}
function bigintColumnToSchema(column, z2, coerce) {
  const unsigned = column.getSQLType().includes("unsigned");
  const min = unsigned ? 0n : CONSTANTS.INT64_MIN;
  const max = unsigned ? CONSTANTS.INT64_UNSIGNED_MAX : CONSTANTS.INT64_MAX;
  const schema = coerce === true || coerce?.bigint ? z2.coerce.bigint() : z2.bigint();
  return schema.gte(min).lte(max);
}
function stringColumnToSchema(column, z2, coerce) {
  if (isColumnType(column, ["PgUUID"])) {
    return z2.uuid();
  }
  let max;
  let regex;
  let fixed = false;
  if (isColumnType(column, ["PgVarchar", "SQLiteText"])) {
    max = column.length;
  } else if (isColumnType(column, ["MySqlVarChar", "SingleStoreVarChar"])) {
    max = column.length ?? CONSTANTS.INT16_UNSIGNED_MAX;
  } else if (isColumnType(column, ["MySqlText", "SingleStoreText"])) {
    if (column.textType === "longtext") {
      max = CONSTANTS.INT32_UNSIGNED_MAX;
    } else if (column.textType === "mediumtext") {
      max = CONSTANTS.INT24_UNSIGNED_MAX;
    } else if (column.textType === "text") {
      max = CONSTANTS.INT16_UNSIGNED_MAX;
    } else {
      max = CONSTANTS.INT8_UNSIGNED_MAX;
    }
  }
  if (isColumnType(column, [
    "PgChar",
    "MySqlChar",
    "SingleStoreChar"
  ])) {
    max = column.length;
    fixed = true;
  }
  if (isColumnType(column, ["PgBinaryVector"])) {
    regex = /^[01]+$/;
    max = column.dimensions;
  }
  let schema = coerce === true || coerce?.string ? z2.coerce.string() : z2.string();
  schema = regex ? schema.regex(regex) : schema;
  return max && fixed ? schema.length(max) : max ? schema.max(max) : schema;
}
function getColumns(tableLike) {
  return isTable(tableLike) ? getTableColumns(tableLike) : getViewSelectedFields(tableLike);
}
function handleColumns(columns, refinements, conditions, factory) {
  const columnSchemas = {};
  for (const [key, selected] of Object.entries(columns)) {
    if (!is2(selected, Column) && !is2(selected, SQL) && !is2(selected, SQL.Aliased) && typeof selected === "object") {
      const columns2 = isTable(selected) || isView(selected) ? getColumns(selected) : selected;
      columnSchemas[key] = handleColumns(columns2, refinements[key] ?? {}, conditions, factory);
      continue;
    }
    const refinement = refinements[key];
    if (refinement !== void 0 && typeof refinement !== "function") {
      columnSchemas[key] = refinement;
      continue;
    }
    const column = is2(selected, Column) ? selected : void 0;
    const schema = column ? columnToSchema(column, factory) : external_exports2.any();
    const refined = typeof refinement === "function" ? refinement(schema) : schema;
    if (conditions.never(column)) {
      continue;
    } else {
      columnSchemas[key] = refined;
    }
    if (column) {
      if (conditions.nullable(column)) {
        columnSchemas[key] = columnSchemas[key].nullable();
      }
      if (conditions.optional(column)) {
        columnSchemas[key] = columnSchemas[key].optional();
      }
    }
  }
  return external_exports2.object(columnSchemas);
}
function handleEnum(enum_, factory) {
  const zod = factory?.zodInstance ?? external_exports2;
  return zod.enum(enum_.enumValues);
}
var selectConditions = {
  never: () => false,
  optional: () => false,
  nullable: (column) => !column.notNull
};
var insertConditions = {
  never: (column) => column?.generated?.type === "always" || column?.generatedIdentity?.type === "always",
  optional: (column) => !column.notNull || column.notNull && column.hasDefault,
  nullable: (column) => !column.notNull
};
var createSelectSchema = (entity, refine2) => {
  if (isPgEnum2(entity)) {
    return handleEnum(entity);
  }
  const columns = getColumns(entity);
  return handleColumns(columns, refine2 ?? {}, selectConditions);
};
var createInsertSchema = (entity, refine2) => {
  const columns = getColumns(entity);
  return handleColumns(columns, refine2 ?? {}, insertConditions);
};

// src/db/schema.ts
var categoryEnum = pgEnum("category", [
  "Electronics",
  "Clothing",
  "Books",
  "Furniture"
]);
var categoryEnumValues = categoryEnum.enumValues;
var subscriptionStatusEnum = pgEnum("subscription_status", [
  "active",
  "canceled",
  "expired",
  "past_due"
]);
var orderStatusEnum = pgEnum("order_status", [
  "processing",
  "delivered",
  "cancelled"
]);
var paymentStatusEnum = pgEnum("payment_status", [
  "pending",
  "succeeded",
  "failed"
]);
var paymentMethodEnum = pgEnum("payment_method", [
  "polar",
  "razorpay"
]);
var currencyEnum = pgEnum("currency", ["usd", "inr"]);
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  password: varchar("password", { length: 255 }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var payments = pgTable(
  "payments",
  {
    id: varchar("id").primaryKey(),
    // from polar
    orderId: integer2("order_id").references(() => orders.id, { onDelete: "cascade" }).notNull(),
    amount: integer2("amount").notNull(),
    currency: currencyEnum("currency").notNull(),
    status: paymentStatusEnum("status").notNull().default("pending"),
    paymentMethod: paymentMethodEnum("payment_method").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull()
  },
  (table) => [
    index("payments_order_id_idx").on(table.orderId),
    index("payments_status_idx").on(table.status)
  ]
);
var product = pgTable(
  "product",
  {
    id: serial("id"),
    productId: serial("product_id").primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    description: text("description").notNull(),
    price: integer2("price").notNull(),
    // store price in cents and convert to rupees and dollar in the application layer
    category: categoryEnum("category").notNull()
  },
  (table) => [
    index("index").on(table.name),
    index("product_id_index_column").on(table.productId)
  ]
);
var orders = pgTable(
  "orders",
  {
    id: serial("id").primaryKey(),
    userId: integer2("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
    totalAmount: integer2("total_amount").notNull().default(0),
    status: orderStatusEnum("status").notNull().default("processing"),
    shippingAddress: text("shipping_address"),
    paymentMethod: varchar("payment_method", { length: 50 }),
    notes: text("notes"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull()
  },
  (table) => [
    index("orders_user_id_idx").on(table.userId),
    index("orders_status_idx").on(table.status),
    index("orders_created_at_idx").on(table.createdAt)
  ]
);
var orderProduct = pgTable(
  "order_product",
  {
    id: serial("id").primaryKey(),
    orderId: integer2("order_id").references(() => orders.id, { onDelete: "cascade" }).notNull(),
    productId: integer2("product_id").references(() => product.productId, { onDelete: "restrict" }).notNull(),
    quantity: integer2("quantity").notNull().default(1),
    priceAtOrder: integer2("price_at_order").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull()
  },
  (table) => [
    index("order_product_order_id_idx").on(table.orderId),
    index("order_product_product_id_idx").on(table.productId)
  ]
);
var subscriptions = pgTable(
  "subscriptions",
  {
    id: serial("id").primaryKey(),
    // Your internal user reference
    userId: integer2("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
    // Polar IDs
    polarCustomerId: varchar("polar_customer_id", { length: 255 }).notNull(),
    polarSubscriptionId: varchar("polar_subscription_id", { length: 255 }).notNull().unique(),
    polarProductId: varchar("polar_product_id", { length: 255 }).notNull(),
    // Customer info from Polar
    customerEmail: varchar("customer_email", { length: 255 }).notNull(),
    customerName: varchar("customer_name", { length: 255 }),
    // Subscription details
    status: subscriptionStatusEnum("status").notNull().default("active"),
    currentPeriodStart: timestamp("current_period_start"),
    currentPeriodEnd: timestamp("current_period_end"),
    canceledAt: timestamp("canceled_at"),
    // Timestamps
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull()
  },
  (table) => [
    index("subscriptions_user_id_idx").on(table.userId),
    index("subscriptions_polar_customer_id_idx").on(table.polarCustomerId),
    index("subscriptions_polar_subscription_id_idx").on(
      table.polarSubscriptionId
    ),
    index("subscriptions_status_idx").on(table.status)
  ]
);
var orderInsertSchema = createInsertSchema(orders);
var orderSelectSchema = createSelectSchema(orders);
var orderProductInsertSchema = createInsertSchema(orderProduct);
var orderProductSelectSchema = createSelectSchema(orderProduct);
var paymentInsertSchema = createInsertSchema(payments);
var paymentSelectSchema = createSelectSchema(payments);

// src/db/index.ts
init_config();
if (!config2.DATABASE_URL) {
  console.error("DATABASE_URL is not configured!");
}
var sql2 = cs(config2.DATABASE_URL);
var db = drizzle(sql2, { schema: schema_exports });

// src/modules/payment/razorpay.service.ts
import { STATUS_CODES } from "http";
var RazorpayService = class {
  client = null;
  getClient() {
    if (!config2.RAZORPAY_KEY_ID || !config2.RAZORPAY_KEY_SECRET) {
      throw new Error(
        "Razorpay credentials not configured. Please set RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET."
      );
    }
    if (!this.client) {
      this.client = new import_razorpay.default({
        key_id: config2.RAZORPAY_KEY_ID,
        key_secret: config2.RAZORPAY_KEY_SECRET
      });
    }
    return this.client;
  }
  async createOrder(orderId, opts) {
    let internalOrderId = orderId;
    let orderRecord;
    if (internalOrderId) {
      const [found] = await db.select().from(orders).where(eq(orders.id, internalOrderId));
      if (found) {
        orderRecord = found;
      }
    }
    if (!orderRecord) {
      const [createdOrder] = await db.insert(orders).values({
        userId: opts?.externalCustomerId ? Number(opts.externalCustomerId) || 1 : 1,
        totalAmount: 300,
        status: "processing",
        shippingAddress: "",
        paymentMethod: "credit_card",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      orderRecord = createdOrder;
      internalOrderId = createdOrder.id;
    }
    if (!orderRecord || !internalOrderId) {
      throw new Error("Order creation failed", { cause: STATUS_CODES[500] });
    }
    const currency = config2.RAZORPAY_CURRENCY || "INR";
    const amount = currency === "INR" ? orderRecord.totalAmount * 100 : orderRecord.totalAmount;
    const options = {
      amount,
      currency,
      receipt: `order_${internalOrderId}`,
      payment_capture: 1,
      notes: {
        internalOrderId: String(internalOrderId),
        ...opts?.externalCustomerId ? { externalCustomerId: opts.externalCustomerId } : {},
        ...opts?.customerEmail ? { customerEmail: opts.customerEmail } : {},
        ...opts?.customerName ? { customerName: opts.customerName } : {},
        ...opts?.successUrl ? { successUrl: opts.successUrl } : {}
      }
    };
    if (opts?.metadata) {
      Object.entries(opts.metadata).forEach(([k, v2]) => {
        options.notes[`meta_${k}`] = String(v2);
      });
    }
    const created = await this.getClient().orders.create(options);
    if (!created || !created.id) {
      throw new Error("Failed to create Razorpay order");
    }
    const dbCurrency = ["usd"].includes((currency || "").toLowerCase()) ? (currency || "").toLowerCase() : "usd";
    try {
      await db.insert(payments).values({
        id: created.id,
        orderId: internalOrderId,
        amount: orderRecord.totalAmount,
        currency: dbCurrency,
        status: "pending",
        paymentMethod: "razorpay",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
    } catch (err) {
      console.error("Failed to persist Razorpay payment to DB:", err);
    }
    return { order: created, internalOrderId };
  }
  verifyPaymentSignature(razorpay_order_id, razorpay_payment_id, razorpay_signature) {
    const payload = `${razorpay_order_id}|${razorpay_payment_id}`;
    const expected = crypto2.createHmac("sha256", config2.RAZORPAY_KEY_SECRET).update(payload).digest("hex");
    return expected === razorpay_signature;
  }
  verifyWebhookSignature(rawBody, signature) {
    if (!config2.RAZORPAY_WEBHOOK_SECRET) return false;
    const expected = crypto2.createHmac("sha256", config2.RAZORPAY_WEBHOOK_SECRET).update(rawBody).digest("hex");
    return expected === signature;
  }
  async markPaymentSucceeded(razorpayOrderId) {
    try {
      const result = await db.update(payments).set({ status: "succeeded", updatedAt: /* @__PURE__ */ new Date() }).where(eq(payments.id, razorpayOrderId));
      return result;
    } catch (err) {
      console.error("Failed to mark payment succeeded:", err);
      throw err;
    }
  }
};
var razorpayService = new RazorpayService();

// src/routes/api/payment/handler.ts
init_config();

// src/lib/hash.ts
var hashPassword = (password) => Buffer.from(password).toString("base64");
var verifyPassword = (password, hash2) => hashPassword(password) === hash2;

// src/lib/response.ts
function sendSuccess(data, message, reply, statusCode = 200 | 201) {
  const response = {
    ok: true,
    statusCode,
    message,
    data
  };
  reply.status(statusCode).send(response);
}
function sendError(error48, message, reply, statusCode = 400 | 404 | 409 | 500) {
  const response = {
    ok: false,
    statusCode,
    message,
    error: error48
  };
  reply.status(statusCode).send(response);
}

// src/routes/api/payment/handler.ts
var createPaymentIntentRequestSchema = external_exports2.object({
  orderId: external_exports2.number(),
  provider: external_exports2.enum(["polar", "razorpay"]).optional(),
  customerEmail: external_exports2.string().regex(/^[^\s@]+@[^\s@]+\.[^\s@]+$/).optional(),
  customerName: external_exports2.string().optional(),
  successUrl: external_exports2.string().url().optional(),
  externalCustomerId: external_exports2.string().optional()
});
async function createPaymentIntentHandler(request, reply) {
  const { orderId, provider } = request.body;
  try {
    if (provider === "razorpay") {
      const { customerEmail, customerName, successUrl, externalCustomerId } = request.body;
      const { order, internalOrderId } = await razorpayService.createOrder(
        orderId,
        {
          customerEmail,
          customerName,
          successUrl,
          externalCustomerId
        }
      );
      return sendSuccess(
        {
          order,
          keyId: config2.RAZORPAY_KEY_ID,
          internalOrderId,
          successUrl: successUrl || config2.SUCCESS_URL
        },
        "Razorpay order created",
        reply,
        201
      );
    }
    const { checkoutUrl, checkoutId } = await paymentService.createPaymentCheckout(orderId);
    return sendSuccess(
      { checkoutUrl, checkoutId },
      "Payment checkout created",
      reply,
      201
    );
  } catch (error48) {
    if (error48 instanceof Error) {
      return sendError("CREATE_PAYMENT_FAILED", error48.message, reply, 400);
    }
    return sendError(
      "INTERNAL_SERVER_ERROR",
      "Internal Server Error",
      reply,
      500
    );
  }
}
async function stripeWebhookHandler(request, reply) {
  return sendError(
    "STRIPE_DEPRECATED",
    "Stripe is deprecated. Use Polar.",
    reply,
    410
  );
}

// src/schema/razorpay.schema.ts
var paymentStatusValues = paymentStatusEnum.enumValues;
var insertPaymentSchema = createInsertSchema(payments).extend({
  status: external_exports2.enum(paymentStatusValues).default(paymentStatusValues[0]),
  createdAt: external_exports2.date().default(/* @__PURE__ */ new Date()),
  updatedAt: external_exports2.date().optional()
});
var paymentSchema = createSelectSchema(payments).omit({
  updatedAt: true
});
var createRazorpayCheckoutIntentSchema = {
  body: external_exports2.object({
    orderId: external_exports2.number(),
    provider: external_exports2.enum(["polar", "razorpay"]).optional()
  }),
  response: {
    200: external_exports2.object({
      checkoutUrl: external_exports2.string().optional(),
      checkoutId: external_exports2.string().optional(),
      keyId: external_exports2.string().optional(),
      order: external_exports2.any().optional()
    })
  }
};
var razorpayPaymentSchema = paymentSchema.extend({
  currency: external_exports2.literal("inr").default("inr"),
  paymentMethod: external_exports2.literal("razorpay").default("razorpay"),
  status: external_exports2.enum(paymentStatusValues).default(paymentStatusValues[0])
});
var createRazorpayPaymentSchema = razorpayPaymentSchema.omit({ id: true, createdAt: true }).extend({
  currency: external_exports2.literal("inr").default("inr"),
  paymentMethod: external_exports2.literal("razorpay").default("razorpay"),
  status: external_exports2.enum(paymentStatusValues).default("failed")
}).refine(
  (d2) => d2.paymentMethod === "razorpay" && d2.currency === "inr" && d2.status === paymentStatusValues[0],
  {
    message: "Payment method must be razorpay and currency must be inr"
  }
);

// src/routes/api/payment/index.ts
var createPaymentIntentSchema = external_exports2.object({
  checkoutUrl: external_exports2.string().optional(),
  checkoutId: external_exports2.string().optional(),
  keyId: external_exports2.string().optional(),
  order: external_exports2.any().optional()
});
async function paymentRoutes(fastify) {
  const fastifyWithZod = fastify.withTypeProvider();
  fastifyWithZod.post("/intent", {
    schema: {
      body: createRazorpayCheckoutIntentSchema.body,
      response: {
        200: createPaymentIntentSchema
      },
      description: "Create a payment session for an order. If provider is razorpay, creates a Razorpay order and returns order details + keyId for client-side checkout. If provider is polar or omitted, creates a Polar checkout session and returns the checkout URL.",
      tags: ["Payment", "Checkout"]
    },
    handler: createPaymentIntentHandler
  });
  fastify.post(
    "/webhook",
    { config: { rawBody: true } },
    stripeWebhookHandler
  );
}

// src/routes/api/payment/polar/index.ts
var CreateCheckoutSchema = external_exports2.object({
  customerEmail: external_exports2.string().email().optional(),
  customerName: external_exports2.string().optional(),
  externalCustomerId: external_exports2.string().optional(),
  successUrl: external_exports2.string().url().optional(),
  returnUrl: external_exports2.string().url().optional()
});
var ExternalIdParamSchema = external_exports2.object({
  externalId: external_exports2.string()
});
async function polarRoutes(fastify) {
  const app2 = fastify.withTypeProvider();
  app2.post(
    "/checkout",
    {
      schema: {
        body: CreateCheckoutSchema,
        description: "Create a new checkout session",
        tags: ["Polar", "Checkout"]
      }
    },
    async (req, reply) => {
      try {
        const checkout = await polarService.createCheckout(req.body);
        return sendSuccess(
          { checkout },
          "Checkout created successfully",
          reply,
          201
        );
      } catch (error48) {
        req.log.error(error48);
        return sendError(
          "Failed to create checkout",
          "CHECKOUT_CREATION_FAILED",
          reply,
          500
        );
      }
    }
  );
  app2.get(
    "/access/:externalId",
    {
      schema: {
        params: ExternalIdParamSchema
      }
    },
    async (req, reply) => {
      try {
        const access = await polarService.checkUserAccess(
          req.params.externalId
        );
        return sendSuccess(
          {
            hasAccess: access.hasAccess,
            subscription: access.subscription
          },
          access.hasAccess ? "Access granted" : "No active subscription",
          reply,
          200
        );
      } catch (error48) {
        req.log.error(error48);
        return sendError(
          "Failed to check access",
          "ACCESS_CHECK_FAILED",
          reply,
          500
        );
      }
    }
  );
  app2.get(
    "/plan/:externalId",
    {
      schema: {
        params: ExternalIdParamSchema
      }
    },
    async (req, reply) => {
      try {
        const tier = await polarService.getUserPlanTier(req.params.externalId);
        return sendSuccess({ tier }, `User is on ${tier} plan`, reply, 200);
      } catch (error48) {
        req.log.error(error48);
        return sendError(
          "Failed to get plan tier",
          "PLAN_TIER_FAILED",
          reply,
          500
        );
      }
    }
  );
  app2.get("/products", async (req, reply) => {
    try {
      const products = await polarService.listProducts();
      return sendSuccess({ products }, "Products retrieved", reply, 200);
    } catch (error48) {
      req.log.error(error48);
      return sendError(
        "Failed to fetch products",
        "PRODUCTS_FETCH_FAILED",
        reply,
        500
      );
    }
  });
  app2.get("/status", async (req, reply) => {
    const { config: config3 } = await Promise.resolve().then(() => (init_config(), config_exports));
    const isSandbox = config3.POLAR_SERVER === "sandbox";
    const hasToken = !!config3.POLAR_ACCESS_TOKEN;
    const hasOrgId = !!config3.POLAR_ORGANIZATION_ID;
    const hasProductId = !!config3.POLAR_PRODUCT_ID;
    let apiStatus = "unknown";
    let apiError = null;
    if (hasToken) {
      try {
        await polarService.listProducts();
        apiStatus = "connected";
      } catch (error48) {
        apiStatus = "error";
        apiError = error48 instanceof Error ? error48.message : "Unknown error";
      }
    } else {
      apiStatus = "not_configured";
    }
    return sendSuccess(
      {
        environment: isSandbox ? "sandbox" : "production",
        apiBaseUrl: isSandbox ? "https://sandbox-api.polar.sh" : "https://api.polar.sh",
        dashboardUrl: isSandbox ? "https://sandbox.polar.sh" : "https://polar.sh",
        configuration: {
          hasAccessToken: hasToken,
          hasOrganizationId: hasOrgId,
          hasProductId,
          organizationId: hasOrgId ? config3.POLAR_ORGANIZATION_ID : null,
          productId: hasProductId ? config3.POLAR_PRODUCT_ID : null
        },
        api: {
          status: apiStatus,
          error: apiError
        },
        testCard: isSandbox ? {
          number: "4242 4242 4242 4242",
          expiry: "Any future date",
          cvc: "Any 3 digits",
          description: "Use this card for test payments in sandbox"
        } : null
      },
      "Polar integration status",
      reply,
      200
    );
  });
}

// src/types/api.ts
var successResponseSchema = (dataSchema) => zod_default.object({
  ok: zod_default.literal(true),
  statusCode: zod_default.number(),
  message: zod_default.string(),
  data: dataSchema
});
var errorResponseSchema = zod_default.object({
  ok: zod_default.literal(false),
  statusCode: zod_default.number(),
  message: zod_default.string(),
  error: zod_default.string()
});

// src/schema/product.schema.ts
var productSchema = createSelectSchema(product);
var currencyEnum2 = external_exports2.enum(["inr", "usd"]);
var productResponseSchema = createSelectSchema(product).extend({
  price: external_exports2.number()
  // Allow both int and float for display prices
});
var productsDataSchema = external_exports2.object({
  products: external_exports2.array(
    productResponseSchema.extend({
      currency: currencyEnum2
    })
  )
});
var getProductsSchema = {
  querystring: external_exports2.object({
    category: external_exports2.enum(categoryEnumValues).optional()
  }),
  response: {
    200: successResponseSchema(productsDataSchema)
  }
};
var getProductByIdSchema = {
  params: external_exports2.object({
    productId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(
      external_exports2.object({ product: productResponseSchema.extend({ currency: currencyEnum2 }) })
    )
  }
};
var createProductBodySchema = external_exports2.object({
  name: external_exports2.string().min(1),
  description: external_exports2.string().min(1),
  price: external_exports2.number().int().positive(),
  category: external_exports2.enum(categoryEnumValues)
});
var createProductSchema = {
  body: createProductBodySchema,
  response: {
    201: successResponseSchema(external_exports2.object({ product: productSchema }))
  }
};
var updateProductBodySchema = external_exports2.object({
  name: external_exports2.string().optional(),
  description: external_exports2.string().optional(),
  price: external_exports2.number().int().positive().optional(),
  category: external_exports2.enum(categoryEnumValues).optional()
}).refine((data) => Object.keys(data).length > 0, {
  message: "At least one field must be provided to update the product"
});
var updateProductSchema = {
  params: external_exports2.object({
    productId: external_exports2.coerce.number().int().positive()
  }),
  body: updateProductBodySchema,
  response: {
    200: successResponseSchema(external_exports2.object({ product: productSchema }))
  }
};
var deleteProductSchema = {
  params: external_exports2.object({
    productId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(
      external_exports2.object({ deleted: external_exports2.boolean(), productId: external_exports2.number() })
    )
  }
};

// src/modules/product.service.ts
init_config();
import { STATUS_CODES as STATUS_CODES2 } from "http";
var ProductService = class {
  /**
   * Check if Polar API is configured
   */
  isPolarConfigured() {
    return !!(config2.POLAR_ACCESS_TOKEN && config2.POLAR_ORGANIZATION_ID);
  }
  convertToPaises(priceInRupees) {
    return Math.round(priceInRupees * 100);
  }
  formatProduct(product2) {
    return {
      ...product2,
      price: product2.price / 100,
      // Convert paises to rupees
      currency: "inr"
      // Store prices in Indian Rupees
    };
  }
  formatProducts(products) {
    return products.map((product2) => this.formatProduct(product2));
  }
  /**
   * Get all products
   * Falls back to sample data if Polar API is not configured or fails
   * @returns Array of products
   */
  async getAllProducts() {
    try {
      const products = await db.select().from(product);
      const formattedProducts = this.formatProducts(products);
      return formattedProducts;
    } catch (error48) {
      console.error("Error fetching products from database:", error48);
      throw new Error(
        error48 instanceof Error ? error48.message : "Failed to fetch products"
      );
    }
  }
  /**
   * Get products by category
   * @param query Category enum value
   * @returns Array of products
   */
  async getProductByQuery(query) {
    try {
      const products = await db.select().from(product).where(eq(product.category, query)).execute();
      const formattedProducts = this.formatProducts(products);
      return formattedProducts;
    } catch (error48) {
      throw new Error(
        error48 instanceof Error ? error48.message : "Failed to fetch products by category"
      );
    }
  }
  /**
   * Get product by ID
   * @param id Product ID
   * @returns Product object
   */
  async getProductById(id) {
    try {
      const [products] = await db.select().from(product).where(eq(product.id, id));
      if (!products) {
        throw new Error(`Product with ID ${id} not found`, {
          cause: {
            STATUS_CODES: STATUS_CODES2["404"]
          }
        });
      }
      const formattedProduct = this.formatProduct(products);
      return formattedProduct;
    } catch (error48) {
      throw new Error(
        error48 instanceof Error ? error48.message : "Failed to fetch product by ID",
        {
          cause: {
            STATUS_CODES: STATUS_CODES2["500"]
          }
        }
      );
    }
  }
  /**
   * Create a new product
   * @param data Create product data
   * @returns Created product
   */
  async createProduct(data) {
    try {
      const [created] = await db.insert(product).values({
        name: data.name,
        description: data.description,
        price: this.convertToPaises(data.price),
        category: data.category
      }).returning();
      return created;
    } catch (error48) {
      throw error48;
    }
  }
  /**
   * Update an existing product
   * @param id Product ID
   * @param data Update product data
   * @returns Updated product or null if not found
   */
  async updateProduct(id, data) {
    try {
      const existingProduct = await this.getProductById(id);
      if (!existingProduct) {
        throw new Error(`Product with ID ${id} not found`, {
          cause: {
            STATUS_CODES: STATUS_CODES2["404"]
          }
        });
      }
      const updatedProduct = db.update(product).set(data).where(eq(product.id, id)).returning();
      return updatedProduct;
    } catch (error48) {
      throw new Error(
        error48 instanceof Error ? error48.message : "Failed to update product"
      );
    }
  }
  /**
   * Delete a product
   * @param id Product ID
   * @returns Deletion status
   */
  async deleteProduct(id) {
    try {
      await db.delete(product).where(eq(product.id, id));
      return { deleted: true, productId: id };
    } catch (error48) {
      throw new Error(
        error48 instanceof Error ? error48.message : "Failed to delete product"
      );
    }
  }
};
var productService = new ProductService();

// src/routes/api/products/handler.ts
var getProductsHandler = {
  handler: async (request, reply) => {
    try {
      const { category } = request.query;
      const products = category ? await productService.getProductByQuery(category) : await productService.getAllProducts();
      if (!products || products.length === 0) {
        return sendError(
          category ? `No products found for category: ${category}` : "No products found",
          "NOT_FOUND",
          reply,
          404
        );
      }
      sendSuccess(
        { products },
        category ? `Products in '${category}' fetched successfully` : "All products fetched successfully",
        reply,
        200
      );
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to fetch products",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var getProductByIdHandler = {
  handler: async (request, reply) => {
    try {
      const { productId } = request.params;
      const product2 = await productService.getProductById(productId);
      if (!product2) {
        return sendError(
          `Product with ID ${productId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      sendSuccess({ product: product2 }, "Product fetched successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to fetch product",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var createProductHandler = {
  handler: async (request, reply) => {
    try {
      const result = await productService.createProduct(request.body);
      sendSuccess(
        { product: result },
        "Product created successfully",
        reply,
        201
      );
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to create product",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var updateProductHandler = {
  handler: async (request, reply) => {
    try {
      const { productId } = request.params;
      const result = await productService.updateProduct(
        productId,
        request.body
      );
      if (!result) {
        return sendError(
          `Product with ID ${productId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      sendSuccess(
        { product: result },
        "Product updated successfully",
        reply,
        200
      );
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to update product",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var deleteProductHandler = {
  handler: async (request, reply) => {
    try {
      const { productId } = request.params;
      const result = await productService.deleteProduct(productId);
      if (!result.deleted) {
        return sendError(
          `Product with ID ${productId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      sendSuccess(result, "Product deleted successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to delete product",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};

// src/routes/api/products/index.ts
async function productsRoute(fastify) {
  fastify.withTypeProvider().get("/", {
    handler: getProductsHandler.handler
  });
  fastify.withTypeProvider().post("/", {
    schema: createProductSchema,
    handler: createProductHandler.handler
  });
  fastify.withTypeProvider().get("/:productId", {
    schema: getProductByIdSchema,
    handler: getProductByIdHandler.handler
  });
  fastify.withTypeProvider().put("/:productId", {
    schema: updateProductSchema,
    handler: updateProductHandler.handler
  });
  fastify.withTypeProvider().delete("/:productId", {
    schema: deleteProductSchema,
    handler: deleteProductHandler.handler
  });
}

// src/schema/order.schema.ts
var orderSchema = createSelectSchema(orders);
var orderProductSchema = createSelectSchema(orderProduct);
var orderStatusValues = orderStatusEnum.enumValues;
var orderProductInputSchema = external_exports2.object({
  productId: external_exports2.number().int().positive(),
  quantity: external_exports2.number().int().positive().default(1)
});
var createOrderBodySchema = external_exports2.object({
  userId: external_exports2.number().int().positive(),
  shippingAddress: external_exports2.string().optional(),
  paymentMethod: external_exports2.string().max(50).optional(),
  notes: external_exports2.string().optional(),
  products: external_exports2.array(orderProductInputSchema).min(1, "At least one product is required")
});
var orderWithProductsSchema = external_exports2.object({
  order: orderSchema,
  products: external_exports2.array(orderProductSchema)
});
var createOrderSchema = {
  body: createOrderBodySchema,
  response: {
    201: successResponseSchema(orderWithProductsSchema)
  }
};
var getOrderByIdSchema = {
  params: external_exports2.object({
    orderId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(orderWithProductsSchema)
  }
};
var updateOrderBodySchema = external_exports2.object({
  status: external_exports2.enum(orderStatusValues).optional(),
  shippingAddress: external_exports2.string().optional(),
  paymentMethod: external_exports2.string().max(50).optional(),
  notes: external_exports2.string().optional()
});
var updateOrderSchema = {
  params: external_exports2.object({
    orderId: external_exports2.coerce.number().int().positive()
  }),
  body: updateOrderBodySchema,
  response: {
    200: successResponseSchema(orderWithProductsSchema)
  }
};
var addProductToOrderBodySchema = external_exports2.object({
  productId: external_exports2.number().int().positive(),
  quantity: external_exports2.number().int().positive().default(1)
});
var addProductToOrderSchema = {
  params: external_exports2.object({
    orderId: external_exports2.coerce.number().int().positive()
  }),
  body: addProductToOrderBodySchema,
  response: {
    200: successResponseSchema(orderWithProductsSchema)
  }
};
var removeProductFromOrderSchema = {
  params: external_exports2.object({
    orderId: external_exports2.coerce.number().int().positive(),
    productId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(orderWithProductsSchema)
  }
};
var allOrdersDataSchema = external_exports2.object({
  orders: external_exports2.array(orderWithProductsSchema),
  total: external_exports2.number()
});
var getAllOrdersSchema = {
  querystring: external_exports2.object({
    userId: external_exports2.coerce.number().int().positive().optional(),
    status: external_exports2.enum(orderStatusValues).optional(),
    limit: external_exports2.coerce.number().int().positive().default(10).optional(),
    offset: external_exports2.coerce.number().int().nonnegative().default(0).optional()
  }),
  response: {
    200: successResponseSchema(allOrdersDataSchema)
  }
};
var deleteOrderResponseSchema = external_exports2.object({
  deleted: external_exports2.boolean(),
  orderId: external_exports2.number()
});
var deleteOrderSchema = {
  params: external_exports2.object({
    orderId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(deleteOrderResponseSchema)
  }
};

// src/modules/order.service.ts
var OrderService = class {
  /**
   * Create a new order with products
   * @param data Order creation data including products array
   * @returns Created order with associated products
   */
  async createOrder(data) {
    let totalAmount = 0;
    let productDetails = [];
    for (const item of data.products) {
      const foundProduct = await productService.getProductById(item.productId);
      totalAmount += foundProduct.price * item.quantity;
      productDetails.push(foundProduct);
    }
    const [createdOrder] = await db.insert(orders).values({
      userId: data.userId,
      totalAmount,
      // store total amount in Paises
      status: "processing",
      shippingAddress: data.shippingAddress,
      paymentMethod: data.paymentMethod,
      notes: data.notes
    }).returning();
    for (const item of data.products) {
      await db.insert(orderProduct).values({
        orderId: createdOrder.id,
        productId: item.productId,
        quantity: item.quantity,
        priceAtOrder: productDetails.find((p2) => p2.productId === item.productId)?.price
        // store price at order time in Paises
      });
    }
    return {
      order: createdOrder,
      products: []
    };
  }
  /**
   * Get order by ID with associated products
   * @param orderId Order ID
   * @returns Order with products or null if not found
   */
  async getOrderById(orderId) {
    const [foundOrder] = await db.select().from(orders).where(eq(orders.id, orderId)).limit(1);
    const orderProducts = await db.select().from(orderProduct).where(eq(orderProduct.orderId, orderId));
    return {
      order: foundOrder,
      products: orderProducts
    };
  }
  /**
   * Get all orders for a user
   * @param userId User ID
   * @returns Array of orders with products
   */
  async getOrdersByUserId(userId) {
    const userOrders = await db.select().from(orders).where(eq(orders.userId, userId));
    let result = [];
    for (const order of userOrders) {
      const orderProducts = await db.select().from(orderProduct).where(eq(orderProduct.orderId, order.id));
      result.push({
        order,
        products: orderProducts
      });
    }
    return result;
  }
  /**
   * Update order details (status, shippingAddress, paymentMethod, notes)
   * @param orderId Order ID
   * @param data Update data
   * @returns Updated order with products
   */
  async updateOrder(orderId, data) {
    try {
      const [foundOrder] = await db.select().from(orders).where(eq(orders.id, orderId)).limit(1);
      if (!foundOrder) {
        throw new Error(`Order with ID ${orderId} not found`, {
          cause: {
            STATUS_CODES: 404
          }
        });
      }
      if (foundOrder.status === "cancelled") {
        throw new Error(`Cannot update an order with status 'cancelled'`);
      }
      const now = /* @__PURE__ */ new Date();
      const updatedOrder = {
        ...foundOrder,
        status: data.status ?? foundOrder.status,
        shippingAddress: data.shippingAddress ?? foundOrder.shippingAddress,
        paymentMethod: data.paymentMethod ?? foundOrder.paymentMethod,
        notes: data.notes ?? foundOrder.notes,
        updatedAt: now
      };
      const orderProducts = await db.select().from(orderProduct).where(eq(orderProduct.orderId, orderId));
      await db.update(orders).set({
        status: data.status,
        shippingAddress: data.shippingAddress,
        paymentMethod: data.paymentMethod,
        notes: data.notes,
        updatedAt: now
      }).where(eq(orders.id, orderId));
      return {
        order: updatedOrder,
        products: orderProducts
      };
    } catch (error48) {
      throw new Error(
        error48 instanceof Error ? error48.message : "An unknown error occurred",
        {
          cause: {
            STATUS_CODES: error48 instanceof Error && error48.cause || 500
          }
        }
      );
    }
  }
  /**
   * Add a product to an existing order
   * @param orderId Order ID
   * @param productId Product ID
   * @param quantity Quantity to add
   * @returns Updated order with products
   */
  async addProductToOrder(orderId, productId, quantity = 1) {
    const [foundOrder] = await db.select().from(orders).where(eq(orders.id, orderId)).limit(1);
    if (!foundOrder) {
      throw new Error(`Order with ID ${orderId} not found`);
    }
    if (foundOrder.status === "delivered" || foundOrder.status === "cancelled") {
      throw new Error(
        `Cannot add products to an order that is '${foundOrder.status}'`
      );
    }
    const [foundProduct] = await db.select().from(product).where(eq(product.productId, productId)).limit(1);
    if (!foundProduct) {
      throw new Error(`Product with ID ${productId} not found`);
    }
    const now = /* @__PURE__ */ new Date();
    await db.transaction(async (tx) => {
      const [existingOrderProduct] = await tx.select().from(orderProduct).where(
        and(
          eq(orderProduct.orderId, orderId),
          eq(orderProduct.productId, productId)
        )
      ).limit(1);
      if (existingOrderProduct) {
        await tx.update(orderProduct).set({ quantity: existingOrderProduct.quantity + quantity }).where(eq(orderProduct.id, existingOrderProduct.id));
      } else {
        await tx.insert(orderProduct).values({
          orderId,
          productId,
          quantity,
          priceAtOrder: foundProduct.price
        });
      }
      const orderProducts2 = await tx.select().from(orderProduct).where(eq(orderProduct.orderId, orderId));
      const newTotalAmount = orderProducts2.reduce(
        (sum, op) => sum + op.priceAtOrder * op.quantity,
        0
      );
      await tx.update(orders).set({ totalAmount: newTotalAmount, updatedAt: now }).where(eq(orders.id, orderId));
    });
    const [updatedOrder] = await db.select().from(orders).where(eq(orders.id, orderId)).limit(1);
    const orderProducts = await db.select().from(orderProduct).where(eq(orderProduct.orderId, orderId));
    return {
      order: updatedOrder,
      products: orderProducts
    };
  }
  /**
   * Remove a product from an order
   * @param orderId Order ID
   * @param productId Product ID to remove
   * @returns Updated order with products
   */
  async removeProductFromOrder(orderId, productId) {
    const orderIndex = ordersSample.findIndex((o) => o.id === orderId);
    if (orderIndex === -1) {
      throw new Error(`Order with ID ${orderId} not found`);
    }
    const existingOrder = ordersSample[orderIndex];
    if (existingOrder.status === "delivered" || existingOrder.status === "cancelled") {
      throw new Error(
        `Cannot remove products from an order that is '${existingOrder.status}'`
      );
    }
    const orderProductIndex = orderProductsSample.findIndex(
      (op) => op.orderId === orderId && op.productId === productId
    );
    if (orderProductIndex === -1) {
      throw new Error(
        `Product with ID ${productId} not found in order ${orderId}`
      );
    }
    orderProductsSample.splice(orderProductIndex, 1);
    const now = /* @__PURE__ */ new Date();
    const remainingProducts = orderProductsSample.filter(
      (op) => op.orderId === orderId
    );
    const newTotalAmount = remainingProducts.reduce(
      (sum, op) => sum + op.priceAtOrder * op.quantity,
      0
    );
    const updatedOrder = {
      ...existingOrder,
      totalAmount: newTotalAmount,
      updatedAt: now
    };
    ordersSample[orderIndex] = updatedOrder;
    return {
      order: updatedOrder,
      products: remainingProducts
    };
  }
  /**
   * Get all orders with optional filters
   * @param options Filter options (userId, status, limit, offset)
   * @returns Array of orders with products and total count
   */
  async getAllOrders(options) {
    const { userId, status, limit = 10, offset = 0 } = options || {};
    let filteredOrders = [...ordersSample];
    if (userId !== void 0) {
      filteredOrders = filteredOrders.filter((o) => o.userId === userId);
    }
    if (status !== void 0) {
      filteredOrders = filteredOrders.filter((o) => o.status === status);
    }
    const total = filteredOrders.length;
    const paginatedOrders = filteredOrders.slice(offset, offset + limit);
    const result = [];
    for (const order of paginatedOrders) {
      const orderProducts = orderProductsSample.filter(
        (op) => op.orderId === order.id
      );
      result.push({
        order,
        products: orderProducts
      });
    }
    return {
      orders: result,
      total
    };
  }
  /**
   * Delete an order and its associated products
   * @param orderId Order ID
   * @returns Deletion confirmation
   */
  async deleteOrder(orderId) {
    const orderIndex = ordersSample.findIndex((o) => o.id === orderId);
    if (orderIndex === -1) {
      throw new Error(`Order with ID ${orderId} not found`);
    }
    for (let i = orderProductsSample.length - 1; i >= 0; i--) {
      if (orderProductsSample[i].orderId === orderId) {
        orderProductsSample.splice(i, 1);
      }
    }
    ordersSample.splice(orderIndex, 1);
    return {
      deleted: true,
      orderId
    };
  }
};

// src/routes/api/order/handler.ts
var orderService = new OrderService();
var createOrderHandler = {
  handler: async (request, reply) => {
    try {
      const orderData = request.body;
      const result = await orderService.createOrder(orderData);
      sendSuccess(result, "Order created successfully", reply, 201);
    } catch (error48) {
      request.log.error(error48);
      if (error48 instanceof Error) {
        return sendError(error48.message, "PRODUCT_NOT_FOUND", reply, 404);
      }
      return sendError(
        "Failed to create order",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var getOrderByIdHandler = {
  handler: async (request, reply) => {
    try {
      const { orderId } = request.params;
      const result = await orderService.getOrderById(orderId);
      if (!result) {
        return sendError(
          `Order with ID ${orderId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      sendSuccess(result, "Order fetched successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to fetch order",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var updateOrderHandler = {
  handler: async (request, reply) => {
    try {
      const { orderId } = request.params;
      const updateData = request.body;
      const result = await orderService.updateOrder(orderId, updateData);
      sendSuccess(result, "Order updated successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      if (error48 instanceof Error && error48.message.includes("not found")) {
        return sendError(error48.message, "NOT_FOUND", reply, 404);
      }
      return sendError(
        "Failed to update order",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var addProductToOrderHandler = {
  handler: async (request, reply) => {
    try {
      const { orderId } = request.params;
      const { productId, quantity } = request.body;
      const result = await orderService.addProductToOrder(
        orderId,
        productId,
        quantity
      );
      sendSuccess(result, "Product added to order successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      if (error48 instanceof Error && error48.message.includes("not found")) {
        return sendError(error48.message, "NOT_FOUND", reply, 404);
      }
      return sendError(
        "Failed to add product to order",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var removeProductFromOrderHandler = {
  handler: async (request, reply) => {
    try {
      const { orderId, productId } = request.params;
      const result = await orderService.removeProductFromOrder(
        orderId,
        productId
      );
      sendSuccess(
        result,
        "Product removed from order successfully",
        reply,
        200
      );
    } catch (error48) {
      request.log.error(error48);
      if (error48 instanceof Error && error48.message.includes("not found")) {
        return sendError(error48.message, "NOT_FOUND", reply, 404);
      }
      return sendError(
        "Failed to remove product from order",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var getAllOrdersHandler = {
  handler: async (request, reply) => {
    try {
      const options = request.query;
      const result = await orderService.getAllOrders(options);
      sendSuccess(result, "Orders fetched successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to fetch orders",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var deleteOrderHandler = {
  handler: async (request, reply) => {
    try {
      const { orderId } = request.params;
      const result = await orderService.deleteOrder(orderId);
      sendSuccess(result, "Order deleted successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      if (error48 instanceof Error && error48.message.includes("not found")) {
        return sendError(error48.message, "NOT_FOUND", reply, 404);
      }
      return sendError(
        "Failed to delete order",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};

// src/routes/api/order/index.ts
async function ordersRoute(fastify) {
  fastify.withTypeProvider().get("/", {
    schema: getAllOrdersSchema,
    handler: getAllOrdersHandler.handler
  });
  fastify.withTypeProvider().post("/", {
    schema: createOrderSchema,
    handler: createOrderHandler.handler
  });
  fastify.withTypeProvider().get("/:orderId", {
    schema: getOrderByIdSchema,
    handler: getOrderByIdHandler.handler
  });
  fastify.withTypeProvider().put("/:orderId", {
    schema: updateOrderSchema,
    handler: updateOrderHandler.handler
  });
  fastify.withTypeProvider().delete("/:orderId", {
    schema: deleteOrderSchema,
    handler: deleteOrderHandler.handler
  });
  fastify.withTypeProvider().post("/:orderId/products", {
    schema: addProductToOrderSchema,
    handler: addProductToOrderHandler.handler
  });
  fastify.withTypeProvider().delete("/:orderId/products/:productId", {
    schema: removeProductFromOrderSchema,
    handler: removeProductFromOrderHandler.handler
  });
}

// src/schema/auth.schema.ts
var loginSchema = {
  body: createInsertSchema(users).pick({ email: true, password: true })
};
var registerSchema = {
  body: createInsertSchema(users).pick({
    name: true,
    email: true,
    password: true
  })
};
var forgotPasswordSchema = {
  body: createInsertSchema(users).pick({
    email: true
  })
};
var resetPasswordSchema = {
  body: external_exports2.object({
    token: external_exports2.string(),
    password: external_exports2.string().min(6)
  })
};
var authSchema = loginSchema.body;

// src/routes/api/auth/login/handler.ts
var loginRouteHandler = {
  handler: async (request, reply) => {
    const { email: email3, password } = request.body;
    const [user] = await db.select().from(users).where(eq(users.email, email3));
    if (!user) {
      return sendError("User not found", "NOT_FOUND", reply, 404);
    }
    if (!verifyPassword(password, user.password)) {
      return sendError("Invalid credentials", "UNAUTHORIZED", reply, 401);
    }
    const result = {
      user: {
        id: user.id,
        email: user.email,
        name: user.name
      }
    };
    sendSuccess(result.user, "Login successful", reply, 200);
  }
};

// src/routes/api/auth/login/index.ts
async function loginRoute(fastify) {
  fastify.withTypeProvider().post("/", {
    schema: loginSchema,
    handler: loginRouteHandler.handler
  });
}

// src/routes/api/auth/register/handler.ts
var registerRouteHandler = {
  handler: async (request, reply) => {
    try {
      const { email: email3, password, name } = request.body;
      const [existingUsers] = await db.select().from(users).where(eq(users.email, email3));
      if (existingUsers) {
        return sendError("User already exists", "USER_EXISTS", reply, 409);
      }
      const hashedPassword = hashPassword(password);
      const [newUser] = await db.insert(users).values({
        email: email3,
        password: hashedPassword,
        name
      }).returning({
        id: users.id,
        email: users.email,
        name: users.name
      });
      if (!newUser) {
        throw new Error("User creation failed");
      }
      return sendSuccess(newUser, "User registered successfully", reply, 201);
    } catch (error48) {
      return sendError(
        "Internal server error",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};

// src/routes/api/auth/register/index.ts
async function registerRoute(fastify) {
  fastify.withTypeProvider().post("/", {
    schema: registerSchema,
    handler: registerRouteHandler.handler
  });
}

// src/lib/token.ts
import { randomBytes } from "crypto";
var passwordResetTokens = /* @__PURE__ */ new Map();
var TOKEN_EXPIRATION_MINUTES = 60;
function generateResetToken(userId) {
  const token = randomBytes(32).toString("hex");
  const expiresAt = new Date(Date.now() + TOKEN_EXPIRATION_MINUTES * 60 * 1e3);
  passwordResetTokens.set(token, { userId, expiresAt });
  return token;
}
function validateResetToken(token) {
  const tokenData = passwordResetTokens.get(token);
  if (!tokenData) {
    return null;
  }
  if (tokenData.expiresAt < /* @__PURE__ */ new Date()) {
    passwordResetTokens.delete(token);
    return null;
  }
  return tokenData.userId;
}
function deleteResetToken(token) {
  passwordResetTokens.delete(token);
}

// src/routes/api/auth/forgot-password/handler.ts
var forgotPasswordHandler = {
  handler: async (request, reply) => {
    const { email: email3 } = request.body;
    const foundUsers = await db.select().from(users).where(eq(users.email, email3));
    const user = foundUsers[0];
    if (user) {
      const token = generateResetToken(user.id);
      console.log(`Password reset token for ${email3}: ${token}`);
    } else {
      console.log(`Password reset attempt for non-existent user: ${email3}`);
    }
    const data = {
      emailSent: true
    };
    sendSuccess(data, "MESSAGE SENT SUCCESSFULLY", reply, 200);
  }
};

// src/routes/api/auth/forgot-password/index.ts
async function forgotPasswordRoute(fastify) {
  fastify.withTypeProvider().post("/", {
    schema: forgotPasswordSchema,
    handler: forgotPasswordHandler.handler
  });
}

// src/routes/api/auth/reset-password/handler.ts
var resetPasswordHandler = {
  handler: async (request, reply) => {
    const { token, password } = request.body;
    const userId = validateResetToken(token);
    if (!userId) {
      return sendError("INVALID OR EXPIRED TOKEN", "unauthorized", reply, 401);
    }
    const foundUsers = await db.select().from(users).where(eq(users.id, userId));
    const user = foundUsers[0];
    if (!user) {
      return sendError("USER NOT FOUND", "not_found", reply, 404);
    }
    const hashedPassword = hashPassword(password);
    await db.update(users).set({ password: hashedPassword }).where(eq(users.id, userId));
    deleteResetToken(token);
    sendSuccess(
      { passwordReset: true },
      "PASSWORD RESET SUCCESSFUL",
      reply,
      200
    );
  }
};

// src/routes/api/auth/reset-password/index.ts
async function resetPasswordRoute(fastify) {
  fastify.withTypeProvider().post("/", {
    schema: resetPasswordSchema,
    handler: resetPasswordHandler.handler
  });
}

// src/modules/polar-order.service.ts
init_config();
var polar2 = null;
function getPolarInstance2() {
  if (!config2.POLAR_ACCESS_TOKEN) {
    return null;
  }
  if (!polar2) {
    polar2 = new Polar({
      accessToken: config2.POLAR_ACCESS_TOKEN,
      server: config2.POLAR_SERVER
    });
  }
  return polar2;
}
var ordersStore = /* @__PURE__ */ new Map();
var userAccessStore = /* @__PURE__ */ new Map();
var PolarOrderService = class {
  /**
   * Save an order from webhook
   */
  async saveOrder(params) {
    const now = /* @__PURE__ */ new Date();
    const order = {
      ...params,
      createdAt: now,
      updatedAt: now
    };
    ordersStore.set(params.polarOrderId, order);
    console.log(`\u{1F4DD} Order saved: ${params.polarOrderId}`);
    return order;
  }
  /**
   * Update order status
   */
  async updateOrderStatus(polarOrderId, status) {
    const order = ordersStore.get(polarOrderId);
    if (order) {
      order.status = status;
      order.updatedAt = /* @__PURE__ */ new Date();
      ordersStore.set(polarOrderId, order);
      console.log(`\u{1F4DD} Order ${polarOrderId} status updated to: ${status}`);
    }
  }
  /**
   * Grant access to a user
   * Called when order.paid webhook is received
   */
  async grantAccess(userExternalId, productId) {
    userAccessStore.set(userExternalId, {
      productId,
      grantedAt: /* @__PURE__ */ new Date()
    });
    console.log(`\u{1F389} Access granted to user: ${userExternalId}`);
  }
  /**
   * Revoke access from a user
   * Called when order.refunded webhook is received
   */
  async revokeAccess(userExternalId) {
    userAccessStore.delete(userExternalId);
    console.log(`\u274C Access revoked for user: ${userExternalId}`);
  }
  /**
   * Check if a user has paid for the product
   */
  async hasUserPaid(userExternalId) {
    return userAccessStore.has(userExternalId);
  }
  /**
   * Get user access details
   */
  async getUserAccess(userExternalId) {
    const access = userAccessStore.get(userExternalId);
    if (access) {
      return { hasAccess: true, ...access };
    }
    return { hasAccess: false };
  }
  /**
   * Get order by ID from Polar API
   */
  async getOrderFromPolar(orderId) {
    try {
      const polarInstance = getPolarInstance2();
      if (!polarInstance) {
        throw new Error("Polar SDK is not configured");
      }
      const order = await polarInstance.orders.get({ id: orderId });
      return order;
    } catch (error48) {
      console.error("Failed to get order from Polar:", error48);
      throw error48;
    }
  }
  /**
   * List orders for a customer from Polar API
   */
  async getCustomerOrdersFromPolar(customerId) {
    try {
      const polarInstance = getPolarInstance2();
      if (!polarInstance) {
        throw new Error("Polar SDK is not configured");
      }
      const ordersResponse = await polarInstance.orders.list({
        customerId,
        productBillingType: "one_time"
      });
      const orders2 = [];
      for await (const page of ordersResponse) {
        orders2.push(...page.result.items);
      }
      return orders2;
    } catch (error48) {
      console.error("Failed to list customer orders from Polar:", error48);
      throw error48;
    }
  }
  /**
   * Verify if an external user has paid by checking Polar directly
   * Use this as a fallback verification method
   */
  async verifyUserPaymentFromPolar(externalId) {
    try {
      const polarInstance = getPolarInstance2();
      if (!polarInstance) {
        return { hasPaid: false };
      }
      const customer = await polarInstance.customers.getExternal({
        externalId
      });
      if (!customer) {
        return { hasPaid: false };
      }
      const ordersResponse = await polarInstance.orders.list({
        customerId: customer.id,
        productId: config2.POLAR_PRODUCT_ID,
        productBillingType: "one_time"
      });
      const orders2 = [];
      for await (const page of ordersResponse) {
        orders2.push(...page.result.items);
      }
      const paidOrder = orders2.find(
        (order) => order.billingReason === "purchase"
      );
      return {
        hasPaid: !!paidOrder,
        order: paidOrder
      };
    } catch (error48) {
      console.error("Failed to verify payment from Polar:", error48);
      return { hasPaid: false };
    }
  }
  /**
   * Get the product details
   */
  async getProduct() {
    try {
      const polarInstance = getPolarInstance2();
      if (!polarInstance) {
        throw new Error("Polar SDK is not configured");
      }
      const product2 = await polarInstance.products.get({
        id: config2.POLAR_PRODUCT_ID
      });
      return product2;
    } catch (error48) {
      console.error("Failed to get product:", error48);
      throw error48;
    }
  }
  /**
   * List all products (if you have multiple)
   */
  async listProducts() {
    try {
      const polarInstance = getPolarInstance2();
      if (!polarInstance) {
        throw new Error("Polar SDK is not configured");
      }
      const productsResponse = await polarInstance.products.list({
        isRecurring: false
        // Only one-time products
      });
      const products = [];
      for await (const page of productsResponse) {
        products.push(...page.result.items);
      }
      return products;
    } catch (error48) {
      console.error("Failed to list products:", error48);
      throw error48;
    }
  }
};
var orderService2 = new PolarOrderService();

// src/routes/api/orders/index.ts
var ExternalIdParamSchema2 = external_exports2.object({
  externalId: external_exports2.string()
});
async function ordersRoutes(fastify) {
  const app2 = fastify.withTypeProvider();
  app2.get(
    "/access/:externalId",
    {
      schema: {
        params: ExternalIdParamSchema2,
        description: "Check if a user has access to the SaaS product",
        tags: ["Orders", "Access"]
      }
    },
    async (req, reply) => {
      try {
        const { externalId } = req.params;
        const access = await orderService2.getUserAccess(externalId);
        return sendSuccess(
          {
            hasAccess: access.hasAccess,
            productId: access.productId,
            grantedAt: access.grantedAt
          },
          access.hasAccess ? "User has access" : "User does not have access",
          reply,
          200
        );
      } catch (error48) {
        req.log.error(error48);
        return sendError(
          "Failed to check access",
          "ACCESS_CHECK_FAILED",
          reply,
          500
        );
      }
    }
  );
  app2.get(
    "/verify/:externalId",
    {
      schema: {
        params: ExternalIdParamSchema2,
        description: "Verify payment directly from Polar API",
        tags: ["Orders", "Verification"]
      }
    },
    async (req, reply) => {
      try {
        const { externalId } = req.params;
        const verification = await orderService2.verifyUserPaymentFromPolar(externalId);
        return sendSuccess(
          {
            hasPaid: verification.hasPaid,
            order: verification.order
          },
          verification.hasPaid ? "Payment verified" : "No payment found",
          reply,
          200
        );
      } catch (error48) {
        req.log.error(error48);
        return sendError(
          "Failed to verify payment",
          "VERIFICATION_FAILED",
          reply,
          500
        );
      }
    }
  );
  app2.get("/product", async (req, reply) => {
    try {
      const product2 = await orderService2.getProduct();
      return sendSuccess({ product: product2 }, "Product retrieved", reply, 200);
    } catch (error48) {
      req.log.error(error48);
      return sendError(
        "Failed to fetch product",
        "PRODUCT_FETCH_FAILED",
        reply,
        500
      );
    }
  });
  app2.get("/products", async (req, reply) => {
    try {
      const products = await orderService2.listProducts();
      return sendSuccess({ products }, "Products retrieved", reply, 200);
    } catch (error48) {
      req.log.error(error48);
      return sendError(
        "Failed to fetch products",
        "PRODUCTS_FETCH_FAILED",
        reply,
        500
      );
    }
  });
}

// src/routes/api/payment/razorpay/handler.ts
init_config();
var razorpayCheckOutHandler = {
  handler: async (req, reply) => {
    try {
      const {
        orderId,
        customerEmail,
        customerName,
        successUrl,
        externalCustomerId
      } = req.body;
      const { order, internalOrderId } = await razorpayService.createOrder(
        orderId,
        {
          customerEmail,
          customerName,
          externalCustomerId,
          successUrl
        }
      );
      return sendSuccess(
        {
          order,
          keyId: config2.RAZORPAY_KEY_ID,
          internalOrderId,
          successUrl: successUrl || config2.SUCCESS_URL
        },
        "Razorpay order created",
        reply,
        201
      );
    } catch (error48) {
      req.log.error(error48);
      return sendError(
        "CREATE_ORDER_FAILED",
        error48 instanceof Error ? error48.message : "Order creation failed",
        reply,
        error48 instanceof Error && error48.statusCode ? error48.statusCode : 500
      );
    }
  }
};
var razorpayWebhookHandler = {
  handler: async (req, reply) => {
    const signature = req.headers["x-razorpay-signature"] || "";
    const rawBody = req.rawBody || JSON.stringify(req.body || {});
    if (!signature) {
      return sendError("MISSING_SIGNATURE", "Missing signature", reply, 400);
    }
    const verified = razorpayService.verifyWebhookSignature(rawBody, signature);
    if (!verified) {
      return sendError("INVALID_SIGNATURE", "Invalid signature", reply, 400);
    }
    const payload = req.body;
    try {
      const event = payload.event;
      if (event === "payment.captured") {
        const paymentEntity = payload.payload?.payment?.entity;
        if (paymentEntity?.order_id) {
          try {
            await razorpayService.markPaymentSucceeded(paymentEntity.order_id);
          } catch (err) {
            sendError(
              "MARK_PAYMENT_FAILED",
              "Failed to mark payment succeeded",
              reply,
              500
            );
          }
        }
      }
      return sendSuccess(
        { ok: true },
        "Webhook handled successfully",
        reply,
        200
      );
    } catch (err) {
      req.log.error("Error handling webhook event:", err);
      return sendError(
        "WEBHOOK_HANDLING_FAILED",
        "Failed to handle webhook",
        reply,
        500
      );
    }
  }
};
var razorpayVerifyHandler = {
  handler: async (req, reply) => {
    const bodySchema = external_exports2.object({
      razorpay_order_id: external_exports2.string(),
      razorpay_payment_id: external_exports2.string(),
      razorpay_signature: external_exports2.string()
    });
    const parsed = bodySchema.safeParse(req.body);
    if (!parsed.success) {
      return sendError(
        "INVALID_PAYLOAD",
        "Invalid verification payload",
        reply,
        400
      );
    }
    const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = parsed.data;
    const verified = razorpayService.verifyPaymentSignature(
      razorpay_order_id,
      razorpay_payment_id,
      razorpay_signature
    );
    if (!verified) {
      return sendError(
        "INVALID_SIGNATURE",
        "Signature verification failed",
        reply,
        400
      );
    }
    try {
      await razorpayService.markPaymentSucceeded(razorpay_order_id);
      return sendSuccess({ ok: true }, "Payment verified", reply, 200);
    } catch (err) {
      req.log.error(err);
      return sendError(
        "MARK_PAYMENT_FAILED",
        "Failed to mark payment succeeded",
        reply,
        500
      );
    }
  }
};
var razorpayStatusHandler = {
  handler: async (req, reply) => {
    try {
      const status = !!config2.RAZORPAY_KEY_ID && !!config2.RAZORPAY_KEY_SECRET;
      return sendSuccess({ status }, "Razorpay status retrieved", reply, 200);
    } catch (error48) {
      req.log.error(error48);
      return sendError(
        "RAZORPAY_STATUS_FAILED",
        error48 instanceof Error ? error48.message : "Failed to retrieve Razorpay status",
        reply,
        500
      );
    }
  }
};

// src/schema/payment.schema.ts
var paymentStatusValues2 = paymentStatusEnum.enumValues;
var insertPaymentSchema2 = createInsertSchema(payments).extend({
  status: external_exports2.enum(paymentStatusValues2).default(paymentStatusValues2[0]),
  createdAt: external_exports2.date().default(/* @__PURE__ */ new Date()),
  updatedAt: external_exports2.date().optional()
});
var paymentSchema2 = createSelectSchema(payments).omit({
  updatedAt: true
});
var createRazorpayCheckoutSchema = external_exports2.object({
  orderId: external_exports2.number(),
  // Optional customer info to pre-fill / attach to the Razorpay order
  customerEmail: external_exports2.string().email().optional(),
  customerName: external_exports2.string().optional(),
  // Optional redirect/confirmation URL (your frontend)
  successUrl: external_exports2.string().url().optional(),
  // Optional external customer id (your internal user id)
  externalCustomerId: external_exports2.string().optional()
});
var polarPaymentSchema = paymentSchema2.extend({
  currency: external_exports2.literal("usd").default("usd"),
  paymentMethod: external_exports2.literal("polar").default("polar"),
  status: external_exports2.enum(["pending", "completed", "failed"]).default("pending")
});
var createPolarPaymentSchema = polarPaymentSchema.omit({ id: true, createdAt: true }).extend({
  currency: external_exports2.literal("usd").default("usd"),
  paymentMethod: external_exports2.literal("polar").default("polar"),
  status: external_exports2.enum(["pending", "completed", "failed"]).default("pending")
}).refine(
  (d2) => d2.paymentMethod === "polar" && d2.currency === "usd" && d2.status === "pending",
  {
    message: "Payment method must be polar and currency must be usd"
  }
);

// src/routes/api/payment/razorpay/index.ts
var CreateCheckoutSchema2 = createRazorpayCheckoutSchema;
var VerifyPaymentSchema = external_exports2.object({
  razorpay_order_id: external_exports2.string(),
  razorpay_payment_id: external_exports2.string(),
  razorpay_signature: external_exports2.string()
});
async function razorpayRoutes(fastify) {
  const app2 = fastify.withTypeProvider();
  app2.post("/checkout", {
    schema: {
      body: CreateCheckoutSchema2,
      description: "Create a Razorpay order for an existing orderId",
      tags: ["Razorpay", "Checkout"]
    },
    handler: razorpayCheckOutHandler.handler
  });
  app2.get("/webhook", {
    config: { rawBody: true },
    handler: razorpayWebhookHandler.handler
  });
  app2.post(
    "/verify",
    {
      schema: {
        body: VerifyPaymentSchema,
        description: "Verify Razorpay payment signature (for client-side flow)",
        tags: ["Razorpay", "Verification"]
      }
    },
    razorpayVerifyHandler.handler
  );
  app2.get("/status", {
    handler: razorpayStatusHandler.handler
  });
}

// src/schema/user.schema.ts
var createUserSchema = {
  body: external_exports2.object({
    name: external_exports2.string().min(2),
    email: external_exports2.string().email(),
    password: external_exports2.string().min(6)
  })
};
var getUserSchema = {
  params: external_exports2.object({
    id: external_exports2.string().transform((val) => parseInt(val, 10))
  })
};
var userIdSchema = getUserSchema.params;

// src/routes/api/users/index.ts
async function usersRoute(fastify) {
  fastify.get(
    "/",
    async (request, reply) => {
      if (request.query.email) {
        const user = await db.select({
          id: users.id,
          name: users.name,
          email: users.email
        }).from(users).where(eq(users.email, request.query.email));
        return sendSuccess(user, "User retrieved successfully", reply, 200);
      }
      const allUsers = await db.select({
        id: users.id,
        name: users.name,
        email: users.email
      }).from(users);
      sendSuccess(allUsers, "Users retrieved successfully", reply, 200);
    }
  );
  fastify.withTypeProvider().get(
    "/:id",
    {
      schema: getUserSchema
    },
    async (request, reply) => {
      const { id } = request.params;
      const foundUsers = await db.select({
        id: users.id,
        name: users.name,
        email: users.email
      }).from(users).where(eq(users.id, id));
      const user = foundUsers[0];
      if (!user) {
        return sendError("User not found", "NOT_FOUND", reply, 404);
      }
      sendSuccess(user, "User retrieved successfully", reply, 200);
    }
  );
  fastify.withTypeProvider().post(
    "/",
    {
      schema: createUserSchema
    },
    async (request, reply) => {
      const { name, email: email3, password } = request.body;
      const existingUser = await db.select().from(users).where(eq(users.email, email3));
      if (existingUser.length > 0) {
        return sendError(
          "User with this email already exists",
          "CONFLICT",
          reply,
          409
        );
      }
      const hashedPassword = hashPassword(password);
      const newUser = await db.insert(users).values({
        name,
        email: email3,
        password: hashedPassword
      }).returning({
        id: users.id,
        name: users.name,
        email: users.email
      });
      sendSuccess(newUser[0], "User created successfully", reply, 201);
    }
  );
}

// src/routes/checkout/index.ts
var SuccessQuery = external_exports2.object({ orderId: external_exports2.string().or(external_exports2.number()) });
async function checkoutRoutes(fastify) {
  fastify.get(
    "/success",
    {
      schema: {
        querystring: SuccessQuery,
        description: "Simple confirmation page for a completed checkout",
        tags: ["Checkout"]
      }
    },
    async (request, reply) => {
      const parsed = SuccessQuery.safeParse(request.query);
      if (!parsed.success) {
        return reply.status(400).type("text/html").send(`<h1>Missing orderId</h1>`);
      }
      const orderId = Number(parsed.data.orderId);
      try {
        const [payment] = await db.select().from(payments).where(eq(payments.orderId, orderId)).orderBy(payments.createdAt).limit(1);
        if (!payment) {
          return reply.type("text/html").send(`
            <h1>Payment not found</h1>
            <p>No payment record found for orderId=${orderId}</p>
          `);
        }
        return reply.type("text/html").send(`
          <h1>Payment Confirmation</h1>
          <p>Order ID: ${orderId}</p>
          <p>Payment ID: ${payment.id}</p>
          <p>Status: ${payment.status}</p>
          <p>Amount: ${payment.amount}</p>
        `);
      } catch (err) {
        request.log.error(err);
        return reply.status(500).type("text/html").send(`<h1>Error</h1><p>Failed to load confirmation</p>`);
      }
    }
  );
}

// src/routes/api/checkout/index.ts
init_config();
var polar3 = null;
function getPolarInstance3() {
  if (!config2.POLAR_ACCESS_TOKEN) {
    return null;
  }
  if (!polar3) {
    polar3 = new Polar({
      accessToken: config2.POLAR_ACCESS_TOKEN,
      server: config2.POLAR_SERVER
    });
  }
  return polar3;
}
var CheckoutQuerySchema = external_exports2.object({
  // Customer identification (use your internal user ID)
  userId: external_exports2.string(),
  // Customer email (pre-fills checkout form)
  email: external_exports2.string().email(),
  // Customer name (pre-fills checkout form)
  name: external_exports2.string()
});
async function checkoutRoutes2(fastify) {
  const app2 = fastify.withTypeProvider();
  app2.get(
    "/",
    {
      schema: {
        querystring: CheckoutQuerySchema,
        description: "Create checkout session for SaaS product",
        tags: ["Checkout"]
      }
    },
    async (request, reply) => {
      try {
        const { userId, email: email3, name } = request.query;
        if (!userId || !email3 || !name) {
          return sendError(
            "Missing required parameters (userId, email, and name required)",
            "MISSING_PARAMETERS",
            reply,
            400
          );
        }
        const polarInstance = getPolarInstance3();
        if (!polarInstance) {
          sendError(
            "Polar SDK not configured",
            "PAYMENT_NOT_CONFIGURED",
            reply,
            503
          );
          return;
        }
        const checkout = await polarInstance.checkouts.create({
          // Your SaaS product from config
          products: [config2.POLAR_PRODUCT_ID],
          // Link to your internal user (critical for access granting)
          externalCustomerId: userId,
          metadata: {
            userId,
            email: email3,
            name: name || "",
            application: "Fastifyx85",
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          },
          // Pre-fill customer info
          customerEmail: email3,
          customerName: name,
          // Redirect URLs
          successUrl: config2.SUCCESS_URL
        });
        if (!checkout)
          return sendError(
            "Failed to create checkout",
            "CHECKOUT_CREATION_FAILED",
            reply,
            500
          );
        return reply.redirect(checkout.url);
      } catch (error48) {
        request.log.error(error48);
        return sendError(
          "INTERNAL SERVER_ERROR",
          "Failed to create checkout",
          reply,
          500
        );
      }
    }
  );
  app2.post(
    "/",
    {
      schema: {
        body: CheckoutQuerySchema,
        description: "Create checkout session and return URL",
        tags: ["Checkout"]
      }
    },
    async (request, reply) => {
      try {
        const { userId, email: email3, name } = request.body;
        const polarInstance = getPolarInstance3();
        if (!polarInstance) {
          return reply.status(503).send({
            success: false,
            error: "Payment service not configured",
            message: "Polar SDK is not configured"
          });
        }
        const checkout = await polarInstance.checkouts.create({
          products: [config2.POLAR_PRODUCT_ID],
          externalCustomerId: userId,
          customerEmail: email3,
          customerName: name,
          successUrl: config2.SUCCESS_URL
        });
        return reply.send({
          success: true,
          checkoutUrl: checkout.url,
          checkoutId: checkout.id,
          expiresAt: checkout.expiresAt
        });
      } catch (error48) {
        request.log.error(error48);
        return reply.status(500).send({
          success: false,
          error: "Failed to create checkout",
          message: error48 instanceof Error ? error48.message : "Unknown error"
        });
      }
    }
  );
  app2.get("/product", async (request, reply) => {
    try {
      const polarInstance = getPolarInstance3();
      if (!polarInstance) {
        return reply.status(503).send({
          success: false,
          error: "Payment service not configured",
          message: "Polar SDK is not configured"
        });
      }
      const product2 = await polarInstance.products.get({
        id: config2.POLAR_PRODUCT_ID
      });
      const price = product2.prices?.[0];
      let priceAmount = 0;
      let priceCurrency = "usd";
      if (price && "priceAmount" in price) {
        priceAmount = price.priceAmount;
        priceCurrency = price.priceCurrency;
      }
      const data = {
        id: product2.id,
        name: product2.name,
        description: product2.description,
        price: priceAmount / 100,
        // Convert cents to dollars
        priceCents: priceAmount,
        currency: priceCurrency,
        isArchived: product2.isArchived
      };
      return sendSuccess(data, "Product retrieved", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "INTERNAL SERVERERROR",
        "Failed to fetch product",
        reply,
        500
      );
    }
  });
}

// src/schema/book.schema.ts
var currencyEnum4 = external_exports2.enum(["inr", "usd"]);
var bookSchema = productResponseSchema.extend({
  currency: currencyEnum4
});
var booksDataSchema = productsDataSchema.extend({
  currency: currencyEnum4
});
var getBooksSchema = {
  response: {
    200: successResponseSchema(booksDataSchema)
  }
};
var getBookByIdSchema = {
  params: external_exports2.object({
    bookId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(bookSchema)
  }
};
var createBookBodySchema = createProductBodySchema.pick({
  name: true,
  description: true,
  price: true
});
var createBookSchema = {
  body: createBookBodySchema,
  response: {
    201: successResponseSchema(external_exports2.object({ product: bookSchema }))
  }
};
var updateBookBodySchema = external_exports2.object({
  name: external_exports2.string().optional(),
  description: external_exports2.string().optional(),
  price: external_exports2.number().int().positive().optional()
  // note: category intentionally omitted
}).refine((data) => Object.keys(data).length > 0, {
  message: "At least one field must be provided to update the book"
});
var updateBookSchema = {
  params: external_exports2.object({
    bookId: external_exports2.coerce.number().int().positive()
  }),
  body: updateBookBodySchema,
  response: {
    200: successResponseSchema(external_exports2.object({ product: bookSchema }))
  }
};
var deleteBookSchema = {
  params: external_exports2.object({
    bookId: external_exports2.coerce.number().int().positive()
  }),
  response: {
    200: successResponseSchema(
      external_exports2.object({ deleted: external_exports2.boolean(), productId: external_exports2.number() })
    )
  }
};

// src/routes/api/books/handler.ts
var getBooksHandler = {
  handler: async (_request, reply) => {
    try {
      const books = await productService.getProductByQuery("Books");
      return sendSuccess(
        { products: books },
        "Books fetched successfully",
        reply,
        200
      );
    } catch (error48) {
      reply.log.error(error48);
      return sendError(
        "Failed to fetch books",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var getBookByIdHandler = {
  handler: async (request, reply) => {
    try {
      const { bookId } = request.params;
      const product2 = await productService.getProductById(bookId);
      return sendSuccess(product2, "Book fetched successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to fetch book",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var createBookHandler = {
  handler: async (request, reply) => {
    try {
      const product2 = request.body;
      const payload = {
        ...product2,
        category: "Books"
      };
      const result = await productService.createProduct(payload);
      return sendSuccess(
        { product: result },
        "Book created successfully",
        reply,
        201
      );
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to create book",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var updateBookHandler = {
  handler: async (request, reply) => {
    try {
      const { bookId } = request.params;
      const existing = await productService.getProductById(bookId);
      if (!existing || existing.category !== "Books") {
        return sendError(
          `Book with ID ${bookId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      const result = await productService.updateProduct(bookId, product);
      if (!result) {
        return sendError(
          `Book with ID ${bookId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      return sendSuccess(
        { product: result },
        "Book updated successfully",
        reply,
        200
      );
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to update book",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};
var deleteBookHandler = {
  handler: async (request, reply) => {
    try {
      const { bookId } = request.params;
      const existing = await productService.getProductById(bookId);
      if (!existing || existing.category !== "Books") {
        return sendError(
          `Book with ID ${bookId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      const result = await productService.deleteProduct(bookId);
      if (!result.deleted) {
        return sendError(
          `Book with ID ${bookId} not found`,
          "NOT_FOUND",
          reply,
          404
        );
      }
      return sendSuccess(result, "Book deleted successfully", reply, 200);
    } catch (error48) {
      request.log.error(error48);
      return sendError(
        "Failed to delete book",
        "INTERNAL_SERVER_ERROR",
        reply,
        500
      );
    }
  }
};

// src/routes/api/books/index.ts
async function booksRoute(fastify) {
  fastify.withTypeProvider().get("/", {
    handler: getBooksHandler.handler
  });
  fastify.withTypeProvider().post("/", {
    schema: createBookSchema,
    handler: createBookHandler.handler
  });
  fastify.withTypeProvider().get("/:bookId", {
    schema: getBookByIdSchema,
    handler: getBookByIdHandler.handler
  });
  fastify.withTypeProvider().put("/:bookId", {
    schema: updateBookSchema,
    handler: updateBookHandler.handler
  });
  fastify.withTypeProvider().delete("/:bookId", {
    schema: deleteBookSchema,
    handler: deleteBookHandler.handler
  });
}

// node_modules/.pnpm/@polar-sh+adapter-utils@0.4.3/node_modules/@polar-sh/adapter-utils/dist/index.js
var handleWebhookPayload = async (payload, { webhookSecret, entitlements, onPayload, ...eventHandlers }) => {
  const promises = [];
  if (onPayload) {
    promises.push(onPayload(payload));
  }
  switch (payload.type) {
    case "checkout.created":
      if (eventHandlers.onCheckoutCreated) {
        promises.push(eventHandlers.onCheckoutCreated(payload));
      }
      break;
    case "checkout.updated":
      if (eventHandlers.onCheckoutUpdated) {
        promises.push(eventHandlers.onCheckoutUpdated(payload));
      }
      break;
    case "order.created":
      if (eventHandlers.onOrderCreated) {
        promises.push(eventHandlers.onOrderCreated(payload));
      }
      break;
    case "order.updated":
      if (eventHandlers.onOrderUpdated) {
        promises.push(eventHandlers.onOrderUpdated(payload));
      }
      break;
    case "order.paid":
      if (eventHandlers.onOrderPaid) {
        promises.push(eventHandlers.onOrderPaid(payload));
      }
      break;
    case "subscription.created":
      if (eventHandlers.onSubscriptionCreated) {
        promises.push(eventHandlers.onSubscriptionCreated(payload));
      }
      break;
    case "subscription.updated":
      if (eventHandlers.onSubscriptionUpdated) {
        promises.push(eventHandlers.onSubscriptionUpdated(payload));
      }
      break;
    case "subscription.active":
      if (eventHandlers.onSubscriptionActive) {
        promises.push(eventHandlers.onSubscriptionActive(payload));
      }
      break;
    case "subscription.canceled":
      if (eventHandlers.onSubscriptionCanceled) {
        promises.push(eventHandlers.onSubscriptionCanceled(payload));
      }
      break;
    case "subscription.uncanceled":
      if (eventHandlers.onSubscriptionUncanceled) {
        promises.push(eventHandlers.onSubscriptionUncanceled(payload));
      }
      break;
    case "subscription.revoked":
      if (eventHandlers.onSubscriptionRevoked) {
        promises.push(eventHandlers.onSubscriptionRevoked(payload));
      }
      break;
    case "product.created":
      if (eventHandlers.onProductCreated) {
        promises.push(eventHandlers.onProductCreated(payload));
      }
      break;
    case "product.updated":
      if (eventHandlers.onProductUpdated) {
        promises.push(eventHandlers.onProductUpdated(payload));
      }
      break;
    case "organization.updated":
      if (eventHandlers.onOrganizationUpdated) {
        promises.push(eventHandlers.onOrganizationUpdated(payload));
      }
      break;
    case "benefit.created":
      if (eventHandlers.onBenefitCreated) {
        promises.push(eventHandlers.onBenefitCreated(payload));
      }
      break;
    case "benefit.updated":
      if (eventHandlers.onBenefitUpdated) {
        promises.push(eventHandlers.onBenefitUpdated(payload));
      }
      break;
    case "benefit_grant.created":
      if (eventHandlers.onBenefitGrantCreated) {
        promises.push(eventHandlers.onBenefitGrantCreated(payload));
      }
      break;
    case "benefit_grant.updated":
      if (eventHandlers.onBenefitGrantUpdated) {
        promises.push(eventHandlers.onBenefitGrantUpdated(payload));
      }
      break;
    case "benefit_grant.revoked":
      if (eventHandlers.onBenefitGrantRevoked) {
        promises.push(eventHandlers.onBenefitGrantRevoked(payload));
      }
      break;
    case "customer.created":
      if (eventHandlers.onCustomerCreated) {
        promises.push(eventHandlers.onCustomerCreated(payload));
      }
      break;
    case "customer.updated":
      if (eventHandlers.onCustomerUpdated) {
        promises.push(eventHandlers.onCustomerUpdated(payload));
      }
      break;
    case "customer.deleted":
      if (eventHandlers.onCustomerDeleted) {
        promises.push(eventHandlers.onCustomerDeleted(payload));
      }
      break;
    case "customer.state_changed":
      if (eventHandlers.onCustomerStateChanged) {
        promises.push(eventHandlers.onCustomerStateChanged(payload));
      }
      break;
    case "order.refunded":
      if (eventHandlers.onOrderRefunded) {
        promises.push(eventHandlers.onOrderRefunded(payload));
      }
      break;
    case "refund.created":
      if (eventHandlers.onRefundCreated) {
        promises.push(eventHandlers.onRefundCreated(payload));
      }
      break;
    case "refund.updated":
      if (eventHandlers.onRefundUpdated) {
        promises.push(eventHandlers.onRefundUpdated(payload));
      }
      break;
  }
  switch (payload.type) {
    case "benefit_grant.created":
    case "benefit_grant.revoked":
      if (entitlements) {
        for (const handler of entitlements.handlers) {
          promises.push(handler(payload));
        }
      }
  }
  return Promise.all(promises);
};

// node_modules/.pnpm/@polar-sh+sdk@0.42.5/node_modules/@polar-sh/sdk/dist/esm/webhooks.js
var import_standardwebhooks = __toESM(require_dist5(), 1);
var WebhookVerificationError = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
  }
};
var parseEvent = (parsed) => {
  try {
    switch (parsed.type) {
      case "customer.created":
        return WebhookCustomerCreatedPayload$inboundSchema.parse(parsed);
      case "customer.updated":
        return WebhookCustomerUpdatedPayload$inboundSchema.parse(parsed);
      case "customer.deleted":
        return WebhookCustomerDeletedPayload$inboundSchema.parse(parsed);
      case "customer.state_changed":
        return WebhookCustomerStateChangedPayload$inboundSchema.parse(parsed);
      case "customer_seat.assigned":
        return WebhookCustomerSeatAssignedPayload$inboundSchema.parse(parsed);
      case "customer_seat.claimed":
        return WebhookCustomerSeatClaimedPayload$inboundSchema.parse(parsed);
      case "customer_seat.revoked":
        return WebhookCustomerSeatRevokedPayload$inboundSchema.parse(parsed);
      case "benefit.created":
        return WebhookBenefitCreatedPayload$inboundSchema.parse(parsed);
      case "benefit_grant.created":
        return WebhookBenefitGrantCreatedPayload$inboundSchema.parse(parsed);
      case "benefit_grant.cycled":
        return WebhookBenefitGrantCycledPayload$inboundSchema.parse(parsed);
      case "benefit_grant.revoked":
        return WebhookBenefitGrantRevokedPayload$inboundSchema.parse(parsed);
      case "benefit_grant.updated":
        return WebhookBenefitGrantUpdatedPayload$inboundSchema.parse(parsed);
      case "benefit.updated":
        return WebhookBenefitUpdatedPayload$inboundSchema.parse(parsed);
      case "checkout.created":
        return WebhookCheckoutCreatedPayload$inboundSchema.parse(parsed);
      case "checkout.updated":
        return WebhookCheckoutUpdatedPayload$inboundSchema.parse(parsed);
      case "order.created":
        return WebhookOrderCreatedPayload$inboundSchema.parse(parsed);
      case "order.paid":
        return WebhookOrderPaidPayload$inboundSchema.parse(parsed);
      case "order.updated":
        return WebhookOrderUpdatedPayload$inboundSchema.parse(parsed);
      case "order.refunded":
        return WebhookOrderRefundedPayload$inboundSchema.parse(parsed);
      case "organization.updated":
        return WebhookOrganizationUpdatedPayload$inboundSchema.parse(parsed);
      case "product.created":
        return WebhookProductCreatedPayload$inboundSchema.parse(parsed);
      case "product.updated":
        return WebhookProductUpdatedPayload$inboundSchema.parse(parsed);
      case "refund.created":
        return WebhookRefundCreatedPayload$inboundSchema.parse(parsed);
      case "refund.updated":
        return WebhookRefundUpdatedPayload$inboundSchema.parse(parsed);
      case "subscription.active":
        return WebhookSubscriptionActivePayload$inboundSchema.parse(parsed);
      case "subscription.canceled":
        return WebhookSubscriptionCanceledPayload$inboundSchema.parse(parsed);
      case "subscription.created":
        return WebhookSubscriptionCreatedPayload$inboundSchema.parse(parsed);
      case "subscription.revoked":
        return WebhookSubscriptionRevokedPayload$inboundSchema.parse(parsed);
      case "subscription.uncanceled":
        return WebhookSubscriptionUncanceledPayload$inboundSchema.parse(parsed);
      case "subscription.updated":
        return WebhookSubscriptionUpdatedPayload$inboundSchema.parse(parsed);
      default:
        throw new SDKValidationError(`Unknown event type: ${parsed.type}`, parsed.type, parsed);
    }
  } catch (error48) {
    throw new SDKValidationError("Failed to parse event", error48, parsed);
  }
};
var validateEvent = (body, headers, secret) => {
  const base64Secret = Buffer.from(secret, "utf-8").toString("base64");
  const webhook = new import_standardwebhooks.Webhook(base64Secret);
  try {
    const parsed = webhook.verify(body, headers);
    return parseEvent(parsed);
  } catch (error48) {
    if (error48 instanceof import_standardwebhooks.WebhookVerificationError) {
      throw new WebhookVerificationError(error48.message);
    }
    throw error48;
  }
};

// node_modules/.pnpm/@polar-sh+fastify@0.5.3_fastify@5.6.1/node_modules/@polar-sh/fastify/dist/index.js
var Webhooks2 = ({
  webhookSecret,
  onPayload,
  entitlements,
  ...eventHandlers
}) => {
  return async (request, reply) => {
    const requestBody = typeof request.body === "string" ? request.body : JSON.stringify(request.body);
    const webhookHeaders = {
      "webhook-id": request.headers["webhook-id"],
      "webhook-timestamp": request.headers["webhook-timestamp"],
      "webhook-signature": request.headers["webhook-signature"]
    };
    let webhookPayload;
    try {
      webhookPayload = validateEvent(
        requestBody,
        webhookHeaders,
        webhookSecret
      );
    } catch (error48) {
      console.log(error48);
      if (error48 instanceof WebhookVerificationError) {
        return reply.status(400).send({ received: false });
      }
      return reply.status(500).send({ error: "Internal server error" });
    }
    await handleWebhookPayload(webhookPayload, {
      webhookSecret,
      entitlements,
      onPayload,
      ...eventHandlers
    });
    return { received: true };
  };
};

// src/routes/api/webhooks/index.ts
init_config();
async function webhooksRoutes(fastify) {
  fastify.post(
    "/polar",
    Webhooks2({
      webhookSecret: config2.POLAR_WEBHOOK_SECRET,
      /**
       * Triggered when an order is created (after checkout)
       * For one-time payments, this happens immediately after payment
       */
      onOrderCreated: async (payload) => {
        const order = payload.data;
        const { id, customerId, productId, createdAt } = order;
        const amountCents = order.netAmount;
        const currency = order.currency;
        console.log("\u{1F4E6} Order Created:", {
          orderId: id,
          customerId,
          productId,
          amount: amountCents / 100,
          // Convert cents to dollars
          currency,
          createdAt
        });
        try {
          await orderService2.saveOrder({
            polarOrderId: id,
            polarCustomerId: customerId,
            polarProductId: productId ?? "",
            amountCents,
            currency,
            status: "created",
            customerEmail: order.customer?.email,
            customerExternalId: order.customer?.externalId ?? void 0
          });
        } catch (error48) {
          console.error("Failed to save order:", error48);
        }
      },
      /**
       * Triggered when an order is paid (payment confirmed)
       * This is where you should grant access to your SaaS
       */
      onOrderPaid: async (payload) => {
        const order = payload.data;
        const { id, customerId, productId } = order;
        const customerExternalId = order.customer?.externalId;
        const amountCents = order.netAmount;
        console.log("\u2705 Order Paid:", {
          orderId: id,
          customerId,
          productId,
          amount: amountCents / 100,
          customerExternalId
        });
        try {
          await orderService2.updateOrderStatus(id, "paid");
          if (customerExternalId && productId) {
            await orderService2.grantAccess(customerExternalId, productId);
            console.log(`\u{1F389} Access granted to user: ${customerExternalId}`);
          }
        } catch (error48) {
          console.error("Failed to process paid order:", error48);
        }
      },
      /**
       * Triggered when an order is refunded
       * Revoke access here
       */
      onOrderRefunded: async (payload) => {
        const { id } = payload.data;
        const customerExternalId = payload.data.customer?.externalId;
        console.log("\u{1F4B0} Order Refunded:", { orderId: id, customerExternalId });
        try {
          await orderService2.updateOrderStatus(id, "refunded");
          if (customerExternalId) {
            await orderService2.revokeAccess(customerExternalId);
            console.log(`\u274C Access revoked for user: ${customerExternalId}`);
          }
        } catch (error48) {
          console.error("Failed to process refund:", error48);
        }
      },
      /**
       * Catch-all handler for debugging
       * Remove or disable in production
       */
      onPayload: async (payload) => {
        console.log("\u{1F514} Webhook received:", payload.type);
      }
    })
  );
}

// api/_serverless.ts
var app = (0, import_fastify2.default)({
  logger: true
});
app.setValidatorCompiler(validatorCompiler);
app.setSerializerCompiler(serializerCompiler);
app.register(import_cors.default, {
  origin: true,
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
});
app.register(rootRoute);
app.register(healthRoute, { prefix: "/health" });
app.register(paymentRoutes, { prefix: "/api/payment" });
app.register(polarRoutes, { prefix: "/api/payment/polar" });
app.register(razorpayRoutes, { prefix: "/api/payment/razorpay" });
app.register(checkoutRoutes, { prefix: "/checkout" });
app.register(checkoutRoutes2, { prefix: "/api/checkout" });
app.register(productsRoute, { prefix: "/api/products" });
app.register(booksRoute, { prefix: "/api/books" });
app.register(usersRoute, { prefix: "/api/users" });
app.register(webhooksRoutes, { prefix: "/api/webhooks" });
app.register(ordersRoute, { prefix: "/api/order" });
app.register(ordersRoutes, { prefix: "/api/orders" });
app.register(loginRoute, { prefix: "/api/auth/login" });
app.register(registerRoute, { prefix: "/api/auth/register" });
app.register(forgotPasswordRoute, { prefix: "/api/auth/forgot-password" });
app.register(resetPasswordRoute, { prefix: "/api/auth/reset-password" });
var serverless_default = async (req, res) => {
  await app.ready();
  app.server.emit("request", req, res);
};
export {
  serverless_default as default
};
/*! Bundled license information:

@fastify/proxy-addr/index.js:
  (*!
   * proxy-addr
   * Copyright(c) 2021 Fastify collaborators
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toad-cache/dist/toad-cache.cjs:
  (**
   * toad-cache
   *
   * @copyright 2024 Igor Savin <kibertoad@gmail.com>
   * @license MIT
   * @version 3.7.0
   *)

light-my-request/lib/form-data.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.13.5 Copyright (c) 2026 Matt Zabriskie and contributors *)

@neondatabase/serverless/index.mjs:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
